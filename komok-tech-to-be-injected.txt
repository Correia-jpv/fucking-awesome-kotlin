# komok-tech-to-be-injected

> Minimal dependency injection library for Kotlin based on property delegates

## Overview

This library provides a simple, compile-time safe dependency injection mechanism using Kotlin's `lazy` delegate pattern. It allows defining module classes with bean properties that are lazily initialized and can be mocked for testing.

## Installation

```kotlin
dependencies {
    implementation("io.heapy.komok:komok-tech-to-be-injected:1.0.13")
}
```

## Imports

```kotlin
import io.heapy.komok.tech.di.delegate.bean
import io.heapy.komok.tech.di.delegate.buildModule
import io.heapy.komok.tech.di.delegate.MutableBean
```

## Key Components

- `bean` - Property delegate function to declare injectable beans
- `MutableBean<V>` - Thread-safe lazy container that supports mocking and value override before initialization
- `buildModule<T>()` - Reflectively constructs module tree by analyzing constructor parameters

## Usage Pattern

### Basic Module (no dependencies)

```kotlin
class ConfigurationModule {
    val config by bean {
        AppConfig(
            host = System.getenv("HOST") ?: "localhost",
            port = 8080
        )
    }
}
```

### Module with Dependencies

Module dependencies are declared as **constructor parameters**. Keep them `private` if only used internally.

```kotlin
class UtilsModule(
    private val configurationModule: ConfigurationModule,
) {
    val httpClient by bean<HttpClient> {
        DefaultHttpClient(
            timeout = configurationModule.config.value.timeout
        )
    }

    val cache by bean<Cache> {
        FileCache(
            enabled = configurationModule.config.value.cacheEnabled
        )
    }
}
```

### Composing Modules

Higher-level modules depend on lower-level modules through constructor parameters:

```kotlin
class ApplicationModule(
    private val utilsModule: UtilsModule,
    private val serviceModule: ServiceModule,
) {
    val app by bean {
        Application(
            httpClient = utilsModule.httpClient.value,
            userService = serviceModule.userService.value
        )
    }
}
```

### Building the Module Tree

Use `buildModule<T>()` to automatically construct the entire dependency tree:

```kotlin
fun main() {
    val app = buildModule<ApplicationModule>()
    app.app.value.start()
}
```

The `buildModule` function reflectively analyzes constructor parameters and instantiates all required modules automatically.

### Reusing Modules

Modules can be reused in different contexts:

```kotlin
// In main application
val app = buildModule<ApplicationModule>()

// In a utility script that only needs HttpClient
val utils = buildModule<UtilsModule>()
val client = utils.httpClient.value
```

## Bean Type Inference

Explicit type can be specified when interface differs from implementation:

```kotlin
val httpClient by bean<HttpClient> {  // Interface type
    DefaultHttpClient()                // Implementation
}
```

Or let it be inferred when types match:

```kotlin
val config by bean {
    AppConfig()  // Type inferred as AppConfig
}
```

## Accessing Bean Values

Bean values are accessed via `.value` property:

```kotlin
class ServiceModule(
    private val utilsModule: UtilsModule,
) {
    val userService by bean {
        UserService(
            httpClient = utilsModule.httpClient.value,  // Access via .value
            cache = utilsModule.cache.value
        )
    }
}
```

## Testing

Beans can be mocked before initialization:

```kotlin
val module = buildModule<ServiceModule>()
module.userDao.mock {
    mockk { every { getById(1) } returns User(1, "Test") }
}
```

Or set directly:

```kotlin
module.bean.setValue(testValue)
```

## Design Notes

- Uses Double-Checked Locking (DCL) for thread-safe lazy initialization
- Module dependencies are declared via constructor parameters (not as beans)
- Bean values accessed via `.value` property
- Mocking must happen before first `.value` access
- Constructor parameters should be `private` unless external access is needed
- Implementation classes should be `internal` to allow direct instantiation in modules