[{"title":"From Groovy to Kotlin","url":"https://dkandalov.github.io/groovy/kotlin/2016/06/06/From-Groovy-to-Kotlin.html","body":"\nThis is a write-up of my experience converting source code of [Activity Tracker](https://github.com/dkandalov/activity-tracker) plugin for IntelliJ IDEs from [Groovy](http://www.groovy-lang.org/) to [Kotlin](https://kotlinlang.org/).\n\nIt is written for anyone familiar with Groovy or Kotlin and might be especially relevant if you are considering move from Groovy to Kotlin. Hopefully, it can be interesting for non-Groovy and non-Kotlin people as well.\n\nPlease note that this is not intended to be a thorough comparison or overview of the languages. The only differences mentioned are those which I came across while transforming Groovy code to Kotlin.\n\n#### About migration\n\n[Activity Tracker](https://github.com/dkandalov/activity-tracker) is a proof-of-concept plugin for IntelliJ IDEs to track and record user activity. It keeps all the data locally so you can see and control what is being logged.\n\nIntelliJ plugins are usually written in Java with a bit of xml configs and IntelliJ platform Java API. Activity Tracker is not like that at all. In the first place, it mostly ignores standard xml configuration and uses [LivePlugin](https://github.com/dkandalov/live-plugin) Groovy API instead. From plugin point of view this means that in addition to standard Java APIs it has to interface with LivePlugin Groovy API. Secondly, Activity Tracker was itself written in Groovy.\n\nWriting plugins in Groovy is not a common practice. At the time the main motivation for me was to use programming language more exciting than Java 6. These days IntelliJ uses Java 8 and Kotlin is “officially approved” language for writing plugins. So migrating from Groovy to Kotlin was not only about having fun but also about moving to standard technology.\n\n#### No ‘new’ keyword\n\nUnlike Groovy (and probably most JVM languages) there is no `new` keyword in Kotlin. To create an instance of a class you can just use class name with constructor parameters.\n\nGroovy:\n\n```groovy\nnew ActivityTracker.Config(...)\n```\n\nKotlin:\n\n```kotlin\nActivityTracker.Config(...)\n```\n\n#### No implicit narrowing/widening for numbers\n\nUnlike Groovy (and probably most JVM languages) there is no implicit narrowing/widening conversion for numbers in Kotlin. That is if you have variable of type `Long` you cannot assign `Int` value to it and vice versa.\n\nEven though this might seem strange, it makes perfect sense because `Int` and `Long` classes are not subtypes of each other. The same applies to `Double` and `Float`. Considering how subtle and difficult it can be to find implicit conversion bugs this is probably a good design.\n\n(In case you were wondering about silent number underflow/overflow, it is still there. Works the same way as in Java.)\n\nGroovy:\n\n```groovy\ndef longValue = 123L\ndef intValue = 123\nlongValue = intValue // works ok\n```\n\nKotlin:\n\n```kotlin\nvar longValue = 123L\nvar intValue = 123\nlongValue = intValue // compilation error\nlongValue = intValue.toLong() // works ok\n```\n\n#### Closure type parameters\n\nIn Groovy types and type parameters are optional. You can skip types all together or specify them in when you feel like doing it. I found it useful to always add types to libraries and other APIs which might be heavily used from other code. It works fine except for `Closure<V>` type which has type parameter only for its return value. To be fair, there is `ClosureParams` annotation to specify types for closure inputs, but it’s too painful to use.\n\nIn Kotlin, closures (aka lambdas) have type parameters for inputs and output as you would expect.\n\nGroovy:\n\n```groovy\nprivate updateState(Closure<State> closure) {...}\n// or\nprivate updateState(@ClosureParams(State.class) Closure<State> closure) {...}\n```\n\nKotlin:\n\n```kotlin\nprivate fun updateState(closure: (State) -> State) {...}\n```\n    \n#### “With” vs “run” and “apply”\n\nOne of the interesting features in Groovy is `.with` function defined on `Object` class. It takes a closure and executes it with `this` set to target object. The result of `.with` function is the value of the last expression in closure. This can be useful for calling a bunch of methods on object which doesn’t have fluent API.\n\nConfusingly, Kotlin has `with` function which does exactly the same thing except that it cannot be called on object itself. So to replace Groovy `.with` in Kotlin there is `.run` function. In addition, there is the `.apply` function in Kotlin which is like `.run` but returns target object. This is useful for building object trees and avoiding `it` as the last expression in each closure.\n\nGroovy:\n\n```groovy\ndef actionGroup = new DefaultActionGroup().with {\n    add(toggleTracking)\n    add(new DefaultActionGroup(\"Current Log\", true).with {\n        add(showStatistics)\n        add(openLogInIde)\n        add(openLogFolder)\n        addSeparator()\n        add(rollCurrentLog)\n        add(clearCurrentLog)\n        it // <-- meh\n    })\n    //...\n    it // <-- meh\n}\n```\n\nKotlin:\n\n```kotlin\nval actionGroup = DefaultActionGroup().apply {\n    add(toggleTracking)\n    add(DefaultActionGroup(\"Current Log\", true).apply {\n        add(showStatistics)\n        add(openLogInIde)\n        add(openLogFolder)\n        addSeparator()\n        add(rollCurrentLog)\n        add(clearCurrentLog)\n    })\n    // ...\n}\n```\n\n#### “Modifying” immutable objects\n\nBoth Groovy and Kotlin can define value-objects classes, i.e. a class with immutable fields and implicitly defined equality and hash code methods. In Groovy it’s a class with `@Immutable` annotation, in Kotlin `data class` definition. One of the things you might want to do with value-object is copy it into new object changing one or more fields.\n\nEven though underlying implementation is different, from user point of view Groovy and Kotlin code looks similar.\n\nGroovy:\n\n```groovy\n@Immutable(copyWith = true)\nstatic final class State {\n    boolean isTracking\n    boolean trackIdeActions\n}\nnew State(false, false).copyWith(trackIdeActions: true)\n```\n    \nKotlin:\n\n```kotlin\ndata class State(\n        val isTracking: Boolean,\n        val trackIdeActions: Boolean)\nState(false, false).copy(trackIdeActions = true)\n```\n\n#### Groovy getters and setters\n\nWhen referencing getters/setters from Groovy code you can pretend you’re using a public field. So instead of Java-style getter `o.getFoo()`, you can use `o.foo`. And instead of setter `o.setFoo(\"bar\")`, you can do `o.foo = \"bar\"`.\n\nKotlin also has groovy getters/setters, although for instance methods only.\n\nJava:\n\n```java\nActionManager actionManager = ActionManager.getInstance();\nprintln(actionManager.getComponentName());\n```\n\n\nGroovy:\n\n```groovy\ndef actionManager = ActionManager.instance\nprintln(actionManager.componentName)\n```\n    \nKotlin:\n\n```kotlin\nval actionManager = ActionManager.getInstance()\nprintln(actionManager.componentName)\n```\n\n#### Method names with spaces\n\nBoth Groovy and Kotlin allow method names with spaces. This might sound like a strange feature but it’s great for naming unit-tests so that you don’t have to choose between camel case, underscores or mixing both.\n\nAnother less practical but much more exciting question is whether any string can be a method name. For Groovy the answer is “yes”. Kotlin seems to be more restrictive.\n\nGroovy:\n\n```groovy\n@Test def \"convert event object into csv line\"() {...}\n@Test def \"\\n\"() {...} // good names are hard\n@Test def \"\"() {...}   // the shortest method name ever\n```\n\nKotlin:\n\n```kotlin\n@Test fun `convert event object into csv line`() {...}\n@Test fun `\\n`() {...} // doesn't compile\n@Test fun ``() {...}   // doesn't compile\n```\n\n#### Almost optional “return”\n\nIn Groovy the last expression in function/closure is its return value. You can use `return` keyword to return from function earlier, otherwise it’s entirely optional.\n\nIn Kotlin this is more complex. Functions must have `return` keyword while lambdas cannot use `return`. The result of the last expression in lambda is the value that lambda will return. And `return` in lambda means returning from enclosing method.\n\nThere must be good reasons behind this design in Kotlin but why last expression in function needs `return` keyword is a mystery for me.\n\nIn practice, I had no problems with it except when transforming Kotlin lambdas into methods and the other way round because the code has to be modified to add/remove `return`s.\n\n#### Getting Class object\n\nKotlin has its own reflection classes, i.e. in addition to `java.lang.Class` there is `kotlin.reflect.KClass`. This makes sense because Kotlin has language features which do not exist in Java. (For example, you might want to check using reflection if function argument is optional.)\n\nIn Groovy, as far as I know, it’s not possible to check using reflection whether function argument is optional or not. Probably, analyzing Groovy AST is the way to do it.\n\nJava:\n\n```java\nprintln(ActivityTracker.class);\n``` \n\nGroovy:\n\n```groovy\nprintln(ActivityTracker)\n```\n\nKotlin:\n\n```kotlin\nprintln(ActivityTracker::class.java)\n```\n\n#### Appending writer\n\nGroovy has quite a few “helper” methods which are automatically “added” to Java core classes. For example, `withWriterAppend()` method in `ResourceGroovyMethods` class which simplifies appending to a text file using `Writer`.\n\nIn Kotlin there are also quite a few “helper” methods. In particular for IO operations, in `kotlin.io.FileReadWrite` there is `writer()` function. It does almost the right thing except that there is no option to make writer appendable so reproducing Groovy behaviour is somewhat verbose.\n\nJava:\n\n```java\n// Too many lines of code\n```\n\nGroovy:\n\n```groovy\nnew File(statsFilePath).withWriterAppend(\"UTF-8\") { writer ->\n    // use writer\n}\n```\n\nKotlin:\n\n```kotlin\nFileOutputStream(File(statsFilePath), true).buffered().writer(utf8).use { writer ->\n    // use writer\n}\n```\n    \n#### Enhanced Collections and Maps\n\nIn Groovy there are few functions in `DefaultGroovyMethods` class which are automatically added to all collection classes. For example, `collectEntries()` function takes a closure and, assuming the closure returns two-elements arrays, puts them into a map with first element as a entry key and second element as its value. Or `sort()` function which take a closure and returns sorted collection or even a sorted map.\n\nKotlin has many similar functions available on collections and maps. There are few subtle differences though. Similar to Groovy `collectEntries()` Kotlin has `associateBy()` function but it’s only available on collections, not on maps. This makes it harder to convert one map into another. Another example is `sortBy()` function which in Kotlin exists only on collections and not maps.\n\n(Note that except for few difference the code below is almost identical.)\n\nGroovy:\n\n```groovy\ndef eventsByFile = events\n    .findAll{ it.eventType == \"IdeState\" && it.focusedComponent == \"Editor\" && it.file != \"\" }\n    .groupBy{ it.file }\n    .collectEntries{ [fileName(it.key), it.value.size()] }\n\n// OMG, map sorted by its own value\neventsByFile.sort{ it.value }\n```\n\nKotlin:\n\n```kotlin\nval eventsByFile = events\n    .filter{ it.eventType == \"IdeState\" && it.focusedComponent == \"Editor\" && it.file != \"\" }\n    .groupBy{ it.file }.toList()\n    .associateBy({ it.first }, { it.second.size })\n\neventsByFile\n    .map{ Pair(fileName(it.key), it.value.size)}\n    .sortedBy{ it.second }\n```\n\n#### Same class in different class loaders\n\nOn JVM class loaders work somewhat like “namespaces”. For example, if you load exactly the same bytecode for a class in two different class loaders, then instances of the class won’t be assignable between the class loaders.\n\nIn Groovy this is still true but since Groovy is an optionally typed language, you can skip types and use object from another class loader calling methods dynamically. This is not a feature you would use every day but it can be useful.\n\nSince Kotlin is statically typed language there is no workaround (except for some verbose reflection magic). To be precise, Kotlin has [dynamic types](https://kotlinlang.org/docs/reference/dynamic-type.html) but they are only supported for JavaScript, and not available on JVM.\n\nGroovy:\n\n```groovy\nprivate updateState(Closure<State> closure) {\n    // note that parameter class is commented out because on plugin reload it will\n    // be a different type (since it's loaded in new classloader)\n    stateVar.set { /*State*/ oldValue ->\n        def newValue = closure.call(oldValue)\n        onUpdate(oldValue, newValue)\n        newValue\n    }\n}\n```\n\nKotlin:\n\n```kotlin\n// Can't do this :(\n// The workaround is to convert object to/from instance of a class\n// from parent class loader, e.g. java.lang.String.\n```\n\n#### Extending Groovy interfaces/classes in Kotlin\n\nIf you plan to use Groovy API from Kotlin, be aware that it doesn’t work very well at the moment. Basically, Kotlin compiler doesn’t see method implementations of `groovy.lang.GroovyObject` generated by Groovy.\n\nThe only workaround I found is to manually implement these methods in Kotlin. If you know the answer, I’ll be grateful if you could reply to [this question on Kotlin forum](https://discuss.kotlinlang.org/t/extending-groovy-class-from-kotlin/1675).\n\nGroovy:\n\n```groovy\nclass MyGroovyClass {\n    def foo() {}\n}\n```\n\nKotlin:\n\n```kotlin\n// compilation fails with:\n// Object must be declared abstract or implement abstract base\n// class member public abstract fun setProperty(p0: String!, p1: Any!): Unit\nobject : MyGroovyClass() {\n    override fun foo() {}\n}\n```\n\nJava:\n\n```java\n// yes, this works fine in Java\nnew MyGroovyClass() {\n    @Override public Object foo() {\n        return super.foo();\n    }\n};\n```\n\n#### Summary\n\nKotlin was created few years after Groovy and borrowed some features from it so when switching from Groovy, Kotlin feels like “a language I almost know”.\n\nBeing statically typed, Kotlin might have a bit more “resistance” than Groovy. On the other hand, it seems to be more suitable for writing “big legacy enterprise projects”.\n\nIf you expected opinion about which language is better, sorry there won’t be one. Both Groovy and Kotlin are good.\n\nTo conclude, here is the final code snippet showing strategically designed Kotlin core libraries:\n\n```kotlin\npublic operator fun times(other: Long): Long\n```\n\n","author":"Dmitry Kandalov","date":"2016-06-06","type":"article","categories":["Kotlin"],"features":["highlightjs"],"description":"","filename":"","lang":"EN","enclosure":null},{"title":"Extension Functions Can Be Utility Functions","url":"http://oneeyedmen.com/extension-functions-can-be-utility-functions.html","body":"\nI enjoyed [Extension functions are not utility functions](https://medium.com/@dimsuz/extension-functions-are-not-utility-functions-74a5f9b53892#.o57pbn5k2)\n\nI thought that I disagreed, but on more careful reading maybe not. Instead I’ll pull out some extension functions from my current codebase.\n\nWe’re finding that extension functions are a simple way to make code more expressive.\n\nWithout an extension function:\n\n```kotlin\nprivate fun addressFrom(node: JsonNode): Address = ...\n\nval addresses = nodes.map { addressFrom(it) }\n```\n\nWith an extension function:\n\n```kotlin\nprivate fun JsonNode.toAddress(): Address = ...\n\nval addresses = nodes.map { it.toAddress() }\n```\n\nYou might the find first example more readable like this:\n\n```kotlin\nprivate fun toAddress(node: JsonNode): Address = ...\n\nval addresses = nodes.map(::toAddress)\n```\n\nin which case fill yer boots, but my mind doesn’t work that way.\n\nExtension functions work well here, but the place where they really shine is method chaining.\n\nWithout them:\n\n```kotlin\nprivate fun addressFrom(node: JsonNode): Address = ...\n\nprivate fun isInUK(address: Address): Boolean = ...\n\nval isInUK = isInUK(addressFrom(node))\n```\n\nExtension functions don’t make you turn your brain inside out:\n\n```kotlin\nprivate fun JsonNode.toAddress(): Address = ...\n\nprivate fun Address.isInUK(): Boolean = ...\n\nval isInUK = node.toAddress().isInUK()\n```\n\nYou may have noticed the `private` in the examples above - most of the extension functions that we write this way are used locally - just to make a few lines of code more intuitive. But that’s by no means universally true - this is from some library code to extend Jackson in more general ways:\n\n```kotlin\nfun JsonNode.getExpected(name: String): JsonNode = get(name) ?: throw MissingPropertyException(\"property '$name' is missing\")\n\nfun JsonNode.getNonBlankText(name: String) = getExpected(name).asText().apply {\n    if (isBlank()) throw JsonInterpretationException(\"property $name is blank\")\n}\n```\n\nI had wondered whether this style was best suited to operations on types that we don’t own. But I find we have code that acts on our own types:\n\n```kotlin\nfun suggestionsTemplateDataFor(suggestions: List<JournalJson>) = mapOf(\n    \"results\" to suggestions.withOAText()\n)\n\nprivate fun List<JournalJson>.withOAText(): List<Map<String, Any?>> = this.map { it.withOAText() }\n\nprivate fun JournalJson.withOAText() = TreeMap(this.asPropertyMap().plus( \"openAccessText\" to this.accessType.toUIString()))\n\nprivate fun AccessType.toUIString() = when (this) {\n    AccessType.OPEN_ACCESS -> \"Yes\"\n    AccessType.SUBSCRIPTION -> \"No\"\n    AccessType.OPEN_CHOICE -> \"Optional\"\n    else -> \"Unknown\"\n}\n```\n\nHere `JournalJson` and `AccessType` are simple data classes, unencumbered by all the operations that the rest of the system would like them to have; because they can define operations like `withOAText()` as extension functions when they need them. And if defining an extension on `List<JournalJson>` isn’t a utility function I don’t know what is, but here it really helps us to at least get the gist of what is going on at the top level.\n\nHidden in there is a call to\n\n```kotlin\nfun Any.asPropertyMap(): Map<String, Any?> = SpaceBlanket(this)\n```\n\nwhich _is_ the archetypal extension function definition - high-level and fundamental.\n\nThere are more thoughts on this subject in a follow up article - [More Kotlin Extension Fun](http://oneeyedmen.com/more-kotlin-extension-fun.html)\n\nIf you like this, [Nat Pryce](www.natpryce.com) and I are going to be talking about Expressive Kotlin at the [Kotlin Night London](https://info.jetbrains.com/Kotlin-Night-London.html) next Wednesday, 12 October 2016.\n\nThanks to [Springer Nature](http://www.springernature.com) for allowing me to publish examples from their code. If you’re looking for a Kotlin job in London, they are hiring - please contact me using one of the links in the sidebar.\n\n","author":"Duncan McGregor","date":"2016-10-05","type":"article","categories":["Kotlin"],"features":["highlightjs"],"description":"","filename":"","lang":"EN","enclosure":null},{"title":"An adventure with Kotlin - Part I","url":"http://angrybyte.me/post/154701023805/kotlin-adventures-1","body":"","author":"Milos Marinkovic","date":"2016-12-20","type":"article","categories":["Kotlin","Android"],"features":["highlightjs"],"description":"","filename":"","lang":"EN","enclosure":null},{"title":"Kotlin, the somewhat obscure modern Android-friendly programming language","url":"https://medium.com/math-camp-engineering/kotlin-3e963864db9e#.jumx6jh63","body":"\n### Kotlin, the somewhat obscure modern Android-friendly programming language\n\n[Swift](https://developer.apple.com/swift/) is a terse functional programming language with high Objective-C interoperability used for iOS development.\n\nSwift is better than Objective-C.\n\nYou already know this.\n\nBut you probably don’t know what Kotlin is.\n\n[Kotlin](https://kotlinlang.org/) is Swift for Android. [1]\n\nYou’re not using Objective-C anymore, so why are you using Java?\n\nWe built [Roll for Android](http://tryroll.com) in [Kotlin](https://kotlinlang.org/).\n\n### What is Kotlin? Really.\n\nKotlin is a terse swift-like functional programming language on the JVM platform with high Java interoperability. Kotlin is unique in that its standard library and runtime are extremely small in bytes, yet very powerful. Most is eliminated at compile time (in contrast to [Scala](http://www.scala-lang.org/)), so it can feasibly be used in memory “constrained” environments like Android (not embedded systems, but smartphones):\n\n```kotlin\nval immutableVariable = \"a string\"\n\n// a function\nfun inc(x: Int): Int {\n  return x+1\n}\n\n// anonymous function bound to a variable\nval inc: (Int) -> Int = { it + 1 }\n```\n\n### Why Kotlin and not “X”?\n\nWe wanted to iterate on a lot of the software structure we came up with for our [Swift iOS app](http://tryroll.com), and for a bunch of pieces we needed a powerful type-system. So rather than just stick with Java — it’s way too verbose — we started looking at alternatives. We wanted a strong static type system, yet the obvious choice, Scala, has too much overhead for Android. Kotlin really stood out for us. [This document by Jake Wharton at Square](https://docs.google.com/document/d/1ReS3ep-hjxWA8kZi0YqDbEhCqTt29hG8P44aA9W0DM8/edit?hl=en&forcehl=1) made the decision easier. So we took the risk.\n\n### Great Features\n\n*   [Null type safety!](https://kotlinlang.org/docs/reference/null-safety.html)\n\nIn Kotlin, just like in Swift, optional values are tracked through the type-system. You will not have null pointer exceptions in your Kotlin code:\n\n```kotlin\nval x: String? = tryToGetString()\n// x is not a String (it could be null)\n\nif (x != null) {\n  // x is smart-casted to a String here!\n}\n```\n\n*   [Lambdas can be inlined!](https://kotlinlang.org/docs/reference/inline-functions.html)\n\nAn under appreciated feature of Kotlin (if you’re targeting Android for example) is the zero overhead higher order functions on collections.\n\nIn Kotlin these standard library functions are inlined and desugared to for-loops.\n\nThus, you can write expressive Scala-like code but without all the anonymous inner class overhead (which while negligible on servers, is [an issue in Dalvik](http://developer.android.com/training/articles/memory.html) and possibly Android’s new runtime ART [no evidence], so Android devices will be affected):\n\n```kotlin\nval strs = listOf(\"this\", \"is\", \"a\", \"bunch\", \"of\", \"words\")\n\nval charCount = strs.map{ it.length }.fold(0, { a, b -> a + b })\n\nval evenWords = strs.filter{ it.length % 2 == 0 }\n```\n\n*   [Reified generics!](https://kotlinlang.org/docs/reference/inline-functions.html#reified-type-parameters)\n\nReified generics in Kotlin let you use the generic T in your code at runtime. For example, we’ve used reified generics to implement a clean API for dictionary deserialization to model data classes. Here, we attempt to deserialize an untyped map into some strongly typed data class of type T (like a User):\n\n```kotlin\nprivate inline fun deserialize<reified T>(dict: Map<String, Any?>): T { ... }\n// usage val model = deserialize<ModelData>(modelDataDict)\n```\n\n*   [Statically resolved extension functions!](https://kotlinlang.org/docs/reference/extensions.html)\n\nExtension functions in Kotlin allow you to add “methods” to objects. These are resolved statically so there is no performance overhead or runtime confusion.\n\nExtension functions even work on generic “primitives” like Functions or optional types.\n\nFor example, we have defined monadic bind on options (like if-let in Swift if it were an expression and not a statement) and use it all over our codebase [2]:\n\n```kotlin\ninline fun <T, R> T?.bind(transform: (T) -> R?): R? =\n    this?.let(transform)\n```\n\n*   [Algebraic data types and pattern matching!](https://kotlinlang.org/docs/reference/classes.html#sealed-classes)\n\nAlgebraic data types or (ADTs) (also called Sum types or tagged unions) allow you model data that can be one of several different variants. Once you’ve used ADTs, you can’t live with out them. The compiler will enforce that you have exhaustively handled all the cases. Swift has them, and as of recently Kotlin does too.\n\nHere is an example of the model for a button that is either disabled, shows a number, or shows info about a user:\n\n```kotlin\nsealed class ButtonState {\n  object Disabled: ButtonState()\n  class ShowingNum(val num: Int): ButtonState()\n  class ShowingPerson(val u: User): ButtonState()\n}\n\n// this state shows 5\nval showFiveState = ShowingNum(5)\n\n// all states handled (enforced by the compiler!)\nfun printbutton(state: ButtonState): String = when (state) {\n  is ShowingNum -> \"<{state.num}>\"\n  is ShowingPerson -> \"<{state.u.name}>\"\n  Disabled -> \"-<>-\"\n}\n```\n\n*   Single-method interfaces/classes can be represented as lambdas! aka\n\n```java\nview.setOnClickListener(new View.OnClickListener() {\n  @Override public void onClick(View v) {\n    /* do something */\n  }\n});\n```\n\nbecomes\n\n```kotlin\nview.setOnClickListener { /* do something */ }\n```\n\nThis is great for things like [RxJava](http://reactivex.io/).\n\nSpeaking of which, the Java interoperability is first-class and fantastic. Any Android Java libraries we’ve tried work great from Kotlin.\n\n### Libraries Created\n\nUsing these features, we’ve built:\n\n*   a simple dependency injection framework\n*   a handful of really useful extensions on things like T? (for example monadic bind)\n*   a hack for algebraic data types and pattern matching (before sealed class was released)\n*   a single-atom-state functional reactive UI component framework\n*   and of course a fairly complex app.\n\nAndroid Studio’s Kotlin support is fantastic (good job JetBrains!) — it’s a pleasure to use.\n\n### Build Time\n\nThe biggest issue for us is the build time. Gradle builds used to take around 5–10 minutes. We invested a week of engineering time in getting a [Buck](https://buckbuild.com/) build working alongside Gradle. Buck builds are 3 minutes max and usually are around 45 seconds. With the most recent Android Studio update, incremental Gradle builds are back down under a minute. This is not too much longer than a pure Java app of our size would take to build.\n\n### Use Kotlin!\n\nKotlin is great! The time saved due to the benefits of Kotlin make up for any time lost optimizing build times.\n\nIf you’re interested in learning more, get in touch. We’re hiring!\n\nNote: this post was adapted from an earlier [HackerNews comment](https://news.ycombinator.com/item?id=9947020)\n\n[1] aside: It is more accurate to say Swift is the Kotlin of iOS since Kotlin has existed in the open for many more years than Swift. Due to Kotlin’s obscurity, however, we’re forced to make the Kotlin to Swift comparison.\n\n[2] Thanks @[daniil_vodopian](https://twitter.com/daniil_vodopian) for the terser bind definition\n\n","author":"Brandon Kase","date":"2016-01-15","type":"article","categories":["Android","Kotlin"],"features":["highlightjs"],"description":"","filename":"","lang":"EN","enclosure":null},{"title":"Kotlin VS Java: Basic Syntax Differences","url":"https://yalantis.com/blog/kotlin-vs-java-syntax/","body":"","author":"Irina Galata","date":"2016-12-13","type":"article","categories":["Kotlin","Java"],"features":["highlightjs"],"description":"","filename":"","lang":"EN","enclosure":null},{"title":"A new hope for the JVM: Kotlin","url":"http://engineering.facile.it/blog/eng/kotlin-intro/","body":"\n![Kotlin](http://engineering.facile.it/images/kotlin-intro/logo_Kotlin.svg)\n\n## Premise\n\nJava is an **old** programming language. Version 1.0 was released in 1996 by Sun Microsystems and even though it has evolved and grown a lot over the past twenty years it is still carrying on some bad design choices such as _null_ (ask [Tony Hoare](https://en.wikipedia.org/wiki/Tony_Hoare?section=3#Apologies_and_retractions)), primitive types or lack of a proper function type. With the last version of the language (Java 8) Java tried to address some of these problems introducing concepts such as [`Optional`](https://docs.oracle.com/javase/8/docs/api/java/util/Optional.html) or [lambda expression](http://docs.oracle.com/javase/tutorial/java/javaOO/lambdaexpressions.html). Although these additions clearly represent a step forward for the language I still have the feeling that they are just _patches_ applied to **mitigate problems** and not to solve them at their very source. For example `Optional` could be used to reduce NPE (Null Pointer Exception) but it is clearly not designed for [this purpose](https://twitter.com/mariofusco/status/780770300178956289) and lambda expressions, implemented in Java 8 with SAM types, still force you to write an interface only to define a _function_.\n\n## The Android world\n\nAll the above concerns about Java are even more problematic within the Android world where, due to the notorious [fragmentation](https://developer.android.com/about/dashboards/index.html) (a huge amount of devices are stuck with an **outdated VM**), you are forced to target lower Java versions (6 and 7). Google is addressing the problem with its new compiler [Jack](https://source.android.com/source/jack.html) that enables _some_ of the features of Java 8 maintaining backward compatibility with older OS versions. But still it lets us deal with the verbosity of the language and it doesn’t truly solve the problem.\n\n## A new hope\n\n![Kotlin Hello World!](http://engineering.facile.it/images/kotlin-intro/kotlin_helloworld.png)\n\nBack in 2011 the JetBrains team (the guys behind IntelliJ and so Android Studio) unveiled [Kotlin](https://kotlinlang.org/), a new programming language that targets the JVM (and can also be compiled to JavaScript). Kotlin is a statically-typed language that combines Object Oriented and functional features enforcing no particular philosophy of programming, and it introduces a whole new set of concepts and tools that helps making the code **safer, cleaner and much more readable**. Thanks to its nature it works everywhere Java do and it is also **interoperable** with it, meaning it will not force you to rewrite the entire codebase to taste it: you can add it to your project a little at a time ([maybe starting with tests](https://medium.com/@sergii/using-kotlin-for-tests-in-android-6d4a0c818776#.lyvd3h43x) \uD83D\uDE09). It also features a REPL `kotlinc-jvm` that allows you to test language features with no effort (see the [doc](https://kotlinlang.org/docs/tutorials/command-line.html#running-the-repl) form more info). I am going to rapidly cover some features of Kotlin that address the previously mentioned Java limitations.\n\n### Null-safety\n\nIn Kotlin **a variable cannot be null**. If you want or need a variable to be _nullable_ you have to add `?` to the variable type:\n\n```kotlin\nval x: Int = null // compile error\nval y: Int? = null // ok\n```\n\nThanks to this information the compiler sees `Int` and `Int?` as two completely different types and can therefore enforce the [null-safety](http://kotlinlang.org/docs/reference/null-safety.html) of your variables. The `?.` allows you to safe call methods on nullable variables without throwing NPE but simply returning null at the end of the call chain:\n\n```kotlin\nval x: Int? = null\nx?.toString()?.substring(2) // no NPE, returns null\n```\n\nThe `?:` operator (Elvis operator) allows you to provide a “default” value when the variable is `null`:\n\n```kotlin\n// The two expressions are semantically equivalent:\ntext?.length ?: -1\n(text.length != null) ? text.length  : -1\n```\n\n### Higher-Order Functions and Lambdas\n\nIn Kotlin is possible to declare a method (or more generally a function) that returns or takes another **function as parameter**. The syntax to define the [function type](https://kotlinlang.org/docs/reference/lambdas.html) is similar to other languages such as Scala or Swift and is very **intuitive**:\n\n```kotlin\nval function: (T1, T2) -> R = {t1, t2 -> r}\n```\n\n### Data classes\n\n```kotlin\ndata class City(val name: String, val state: String)\n```\n\n[Data classes](https://kotlinlang.org/docs/reference/data-classes.html) address the verbosity of Java when dealing with classes that have the only purpose to hold data. With a single line you get `equals()/hashCode()`, `toString()` and getters/setters for free (and if you are a Java developer you already knows the benefits!)\n\n# Conclusions\n\nJava has to maintain backward compatibility with previous versions and still has to support the huge amount of developers and codebases present all around the world; therefore it is natural that every new feature and design change is to be considered, weighted and reasoned really carefully, inevitably **slowing down its evolution**. But this does not have to mean that us, as Android developers, “tied” to the JVM, should not try more modern and advanced languages such as Kotlin. At bottom, a part of our job (one of the best!) is to try and **experiment** new technologies and to **learn** new concepts and techniques that improve our ability to address problems in the best possible way (and of course, to have some fun \uD83D\uDE04).\n\nI think that it is fundamental for a software engineer to be **exposed to more than a single programming language**: learning new patterns, exploring other programming paradigms or simply using and understanding a never-seen syntax has an immeasurable value for our growth and most of the times it turns out to be unexpectedly useful even when coding with ”our” language. So why not do it with a language that allows us to continue working on projects targeting our beloved JVM?\n\n","author":"Giacomo Bresciani","date":"2016-10-17","type":"article","categories":["Kotlin"],"features":["highlightjs"],"description":"","filename":"","lang":"EN","enclosure":null},{"title":"Exercises in Kotlin: Part 4 - Control flows and return","url":"http://blog.dhananjaynene.com/2016/04/exercises-in-kotlin-part-4-control-flows-and-return/","body":"\nAfter [Exercises in Kotlin: Part 3 - Functions](http://blog.dhananjaynene.com/2016/04/exercises-in-kotlin-part-3-functions/) we now take a look at control flows and actually doing some basic exercises.\n\n## if/else\n\nAs mentioned earlier, `if/else` is not just a statement but can also be used as an operator (in lieu of the ternary `? :` operator.\n\nAs an example, a familiar way to have if/else statements would be as follows.\n\n```kotlin\nfun greeting(hours: Int): String {\n    var greeting: String = null\n    if (hours < 12) {\n        greeting = \"Good Morning\"\n    } else if (hours < 16) {\n        greeting = \"Good Afternoon\"\n    } else {\n        greeting = \"Good Night\"\n    }\n    return greeting\n}\n```\n\nBut since if/else can be an expression as well, another way to write the function above would be\n\n```kotlin\nfun greeting2(hours: Int): String =\n    \"Good \" + if (hours < 12) {\n        \"Morning\"\n    } else if (hours < 16) {\n        \"Afternoon\"\n    } else {\n        \"Night\"\n    }\n```\n\n## when\n\nThere is another expression that can be used instead of multiple nested if/else expressions or situations where you might use a switch/case block in Java. Using `when` the function above could be written as\n\n```kotlin\nfun greeting3(hours: Int): String =\n    \"Good \" + when {\n        hours < 12 -> \"Morning\"\n        hours < 16 -> \"Afternoon\"\n        else -> \"Night\"\n    }\n```\n\nNote that `when` is an expression and evaluates to a value (in the case above it would be \"Morning\", \"Afternoon\" or \"Night\". You could also use it more conventionally just to write other blocks of code eg.\n\n```kotlin\nfun greeting4(hours: Int): Unit {\n when {\n        hours < 12 -> {\n            println(\"Morning\")\n        }\n        hours < 16 -> {\n            println(\"Afternoon\")\n        }\n        else -> {\n            println(\"Night\")\n        }\n    }\n}\n```\n\nAs you can note, there is no break statement (unlike switch case), and the right hand side of the conditions can be blocks which consist of multiple statements. If used as a part of a when expression, the value returned by a block is the one returned by the last expression in the block.\n\nWhen used as an expression, the compiler expects the conditions to be exhaustive and thus many times you might need to add an else block. However the else block is not required when used as a statement.\n\nThere are many other things you can do including checking the actual instance or just the value as shown in the rather arbitrary example below\n\n```kotlin\nfun anotherWhen(any: Any): Any =\n    when(any) {\n        (any is Int && any < 10000) -> \"Small Number\"\n        is Int -> \"Big Number\"\n        is String -> \"A string\"\n        else -> \"Its just another Any\"\n    }\n```\n\nYou might note that in the first condition, the right hand side of the condition ie. (any < 10000) actually compiles, because the compiler is able to figure out that any will be an Int if reaches the comparison with 10000 and allows it to be used as an Int. This smart casting is actually quite nice and helps save on verbose typecast statements (or for that matter explicit typecasts) when used in when expressions as above.\n\n## while and do-while\n\nThe familiar constructs of `while` and `do while` are also available. eg.\n\n```kotlin\nfun countDown(n: Int) {\n    var counter = n\n    while(counter >= 0) {\n        println(counter)\n        counter--\n    }\n}\n```\n\nNote that in kotlin the while block will not allow you to perform an assignment within the while expression unlike java code. eg. `while((n = next()) > 0)` will not compile. In some of these situations you might actually find the `do while` construct useful. eg. the val n declared within the do while block remains in scope while evaluating the while expression.\n\n```kotlin\ndo {\n    val n = next()\n    // do something\n} while(n > 0)\n```\n\n## for loop\n\nThe for loop is much nicer and often more helpful than in Java. eg. to print each character in a string you could write\n\n```kotlin\nfor(c in \"String\") {\n    println(c)\n}\n```\n\nOne of the useful ability of for loop is to iterate over a range which can be written as `startValue..endValue` eg\n\n```kotlin\n// will print 100, 101, 102... 110\nfor (n in 100..110) {\n    println(n)\n}\n```\n\nThere are many other aspects of the for loop which are better covered after some other topics, so other sample usages will be taken up later.\n\n## break and continue\n\n`break` and `continue` are also available and continue to have the same meaning as in java. For more advanced uses such as breaking to a or returning to a label, see [Returns and jumps](https://kotlinlang.org/docs/reference/returns.html) from the kotlin reference guide.\n\n## Exercise - Counting Sundays\n\nHere's an exercise for you to try out. (Note: the solution follows immediately after, so you might wish to avoid reading it if you want to attempt to do the exercise yourself first).\n\nThis one comes from [Project Euler](http://blog.dhananjaynene.com/2016/04/exercises-in-kotlin-part-4-control-flows-and-return/) Exercise #19\n\nThe problem is stated as follows\n\n```kotlin\nYou are given the following information, but you may prefer to do some research for yourself.\n\n\n1 Jan 1900 was a Monday.\nThirty days has September,\nApril, June and November.\nAll the rest have thirty-one,\nSaving February alone,\nWhich has twenty-eight, rain or shine.\nAnd on leap years, twenty-nine.\nA leap year occurs on any year evenly divisible by 4, but not on a century unless it is divisible by 400.\n\nHow many Sundays fell on the first of the month during the twentieth century (1 Jan 1901 to 31 Dec 2000)?\n```\n\nOne of the possible solutions to this problem is described below\n\n```kotlin\nfun sundaysInTwentiethCentury(): Int {\n    fun daysInMonth(month: Int, year: Int) = when(month) {\n        1,3,5,7,8,10,12 -> 31\n        4,6,9,11 -> 30\n        2 -> when {\n            year % 400 == 0 -> 29\n            year % 100 == 0 -> 28\n            year % 4 == 0 -> 29\n            else -> 28\n        }\n        else -> throw Exception(\"Invalid Month ${month}\")\n    }\n    fun daysInYear(year: Int): Int {\n        var days = 0\n        for(month in 1..12) {\n            days += daysInMonth(month, year)\n        }\n        return days\n    }\n    fun dayOfWeekAfter(currentDow: Int, numberOfDays: Int) = ((currentDow-1) + numberOfDays) % 7 + 1\n    var weekDayOnFirstOfMonth = dayOfWeekAfter(2, daysInYear(1900))\n    var totalSundays = 0\n    for (year in 1901..2000) {\n        for(month in 1..12) {\n            if (weekDayOnFirstOfMonth == 1) totalSundays++\n            weekDayOnFirstOfMonth = dayOfWeekAfter(weekDayOnFirstOfMonth, daysInMonth(month,year))\n        }\n    }\n    return totalSundays\n}\n```\n\n","author":"Dhananjay Nene","date":"2016-04-27","type":"article","categories":["Kotlin"],"features":["highlightjs"],"description":"","filename":"","lang":"EN","enclosure":null},{"title":"Kotlin ❤ FP","url":"https://medium.com/@octskyward/kotlin-fp-3bf63a17d64a","body":"\n#### Functional programming in Kotlin, a new language from JetBrains\n\nI did [a video tutorial on FP in Kotlin](http://blog.jetbrains.com/kotlin/2015/11/webinar-recording-functional-programming-with-kotlin/), which can be viewed online.\n\nIf you use .NET you probably heard about F#, a multi-paradigm but essentially functional programming language for the CLR. And you probably heard good things about it. You may also have heard of Haskell, which is similar.\n\nPerhaps you would like languages such as these on the JVM, but with great tool support and without _mandating_ a functional style ... just making it available when you want it.\n\n[**The Kotlin language**](http://kotlinlang.org/) may at first glance appear to be nothing more than an upgraded Java: lots of syntax conveniences, some type inference and so on. But dig a little deeper and you will discover that many of the most popular and advanced features of functional languages are available.\n\nLet’s get started with some simple examples.\n\n* * *\n\n### Algebraic data types\n\nIt’s normal for functional languages to support syntax like this:\n\n```haskell\ndata  Maybe a  =  Nothing | Just a\n  deriving (Eq, Ord)\n```\n\nThat’s Haskell, and it defines a type called “Maybe” that has two so called _type constructors_, Nothing and Just. The Just type constructor takes a single parameter of unspecified type. The deriving keyword here means a Maybe can be compared for equality, and ordered. It can also be called a _tagged union_.\n\nKotlin doesn’t need a Maybe type because it has optionality as a built in part of the type system. Optionality is so common in programs that it makes sense to integrate it at a deep level, for both convenience and performance reasons:\n\n```kotlin\nval s: String? = if (Math.random() < 0.5) \"Yay!\" else null\nprintln(\"length of string is .... ${s.length()}\")\n```\n\nHere, we get a compile error on the second line, because we’re trying to read the length of a string we might not actually have, depending on a coin flip. There’s a simple fix:\n\n```kotlin\nval s: String? = if (Math.random() < 0.5) \"Yay!\" else null\nprintln(\"length of string is .... ${s?.length() ?: -1}\")\n```\n\nHere, s?.length() will yield null if s was null, and the ?: operator uses the right hand side if the left hand side is null. So this prints -1 if the coin flip didn’t yield the string.\n\nHowever, we won’t think about that more here.\n\nBecause the Maybe type is so familiar to functional programmers, let’s define an equivalent of it here just for illustration.\n\n```kotlin\nsealed class Maybe<out T> {\n    object None : Maybe<Nothing>()\n    data class Just<T>(val t: T) : Maybe<T>()\n}\n```\n\nThe syntax isn’t as terse as Haskell, but isn’t bad either. The data modifier here is optional, but adding it gives us useful features.\n\nWe can do a variety of functional things with this:\n\n```kotlin\nval j = Maybe.Just(1)\nval (i) = j\n```\n\nHere, we define a “just” containing an integer, and then we destructure it to get the integer back. Notice the lack of types: it’s all inferred. If the type had defined multiple fields, we could [destructure all of them](http://kotlinlang.org/docs/reference/multi-declarations.html), which is how this is actually meant to be used:\n\n```kotlin\ndata class Pet(val name: String, val age: Int)\nval alice = Pet(\"Alice\", 6)\nval (name, age) = alice\n```\n\nWhat about pattern matching? This is where the word “sealed” above comes in handy; we can do an exhaustive pattern match without an else/otherwise branch:\n\n```kotlin\nclass User(val age: Int)\n\nfun lookupFromDB(s: String): Maybe<User> = Maybe.None\n\nfun printUser(username: String) {\n    val rec = lookupFromDB(username)\n    when (rec) {\n        is Maybe.None -> println(\"not found\")\n        is Maybe.Just<User> -> println(\"${rec.t.age} years old\")\n    }\n}\n```\n\nHere, we define a simple class with a single immutable property (age), and a couple of functions. We have a lookupFromDB function that returns a Maybe: in this case, always a None, but that’s just an example.\n\nThen we use [the when expression](http://kotlinlang.org/docs/reference/control-flow.html#when-expression) to do a pattern match on the type. When expressions are pretty flexible. They can use arbitrary expressions on the left hand side of each case and if the expression is a type query, the code on the right has the cast applied automatically. That’s why we can just access the t property of rec immediately.\n\n### Immutability\n\nKotlin is not a pure FP language and does not have a ‘default’ for mutable vs immutable. It gently encourages immutability in a few places by choice of syntax, but otherwise makes you choose each and every time.\n\nHere’s some code:\n\n```kotlin\ndata class Person(var name: String, var age: Int)\nval p = Person(\"Mike\", 31)\np.name = \"Bob\"\n```\n\nHere “p” is an immutable **val**ue: it cannot be reassigned. It’s like a final variable in Java, or a let expression in Haskell/F#. But then the contents of this structure are mutable **var**iables, so they can be reassigned later. The IDE highlights identifiers differently if they’re mutable.\n\nHere’s how it looks like, fully immutable\n\n```kotlin\ndata class Person(val name: String, val age: Int)\nval mike = Person(\"Mike\", 31)\nval olderMike = mike.copy(age = 32)\n```\n\nThe copy method is auto generated whenever the data modifier is used. It has a named argument for every property, with the default value of that argument being whatever the current value is. Net result, you can use it to create a fresh object with tweaked fields.\n\nLists are immutable by default:\n\n```kotlin\nval people = listOf(mike, olderMike)\npeople.add(Person(\"Bob\", 50))                     // ERROR\n\nval peopleDB = arrayListOf(mike, olderMike)\npeopleDB.add(Person(\"Bob\", 50))\n\nval view: List<Person> = peopleDB\nval snapshot = peopleDB.toList()\n```\n\nThe second line won’t compile: listOf() returns an immutable list. The fourth line does because we specifically picked an array list (vs a linked list), which is mutable. We can, of course, cast away the mutability to create a read only view, or clone the list to create a snapshot of it.\n\nCurrently there’s no dedicated list literal syntax. There might be in future, but for now, we must use functions.\n\n### Mapping, filtering, reducing etc\n\nKotlin has support for efficient lambdas, and extends the default JDK collections classes to support common functions from FP standard libraries. This can even be used on Java 6 and thus Android:\n\n```kotlin\nval nums = listOf(1, 2, 3, 4)\nval r = nums.map { it * 2 }.sum()       // r == 20\n```\n\nHere, the “it” identifier is a convenience: if a lambda has only one argument, it’s called “it” automatically. We can specify an explicit name when “it” would get too confusing, like in nested lambdas.\n\nMap is an _extension function_. Where Java programmers would define a FooUtils class with static methods to add functionality to Foo classes, Kotlin lets you extend the class with a (statically dispatched) method directly. And then it uses that to give Java platform types like Iterable [new features](http://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-iterable/index.html).\n\nA more advanced example:\n\n```kotlin\nval strs = listOf(\"fish\", \"tree\", \"dog\", \"tree\", \"fish\", \"fish\")\nval freqs = strs.groupBy { it }.mapValues { it.value.size() }\nprintln(freqs)     // {fish=3, tree=2, dog=1}\n```\n\n### Recursive functions\n\nFunctional programmers like to express solutions to problems using recursion. This often needs an optimisation called _tail call optimisation_ to work well. Kotlin supports this in certain circumstances.\n\nHere’s a simple example. A _fixpoint_ of a mathematical function is an input that gives itself as an output. To find a fixpoint of cosine, you can keep feeding the output back as an input until things stabilise. Here’s an example in an imperative fashion:\n\n```kotlin\nprivate fun cosFixpoint(): Double {\n    var x = 1.0\n    while (true) {\n        val y = Math.cos(x)\n        if (x == y) return y\n        x = y\n    }\n}\n```\n\nPretty simple: starting at 1.0 we keep calling cos until cos(a) == a.\n\nHere’s the same written in a recursive manner:\n\n```kotlin\ntailrec fun cosFixpoint(x: Double = 1.0): Double {\n    val r = Math.cos(x)\n    return if (x == r) x else cosFixpoint(r)\n}\n```\n\nIt could also be a one liner (or two here, with big fonts):\n\n```kotlin\nimport java.lang.Math.cos\n\ntailrec\nfun f(x: Double = 1.0): Double = if (x == cos(x)) x else f(cos(x)))\n```\n\nThat version relies on the JIT compiler to notice that it can eliminate the duplicated call to Math.cos(x).\n\n### Currying, partial application, composition\n\nThese are features you’ll find in F# and Haskell, though I never felt a need for them myself. Currying turns a function into a chain of functions. Partial application lets you ‘fix’ certain parameters to a function, resulting in a new function.\n\nKotlin doesn’t support these out of the box. But it’s flexible enough that they can be added by [a library called funKtionale](https://github.com/MarioAriasC/funKTionale/wiki), in a natural manner:\n\n```kotlin\nimport org.funktionale.currying.*\n\nval sum2ints = { x: Int, y: Int -> x + y }\nval curried: (Int) -> (Int) -> Int = sum2ints.curried()\nassertEquals(curried(2)(4), 6)\nval add5 = curried(5)\nassertEquals(add5(7), 12)\n```\n\n... and ...\n\n```kotlin\nimport org.funktionale.partials.*\n\nval format = { prefix: String, x: String, postfix: String ->\n    \"${prefix}${x}${postfix}\"\n}\n\nval prefixAndBang = format(p3 = \"!\")\n\n// Passing just the first parameter will return a new function\nval hello = prefixAndBang(p1 = \"Hello, \")\n\nprintln(hello(\"world\"))\n```\n\n### Lazyness\n\nKotlin is a strict/eager language, and this is how it should be. As far as I’m aware, no other well known language uses lazy-by-default except Haskell.\n\nHowever you can do lazy computations if you want to. Here’s a dead simple real world example: avoiding the work of building a string if logging is disabled.\n\n```kotlin\nval loggingEnabled = System.getProperty(\"log\") != null\n\nfun log(s: String): Unit = if (loggingEnabled) println(s)\n\nfun log(ls: () -> String): Unit = if (loggingEnabled) println(ls())\n```\n\nThe log function is overloaded: it can take an actual string, or a function that calculates a string:\n\n```kotlin\nlog(\"now!\")\nlog { \"calculate me later\" }\n```\n\nFunctional programming occasionally involves building infinite lists of things and operating on them in a lazy and possibly parallel manner. [This is often seen as a key selling point for FP](http://research.microsoft.com/en-us/um/people/simonpj/papers/stm/STMTokyoApr10.pdf) (see slide 10).\n\nSince version 8 Java can do this too, and therefore so can Kotlin. For example:\n\n```kotlin\nval ONE = BigInteger.ONE\nfun primes(n: Long) =\n        Stream.iterate(ONE) { it + ONE }.\n        filter { it.isProbablePrime(16) }.\n        limit(n).\n        toList()\n```\n\nJava calls infinite lazy lists _streams._ Here, we build a list of all the positive BigIntegers. Then we select only the ones that are probably prime numbers with chance 2^16, according to the Miller-Rabin primality test. Then we take _n_ of them and put them into a regular non-lazy list. This is classical functional programming.\n\nHow fast is this?\n\n```kotlin\nrepeat(3) {\n    val t = measureTimeMillis {\n        primes(100000)\n    }\n    println(\"Took $t msec\")\n}\n```\n\nOn my laptop, after the first run when the JIT compiler has crunched, it takes about 1.5 seconds.\n\nOne nice thing about pipelines of pure functions is you can parallelise them. Let’s do that now:\n\n```kotlin\nfun primes(n: Long) =\n        Stream.iterate(ONE) { it + ONE }.\n        parallel().\n        filter { it.isProbablePrime(16) }.\n        limit(n).\n        toArray()\n```\n\nWe inserted a call to parallel() in our stream. This tells the JVM to run the rest of the pipeline in multiple threads. Rerunning the program shows that this improved performance 3x: it now only takes half a second. Not bad!\n\n### STM\n\nSoftware transactional memory is a way to write concurrent code. It is well explained in [this paper by Simon Peyton-Jones](http://research.microsoft.com/en-us/um/people/simonpj/papers/stm/beautiful.pdf), one of the architects of Haskell.\n\nInstead of using locks you write code like this:\n\n```kotlin\nvar account1 = 5\nvar account2 = 0\n\nfun transfer(amount: Int) {\n    atomic {\n        account1 -= amount\n        account2 += amount\n    }\n}\n```\n\nFrom the programmers perspective, anything that happens inside the atomic block takes effect all at once when the block is exited and there can be no race conditions inside it. But multiple threads can all be inside the atomic block at once, doing useful work. Pretty neat, right?\n\nA simple implementation would be to have a giant global lock, but that’d be very slow. So fancier implementations record every change made inside the block by threads running concurrently, and detect conflicts: if there is a conflict, the block is retried. Haskell has an implementation of such a thing.\n\nKotlin does not have language support for software transactional memory. However, this is not such a big deal because via the JVM it gets support using libraries like [Scala STM](http://nbronson.github.io/scala-stm/quick_start.html) (see below), and even something better: _hardware_ transactional memory. Yup.\n\nModern (very modern) Intel chips support a set of processor extensions called TSX. TSX allows code to create an atomic transaction at the hardware level. Changes to RAM are buffered up in cache lines and interference between threads is tracked by the CPU itself. If there was a conflict, the CPU aborts the transaction and expects the code to either try again or fall back to regular locking. If no thread bumped into you, your writes are flushed to RAM in one go at the end.\n\nStarting with Java 8 Update 40, so-called “RTM locking” is enabled by default when the CPU supports it. This converts _every_ Java synchronized block into a hardware level atomic transaction using TSX. That means you will have multiple threads running inside synchronized blocks at once. The JVM profiles the app to find blocks that experience frequent thread interference, where the CPU is wasting time due to constantly rolling back/retrying, and converts them back to using regular locks. As Kotlin runs on the JVM it gets this functionality for free.\n\nThis lets you write code in the “one big lock” style without suffering the performance downsides, as long as you are on sufficiently new hardware.\n\nI should note here that STMs often provide extra features, like the ability to pause/retry a code block when the dependencies change, or the ability to explicitly cancel a transaction without retrying it (by throwing an exception). Hardware TM doesn’t offer this, or rather the JVM doesn’t surface the support at the moment. If you want more control, you must use a library and explicitly change your data model to incorporate transactional variables:\n\n```kotlin\nimport scala.concurrent.stm.japi.STM.*\n\nval counter = newRef(10)\ntry {\n    atomic {\n        increment(counter, 1)\n        println(\"counter is ${counter.get()}\")    // -> 11\n        throw Exception(\"roll back!!\")\n    }\n} catch(e: Exception) {\n    println(\"counter is ${counter.get()}\")        // -> 10\n}\n```\n\nHaskell has one other neat trick up its sleeve —using its type system it can ensure that variables are only accessed inside atomic blocks, so you can never forget to wrap your code up properly. We can do something a bit similar in Kotlin:\n\n```kotlin\nclass ThreadBox<T>(v: T) {\n    private val value = v\n    @Synchronized fun locked<R>(f: T.() -> R): R = value.f()\n}\n\nval bank = ThreadBox(object {\n    val accounts = intArrayOf(10, 0, 0, 0)\n})\n\nfun transfer(from: Int, to: Int, amount: Int) {\n    bank.locked {\n        accounts[from] -= amount\n        accounts[to] += amount\n    }\n}\n```\n\n\nA ThreadBox is a simple class that takes a pointer to some object in its constructor. It keeps that pointer privately. So, if there’s no other reference to the passed object it can only be accessed via the ThreadBox. When we declare _bank_, we use the object keyword to create an anonymous object and pass it in — so we know the only way to reach the accounts array is via the ThreadBox. And the ThreadBox only gives out that pointer inside an atomic block.\n\nThe compiler won’t let us access the array outside an atomic block ... unless we let a reference escape. So this is not as strong as the Haskell type system approach, but it’s a good start.\n\nThere’s a version of this code that can catch more mistakes [here](https://gist.github.com/mikehearn/1ad4a9c375e59e52b8cf).\n\nThe atomic method is a higher order function protected by a regular Java synchronized method, and it just immediately calls the provided code block under the lock. The JVM will ignore the lock on hardware that supports TSX and all threads can proceed in parallel, in an atomic transaction. As long as the two threads are using different account IDs for _from_ and _to_, no locking is done at all: that makes it nice and fast.\n\n### Things Kotlin lacks\n\nAt the moment there is no way to control side effects: any function call can be potentially side effecting. It would be nice if a future version of the language introduced something like the C++ const keyword, or D’s transitive const, to reduce the reliance on actually immutable data structures. The JVM offers features that can seal off common sources of external state, such as the disk and network, however the heap is still available. It may be an interesting project to make the JVM’s sandboxing features easily available via a Kotlin DSL.\n\nThere is not at this moment any high performance immutable collections library. Both Clojure and Scala have maps and sets in which mutating the collection returns a new collection, with internal data sharing to make performance practical. The Kotlin standard library does not. If someone were to make one, using [the CHAMP code](http://michael.steindorfer.name/publications/oopsla15.pdf) published this year would give significant improvements over the algorithms used in Scala/Clojure.\n\n","author":"Mike Hearn","date":"2015-09-18","type":"article","categories":["Kotlin","Functional"],"features":["highlightjs"],"description":"","filename":"","lang":"EN","enclosure":null},{"title":"Kotlin & Android: A Brass Tacks Experiment, Part 4","url":"https://medium.com/@CodingDoug/kotlin-android-a-brass-tacks-experiment-part-4-4b7b501fa457#.dllcmjpbu","body":"\n![Header Picture](https://cdn-images-1.medium.com/max/800/1*UN-S8ELMC2kpHf4tJKfbLQ.png)\n\n*Disclaimer: I am a Google employee, but the views expressed in this article are not those of my employer.*\n\n## Kotlin & Android: A Brass Tacks Experiment, Part 4\n\nWelcome to part 4 in this a series! If you missed [part 2](https://medium.com/p/kotlin-android-a-brass-tacks-experiment-part-2-c67661cfdf5f) and [part 3](https://medium.com/p/kotlin-android-a-brass-tacks-experiment-part-3-84e65d567a37), consider jumping back to those for a minute to see where we are in this journey to learn what the Kotlin® language can uniquely offer for Android development.\n\nAt this point, we have a pair of functions that we can use to succinctly express the creation of an entire Android view hierarchy in Kotlin code instead of the usual XML resources. Kotlin’s *type-safe builder* pattern is really shining here! However, in practice, there are still some rough edges with this scheme. Most notably, Android developers are used to having some special expressions in XML for certain Android concepts, such as sizes of Views measured in density independent pixels. This is super easy in XML and super tiresome in code!\n\nHere’s an example of a tiresome way to set the maxWidth property of a TextView to 120dp using our new v function:\n\n\n```kotlin\nval view = v<TextView>(context) {\n    // ugly!\n    maxWidth = TypedValue.applyDimension(\n        TypedValue.COMPLEX_UNIT_DIP, 120, context.resources.displayMetrics).toInt()\n}\n```\n[gist](https://gist.github.com/CodingDoug/abe3765f9fe641871ede)\n\nContrast that to XML layouts, where you’d simply say:\n\n```xml\n<TextView android:maxWidith=\"120dp\" />\n```\n[gist](https://gist.github.com/CodingDoug/c239a76530670537ce6b)\n\nBah! We just lost all the convenience that our v functions were trying to gain!\n\n### We need an abbreviated way to convert dp to px.\n\nWhat I’d like is a function to provide shortened syntax for specifying pixel measurements in other units. Here’s what I want to say instead of the above mess:\n\n```kotlin\nval view = v<TextView>(context) {\n    // simpler way to set maxWidth to 120dp\n    maxWidth = dp_i(120)\n}\n```\n[gist](https://gist.github.com/CodingDoug/cef8e7f5fe6324ff6436)\n\nWhat I’m proposing here is a function that takes a value measured in dp and returns the value converted to px for the current device. Why call the function “dp_i” and not just “dp”? Sometimes Android wants to take pixel measurements as a floating point number and sometimes as an integer. I don’t want to manually cast the return value (still too many more characters), so I’ll just make one function for of each type, “dp_i” and “dp_f”.\n\nBut there’s a wrinkle here. If you look back at the full code that computes the dp value, it requires a Context to operate. I don’t want to have to pass a Context as another argument to dp_i every time I call it. So I’m going to use a feature of Kotlin called [extension functions](https://kotlinlang.org/docs/reference/extensions.html) to get the brevity I prefer.\n\nLet’s jump right into the code. Written as extension functions, here’s what dp_i and dp_f look like:\n\n```kotlin\nimport android.view.View\n\nfun View.dp_f(dp: Float): Float {\n    return TypedValue.applyDimension(\n        TypedValue.COMPLEX_UNIT_DIP, dp, context.resources.displayMetrics)\n}\n\nfun View.dp_i(dp: Float): Int {\n    return dp_f(dp).toInt()\n}\n```\n[gist](https://gist.github.com/CodingDoug/489045d5a92be732dec9)\n\n### How does an extension function work?\n\nThe first thing to notice in the above code is the apparent name of the functions. You might have expected to see just “dp_f” for the first function, but instead we have “View.dp_f”. This is a special syntax in Kotlin for extension functions. There is a dot between a class name (here, android.view.View) and the name of the function to define. What we did here was tell Kotlin to augment the View class with a new two new methods called “dp_f” and “dp_i”. There’s a couple things you get with extension functions like these.\n\n**First, code in the body of the extension functions can act like a member of View by accessing its members and methods (but only of “public” and “internal” visibility)**. This means that dp_f can use the View’s Context reference as exposed by the synthetic property called “context”. Now we don’t have to pass a Context as a parameter since it comes implicitly with the View.\n\n**Second, other code that imports these extension functions can call them as if they’re normal member methods on instances of View objects**. This means that our v function’s lambda with receiver argument of type View can call these methods similarly to ordinary functions, implicitly using the receiver View object reference. So you can say “maxWidth = dp_i(120)” in the lambda, and Kotlin will recognize that you want to call the dp_i function on the View type receiver object.\n\n**One important thing to know here is that Kotlin doesn’t actually make changes to a class definition when defining an extension function**. A class will always be its own complete unit after it’s been loaded by a program, so we can only use extension functions to add code around it. Also, the existing methods on View also can’t reach back into and extension function, because it’s not a real member defined with the class.\n\nThe upshot of these points, for this experiment, is that we now have convenient functions for converting dp to px in our v function lambdas!\n\n**We’re not stopping here! How about another shortcut using extension functions?**\n\nWe’ve seen that you can do tricky things with extension functions to make some kinds of functions more convenient to use. Let’s continue with that thought to tighten up our v functions.\n\nCurrently, we have these two function signatures, the first for building the root view using a Context and the second for creating nested child views in a parent view:\n\n```kotlin\ninline fun <reified TV : View> v(context: Context, init: TV.() -> Unit) : TV\n\ninline fun <reified TV : View> v(parent: ViewGroup, init: TV.() -> Unit) : TV\n```\n[gist](https://gist.github.com/CodingDoug/c91ef8277e3edae1be6e)\n\nIt would be nice if we didn’t have to pass the Context or ViewGroup as the first parameter. With extension functions, we achieve this just like we did above when avoiding passing a Context to dp_f. Here’s a re-implementation of both functions as extension functions, with the commented out lines showing the original code for v above the newly modified lines:\n\n```kotlin\n//inline fun <reified TV : View> v(context: Context, init: TV.() -> Unit) : TV {\ninline fun <reified TV : View> Context.v(init: TV.() -> Unit) : TV {\n    val constr = TV::class.java.getConstructor(Context::class.java)\n\n // val view = constr.newInstance(context)\n    val view = constr.newInstance(this)\n\n    view.init()\n    return view\n}\n\n//inline fun <reified TV : View> v(parent: ViewGroup, init: TV.() -> Unit) : TV {\ninline fun <reified TV : View> ViewGroup.v(init: TV.() -> Unit) : TV {\n\n    val constr = TV::class.java.getConstructor(Context::class.java)\n\n // val view = constr.newInstance(parent.context)\n    val view = constr.newInstance(context)\n\n    parent.addView(view)\n    view.init()\n    return view\n}\n```\n[gist](https://gist.github.com/CodingDoug/43d17d44459805e51072)\n\nYou can see that we’re removing the first argument to each function (Context and ViewGroup), and instead, expecting those references to come from the instance of the class they are extending. The functions now have just a single argument — the lambda with receiver that modifies the created View.\n\nWith these modified functions, if we’re coding inside an Activity (which is a subclass of Context), we refer to v as a member of the Activity object. We can take advantage of this to build nested views even easier like this:\n\n```kotlin\nv<LinearLayout> {\n    layoutParams = LayoutParams(WRAP_CONTENT, WRAP_CONTENT)\n    orientation = VERTICAL\n\n    v<TextView> {\n        layoutParams = LayoutParams(WRAP_CONTENT, WRAP_CONTENT)\n        text = \"Hello\"\n    }\n    v<TextView> {\n        layoutParams = LayoutParams(WRAP_CONTENT, WRAP_CONTENT)\n        text = \"World\"\n    }\n}\n```\n[gist](https://gist.github.com/CodingDoug/3961d2ccc55376cf1274)\n\nThe invocations of v don’t even look like function calls because we no longer need parenthesis at all. If you recall from [part 2 in this series](https://medium.com/@CodingDoug/kotlin-android-a-brass-tacks-experiment-part-2-c67661cfdf5f), if the last argument to a function is a lambda, you can place it after the parenthesis. And in this case, when there’s only one argument, you don’t need the parenthesis at all!\n\nKotlin’s extension functions have just gone a long way toward helping us express an Android view hierarchy in a very readable and succinct way in code. However, there’s still some more problem spots that could use some attention. For example, lets take this code that assigns 16dp of left padding to a TextView:\n\n```kotlin\nv<TextView> {\n    layoutParams = LayoutParams(WRAP_CONTENT, WRAP_CONTENT)\n    setPadding(dp_i(16), 0, 0, 0)\n    text = \"Hello\"\n}\n```\n[gist](https://gist.github.com/CodingDoug/6119424973b9c0f3824d)\n\nIt’s pretty ugly to mix a method call to setPadding() with the synthetic property accessors for layoutParams and text. setPadding() is causing us problems here because it’s not a JavaBeans-style setter — it has more than one argument. Therefore, Kotlin can’t assign a synthetic property to it. But fear not! This can be fixed with clever use of another Kotlin language feature, as we’ll discover in the upcoming part 5.\n\nIf you want to stay on top of this series, you can follow me both [here on Medium](https://medium.com/@CodingDoug) and [on Twitter](https://twitter.com/CodingDoug) as CodingDoug and get instant notification of future parts!\n\n","author":"Doug Stevenson","date":"2016-02-04","type":"article","categories":["Kotlin","Android"],"features":["highlightjs"],"description":"","filename":"","lang":"EN","enclosure":null},{"title":"Kotlin для начинающих","url":"https://habrahabr.ru/post/278277/","body":"\nУже не мало нашумел Kotlin в мире программирования, не мало профессиональных инженеров уже обратил на него внимание, но также есть и те кому он не симпатизирует.\n\n![Kotlin](https://habrastorage.org/files/a52/453/729/a52453729bd64cb3b5ca8a4892e45cc1.png)\n\nВ данном топике я бы хотел обратить внимание тех начинающих программистов которые возможно только делают свой выбор языка программирования, которому бы хотели посвятить свою жизнь так сказать.\n\nЯ сам Java Developer и для меня наступил тот период я когда хотелось посмотреть на другие языки, взять какие-то практики для себя с них.\n\nИ однажды примерно в 2013 году я услышал что та прекрасная компания делающая такие крутые продукты как **Intellij IDEA**, **Youtrack** а именно [JetBrains](https://www.jetbrains.com/), анонсировала о новом языке [Kotlin](https://kotlinlang.org/), который на то время был в активной стадии разработки.\n\nИ в этом году а именно 15 февраля 2016 года был выпушен релиз **Kotlin 1.0**. С этого момента я начал уже более активней его изучать и пытаться применять в небольших свои проектах.\n\n## Kotlin для начинающих\n\nИ этим постом я бы хотел поделится серией видео в которой я начал делится всем тем что я изучил за это время касаемо Kotlin.\n\n**Урок 0. Введение и знакомство**\nhttps://www.youtube.com/watch?v=L9k_NdTaMeI\n\n\n**Урок 1. String Templates**\nhttps://www.youtube.com/watch?v=frw1DpNm_ms\n\nПока планирую выкладывать два видео в неделю, весь список будет [тут](https://goo.gl/yegW0d).\nСпасибо за ваше внимание, и надеюсь, данная информация кому-то будет полезно!\n\n","author":"@Devcolibri","date":"2016-03-02","type":"article","categories":["Kotlin"],"features":["highlightjs"],"description":"","filename":"","lang":"RU","enclosure":null},{"title":"Kotlin Month Post 2: Inheritance and Defaults","url":"https://programmingideaswithjake.wordpress.com/2016/03/05/kotlin-month-post-2-inheritance-and-defaults/","body":"\n## Intro\n\nContinuing on with [Kotlin Month](https://programmingideaswithjake.wordpress.com/kotlin/#kotlinmonth), this week, I’ll be discussing topics in Kotlin that have to do with inheritance and default values.\n\n## Composition Over Inheritance\n\nKotlin has put in a feature and a couple defaults that help developers keep the principle of Composition Over Inheritance at the forefront of their mind. The first of these is a feature that lets you composition almost as easily as inheritance when it comes to defining wrapper classes.\n\n## First-Class Delegation\n\nKotlin provides first-class access to delegation with very little help from you, the developer. All that needs to be done is:\n\n1. The new class inherits from an interface\n1. The new class provides a primary constructor that defines a property that inherits from the same interface\n1. After declaring the inheritance of the interface, include “by <name of property>”\n\nFor example:\n\n```kotlin\ninterface A {\n   fun doSomething(): Unit\n}\n\nclass B (val a: A) : A by a\n```\n\nIn this example, we have interface `A`, which has a `doSomething()` method to be implemented. Class `B` is our delegator class. It inherits from `A`, includes a primary constructor with a property called `a` that inherits from `A` (`(val a: A)`), and says to delegate to `a` with `A by a`.\n\nNow `B` doesn’t need to explicitly implement any of the methods from `A` because they’re implicitly provided via delegation, just like it would with normal inheritance if `B` was inheriting from a fully implemented class. In this case, instead of just pointing to its parent class implementation, it gets a default implementation as if `B` had been defined like this:\n\n```kotlin\nclass B (val a: A) A {\n   override fun doSomething() {\n      a.doSomething()\n   }\n}\n```\n\nThe delegation can be done for multiple interfaces at a time, too.\n\nI created a [class decorator in Python](https://programmingideaswithjake.wordpress.com/2015/05/23/python-decorator-for-simplifying-delegate-pattern/) that did something like this a while back, since I liked this idea so much.\n\nKotlin practically needed something like this in the language to go along with a certain set of defaults...\n\n## Final By Default\n\nClasses and public methods are `final` by default in Kotlin, meaning they can not be inherited from or overridden, respectively. In order to make those options available, classes and methods must be marked as `open`.\n\nThis goes along with item 17 in Effective Java, namely “Design and document for inheritance or else prohibit it”, just as this entire item lines up with item 16 in Effective Java, “Favor Composition Over Inheritance”.\n\nThese two pieces work together quite nicely and will hopefully mean that code written in Kotlin will be of better quality because of it.\n\nMany people are against the decision of final by default, but they largely seem to not realize that C# has had the same thing all along (without first-class delegation, I might add), and I haven’t heard any complaints from their side. I would venture to guess that most of the people that argue this point also don’t have a mindset of preferring composition. Obviously, there are some cases where this may backfire (especially if a library doesn’t provide an interface for a certain class you want to extend), but this should hopefully prevent more problems than it makes.\n\n## Visibility Modifier Defaults\n\nWhat is the most commonly typed word in all of Java? I would venture to guess that it’s `public`, with `return` and `import` in a close second place. For the most part, that `public` keyword is clutter; most things are public, and it should probably be the default. Kotlin decided to do just that, making the code cleaner.\n\nNow, this does go against the general advice for encapsulation for making members of a class as private as possible, but even when this advice is followed pretty well, `public` is still the most common visibility modifier. So, thankfully, `public` is the default in Kotlin.\n\n## Sealed Classes\n\nSealed Classes are a more interesting than useful feature, in my opinion. They provide a way to lock in a hierarchy so that the only subclasses of the sealed class are those defined within its borders. This is really handy for the split-type monads (such as Either and Maybe/Optional) and, judging by the example used in the documents, expression trees.\n\nAgain, Kotlin has an additional feature that plays well with this feature, and that’s the when expression, which is a reimagined `switch`. The `when` expression is made aware by the compiler to know whether all of the subclasses are presented so that it doesn’t force you to needlessly provide a default `else` clause.\n\nAgain, I find this feature more interesting than useful, especially since I worked out a (slightly more painful) way to largely recreate the same thing in Java (with an additional idea or two running through my head). If you’re curious how I do it, leave a comment letting me know, and I’ll do a post about it.\n\n# Extension Methods\n\nExtension methods are methods that you can “add onto a class” after the fact. I use quotes because they’re not actually added to the class (at least not in Kotlin); rather, they are a static methods that can be used as if they’re methods on an instance, allowing you to import those methods to be used only in certain instances and to discover them with autocompletion. But mostly it’s a syntax that makes static methods look less stupid.\n\nWhy are these not more of a thing in the programming world? All those `String` and `Date` utility classes would be so much easier to use if they could be used as extensions to the actual class. Other than C#, I don’t know of any other languages that do this (understandably, dynamic languages don’t actually need anything special for this feature, since you can literally add any method to a class any time you want). If you know of any, I’d appreciate it if you listed them in the comments.\n\nAnother awesome thing about extension methods is how Kotlin combines them with lambdas to make extension lambdas, which make certain things like [their](https://kotlinlang.org/docs/reference/type-safe-builders.html) [type-safe](https://programmingideaswithjake.wordpress.com/2016/01/16/mimicking-kotlin-builders-in-java-and-python/) [builders](https://programmingideaswithjake.wordpress.com/2016/01/23/kotlin-like-builders-in-java-and-python-continued-additional-parameters/) so much cleaner.\n\n## Outro\n\nThat’s the end of *this* article. Tune in next week for the third post of [Kotlin Month!](https://programmingideaswithjake.wordpress.com/kotlin/#kotlinmonth) That one will go over the safety features that Kotlin has, such as null safety and improved generics.\n","author":"Jacob Zimmerman","date":"2016-03-05","type":"article","categories":["Kotlin"],"features":["highlightjs"],"description":"","filename":"","lang":"EN","enclosure":null},{"title":"Write a lightweight, cross-platform HTML5 desktop app with Kotlin","url":"https://medium.com/@lorenzoangelini/write-a-lightweight-cross-platform-html5-desktop-app-with-kotlin-1033eb708800#.rt99y3jm1","body":"\n## How even a developer like me can build stunning cross-platform desktop apps (using Copy & Paste)\n\n#### The problem\n\n**UI design is hard**, very hard, especially for a developer like me.\n\nI love to code, I always think about clever ways to tune and refactor my code.\n\nAt the same time I find building beautiful UIs so hard and frustrating that sometimes I wish I lived when the only way to interact with my app was a lovely black and white command line interface.\n\nBut then, I immediately remember I’ve been lucky enough to live (and code) in years in which **HTML is the glorious standard for web content creation.**\n\nThe best thing that could happen has already happened: **one common presentation “language” shared by everyone**.\n\nThe consequence is that, nowadays, you can find plenty of free online resources for creating stunning HTML5 UIs with little or no effort at all: tutorials, guides and libraries of already-made well-crafted UI widgets are available at your disposal.\n\n**Want to start sketching up a shiny new project but no idea where to start with the UI?** Pick [Bootstrap](http://getbootstrap.com) and you’ll get, immediately, a lot of reusable UI components, already styled by professional designers.\n\nDon’t like Bootstrap default theme? choose [another one](https://bootswatch.com).\n\nDo you want to add some fancy interaction? Pick [React](https://facebook.github.io/react) and you’ll get the framework Facebook developers used for building fast, interactive UIs.\n\n**All well and good until your customer needs a desktop application**: coming from the wonderful world of web development the risk of falling into deep depression becomes real.\n\nIn the world of desktop applications there is neither a common language nor a common technology stack to define user interfaces: billions of programming languages mixed with billions of UI toolkits.\n\n**This heterogeneity of possible solutions leads to less documentation, less examples and most of these solutions aren’t even cross-platform at all**... to sum it up: a complete disaster!\n\nSome solutions have been proposed to overcome this problem: Both the [NW.js](https://nwjs.io/) and the [Electron](http://electron.atom.io) projects let developers write HTML+Javascript code and run it as a desktop app.\n\nThese solutions are really valuable choices (ever heard of the [Atom](https://atom.io/) editor? :)), but, as you may guess, they’re not pure magic and have their own downsides.\n\nActually, your app will be packaged with a shrinked version of the chromium browser to make magic happens... The result? **A simple app built with NW.js/Electron has a size of at least 100MB!**\n\n#### My solution\n\nLuckily enough, it seems that (almost) everyone in this world has a JRE installed on his machine, and even more luckily it seems that JavaFX has a component called WebView that renders HTML5 content.\n\nHoorray! no more need to bundle a browser with my application! :)\n\nSo, **why not mix the power and conciseness of the brand new** [**Kotlin language**](https://kotlinlang.org/) **with all the benefits of HTML5 for UI creation?**\n\nLet’s start now.\n\n#### Your first HTML5 desktop app with Kotlin\n\nWe want to build an extremely simple PhoneBook desktop application.\n\nLet’s start by defining a simple model for our contacts.\n\nWith Kotlin, this task translates to a one-liner, we can use a data class with four attributes: a name, a phone number, an email address and a physical address.\n\nIn the model class, we also add the logic to retrieve data: the “all” function may populate a list of Contacts, fetching data from literaly everywhere (text files, relational DBMS, NoSQL datasources, ...).\n\nFor the purpose of this example project we just create some fake data.\n\n```kotlin\ndata class Contact(val name: String, val phone: String, val email: String, val address: String) {\n    companion object {\n        fun all() = listOf(Contact(\"Paul Black\", \"+39 334256789\", \"paul.black@example.com\", \"282 Kevin Brook Street, Imogeneborough\"),\n                           Contact(\"John Red\", \"+44 340556677\", \"john.red@example.com\", \"3316 Arron Smith Drive, New Roads\"),\n                           Contact(\"Ken White\", \"+32 39876544\", \"ken.white@example.com\", \"169 Ersel Street, Paxtonville\"))\n    }\n}\n```\n\nWe now need a function that, given a Contact, returns the HTML markup to render it.\n\nIn this project we will use Bootstrap to make things prettier and every Contact will be displayed inside its “panel”_._\n\nAs you can see, we use Kotlin String interpolation as a sort of template engine.\n\n```kotlin\nfun contactPanel(contact: Contact) =\n\"\"\"\n<div class=\"contact panel panel-info\">\n    <div class=\"panel-heading\"> <h3 class=\"panel-title\">${contact.name}</h3> </div>\n    <div class=\"panel-body\">\n        <div class=\"row\">\n            <div class=\"col-md-3 col-lg-3\" align=\"center\">\n                <img class=\"img-circle img-responsive\"\n                     alt=\"${contact.name} pic\"\n                     src=\"${HTML5View.resourceLink(\"/img/default-avatar.jpg\")}\" />\n            </div>\n            <div class=\"col-md-9 col-lg-9\">\n                <table class=\"table table-contact-information\">\n                    <tbody>\n                        <tr> <td>Phone:</td> <td>${contact.phone}</td> </tr>\n                        <tr> <td>Email:</td> <td>${contact.email}</td> </tr>\n                        <tr> <td>Address:</td> <td>${contact.address}</td> </tr>\n                    </tbody>\n                </table>\n            </div>\n        </div>\n    </div>\n</div>\n\"\"\"\n```\n\nMaking use of the above function, we should now build another function that, given a Contact list, returns the complete HTML view.\n\n```kotlin\nfun contactsView(contacts: List<Contact>) =\n\"\"\"\n<html>\n    <head>\n        <link rel=\"stylesheet\" href=\"${HTML5View.resourceLink(\"/css/bootstrap.min.css\")}\" />\n        <link rel=\"stylesheet\" href=\"${HTML5View.resourceLink(\"/css/contacts.css\")}\" />\n        <title>My contacts</title>\n    </head>\n    <body>\n        <div class=\"container\">\n            <div class=\"row\">\n                <div class=\"col-md-6 col-md-offset-3\">\n                    ${contacts.map { contactPanel(it) }.joinToString(\"\\n\")}\n                </div>\n            </div>\n        </div>\n    </body>\n</html>\n\"\"\"\n```\n\nAs you may have already spotted in the HTML template, we need references to other static files such as images, css and javascript resources.\n\nWe use an helper method called “resourceLink” that solves this problem for us.\n\nLet’s build this method into the class that is responsible to handle the window and Webview creation.\n\nIt’s really simple and takes advantage of the [Java resource system](http://docs.oracle.com/javase/7/docs/technotes/guides/lang/resources.html) to access static files that will be bundled inside the final executable Jar of our app.\n\n```kotlin\nfun resourceLink(path: String) = \"${HTML5View::class.java.getResource(path)}\"\n```\n\nIt’s time to take a look at the class that creates the JavaFX window and the WebView that will render our HTML and execute our Javascript code.\n\nUsing [TornadoFX](https://github.com/edvin/tornadofx), a lightweight JavaFX framework for Kotlin, building this class becomes really simple and natural: TornadoFX uses several language features from Kotlin to create JavaFX visual components with the most concise code as possible.\n\n```kotlin\nclass HTML5View : View() {\n    companion object {\n        fun resourceLink(path: String) = \"${HTML5View::class.java.getResource(path)}\"\n    }\n\n    override val root = WebView()\n    init {\n        with(root) {\n            setPrefSize(800.0, 600.0)\n            // Atomatically set the title of the window as the HTML document title\n            titleProperty.bind(engine.titleProperty())\n            // Show all the contacts\n            engine.loadContent(contactsView(Contact.all()))\n        }\n    }\n}\n```\n\nThe last thing left to do is to create the “main” function that starts our application.\n\n```kotlin\nclass HTML5App : App(HTML5View::class)\n\nfun main(args: Array<String>) = Application.launch(HTML5App::class.java)\n```\n\nAnd that’s all the code needed for this simple PhoneBook application... Pretty easy right? :)\n\nWe can now use the “shadowJar” Gradle plugin to package a redistributable fat executable Jar with all the dependencies, and it weights only 4.6 MB!\n\n![](https://cdn-images-1.medium.com/max/800/1*dJiZHivKunYuYpSI5NZfpg.png)\n\nStarting form this example project, **it’s easy to extend this idea and build beautiful, lightweight and cross-platform applications** taking advantage of all the resources the web has to offer for creating HTML content.\n\nYou can find all the complete source code at [my Github account](https://github.com/lorenzo-ange).\n\n[**lorenzo-ange/html5-desktop-app**](https://github.com/lorenzo-ange/html5-desktop-app) - _This is an example of a desktop application written with Kotlin and HTML5._\n\n**Thanks for reading!**\n\n","author":"Lorenzo Angelini","date":"2016-12-24","type":"article","categories":["Kotlin"],"features":["highlightjs"],"description":"","filename":"","lang":"EN","enclosure":null},{"title":"Kotlin 1.0.3 EAP","url":"https://discuss.kotlinlang.org/t/kotlin-1-0-3-eap/1729","body":"\nWe're starting Kotlin `1.0.3` EAP.\n\n### What's new\n\n1.0.3 brings some minor changes to compiler and lots of improvements to IntelliJ plugin:\n- Improved completion, refactorings, Maven support, formatter and Spring support\n- Language injection support\n- New intentions, inspections and quickfixes\n- Lots of bugfixes\n\nSee full [changelog](https://github.com/JetBrains/kotlin/blob/3731e170e459bf02b562464ca02ccb6812760ee2/ChangeLog.md)\n\n### How to get EAP build\n\nTo use this build from Gradle or Maven, add [https://dl.bintray.com/kotlin/kotlin-eap](https://dl.bintray.com/kotlin/kotlin-eap) to your repositories.\nTo use the new version of the Kotlin plugin for IntelliJ IDEA, configure Early Access Preview channel in **Tools | Kotlin | Configure Kotlin Plugin Updates** and press \"Check for updates now\".\n\nBuild number is `1.0.3-eap-30`\n\nPlease do provide feedback and report any issues to our [issue tracker](https://youtrack.jetbrains.com/issues/KT#newissue) (please specify your plugin version and IDE version)\n\n","author":"Pavel Talanov","date":"2016-06-08","type":"article","categories":["Kotlin"],"features":["highlightjs"],"description":"","filename":"","lang":"EN","enclosure":null},{"title":"Announcing the Support Program for Kotlin User Groups and Events","url":"https://blog.jetbrains.com/kotlin/2017/01/announcing-the-support-program-for-kotlin-user-groups-and-events/","body":"\nToday we are launching a new [Community section at our web-site](https://kotlinlang.org/community/)!\n\n![Explore Kotlin Community](https://d3nmt5vlzunoa1.cloudfront.net/kotlin/files/2017/01/Screen-Shot-2017-01-26-at-17.37.05.png)\n\nIt will provide you with the guidelines to organize Kotlin related events, and the description of support managed by JetBrains. We are now happy to announce that we have formalized the support process for User Groups and Events around Kotlin.\n\nIt is exciting to see that in 2016 about 150,000 of developers all over the world tried Kotlin. We now have an amazing community, which enables us to hold Kotlin-dedicated talks and meetups. We have also held two Kotlin Nights: the first one [was in San-Francisco](https://blog.jetbrains.com/kotlin/2016/06/kotlin-night-recordings/) and the other one [was in London](https://blog.jetbrains.com/kotlin/2016/09/kotlin-night-in-london/). What is even more fantastic is that you, the community, start to organise these events, and we are here to help. It is also great to see demand for more Kotlin Nights.\n\nWe offer the following programs:\n\n## [Kotlin User Groups Support Program](https://kotlinlang.org/community/user-groups.html)\n\nWe appreciate what you do and would love to help you find partners and speakers for your meetups, as well as to help promote your events. We can give you swag and provide you with an advice. Please [fill up the form for your user group](https://docs.google.com/forms/d/e/1FAIpQLSdkLbD_SPbXZDVW2nQPgUiLCW4HOSXysOVK1jPLcShPfyhkNA/viewform) or feel free to reach out via [e-mail](mailto:alina@jetbrains.com).\n\n## [Kotlin Nights Support Program](https://kotlinlang.org/community/kotlin-nights.html)\n\nWe encourage everyone who wants to organise a Kotlin Nights event to do so. We can provide support in terms of merchandise, and promote your event via our media channels. We have a Kotlin Night Kit available for you to use, which includes the guidelines, branding materials and swag for speakers and attendees. If you need help reaching out to potential partners or with any other steps, feel free to ping us via [e-mail](mailto:alina@jetbrains.com).\n\n## [Kotlin Talks & Speakers Support](https://kotlinlang.org/community/talks.html)\n\nIf you are a speaker, let us know about your upcoming event, and we will send you a t-shirt and stickers for the attendees. By the way, they are available online for everyone at [Stickermule](https://www.stickermule.com/user/1069238064/stickers) and [Apparel Store](https://www.ptxstore.com/jetbrains/product_info.php?products_id=3011). Check out the New Events web page and [submit your talk](https://docs.google.com/forms/d/e/1FAIpQLSfeXstxUcBsOypWtE9McIpYU82szB3yIYkU-30fNXOVoJocEQ/viewform) to show up on the global [Kotlin activities map](https://kotlinlang.org/community/talks.html).\n\nJUGs and GDGs are also encouraged to participate! If you have Kotlin-related talks or specially dedicated meetups, [submit them](https://docs.google.com/forms/d/e/1FAIpQLSfeXstxUcBsOypWtE9McIpYU82szB3yIYkU-30fNXOVoJocEQ/viewform), and we will figure out an optimal support plan for you.\n\nMoreover, we have a standard JetBrains Community Support Program for user groups related to software development , as well as community-driven events, not just Kotlin-related. [You can easily apply here](https://www.jetbrains.com/support/community/?fromMenu#section=communities).\n\nIf you have any questions, please ping [Alina](mailto:alina@jetbrains.com), who will be more than happy to help you.\n","author":"Alina Dolgikh","date":"2017-01-30","type":"article","categories":["Kotlin"],"features":["highlightjs"],"description":"","filename":"","lang":"EN","enclosure":null},{"title":"Погружение в Async-Await в Android","url":"https://habrahabr.ru/post/314656/","body":"\n\n","author":"Макс Ровкин","date":"2016-11-09","type":"article","categories":["Kotlin","Android"],"features":["highlightjs"],"description":"","filename":"","lang":"RU","enclosure":null},{"title":"How to get IDEA to detect kotlin generated sources using Gradle","url":"https://blog.nishtahir.com/2016/06/25/how-to-get-idea-to-detect-kotlin-generated-sources-using-gradle/","body":"\nSo I recently got my hands on Kotlin and it's been great so far.\n\nHowever one of the things that the IDEA kotlin plugin doesn't do<sup id=\"fnref:1\">[1](#fn:1)</sup> is detect the `kapt` folder which contains any sources generated from annotation processing. This can be fixed using the IDEA gradle plugin<sup id=\"fnref:2\">[2](#fn:2)</sup>.\n\nThe idea plugin isn't able to mark the kapt folder as a source directory unless it's been added to the gradle source set.\n\n```gradle\nsourceSets.main.java.srcDir file(\"$buildDir/generated/source/kapt/\")\n\n```\n\nThe next step is to tell the idea plugin to mark the kapt folder as a generated sources root in the module<sup id=\"fnref:3\">[3](#fn:3)</sup>.\n\n```gradle\nidea {  \n    module {\n        // Tell idea to mark the folder as generated sources\n        generatedSourceDirs += file(\"$buildDir/generated/source/kapt/\")\n    }\n}\n```\n\nWhen put together your build script should look a little like this.\n\n```gradle\napply plugin: 'idea'\n\n...\n\nkapt {  \n    generateStubs = true\n}\n\n// Add kapt directory to sources\nsourceSets.main.java.srcDir file(\"$buildDir/generated/source/kapt/\")\n\nidea {  \n    module {\n// Tell idea to mark the folder as generated sources\n        generatedSourceDirs += file(\"$buildDir/generated/source/kapt/\")\n    }\n}\n```\n\n###### Footnotes and references\n\n1. <a name=\"fn:1\"></a> →, V. (2015). Better Annotation Processing: Supporting Stubs in kapt. [online] Kotlin Blog. Available at: [https://blog.jetbrains.com/kotlin/2015/06/better-annotation-processing-supporting-stubs-in-kapt/#comment-36065](https://blog.jetbrains.com/kotlin/2015/06/better-annotation-processing-supporting-stubs-in-kapt/#comment-36065) [Accessed 25 Jun. 2016]. [↩](#fnref:1 \"return to article\")\n\n2. <a name=\"fn:2\"></a> Docs.gradle.org. (2016). The IDEA Plugin - Gradle User Guide Version 2.14. [online] Available at: [https://docs.gradle.org/current/userguide/idea_plugin.html](https://docs.gradle.org/current/userguide/idea_plugin.html) [Accessed 25 Jun. 2016]. [↩](#fnref:2 \"return to article\")\n\n3. <a name=\"fn:3\"></a> Docs.gradle.org. (2016). IdeaModule - Gradle DSL Version 2.14. [online] Available at: [https://docs.gradle.org/current/dsl/org.gradle.plugins.ide.idea.model.IdeaModule.html](https://docs.gradle.org/current/dsl/org.gradle.plugins.ide.idea.model.IdeaModule.html) [Accessed 25 Jun. 2016]. [↩](#fnref:3 \"return to article\")\n","author":"Nish Tahir","date":"2016-06-25","type":"article","categories":["Kotlin"],"features":["highlightjs"],"description":"","filename":"","lang":"EN","enclosure":null},{"title":"Kotlin Eclipse Plugin 0.7 Is Here!","url":"http://blog.jetbrains.com/kotlin/2016/06/kotlin-eclipse-plugin-0-7-is-here/","body":"\nWe are happy to present a new release of our plugin for Eclipse IDE. Along with the support for Kotlin **1.0.2** compiler, this update brings very important features and improvements.\n\nThe code formatting feature was rebuilt in this release. Instead of our first naive implementation we have mostly managed to port the advanced formatter from the Kotlin IntelliJ Idea plugin into Eclipse. This means that [a lot of fixes](https://youtrack.jetbrains.com/issues/KT?q=Formatter%20State:%20Fixed%20Subsystems:%20IDE) are already there and upcoming improvements will be picked up automatically!\n\n![](http://d3nmt5vlzunoa1.cloudfront.net/kotlin/files/2016/06/fromater.gif)\n\nNew line auto-indent also benefitted from this code reuse and now shows far more predictable and smart behaviour.\n\nIt was possible to add missing classes imports one-by-one with a quick-fix since 0.1.0 version, and now we’ve improved on that by introducing the _Organize Imports_ feature. It will clean unused imports, add missing imports for classes used in the file and resort them.\n\n![](http://d3nmt5vlzunoa1.cloudfront.net/kotlin/files/2016/06/organize.gif)\n\nOur completion got several fixes in prioritizing variants and is now far more usable. Also not-imported classes are now suggested in completion popup at once and will be inserted together with the corresponding import.\n\n![](http://d3nmt5vlzunoa1.cloudfront.net/kotlin/files/2016/06/import.gif)\n\nSeveral quick-fixes about missing or illegal modifiers were added:\n\n*   It’s now possible to add an open modifier to a declaration which is overridden or subclassed.\n    ![](http://d3nmt5vlzunoa1.cloudfront.net/kotlin/files/2016/06/open.gif)\n*   It’s now easy to deal with the _“class must be declared abstract”_ compiler error.\n    ![](http://d3nmt5vlzunoa1.cloudfront.net/kotlin/files/2016/06/abstract.png)\n\n*   Invalid modifier removing is now also available from the quick-fix popup.\n    ![](http://d3nmt5vlzunoa1.cloudfront.net/kotlin/files/2016/06/modifiers.png)\n\nPlease give it a try.\n\n[![Drag to your running Eclipse workspace to install Kotlin Plugin for Eclipse](http://i2.wp.com/marketplace.eclipse.org/sites/all/themes/solstice/_themes/solstice_marketplace/public/images/btn-install.png?zoom=1.5&w=640)](http://marketplace.eclipse.org/marketplace-client-intro?mpc_install=2257536 \"Drag to your running Eclipse workspace to install Kotlin Plugin for Eclipse\")\n\nIf you run into any problems or encounter missing features, please don’t hesitate to leave your feedback here or file issues in YouTrack.\n\n","author":"Nikolay Krasko","date":"2016-06-03","type":"article","categories":["Kotlin","Eclipse"],"features":["highlightjs"],"description":"","filename":"","lang":"EN","enclosure":null},{"title":"Experimenting with “mutation testing” and Kotlin","url":"https://medium.com/@s4n1ty/experimenting-with-mutation-testing-and-kotlin-b515d77e85b5#.9ps78uqer","body":"\nThe most common approach to measuring how comprehensive your unit tests are is to look at “code coverage”, literally the number of lines of your code that are executed by your unit tests.\n\nWhile this isn’t a bad approach, it really only tests what code is executed by your tests, it doesn’t directly measure their ability to detect bugs in your code, which is their purpose. You could easily write unit tests that execute every line of code, and yet will pass regardless of what your code actually does.\n\nMutation testing addresses this problem. In a completely automated way, it deliberately introduce bugs (“mutations”) in your code, and then verifies that the unit tests fail.\n\nThere is an excellent tool called [Pitest](http://pitest.org/) for Java and other JVM languages that does exactly this, so I decided to test it on a relatively [simple library](https://github.com/sanity/pairAdjacentViolators) I created recently (related to machine learning), I did my best to unit test it fairly comprehensively.\n\nMy library is implemented in [Kotlin](http://kotlinlang.org/) (which runs on the JVM) and which uses Gradle as a build tool. Adding Pitest was super-easy, I expected some headaches because I’m using Kotlin and not Java, but it worked perfectly first time, exactly as advertised. Very impressive. [Here](https://github.com/sanity/pairAdjacentViolators/commit/38abd1edfdb4389fee4a31be867dfd4c29747a36) are the modifications required to my build.gradle file.\n\nPitest took between 17 and 30 seconds to run, quite fast considering. Pitest appears to be fairly smart about only running the unit tests that matter for any given file, which suggest that it will scale linearly with the size of your codebase.\n\n[Here](https://sanity.github.io/pairAdjacentViolators/pitest-example/) are the results. They look very similar to a normal code coverage report, you can see each of the three main classes in the project, and if you click on each you can see the respective source file, with each line of code colored red or green.\n\nTake line 17 of [PairAdjacentViolators.kt](https://sanity.github.io/pairAdjacentViolators/pitest-example/PairAdjacentViolators.kt.html), if you mouseover the ‘1’ to the left of the code you can see that here it attempted a mutation, specifically changing:\n\n```kotlin\nval combinedWeight = weight + other.weight\n```\n\nto..\n\n```kotlin\nval combinedWeight = weight - other.weight\n```\n\nAnd, as we would hope, this resulted in a “kill”, a unit test failure.\n\nNow let’s look at line 39, which is marked red:\n\n```kotlin\nPAVMode.INCREASING -> previous.y >= next.y\n```\n\nIf you mouseover this you can see that reversing the condition (>= becomes <=) did result in a failure, but simply changing the conditional boundary (from >= to >) did not. This is unsurprising as this is a very subtle change, but impressive that it was caught.\n\nEvery instance where a code mutation doesn’t result in a unit test failure prompts an interesting train of thought about why not. Is it because the code is unimportant (like a toString() method only really used for debugging)? Is it because the change is too subtle and the difference in code behavior is unimportant? Or is it something that should really have been tested? This is a very healthy thought process if you really care about the correctness of your code.\n\nIf I was working on code where I needed a very high degree of reliability, I think mutation coverage is an excellent way to ensure that your unit tests are effective, and at pointing out areas where they might require further work.\n\n","author":"Ian Clarke","date":"2016-10-16","type":"article","categories":["Kotlin"],"features":["highlightjs"],"description":"","filename":"","lang":"EN","enclosure":null},{"title":"Code Swarm for Kotlin","url":"https://www.youtube.com/watch?v=UTN2_YXEzL4","body":"\n\n<iframe width=\"960\" height=\"480\" src=\"https://www.youtube.com/embed/UTN2_YXEzL4\" frameborder=\"0\" allowfullscreen></iframe>\n\ncode_swarm visualization for kotlin (https://github.com/JetBrains/kotlin). The Kotlin Programming Language\n\nThis visualization was generated by following this tutorial:\nhttp://derwiki.tumblr.com/post/43181171352/creating-a-codeswarm-for-your-git-repository\n\nMore information:\nhttp://vis.cs.ucdavis.edu/~ogawa/codeswarm/\nhttps://github.com/rictic/code_swarm\n\nWhy make this visualization?\n- I'm studying how popular projects evolve\n\n","author":"Landon Wilkins","date":"2016-11-24","type":"video","categories":["Kotlin"],"features":["highlightjs"],"description":"","filename":"","lang":"EN","enclosure":null},{"title":"Kotlin’s Android Roadmap","url":"http://blog.jetbrains.com/kotlin/2016/03/kotlins-android-roadmap/","body":"\n## Introduction\n\nOne of the most interesting pieces of news we’ve all seen recently is Google announcing [(limited) Java 8 support for Android N](http://developer.android.com/preview/j8-jack.html) with the Jack compiler for Java. Naturally, our users are curious about how these news affect them, and this blog post outlines our plans and our vision for Kotlin’s place in the Android development world in light of Google’s announcements.\n\n### Kotlin’s Roadmap for Android\n\nWe pay a lot of attention to making Kotlin a good tool for Android development. In the next few releases (1.0.X) we will continue improving our toolchain and libraries. Our current efforts are focused on three main areas: speeding up the development workflow, reducing the size of the runtime library and providing more complete tooling support.\n\n#### Development Workflow\n\nTo speed up the development workflow, **incremental compilation** is coming to Kotlin’s Gradle plugin. This will improve the build times considerably: when a source file is changed, we’ll only recompile this particular file and those files really depending on it, not the whole module.\n\nThe next thing we plan to do to improve Android build performance is providing an integration with Android’s new **[Jack and Jill toolchain](http://tools.android.com/tech-docs/jackandjill)**. Right now there are some issues that prevent Jack from handling Kotlin-generated bytecode correctly ([196084](https://code.google.com/p/android/issues/detail?id=196084) and [203531](https://code.google.com/p/android/issues/detail?id=203531)), but we plan to work together with the Google team to either resolve the issues or provide workarounds on our side. Once this is done, we’ll be able to translate only changed class files using Jill during incremental compilation, as opposed to translating all class files every time (which is the only possible behavior in the old Android tooling).\n\nLast, but not least: **Instant Run**. Currently, Cold Swap works fine for Kotlin, but Warm and Hot Swap require some further investigation. We’ll do what we can to get them fixed ASAP. In the meantime, [JRebel for Android](https://zeroturnaround.com/software/jrebel-for-android/) works fine with Kotlin already.\n\n#### Runtime Size\n\nWe are planning several improvements to **reduce the methods count** of kotlin-stdlib. Our current result is 7’191: ![http://www.methodscount.com/?lib=org.jetbrains.kotlin%3Akotlin-stdlib%3A1.0.0](https://img.shields.io/badge/Methods%20count-core:%206289%20|%20deps:%20902-e91e63.svg)\n\nOptimizing top-level functions representation in multi-file facade classes and moving inline-only functions out of the runtime-available binary will win us several thousand methods.\n\n#### Tooling Support\n\nThe main thing missing from Kotlin 1.0’s Android support story is **Lint Checks**, and we’re happy to announce that they are coming to Kotlin. We have already implemented all the checks available in Android Studio 1.5 (planning to publish them in Kotlin 1.0.2), and the new 2.0 checks are on the way. Our Lint checks are built on top of a common representation of Kotlin and Java code, and we plan to contribute that representation to the Android SDK, so that new checks added in future versions of the Android SDK will work with Kotlin out of the box.\n\nMore Android-specific IDE support, such as a _New Kotlin Activity_ action, code insight and navigation features, and others will also be added gradually as 1.0.X releases are published.\n\n### Kotlin and Java 8\n\nJava 8 has been around for quite a while now, and thus many of our users, those who are not doing Android development, have chosen Kotlin over Java 8 and are happy about it. Now that Android has official support for the Java 8 language features, how does that change the decision of choosing between Kotlin and Java?\n\nFirst of all, while Java 8 does bring lambdas to Android, there are important differences between the way the Android toolchain supports lambdas on existing platform versions (that don’t run the N release) and the way Kotlin supports lambdas. To understand the difference, let’s see how the following simple code snippets are compiled:\n\nKotlin: `list.forEach { process(it) }`\nJava 8: `list.forEach(it -> process(it))`\n\nJava’s version is a tiny bit longer, but let’s not focus on that. Instead, let’s see what happens under the hood. Starting with Java:\n\n* in Android’s Java 8 every lambda is compiled to a class, which has two methods: constructor and the actual body (affecting the method count of your application);\n* this class is later instantiated at runtime, in many cases — every time the `forEach` is called (creating pressure on the garbage collector);\n* and to access it, Java uses a polymorphic call to `Consumer.accept`, which may happen on every iteration in a tight loop (affecting performance, because the runtime cannot always inline such calls).\n\nKotlin, on the other hand, supports inline functions, and `forEach` is one such function. When you use an inline function with a lambda, both the body of the function and the lambda are inlined at the call site. As a result:\n\n* the bytecode of the lambda is inserted directly into the bytecode of the calling method, so the method count does not increase;\n* executing the code does not allocate any objects, so there is no garbage collector pressure;\n* the resulting bytecode does not contain any polymorphic method calls, ensuring the best possible execution speed at runtime.\n\nBottomline: lambdas in Java 8 on Android are not at all free, and one should probably think twice every time and choose between good code and performance. In Kotlin, you don’t have to make such compromises, and you can use lambdas as much as you need to express the ideas in your code.\n\nAnd of course, Kotlin has many other language features which are not available in any version of Java. Just to list a few:\n\n*   Support for **null-safety** prevents most of the NullPointerException problems in your code, saving you from the dreaded “Unfortunately, application has stopped” message;\n*   **Properties, primary constructors and data classes** greatly reduce the amount of boilerplate in the code representing the data model of your application:\n    `data class User(val name: String, val groupId: String = \"default\")`\n*   **Delegated properties** allow to extract the common logic in property getters and setters and to put that into a library:\n    `val imageData by lazy { loadData(imageFile) }`\n\nAnd the DSL construction features of Kotlin give you an entirely new level of flexibility in building your application which is simply not available in Java. For example, it gives you the option to replace XML layouts with an embedded DSL and to describe the UI of your application in the same language as the rest of the code, with full access to the abstraction features of the language. Here’s how this can be accomplished using the [Anko library](https://github.com/kotlin/anko):\n\n```kotlin\nverticalLayout {\n    val name = editText()\n    button(\"Say Hello\") {\n        onClick { toast(\"Hello, ${name.text}!\") }\n    }\n}\n```\n\nAs you see, Kotlin has lots and lots of things to offer to make you more productive, beyond what Java 8 can offer to a Java 6 developer. And it’s also easy to learn, with [comprehensive documentation](https://kotlinlang.org/docs/reference/), [interactive exercises](http://blog.jetbrains.com/kotlin/2016/03/kotlin-educational-plugin/) and books covering both [Kotlin in general](https://www.manning.com/books/kotlin-in-action) and the use of [Kotlin for Android development](https://leanpub.com/kotlin-for-android-developers). So if you haven’t tried Kotlin yet, now is as good time as any!\n\n","author":"Dmitry Jemerov","date":"2016-03-30","type":"article","categories":["Kotlin","Android"],"features":["highlightjs"],"description":"","filename":"","lang":"EN","enclosure":null},{"title":"GeeCON Prague 2014: Andrey Cheptsov - A Reactive and Type-safe Kotlin DSL for NoSQL and SQL","url":"https://vimeo.com/110781020","body":"\n[GeeCON Prague 2014: Andrey Cheptsov - A Reactive and Type-safe Kotlin DSL for NoSQL and SQL](https://vimeo.com/110781020)\n\n","author":"Andrey Cheptsov","date":"2014-11-03","type":"video","categories":["Kotlin","SQL"],"features":["highlightjs"],"description":"","filename":"","lang":"EN","enclosure":null},{"title":"Kotlin: как сделать жизнь Java-разработчика легче?","url":"https://dev.by/lenta/anadea/kotlin-kak-sdelat-zhizn-java-razrabotchika-legche","body":"\n15 февраля 2016 года компания JetBrains выпустила версию 1.0 языка Kotlin, находившегося в разработке около пяти лет. Работает этот язык поверх JVM. Что такое Java, мы уже рассмотрели в отдельной статье с Александром Михальченко. Сегодня мы снова собрались с ним, на этот раз для разговора о Kotlin - о том, чем хорош этот язык и чем плох, как для разработчиков, так и для предпринимателей.\n\n**Привет, Саш.**  \n\nИ тебе привет.\n\n**Итак, что, собственно, такое Kotlin?**  \n\nЯзык программирования, разработанный компанией JetBrains, работающий на платформе Java. Он использует JDK, как и сама Java, но имеет другой синтаксис. Решение не ново - уже существуют языки, которые так делают: Scala и Closure, например. Появились они, в основном, из-за проблем с самой Java в плане синтаксиса. То есть, Java - язык надежный, хороший, добротный, на нём можно писать серверные приложения, но синтаксис у него, скажем так, излишне многословный. Дело в том, что разработчики Java довольно инертно её дорабатывают. Они стараются по максимуму поддерживать обратную совместимость и считают, что у пользователей, перешедших на новую версию, должен работать код, написанный ещё в 95-м. У них даже лозунг такой: \"написанное однажды работает везде\". Это, конечно, больше про кроссплатформенность...\n\n**...но они решили копнуть глубже?**\n\nДа - написано на одной версии, будет работать на всех следующих.\n\n**Смело!**\n\nВ этом, собственно, и заключается проблема - ничего старого из языка они не выкидывают. Из-за этого замедляется его развитие. Со временем появляется всевозможный мусор. Там даже есть метка для устаревших классов, которая стоит над ними внутри самого JDK. В документации, конечно, говорится, что если такая метка появилась, то в одной из следующих версий устаревшая функциональность может исчезнуть, но мне такие случаи неизвестны.\n\n**Сами разработчики понимают, что эти устаревшие методы уже давным-давно никто не использует?**\n\nОни понимают и даже настаивают на том, чтобы эти методы не использовали. Но поскольку есть софт, написанный на старых версиях, не получится так просто убрать старый код. Всё те приложения сломаются.\n\n**От чего же избавился Kotlin?**  \n\nKotlin и другие JVM-языки помогли разработчикам писать программы с меньшим количеством кода. Помимо всего того, что есть в Java, они добавляют вещи из мира функционального программирования. Это значительно облегчает написание кода - делает его короче и выразительнее. Чем меньше кода мы пишем, тем меньше кода нужно поддерживать, писать меньше тестов. Собственно, большинство языков появилось по этой самой причине - поменять синтаксис Java, сделать его более удобным, более прагматичным.\n\n**Насколько сейчас актуален этот язык?**  \n\nСейчас он не то, чтобы слишком популярен - язык молодой, сообщество ещё не набралось. По причине своей молодости Kotlin ещё не в силах конкурировать с той же Scala - более мощным языком с длинной историей. Там уже и над ошибками поработали, и добавили кучу интересных вещей, а Kotlin это только предстоит. В этом более зрелые языки пока что его переигрывают. Но тем не менее, амбиций Kotlin не занимать: язык разрабатывали пять лет, разработчики старались сделать его как можно прагматичнее и не допустить ошибок, которые есть в Java, чтобы \"написано однажды\" не было высечено в камне и язык можно было развивать. Обещают много интересных фич в будущем, которые в том числе покроют функциональность, имеющуюся на данный момент в Scala.\n\n**Как и Java, Kotlin лучше подойдёт большим проектам?**  \n\nДа. По синтаксису, его можно использовать просто как дополнение к Java. Берём стек Java, к примеру, для серверных приложений, и просто заменяем Java на Kotlin. Всё будет работать, при этом, писать код станет проще. Вопрос заключается лишь в том, что выбрать вместо Java. На сегодняшний день, думаю, многие разработчики всё же остановятся на Scala.\n\n**А тебе что больше по душе - Kotlin или Scala?**  \n\nМне нравятся оба языка. Думаю, что Kotlin дальше пойдёт в плане Android. Есть, конечно, возможность писать Android-приложения на Scala, но там есть проблема: большой runtime. Она за собой тащит кучу библиотек, из-за чего увеличивается размер apk-файла. У Kotlin же самый маленький runtime среди всех остальных языков (кроме Java). Обычно это Java плюс \"что-то\", и это \"что-то\" - это overhead, который за собой язык тащит. У Kotlin он самый маленький - около 700 кб, в то время как у Scala - несколько мегабайт.\n\n**Какие недостатки у Kotlin?**  \n\nСам я пока что не натыкался ни на какие баги, с компилятором или чем-то другим у меня проблем тоже не было. По поводу синтаксиса - он справлялся с задачами, с которыми я сталкивался. В чём он уступает той же Scala - это в работе с многопоточностью. Java, к слову, тоже в этом проигрывает. У Scala есть future API, которая позволяет выполнять асинхронные задачи в несколько потоков и при этом получается нормальный код вместо мешанины, где разные секции работают в разных потоках и при этом не видна их связь. Scala всё это структурирует средствами своего синтаксиса. В Kotlin что-то такое обещали реализовать в версии 1.1. Но в целом, мне нравится работать на Kotlin из-за его добротного синтаксиса.\n\n**Что скажешь насчёт безопасности Kotlin?**  \n\nТут вот в чём дело: весь код, написанный на Kotlin, в дальнейшем преобразуется в Java-код. Своего он ничего не добавляет. Соответственно, насколько безопасна Java, настолько безопасен и Kotlin. Если мы говорим о безопасности написания кода, то мне очень нравится null safety в Kotlin. Компилятор может предупредить программиста о том, что ссылка может быть пустой. Если мы попробуем с ней что-то сделать, произойдет ошибка на этапе компиляции. В Java же приложение просто упадет на этапе выполнения.\n\n**Что Kotlin может предложить бизнесу? Чем он заинтересует бизнесменов?**  \n\nЕсли сравнивать с Java то разработка на Kotlin обойдётся дешевле. Почему? Нужно писать меньше кода и меньше кода поддерживать. Это значит, что код писать проще, а следовательно, приложение будет разрабатываться быстрее. А как известно, время - это деньги.\n\n**Маленькие проекты и Kotlin.**  \n\nЕсли мы говорим о каких-то маленьких десктопных приложениях, то для коммерческого использования лучше брать С++. Опять же, Kotlin в дальнейшем транслируется в Java, поэтому, насколько Java хороша в какой-то области, настолько хорош и Kotlin. Kotlin больше помогает писать программы, непосредственную пользу он приносит в первую очередь программистам.\n\n**Спасибо большое за интервью, Саш. Было интересно!**\n\nВсегда рад.\n\n**Итого**\n\nПо сути, прямое назначение Kotlin - облегчить жизнь программистов, дать им возможность уместить в одну строчку кода то, что в Java заняло бы пять. Как сказал Александр, по ощущениям это сродни смене старого Ford Focus на новенький BMW M3 - когда почувствуешь этот полёт, на старые колёса не захочется возвращаться.\n\nНесомненным преимуществом является полная совместимость с Java, в том числе и обратная. Все библиотеки для Java будут работать на Kotlin и наоборот. Также этот язык открывает прелести тех же Closure и Scala для Android-разработчиков. Порадуются и предприниматели, ведь теперь проекты будут делаться быстрее и дешевле.\n\nМинус у языка один - его юный возраст. Однако, судя по тому, что JetBrains целых пять лет потратили на его разработку, очень сомнительно, что они забросят своё детище в ближайшие годы. Поэтому уже сейчас можно и нужно брать Kotlin на вооружение - тем более, если вы разрабатываете приложения для Android.\n\n","author":"Stanislav Sinitsky, Alexander Mikhalchenko","date":"2016-12-07","type":"article","categories":["Kotlin","Android"],"features":["highlightjs"],"description":"","filename":"","lang":"RU","enclosure":null},{"title":"More readable tests with Kotlin","url":"http://tengio.com/blog/more-readable-tests-with-kotlin/","body":"\n# More readable tests with Kotlin\n\n_The following is a highly opinionated rant. These are just my personal views on a subject I care about._\n\nTests should be easy to read. You should be able to go to a test class you are not familiar with, collapse all the methods, and have a very quick read of all the test names. You do that, and in a matter of seconds you should have a very good idea of what the system under test is expected to do and in what circumstances. If you can do this then what they say about tests, that they serve as living documentation, becomes more true than ever.\n\nNow here’s what a BDD-style `given-when-then` format I’ve seen used and have used myself in the past looks like:\n\n![article-img](http://tengio.com/img/blog/0002/given-when-then-sample.jpg) _Given when then tests_\n\nIt’s not exactly a pleasure to read a screen full of this stuff is it? The `given-when-then` keywords take up precious space on the screen. I really don’t want to read a screen full of this stuff, because after a while it sort of starts looking a bit like:\n\n```kotlin\n@Test\nfun blahblahIHopeTheyPayMeThisMonthBlahblahBlahblahBlahblah() { ... }\n\n@Test\nfun blahblahBlahblahIHateMyLifeBlahblahBlahblahBlahblahBlahBlahBlah() { ... }\n\n@Test\nfun blahblahBlahblahBlahblahBlahIWantToGoHomeAndCryBlahblahBlahBlahBlah() { ... }\n```\n\nat which point I might well be tempted to uncollapse the methods and just read the test code, and bam! my reading speed and information retention just plummeted. Not what I wanted.\n\nWell, that’s one way of doing it, but there are others. Roy Osherove suggests something like the following format instead:\n\n```kotlin\n@Test\nfun createUser_WithAllFieldsValid_DisplaysSuccessScreen() { ... }\n\n@Test\nfun createUser_WithAnyInvalidField_DoesNotSendRequest() { ... }\n```\n\nI’ve used that for a while, it was neat and I liked it. It still has a clear structure, and it gets rid of the formulaic keywords `given-when-then` while achieving a very similar result. Nice, but in my humble opinion it still has a little bit of a flaw. It reads like it was meant to be read by a robot, not a human. Also it’s pretty much inevitable that eventually you run on problems expressing your intention behind what you are trying to test when using this format. Or maybe it’s just me.\n\nSo here’s an alternative approach I prefer using at the moment, which I think I learnt from [@mvarnagiris](https://medium.com/@mvarnagiris) :\n\n```kotlin\n@Test\nfun displaysSuccessScreenWhenCreatingAUserWithAllFieldsValid() { ... }\n\n@Test\nfun doesNotSendRequestWhenCreatingAUserWithAnyFieldInvalid() { ... }\n```\n\nI think it reads more like what you would actually say when asked “what does this system do?” by a colleague or manager. You lose the nice structure of the other formats, but hey, I don’t see many people explaining their product owner or colleague what they just did by speaking like a robot.\n\nBut wait what’s that? Oh look! It’s the good old `blahblahBlahblahBlahblahIsIt530YetBlahblahBlahblah()` effect again!\n\nNow, it’s Kotlin we’re using, so let’s use the `` thingy Kotlin offers, I say. Feel free to use them in your test methods, or even class names, and feel free to write your test names in a as readable and as descriptive a way as you can. This is what I’d rather see:\n\n![article-img](http://tengio.com/img/blog/0002/human-readable-tests.jpg) _Human readable tests_\n\nNow I can read a whole page of this stuff, quickly and without getting tired. What’s more, I can actually read the summaries of the tests that have run at the bottom of the screen and actually get some more info out of it more than that all my `givenBlahblahCoolStoryBroBlahblah`s are green, whatever they mean. What summary would you rather read?\n\n_Wall of text meant for robots:_\n\n![article-img-not-scaled](http://tengio.com/img/blog/0002/robot-readable-results.jpg)\n\n_Information meant for humans:_\n\n![article-img-not-scaled](http://tengio.com/img/blog/0002/human-readable-results.jpg)\n\nI for one would definitely go for the second one. But that’s only my fallible opinion anyway, what do _YOU_ think?\nn\n\n","author":"Flavio","date":"2016-08-05","type":"article","categories":["Kotlin","Tests"],"features":["highlightjs"],"description":"","filename":"","lang":"EN","enclosure":null},{"title":"Thinking Functionally","url":"https://medium.com/lewisrhine/thinking-functionally-7149814df9b9#.1vlgn9qm1","body":"\nOne of the great things happening right now in software development is the blending of functional and Object Ordained ideas. While things like Scala have been doing this for a while now, the explosion of popularity of things like Kotlin, Swift, and Rx are giving developers the best of both worlds. Hell, even JavaSript now has classes (I know JS lovers, classes are the devil).\n\nThe problem is that the benefits of functional practices don’t easily jump out to people. If you have taught in OOP your entire professional life it’s going to be hard to change. It is completely valid to see the benefits and not think it’s worth it, but if you don’t completely understand what the real benefits are you can’t make an educated decision.\n\nThe best example of this is is the Android world right now is Rx. This is a question that comes up a lot with Rx, “Yeah but... does it need to be a stream?” It’s a really important question. It’s like a levee breaking the relentless waves of “Use Rx! Rx everything!” For me, it’s also a mark of the failings of communication on the pro-Rx side.\n\nRx is all about reactive functional programming but the reactive part gets all the attention. It leads to a lot of misunderstanding, misuse, and mistrust of Rx. When you’re getting a list of items why not just return a list? Why would you need to return it as a stream? If you are told to look at Rx as reactive streams only, it’s easy to say you don’t need a stream. Just get the list.\n\nThe problem is that this leads to thinking of the list as an object with state, not just data. There is a good chance that once you get the list you are going to just pass it around to other classes. If one of them needs to sort or filter the list you are going to just call those methods on the object and change its state. But what about the other classes using it? They are expecting that list to be in a different state. Before you know it you have an out of control state.\n\nHowever, if you think of it as a stream of data that you can run through a series of functions you can start to frame the true benefits. If you need to sort or filter the data instead of modifying the state of an object, ask for the data stream again this time running through a sort, or filter function. You are not just making that list a stream for the sake of making it a stream. You are doing it because it allows the use of more state safe practices in functional programming.\n\nI want to show a simple example of how thinking functionally can help the quality of life in Android. If you are an Android developer, you have written a ton of RecyclerView Adapters. Despite the fact that most adapters are going to be pretty basic you have to create a whole new class. Why not just have a function that will do all the that work for us that we can just reuse when creating a simple adapter.\n\n```kotlin\ninline fun <T> simpleAdapter(data: List<T> = emptyList(), viewLayout: Int, crossinline bindViewHolder: (holder: RecyclerView.ViewHolder, item: T) -> Unit) = object : RecyclerView.Adapter<RecyclerView.ViewHolder>() {\n    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): RecyclerView.ViewHolder {\n        return object : RecyclerView.ViewHolder(LayoutInflater.from(parent.context).inflate(viewLayout, parent, false)) {}\n    }\n\n    override fun onBindViewHolder(holder: RecyclerView.ViewHolder, position: Int) = bindViewHolder(holder, data[position])\n    override fun getItemCount(): Int = data.size\n```\n\nNotice the last parameter this function takes is another function that is invoked by the adapter when onBindViewHolder is called. Let’s look at how we use this function.\n\n```kotlin\ninline fun <T> simpleAdapter(data: List<T> = emptyList(), viewLayout: Int, crossinline bindViewHolder: (holder: RecyclerView.ViewHolder, item: T) -> Unit) = object : RecyclerView.Adapter<RecyclerView.ViewHolder>() {\n    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): RecyclerView.ViewHolder {\n        return object : RecyclerView.ViewHolder(LayoutInflater.from(parent.context).inflate(viewLayout, parent, false)) {}\n    }\n\n    override fun onBindViewHolder(holder: RecyclerView.ViewHolder, position: Int) = bindViewHolder(holder, data[position])\n    override fun getItemCount(): Int = data.size\n```\n\nWhat this does besides saving time and class files is it restricts you from thinking of the adapter as a class. You can’t override all its methods and change everything about how they work to force it to work the way you think it should. You have no access to change the state of the data.\n\nI know this sounds terrifying but remember we can be our own worst enemies a lot of the time. So building safety walls to stop ourselves can be a really good thing.\n\n","author":"Lewis Rhine","date":"2016-12-07","type":"article","categories":["Kotlin"],"features":["highlightjs"],"description":"","filename":"","lang":"EN","enclosure":null},{"title":"Composing functions in Kotlin with extensions and operators","url":"https://medium.com/@fourlastor/composing-functions-in-kotlin-with-extensions-and-operators-76a499f5b4b7#.72408kmql","body":"\nToday I was wondering if I could achieve a more elegant way to compose functions with Kotlin. Let’s imagine we have this:\n\n```kotlin\nfun same(val: Int) = val  \nfun twice(val: Int) = val * 2  \nfun trice(val: Int) = val * 3\n```\n\n```kotlin\nfun composed(val: Int) = same(twice(trice(int)))\n```\n\nThat gets the job done, but wouldn’t it be better if there was a way to remove all those brackets and get something more similar to a pipeline? Keep in mind: the order of execution will be inverse (trice-twice-same), which is not intuitive.\n\nTurns out there is, if we use two awesome Kotlin features: [_extensions_](https://kotlinlang.org/docs/reference/extensions.html)and [_operator overloading_](https://kotlinlang.org/docs/reference/operator-overloading.html). What are those?\n\n### Extensions\n\n**Extensions** let you add extra methods to any type, calling them as if you were declaring a method inside that type. An example could be:\n\n```kotlin\nfun Int.double() {  \n  return this * 2  \n}\n```\n\n```kotlin\n2.double() == 4\n```\n\nThis basically means: add a method to the type `Int` with name `double`, which you can then invoke on any `Int`. The keyword `this` is used to get the instance on which you’re invoking the method (the _receiver_ object). How this works in more detail is compiling to a static method of which `this` is the first parameter.\n\nAn interesting thing is that, in Kotlin, a function can be used as a type too! So we might be able to write something like this, as an extension function:\n\n```kotlin\nfun (() -> Unit).andHello() {  \n  this()  \n  println(\"Hello, world!\")  \n}\n```\n\n```kotlin\nfun greet() {  \n  println(\"Hey there!\")  \n}\n```\n\n```kotlin\nfun greetAndHello() {  \n  ::greet.andHello()  \n}\n```\n\n`() -> Unit` is the way you can describe a function type (you’d do the same if it was a parameter). Inside the `()` you would put the parameters, `Unit` means it’s a `void` function (otherwise it would be the return type, for example `(Int, Int) -> Int` would be a function taking 2 `Int` parameters and returning an `Int`.\n\nHere we are referencing a function with the `::` operator, and applying the `andHello()` method to it. Pretty neat!\n\n### Operator overloading\n\nImagine you have an interesting type, and you’d like to use some standard operators with it. Wouldn’t it be great, for example, if you could access the elements in a map simply using square brackets? You can indeed!\n\n```kotlin\nval map = mapOf(\"a\" to 1, \"b\" to 2, \"c\" to 3)\n```\n\n```kotlin\nprintln(map[\"a\"]) // 1\n```\n\nHow does this work? Via **operator overloading**: you declare a method with the keyword `operator` in front of it, plus a certain name and signature, and then implement the method as you would do with any other method.\n\n```kotlin\nclass Map<Key, Value> {  \n  operator get(key: Key): Value {  \n    // get and return the value from the map here  \n  }  \n}\n```\n\nYou can then use the operator on that type normally. That can come in handy to redeclare operators in a way that makes more sense for your classes (maybe you want to sum two`Time` instances together?).\n\nYou can find the full list of available operators and respective signatures in the [operator overloading documentation page](https://kotlinlang.org/docs/reference/operator-overloading.html).\n\nSo, let’s take a small leap and imagine this is the final result we wanted:\n\n```kotlin\nfun composed(val: Int) = (::trice..::twice..::same) (val)\n```\n\nWhat are we trying to achieve? It’s pretty clear: we want to call, in sequence, in this order, the functions. Notice how the call order is now reversed compared to the first example (and makes it easier to read).\n\nI’m using the `..` operator (range) because it reminds me of _chaining_ when we talk about functions. For example, it’s used to call multiple methods in sequence on an object in Dart.\n\nHow could we achieve that? All those functions are receiving one parameter and returning something, and we know that we can create an extensions for it.\n\n```kotlin\noperator fun <T, R, V> ((T) -> R).rangeTo(other: (R) -> V): ((T) -> V) {  \n    return {other(this(it))  \n    }}\n```\n\nWhat is this? Let’s go one step at a time.\n\nFirst of all, we’re declaring an operator overload. The `rangeTo` method represents the `..` operator.\n\nWe’re declaring this extension on _any_ function of type `(T) -> R` so any function that takes a parameter of type `T` and returns a type `R`. Notice that `T` and `R` can be the same (for example, `Int`s).\n\nThis extension accepts another function, of type `(R) -> V`, so it will take the previous function return type and return another type.\n\nFinally, this will generate another function, of type `(T) -> V` which is what we expect after calling both functions.\n\nWith the acquired knowledge, let’s look at this again, does it make more sense?\n\n```kotlin\nfun composed(val: Int) = (::trice..::twice..::same) (val)\n```\n\nWe’re applying the `..` operator to `trice`, `twice`, and `same`, in order. Since the return type is a function, the result of `::trice..::twice` can be then chained with `::same`. The result of this last operation is again a function, which then we invoke with `(val)` as an argument.\n\nKotlin metaprogramming features are extremely intersting, and give you the chance to make your code more expressive, especially when you combine features like extensions and operator overloading. This is only a small example of what you can achieve, so start playing with it if you aren’t already!\n\n","author":"Daniele Conti","date":"2016-10-27","type":"article","categories":["Kotlin"],"features":["highlightjs"],"description":"","filename":"","lang":"EN","enclosure":null},{"title":"Corda: Kotlin","url":"https://www.corda.net/2017/01/10/kotlin/","body":"\nWhen people start looking at Corda’s code the things they notice immediately is that it’s written in [Kotlin](https://kotlinlang.org/), a new programming language from JetBrains that targets the JVM and Javascript. This was an unusual choice, so in this post I’ll give some background on why we did it and discuss experiences from our “year of enterprise Kotlin”.\n\n## Why Kotlin?\n\nWe can break this decision down into two parts:\n\n1.  Which platform to use? JVM, .NET, Node, Python/Ruby, Go, Haskell or native?\n2.  Having selected the JVM, which language targeting it? Java? If not, why not? And if not, then which of Scala, Ceylon, Clojure, Kotlin, Python, Ruby, Javascript or Haskell to use (as they all have implementations that target the JVM).\n\nThe reasons for choosing the JVM as a platform are well understood in the enterprise space and not something that needs to be dwelled on much here. Suffice it to say that if you want a scalable, thread-safe, garbage collected, cross platform runtime with a very large collection of well documented libraries that solve common business tasks then your field has already been narrowed to just the JVM and .NET.\n\nAt the time Corda started development, it didn’t have a name and it wasn’t  clear that it’d go ahead and turn into a product. In fact, when the project that would become Corda began in December 2015 (my first day on the job), there were no plans to build a new enterprise distributed ledger. Corda started out as a collection of prototypes to explore some new ideas and requirements that the consortium’s _Architecture Working Group_ was interested in, particularly around limited data visibility, and a data model that gave the scalability of the “UTXO set” approach along with the generic programmability of Ethereum’s imperative smart contracts.\n\nBecause it wasn’t clear if these prototypes would turn into anything or just inform the thinking of other products on the market, we faced a tricky choice: on one hand, we wanted to rapidly explore algorithms and data structures in a way that was productive. On the other, it needed to be something that could still be used to build a large enterprise product and for which we could rapidly hire.\n\nJava obviously fit the bill, but its lack of modern conveniences significantly reduces productivity and, more subtly, developer morale.\n\nDynamic typing was out: the correctness, tooling and performance benefits of static typing are too great to ignore.\n\nLanguages radically different from the mainstream are also out, as we wanted to be able to hire financial industry domain experts – whilst building a team around languages like Haskell [is by no means impossible](https://lexi-lambda.github.io/blog/2016/06/12/four-months-with-haskell/), intersecting people with serious banking experience _and_ lazy pure functional languages _and_ who happen to live in London felt risky. In addition, the nature of the product means our “users” are actually plugin/app developers who build on the platform, and it wouldn’t make sense to require them to learn entirely new paradigms and toolchains. Our choice of language should not constrain our users too much.\n\nAdded up, these requirements left us with Kotlin, Scala and Ceylon. All are rather similar languages and all were quite appealing. We went for Kotlin for these reasons:\n\n* Near seamless Java interop\n    * In particular, Kotlin programs use a compiler-enhanced version of the regular JDK collections. Thus there are no interop issues created by the use of a different collections library. Passing collections in and out of Java libraries is something we do all over the place in Corda, so it’s important that this be painless.\n    * Kotlin classes produce ordinary looking Java APIs with get/set/is methods as appropriate for the type. No special annotations or effort is required. Because Corda exposes an API that is intended to be transparently usable by Java developers, this is a big win: ordinary code tends to produce APIs that can’t be told apart from a Java API, with only a few minor aspects needing thought (e.g. you need to manually annotate methods to specify that they throw checked exceptions, otherwise they aren’t catchable from Java).\n* Inlining of small functions like map/filter/fold/groupBy is done by the compiler frontend instead of relying on the JVM to do it. Unfortunately the JVM’s JIT compilers, whilst generally excellent, don’t reliably remove the overhead of heavy use of higher order functions. Using Kotlin fixes this, along with allowing you to do flow control inside the lambda functions. This is the kind of feature that’s obscure but adds up, as we write code in this functional style all over the place and could easily dig ourselves into a performance hole if this style translated badly to machine code.\n* Because Kotlin code translates to equivalent Java very closely, almost all existing Java-oriented tools work out of the box. This isn’t always true of other languages, for instance, Quasar struggles to instrument Scala code because it wants method annotations and Scala translates lambdas to methods that can’t be annotated. Kotlin lambdas are often inlined anyway (see above) and can be annotated when not.\n* Excellent documentation and tiny standard library makes it a very fast language to learn. We do not explicitly advertise our positions as needing Kotlin experience and have been hiring people who didn’t know it already, with ramp-up times in the range of 1-3 days before the new team member is producing idiomatic code.\n* IntelliJ is the most popular IDE, judging from what our interview candidates select (they have a free choice of tools). Kotlin has the best IntelliJ support of all the post-Java languages.\n* I already had experience with it and had found it to be enjoyable, so I felt confident new team members would enjoy it too.\n\nIf Kotlin didn’t exist we’d probably have gone with Scala instead: it is heavily inspired by Scala and they’re both great languages.\n\n## Our year of Kotlin\n\nSo what was it like, using a new language in an enterprise context for a year?\n\nThe highlight has undoubtedly been spontaneously hearing from team members how much they’re enjoying working with it. Programming languages are a very personal thing and people tend to have strong opinions on them. When you ask people to learn a new language as the first task in their new job, and when you don’t even _tell_ developers that this is what you’ll be doing, there’s always a risk that some team members will just hate it and find it hurts rather than helps their productivity.  That hasn’t been an issue here.\n\nSome issues that frequently crop up in the post-Java/C# enterprise space and our experiences:\n\n* **Code that looks very different depending on who wrote it.**  By and large not a big issue. Unlike Go, which mandates a particular code style, Kotlin code written by different authors can look different. But IntelliJ has a reformatter tool that is capable of unifying code style across the codebase. It’s more limited than the Java equivalent, but has been sufficient. A more subtle issue that can crop up, especially with Scala codebases, is Java-OOP vs Haskell-FP style coding. Scala code that uses libraries like scalaz [can prove difficult to read](https://gist.github.com/folone/6089236) for people who are expecting to see a better Java. Kotlin comes down pretty firmly on the better Java side of the debate, and [although you can do some kinds of functional programming in Kotlin](https://blog.plan99.net/kotlin-fp-3bf63a17d64a#.lmrq68n03), the community hasn’t divided into camps (at least, not yet). We’ve had some cases where code was written as if it were Haskell, but that has got worked out in code review.\n* **Libraries.** We use over 50 open source libraries in Corda and they have all been painless. We have not found ourselves writing wrapper or adapter layers. Kotlin projects typically use Gradle or Maven as their build system: there’s no official Kotlin-specific replacement for these tools (though Gradle is adopting Kotlin as its new scripting language!).\n* **SQL DSLs.** C# has LINQ, Java has jooq and Kotlin has [Exposed](https://github.com/JetBrains/exposed). This is an area where Kotlin is a bit weaker than the competition: Exposed is a great example of how to use Kotlin’s DSL building features, but the library itself does not have a stable API and is a side project. Jooq can of course be used from Kotlin as well and in hindsight that would probably have been a better route to go.\n* **IDE/tooling.**  The Kotlin plugin for IntelliJ is of course also written by JetBrains and is generally superb. However, it’s not quite as sophisticated as the Java support is. New editor features like [parameter hints](https://blog.jetbrains.com/idea/2016/09/intellij-idea-2016-3-eap-faster-git-log-parameter-hints-and-more/) have to be manually ported to Kotlin and as such support tends to lag behind the much older Java plugin. We’ve also found the IDE plugin to report internal errors quite frequently, although the frequency of IDE exceptions has fallen dramatically over the course of the year (and they don’t seem to impact anything when they occur). Tooling is also pain-free, as tools written for Java typically work out of the box. The exception are tools that actually parse source code rather than bytecode: those obviously cannot be reused.That said, Kotlin’s compiler and IDE plugin are not as robust as Java’s even a year after the 1.0 release. You basically never encounter internal compiler errors in javac. They are something we do still encounter in Kotlin on rare occasions.\n* **Customer acceptance.** Corda’s users are typically large, conservative financial institutions. Such companies tend to prefer the use of well known, established languages. Kotlin, being neither, obviously raised some eyebrows when we started out. “Why Kotlin” is a question that has largely faded away over the past year as people looked closer and realised that it wasn’t as risky as new languages typically are.We have also tried to address this by providing Java code samples to prove that developers can build on the platform without having to learn Kotlin. There we’ve been a bit less successful: many developers who are new to Corda still start out by getting familiar with Kotlin first. It’s a bit unclear if this is because we don’t provide enough Java-specific samples and docs or whether it’s a good excuse to learn a cool new tool. We’ve also been assisted here by the growing acceptance of Kotlin inside the large investment banks. We’ve heard from several consortium members over the past year that their internal software development teams have started seriously looking at Kotlin for their own use: often prompted by the existence of the Java-to-Kotlin converter tool that makes introduction into an existing codebase much more seamless.\n* **Commercial support.** A risk with using obscure languages is that they might not stick around, or might have goals that are not compatible with the needs of the user base that grows around the product (e.g. in the case of research languages where the primary goal of the developers is to publish papers). One reason we felt comfortable going with Kotlin is that JetBrains is a stable, profitable company that has been around for over 15 years. JetBrains is rapidly “eating its own dogfood” by introducing Kotlin code into the core of its primary products; thus there is little risk of it becoming unmaintained. Additionally, JetBrains is old enough that its core market (IDEs and developer productivity tools) is no longer particularly fashionable or new, giving a low risk of a corporate buyout that causes an unpredictable strategy change.Whilst there are no commercial support packages available for Kotlin, in practice the team fixes reported issues pretty fast. JetBrains are currently aiming to release the next major upgrade of the language about a year after 1.0, a release cycle which is quite compatible with enterprise development cycles.\n\n## Conclusion?\n\nWe have no regrets: picking an unproven language at the start of this project was a risk, but a calculated one. It’s worked out well for us and we’d do it again.\n","author":"Mike Hearn","date":"2017-01-10","type":"article","categories":["Kotlin"],"features":["highlightjs"],"description":"","filename":"","lang":"EN","enclosure":null},{"title":"Lessons from converting an app to 100% Kotlin","url":"https://medium.com/keepsafe-engineering/lessons-from-converting-an-app-to-100-kotlin-68984a05dcb6#.ymxam7e1t","body":"\n### Lessons from converting an app to 100% Kotlin\n\nI’ve been following the development of [Kotlin](https://kotlinlang.org) for a while. Kotlin is a relatively new language that primarily targets the JVM, and is interoperable with Java. With the release of Kotlin version [1.0.2](https://blog.jetbrains.com/kotlin/2016/05/kotlin-1-0-2-is-here), which brought incremental compilation and a large reduction in the number of methods in its standard library, I was eager to start using it in production.\n\nI’m the lead engineer on [App Lock](https://play.google.com/store/apps/details?id=com.getkeepsafe.applock) at [Keepsafe](https://www.getkeepsafe.com), which, like most Android apps, was written in Java. There are quite a few places where Java falls short of modern languages, especially the version of Java 7 that Android supports. To reduce the pain, it is common to use libraries such as [Retrolambda](https://github.com/evant/gradle-retrolambda) for a backport of lambdas and try-with-resources, [Guava](https://github.com/google/guava) for immutable collections and utility functions, [ButterKnife](https://github.com/JakeWharton/butterknife/) for view binding, or [ReactiveX](https://github.com/ReactiveX/RxJava) for functional programming. All of those libraries come with drawbacks, though. Retrolambda frequently causes incremental builds to fail, and every library you depend on adds methods to your APK.\n\nEven with those libraries, Java code is verbose. Your code has to go through a lot of ceremony that the designers of Java thought was a good idea in the 90s, but is clearly unnecessary today. Kotlin provides a well thought-out syntax and extensive standard library that removes many of the pain points that exist in Java. So over the course of a few days, I converted the entire App Lock codebase into Kotlin. Here are my thoughts on the process.\n\n### Kotlin vs Java in App Lock\n\n![](https://d262ilb51hltx0.cloudfront.net/max/800/1*0JjkzvEAP17sK28Ud12QqQ.png)\n_Method count in App Lock after converting to Kotlin. From the dexcount gradle plugin._\n\nOne concern that people will raise about converting to Kotlin is the number of methods added by its standard library. Thanks to massive libraries like the support library and GMS, many apps are in danger of bumping up against the [Dex method limit](https://developer.android.com/studio/build/multidex.html). I used the [dexcount gradle plugin](https://github.com/KeepSafe/dexcount-gradle-plugin) to break down the method count before and after the rewrite. The end result is that the total method count after proguard _decreased_ by 10% from 5491 to 4987 (not counting GMS or appcompat). The code count decreased by 30% from 12,371 lines of Java, to 8,564 lines of Kotlin.\n\n> Converting the app from Java to Kotlin reduced the total method count by 10%, and the total lines of code by 30%\n\nThe method count decrease is a result of both Kotlin being a more concise language, as well as the fact that many of the quality of life libraries that were previously used in Java are no longer necessary.\n\n#### Retrolambda\n\nRetrolambda generates an anonymous class for every lambda which add several methods each. Kotlin has inline methods to which a lambda can be passed without adding any extra methods.\n\nFor example, the extremely useful standard library function [_apply_](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/apply.html):\n\n```kotlin\npublic inline fun nT> T.apply(block: T.() -> Unit): T {   \n    block(); return this   \n}\n```\n\nWhich is called like this:\n\n```kotlin\nmyObject.apply **{** /* modify myObject */ **}**\n```\n\nEven though you’re defining a lambda function at the call site, no anonymous class is generated, so no extra methods are added, and no allocation happens due to that call. In fact, the _apply_ function itself, like most inline functions in the Kotlin standard library, doesn’t cause a method to be added in the compiled code.\n\n#### Guava\n\nThe entirety of Guava is covered by the Kotlin standard library, which has the additional advantage of being easier to use. Big Guava ComparisonChains can be replaced with a few characters with the [kotlin.comparisons functions](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.comparisons/index.html).\n\n```java\n// Guava  \nComparisonChain._start_()  \n        .compareTrueFirst(lhs.isActive(), rhs.isActive())  \n        .compare(lhs.lastName(), rhs.lastName())  \n        .compare(lhs.firstName(), rhs.lastName())  \n        .result();\n```\n\n```kotlin\n//Kotlin  \n_compareValuesBy_(lhs, rhs,   \n    **{it**.active**}**, **{it**._lastName_**}**, **{it**._firstName_**}**)\n```\n\nThe null safety of Guava’s Optional class is [built in to Kotlin](https://kotlinlang.org/docs/reference/null-safety.html).\n\n```java\n// Guava  \nreturn Optional._of_(value).or(defaultValue);\n```\n\n```kotlin\n// Kotlin  \nreturn value ?: defaultValue\n```\n\nGuava’s lazy fields and Preconditions classes are covered by the [Kotlin standard library](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/index.html).\n\n```java\n// Guava  \nprivate Supplier<String> lazyField = Suppliers._memoize_(  \n    () -> \"value\");  \npublic String getField() {  \n    return lazyField.get();  \n}\n```\n\n```kotlin\n// Kotlin  \nval field by _lazy_ **{** \"value\" **}**\n```\n\n```java\n// Guava  \nPreconditions.checkNotNull(value, \"error %s\", arg);\n```\n\n```kotlin\n// Kotlin  \n_checkNotNull_(value) **{**\"$arg\"**}**\n```\n\nNearly all of Guava’s collections classes [exist in Kotlin](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/index.html). Even with all of that functionality, the entire Kotlin standard library is still smaller than Guava alone.\n\n#### ButterKnife\n\nButterKnife can still be used in Kotlin, but the [Kotlin Android Extensions](https://kotlinlang.org/docs/tutorials/android-plugin.html) provide a more natural way to access bound views. Other solution also exist such as [Kotterknife](https://github.com/JakeWharton/kotterknife) and [Anko](https://github.com/Kotlin/anko), but I find that regular XML layouts with the Kotlin Android Extensions are currently the best way to work with Views. Kotterknife requires more boilerplate than the extensions. Anko adds thousands of methods, and its DSL is often more complicated and less capable than XML.\n\n#### RxJava\n\nRxJava is still awesome, and I still use it in many places in App Lock. But since Java on Android doesn’t have functional methods on collections, I will sometimes use RxJava as a substitute. Something like this in Java:\n\n```kotlin\nObservable.from(collection)  \n    .filter(it -> it.isActive())  \n    .map(it -> it.size())  \n    .reduce((it, sum) -> it + sum)  \n    .toBlocking().single();\n```\n\nCan be replaced with this in Kotlin:\n\n```kotlin\ncollection.filter { it.isActive() }  \n          .map { it.size() }  \n          .reduce { it, sum -> it + sum }\n```\n\n### Getting started with Kotlin\n\nIf you already know Java, learning Kotlin is easy. You can work through the [Kotlin Koans online](http://kotlinlang.org/docs/reference/), and the [reference documentation](http://kotlinlang.org/docs/reference/) is very well written. Jake Wharton also gave a [great talk about some of the useful syntax features in Kotlin](https://vimeo.com/144877458).\n\nThe best part about Kotlin is that it can be called from Java, and Java can be called from Kotlin. So you don’t need to convert your entire codebase at once. I would suggest you start with a single file that you rewrite from scratch. IntelliJ has an automated Java-to-Kotlin converter, but it frequently produces incorrect code, so it’s better to start from scratch until you have a better handle on the language.\n\nOnce you have the basics down, I recommend picking some existing Java code that has few dependencies, and converting it to Kotlin. UI code like an Activity of Fragment on Android is a good place. Picking a class with no dependencies allows you to focus on just the code you’re working on without worrying about how any interfaces are changing. Keep the [Kotlin reference](https://kotlinlang.org/docs/reference/) open so that you can quickly answer questions about syntax or the standard library that come up while you’re working. You could also choose to start new Kotlin code from scratch instead of converting from Java, but I find that it’s easier to pick up some of the less obvious syntax from converted code than trying to figure it out from a blank slate. The automated conversion does a really good job in most cases, and the places where it fail are usually easy to fix.\n\nSomething to keep in mind while you’re learning Kotlin is to avoid getting overwhelmed. If you don’t already use a design pattern like MVP or MVVM, don’t worry about try to learn it at the same time. Don’t worry about finding every Kotlin library available. Just focus on taking what you know about Java and translating that knowledge to Kotlin. If you still have pain points, then you can add more libraries or design patterns.\n\n### Should you convert your entire codebase at once?\n\nAfter you’ve got some Kotlin working in your codebase, you’ll have to decide whether or not to convert everything at once, or take it more slowly. Fortunately, Kotlin has excellent two-way interoperability with Java, so you can convert single classes at a time, and ship with both languages running together.\n\nFor large codebases, it can be too much work to convert everything in one release. In [Keepsafe’s main app](https://play.google.com/store/apps/details?id=com.kii.safe), about 15% of the code is Kotlin as of this writing. In that app, if we have to make significant changes to a Java class, we’ll usually convert the class to Kotlin while we’re working on it. This allows us to steadily improve the codebase without slowing down our work on new features.\n\nHowever, if your project is small enough that you can convert to 100% Kotlin, it’s something worth considering. When you don’t have to maintain Java compatibility, you can simplify your internal APIs and remove a lot of the libraries I talked about earlier. You can convert static utility classes into extension functions, and take advantage of the stronger type inference in Kotlin.\n\n### Final thoughts\n\nKotlin is a great language, and is a huge improvement over Java. Converting App Lock to Kotlin resulted in an app that was faster, smaller, and which had fewer bugs than before. The language is mature enough now that there were no important features missing, in either the tooling, the language, or the standard library. If you’re wondering whether to give Kotlin a try now or if you should wait a while longer, I can tell you that Kotlin is ready for full time production use now. If you work with Android or another Java environment where Kotlin is a possibility, you owe it to yourself to give Kotlin a try.\n\n\n_This is the first post of a series of two. Follow_ [_Keepsafe Engineering_](http://www.keepsafe.tech) _to get notified about future posts. Interested in writing Kotlin code your self? Have a look at our_ [_Kotlin job opening_](https://jobs.lever.co/keepsafe/6414e440-ed8e-4c1e-a156-6e4e1b716577)_._\n","author":"AJ Alt","date":"2016-08-10","type":"article","categories":["Kotlin","Android"],"features":["highlightjs"],"description":"","filename":"","lang":"EN","enclosure":null},{"title":"5 small things you probably don’t know about Kotlin","url":"https://medium.com/@piotr.slesarew/5-small-things-you-probably-dont-know-about-kotlin-255261940de6#.pgfivsdr7","body":"\n> There are known knowns. These are things we know that we know. There are known unknowns. That is to say, there are things that we know we don’t know. But there are also unknown unknowns. There are things we don’t know we don’t know. — Donald Rumsfeld\n\nI have been using Kotlin for almost a two years and I started from putting it to toy project intended for my tech talks. Do you remember that time when Kotlin had _traits_ instead of _interfaces_? From the very first line, I knew that this language will change my life, and you know what? I was totally right.\n\nKnowledge makes you better and that is why world’s most successful engineers are constantly learning new things. Here is my list of five less known things about Kotlin and I hope you will find at least three worth knowing.\n\n### 1. Name your imports\n\nIn Kotlin, _imports_ are used by the compiler to let you name your classes by their unqualified name. What happens if you have naming conflict? Sad things happen!\n\n```kotlin\npackage com.code.sliski.userinfoscreen.ui\n\nimport ...\n\nimport android.view.View // Conflict\n\nclass UserInfoFragment : Fragment(), com.code.sliski.userinfoscreen.ui.View { // Conflict\n\n    override fun onCreateView(inflater: LayoutInflater, \n                              container: ViewGroup?, \n                              state: Bundle?): View = // Conflict\n            inflater.inflate(user_info_fragment,\n                             container,\n                             false)\n}\n\ninterface View // Conflict\n```\n\nPersonally, I hate using fully qualified package names in my code as it lowers readability and clarity. **In Python, you can name your imports to fix the conflicts and Kotlin supports it as well** ❤.\n\n```kotlin\nimport android.view.View as AndroidView // Named import\n\nclass UserInfoFragment : Fragment(), View {\n    \n    override fun onCreateView(inflater: LayoutInflater, \n                              container: ViewGroup?, \n                              state: Bundle?): AndroidView = // Using named import\n}\n```\n_Refactored code using named import_\n\n### 2. Change companion object name\n\nCompanion object was introduced to replace static members. It is not only for declaring static properties but also to name them. How? Let’s have a look at this example.\n\n```kotlin\n// Using in Java\nCustomButton button = new CustomButton(context);\nbutton.setVisibility(CustomButton.Companion.getGONE());\n\n// Using in Kotlin\nval button = CustomButton(context)\nbutton.visibility = CustomButton.VISIBLE\n\nclass CustomButton(context: Context?) : View(context) {\n    companion object {\n        // Visibility\n        val GONE = 1\n        val VISIBLE = 2\n        val INVISIBLE = 3\n    }\n}\n```\n\nBy default, Kotlin creates a static nested class _Companion_ for every companion object. That is why you need to use _CustomButton.Companion_ to access static members from Java code(you can also use it in Kotlin but it is not necessary). **Kotlin lets you change the default name of companion object to whatever name you want.** Refactored code looks like this.\n\n```kotlin\n// Using in Java\nCustomButton button = new CustomButton(context);\nbutton.setVisibility(CustomButton.Visibility.getGONE());\n\n...\n\nclass CustomButton(context: Context?) : View(context) {\n    companion object Visibility {\n        val GONE = 1\n        val VISIBLE = 2\n        val INVISIBLE = 3\n    }\n}\n```\n\nThe biggest drawback is that Kotlin does not support multiple companion objects for a class. It would be great for grouping static properties.\n\n```kotlin\n// Using in Java\nCustomButton button = new CustomButton(context);\nbutton.setVisibility(CustomButton.Visibility.getGONE());\n\n...\n\nclass CustomButton(context: Context?) : View(context) {\n    companion object Visibility {\n        val GONE = 1\n        val VISIBLE = 2\n        val INVISIBLE = 3\n    }\n}\n```\n\nThis code does not compile because Kotlin supports only one companion object per class\n\n### 3. Compose functions\n\nI bet you used function references before but have you ever tried to use them to compose functions? Imagine that you want to map an array of prices to prices that are taxed, discounted and rounded. Using common approach you will end up with something like this.\n\n```kotlin\nval prices = listOf(21.8, 232.5, 231.3)\nprices.map(::taxed)\n      .map(::discounted)\n      .map(::rounded)\n\nfun taxed(value: Double): Double = value * 1.4\nfun discounted(value: Double): Double = value * 0.9\nfun rounded(value: Double): Double = Math.round(value).toDouble()\n```\n\nThis example is begging for composition so do not disregard it and make the code better place. Abracadabra!\n\n```kotlin\nval prices = listOf(21.8, 232.5, 231.3)\nval taxedDiscountedRounded = compose(::taxed, ::discounted, ::rounded)\nprices.map(taxedDiscountedRounded)\n\nfun <A, B> compose(f: (A) -> A,\n                   g: (A) -> A,\n                   h: (A) -> B): (A) -> B = { x -> h(g(f(x))) }\n\nfun taxed(value: Double): Double = value * 1.4\nfun discounted(value: Double): Double = value * 0.9\nfun rounded(value: Double): Double = Math.round(value).toDouble()\n```\n\n**Functions composition not only makes your code cleaner but also faster.** Once you understand it, you will be able to compose almost everything.\n\n### 4. Change name of generated class\n\nExtension functions are one of the most attractive features in Kotlin but using them in Java code can give you a serious headache. It is ugly and besides is nothing else like invoking a static method.\n\n```kotlin\n// Main.java\npublic static void main(String[] args) {\n    String name = null;\n\n    AnyKt.ifNull(name, new Function1<Object, Unit>() {\n        @Override\n        public Unit invoke(Object o) {\n            return null;\n        }\n    });\n}\n\n// Any.kt\ninline fun <T> T?.ifNull(function: (T?) -> Unit) {\n    if (this == null) function(this)\n}\n```\n\nKotlin generates class _AnyKt_ with a static method so you can use it in Java. **There is an option to change the name of generated class to achieve better readability.**\n\n```kotlin\n// Main.java\npublic static void main(String[] args) {\n    String name = null;\n\n    Nullcheck.ifNull(name, new Function1<Object, Unit>() {\n        @Override\n        public Unit invoke(Object o) {\n            return null;\n        }\n    });\n}\n\n// Any.kt\n@file:JvmName(\"Nullcheck\")\npackage ...\n\ninline fun <T> T?.ifNull(function: (T?) -> Unit) {\n    if (this == null) function(this)\n}\n```\n\n### 5. Validate an assignment and “veto” it\n\nThe way in which Kotlin handles delegation is pretty spectacular so if you are not familiar with it, you should totally check my article: “Zero boilerplate delegation in Kotlin”.\n\nBesides of “class delegation”, there is an interesting mechanism called “delegated properties”which is used for _lazy_ property initialization. How would you solve scenario in which you need to be able to intercept an assignment and “veto” it? Is there any clean way to do it? Yes, there is!\n\n```kotlin\nvar price: Double by Delegates.vetoable(0.0) { prop, old, new ->\n    validate(new)\n}\n\nfun validate(price: Double) : Boolean {\n    // Validation checks\n}\n```\n\nSample shows usage of a built-in _vetoable_ delegate. Lambda passed to the _vetoable_ is called before the assignment of a new value to property. **Returning false from the lambda allows you to “veto” the assignment but if you want to pass it through return true.**\n\n![](https://cdn-images-1.medium.com/max/880/1*gkc1Y_YumE5sIffEmO03Yw.jpeg)\n\n[http://looneytunes.wikia.com/wiki/That's_All_Folks](http://looneytunes.wikia.com/wiki/That%27s_All_Folks)\n\n","author":"Piotr Ślesarew","date":"2016-11-25","type":"article","categories":["Kotlin"],"features":["highlightjs"],"description":"","filename":"","lang":"EN","enclosure":null},{"title":"Mocking Kotlin with Mockito","url":"http://hadihariri.com/2016/10/04/Mocking-Kotlin-With-Mockito/","body":"\n## The un-mockable\n\nGiven that by default Kotlin classes and functions are final (i.e, you need the `open` modifier to be able to inherit from them), when trying to mock behaviour in tests, you’re often left with no choice other than to declare these `open` or introduce interfaces solely for the purpose of testing. Neither of these are really great.\n\nFor instance, given the following code\n\n```kotlin\nclass LoanCalculator {\n    fun calculateAmount(customerId: Int): Double {\n        return 100.0 * customerId\n    }\n}\n\n```\n\nand a class that uses the above\n\n```kotlin\nclass LoanService(val loanCalculator: LoanCalculator) {\n    fun authoriseCustomerLoan(customerId: Int): Double {\n        if (customerId != 0) {\n            return loanCalculator.calculateAmount(customerId)\n        }\n        return 0.0\n    }\n}\n\n```\n\nIf I want to be able to mock the `calculateAmount` function, I could write something like the following\n\n```kotlin\n@Test\nfun authoriseCustomerLoan() {\n    val mockLoanCalculator = mock(LoanCalculator::class.java)\n    `when`(mockLoanCalculator.calculateAmount(3)).thenReturn(300.0)\n    val loanService = LoanService(LoanCalculator())\n    val amount = loanService.authoriseCustomerLoan(3)\n    assertEquals(300.0, amount)\n\n}\n```\n\nbut on running it, Mockito would complain indicating that it cannot mock a class/method that is final.\n\n## MockMaker\n\n[Mockito 2](http://mockito.org/) solves this. With the recent [release of version 2](https://github.com/mockito/mockito/wiki/What's-new-in-Mockito-2), one of the big changes is the ability to mock the un-mockable. In other words, you can mock final classes in Java and consequently all classes and member functions in Kotlin.\n\nIn order to take advantage of this feature, you write your code in exactly the same way you would for mocking an open class/function. However, you need to perform an additional step which basically consists in creating a file named `org.mockito.plugins.MockMaker` and placing this under the `resources/mockito-extensions` directory in your test folder[1].\n\nThe file contains a single line:\n\n```\nmock-maker-inline\n```\n\n![Mockito Resource Folder](http://hadihariri.com/images/mockito-1.png)  \n\nIf you’re using Gradle, you can also have it [generate the file for you.](https://github.com/hhariri/mockito-sample/blob/master/build.gradle#L16). You can download the [sample project I’ve created from GitHub](https://github.com/hhariri/mockito-sample/)\n\nFinally, a big kudos to [Rafael](https://twitter.com/rafaelcodes) for his work in making this possible!\n\n[1] This feature is still new and plans are to make it easier to configure as they receive feedback on its usage.\n\n","author":"Hadi Hariri","date":"2016-10-04","type":"article","categories":["Kotlin","Testing"],"features":["highlightjs"],"description":"","filename":"","lang":"EN","enclosure":null},{"title":"Issues Faced With Kotlin During Android Development","url":"http://blog.bilue.com.au/issues-faced-with-kotlin-during-android-development-1","body":"\n[Kotlin](https://kotlinlang.org/) seems like the future of Android development. It is a new statically-typed programming language that runs on JVM, with a very refined syntax and enhanced features. There is a lot to love about it. Kotlin is interoperable with Java, which should reduce the risk of future incompatibility. The additional language features such as Function Extensions and High Order Function make it much more extensible and scalable. The code is concise with data classes, single expression function, infix and many more... enough said. Kotlin is just great!\n\n![Screen_Shot_2016-08-10_at_2.10.19_pm.png](http://offers.bilue.com.au/hs-fs/hubfs/Screen_Shot_2016-08-10_at_2.10.19_pm.png?t=1470802416157&width=733&height=294)  \n\nI started working on some real apps using Kotlin that have since been published on the playstore. I have to say it was relatively smooth sailing. Nonetheless, there were some hiccups along the way that are worth sharing.\n\n### **1. Method Count Increase.**\n\nMethod count increase was one of the issues I was fully aware before starting with Kotlin. At the time of writing, there are an additional [7’191 methods](https://blog.jetbrains.com/kotlin/2016/03/kotlins-android-roadmap/) adding to the total method count. This would add more than 10% to the 65k methods limit. Nonetheless, I didn’t worry that much as the MultiDex support is there to help to overcome this issue.\n\n### **2. Using Libraries that require Annotation.**\n\nThere are many cool libraries that can assist with making Android Development much more efficient. However, when switching over to Kotlin, using some of them becomes a challenge. There are two libraries which I can’t manage to use directly after switching to Kotlin, i.) [Icepick](https://github.com/frankiesardo/icepick) and ii.) [EventBus](https://github.com/greenrobot/EventBus). The main reason is that the Annotation (i.e. _@State _and_ @Subscribe_) is not picked up by the code. Fortunately, with EventBus, I managed to work around this by creating a composite class object using Java Code. Note that this doesn’t mean all libraries using Annotation would not work for Kotlin. I managed to use [Retrofit 2.0](http://square.github.io/retrofit/) and [Dagger 2.0](http://google.github.io/dagger/) (where both use Annotation extensively) in Kotlin directly.\n\n### **3. Mocking Need Open Class/Function.**\n\nBy default a class and function is considered final for Kotlin. Mocking (using [Mockito](http://mockito.org/)) requires a non-final class. So in order to have that, we have to explicitly _open_ a class if we would like to mock it for testing. If this is not done, it would error out easily. The more tricky issue is the function. If the function is not _open_, there would be no error issue when running the test. Instead of intercepting the function, it would call the actual internal function, where the test would fail with NPE. Without knowing the function needs to be _open_, the root issue might not be easily discoverable.\n\n### **4. Java to Kotlin Converter Limitation.**\n\nThe Kotlin Plugin for Android Studio is just great, especially allowing to auto convert from Java to Kotlin. However, the conversion might not be ideal. e.g.\n\nis converted to\n\n```kotlin\nclass SimpleClass(memberVariable: Int) {\n  internal var memberVariable = 0\n\n  init {\n      this.memberVariable = memberVariable\n  }\n}\n```\n\nWhereby it could be as simple as\n\n```kotlin\nclass SimpleClass(val memberVariable: Int) {}\n```\n\nAnyway, it’s always good to review the converted code and explore so that we don’t just have Kotlin code in Java style, without the real advantage of Kotlin.\n\n### **5. Other Converter Issue.**\n\nI love writing a new function from an object, and pressing _Alt-Enter_ to trigger the auto-function creation. If you are writing on the Java side of code, and call a Kotlin function (that you just intended to create), sorry you are out of luck. Android Studio will only auto create that function for you in the Kotlin code.\n\nAt times for experimental purposes we would also like to convert from Kotlin to Java, given that it was inter-operable with Java. This is not possible however the tools only allow you to convert from Java to Kotlin and not vice versa. Perhaps this is by design, and I could imagine it would be difficult for Java to handle conversion of more advanced Kotlin language features.\n\nNone of these issues are show stoppers. The advantage and fun of learning new things outweighs them in any case. The language features are richer and there is so much to explore. I haven’t really faced many issues from Kotlin’s language as yet. I’m sure I’ll uncover more issues, but I don’t expect them to “kill me”. Java is always there to the rescue :)\n\nAs with any new thing, one other challenge is finding community support. Suppose you are experimenting with new Android Features and face a road-block. If you post your question to Stackoverflow using your Kotlin code, you are unlikely to generate support.\n\nSo... you might as well be the one who supports others... which is in itself a good thing! :)\n\n","author":"Elisha Lye","date":"2016-08-10","type":"article","categories":["Kotlin","Android"],"features":["highlightjs"],"description":"","filename":"","lang":"EN","enclosure":null},{"title":"Why I prefer Kotlin","url":"https://dev.to/grahamcox82/why-i-prefer-kotlin","body":"\nI've been an enterprise Java developer for a little over 10 years, and I've been using Java for just over 16 years - back when Java 1.3 was the latest and greatest. It's been a long ride. Back then there were no Lambdas, no Streams, no Generics, no Annotations. There wasn't even an `assert` keyword.\n\nThese days, Java has a huge amount for a very vast and powerful ecosystem. And one of the most powerful parts of all of that is the built in support for alternative languages as part of the same system. The JVM makes it possible to have many different languages - meaning the actual code you type into the editor - compile down to compatible bytecode and all run together in the same application. That's a huge benefit for software development, since you can now write different parts of the application in the best suited language for the job.\n\nSo what exactly is Kotlin, and why do I like it so much? Unlike many of of the other JVM languages, Kotlin doesn't try to be anything special or different. It simply exists as a vastly simplified, streamlined Java language. There is very little, if anything, that Java can do that Kotlin can't do. The difference is that Kotlin does the same in significantly less code, making it significantly easier to read and maintain. Kotlin also has a large emphasis on Java Interop, meaning that it's trivial to use it in conjunction with existing Java libraries. Some other JVM languages make this much harder to achieve, if it's possible at all.\n\nSo, in general, my experience so far is that Kotlin allows me to do everything that Java does, but simpler.\n\nThe only thing that I've struggled with at all was some of the tooling - but this really doesn't bother me that much. By this, I'm talking Code Coverage (The JVM bytecode includes many lines that just don't exist in the Kotlin code, so covering them is less easy), FindBugs, PMD, Checkstyle, and so on. I've not explored Sonar for Kotlin yet, but it's very likely that this will fill in many of the gaps if it works.\n\n","author":"Graham Cox","date":"2017-01-02","type":"article","categories":["Kotlin"],"features":["highlightjs"],"description":"","filename":"","lang":"EN","enclosure":null},{"title":"Kotlin 1.0.2 is Here","url":"http://blog.jetbrains.com/kotlin/2016/05/kotlin-1-0-2-is-here/","body":"\nWe’re happy to announce the release of Kotlin 1.0.2, the second bugfix and tooling update for Kotlin. In addition to compiler and language bugfixes, Kotlin 1.0.2 adds a number of major features to the IDE and the build tools.\n\n### Incremental Compilation in Gradle and the IDE\n\nThe new release continues our work on Kotlin incremental compilation support, speeding up the turnaround time during development. Incremental compilation in the IDE (which was previously marked as experimental) is now enabled by default. Also, the long-awaited support for **incremental compilation in Gradle builds** is now there.\n\nTo enable incremental compilation for Gradle, you need to set the **kotlin.incremental** property to true (for example, by adding the line `kotlin.incremental=true` to the `gradle.properties` file in the root directory of your project).\n\n### Android Lint Checks\n\nKotlin 1.0.2 introduces support for **Android Lint checks** for Kotlin code, ensuring that issues like using the API not available in the Android version you’re targeting are correctly detected.\n\nThe set of checks supported in Kotlin 1.0.2 corresponds to the checks supported in Android Studio 1.5; checks added or improved in Android Studio 2.0 will be supported in the next release of Kotlin. Also, the current version runs Lint checks for Kotlin code only inside the IDE (as part of on-the-fly code inspections, or in batch mode through Analyze | Inspect Code). Running checks from the command line will be supported in the next release.\n\n### Compact Standard Library\n\nOne other improvement relevant for Android developers is that the size of the standard library has been reduced by ~1500 methods (from approximately 6600 to 5100). Even before this change, the library was [smaller than those of Kotlin’s main competitors](https://github.com/SidneyXu/AndroidDemoIn4Languages), and now the situation is even better. Of course, the library is still fully binary compatible.\n\n### Java 7/8 Support Libraries\n\nAs a temporary workaround for better Java 7/8 support before full support is introduced in Kotlin 1.1, we’re now providing support libraries that expose the APIs added in Java 7 and 8 (such as the Stream API) as extension functions on Kotlin standard library classes. See the [forum post](https://discuss.kotlinlang.org/t/jdk7-8-features-in-kotlin-1-0/1625) for instructions on using the libraries.\n\n### IntelliJ IDEA Plugin features\n\nThe IntelliJ IDEA plugin has gained a number of major new features:\n\n* For users of Android Studio, there’s now a possibility to create a **new activity** in Kotlin;\n* For users of IntelliJ IDEA Ultimate, there is now initial support for the **Spring Framework**, including inspections, line markers, SpEL language injection support, actions to generate dependencies, and more;\n* A bunch of **inspections and quickfixes** have been added, such as an inspection for highlighting `var`s that can be `val`;\n* Improvements to Gradle integration, debugger, formatter, refactorings and other areas of the plugin.\n\n### JavaScript support\n\nWe’ve resumed work on our JavaScript backend, and the version 1.0.2 fills in most of the remaining gaps in the language feature support when targeting JavaScript. Newly supported features include nested classes, local classes, non-local returns in local lambdas, unsafe casts and more.\n\n### Maven Archetype\n\nWe’re now providing a Maven archetype to easily create Kotlin projects. Use “New project | Maven | Create from Archetype...” in IntelliJ IDEA, or the following command line:\n\n```kotlin\nmvn archetype:generate -Dfilter=org.jetbrains.kotlin:\n```\n\n### Dokka 0.9.8\n\nTogether with Kotlin 1.0.2, we’re releasing a new version of [Dokka](https://github.com/kotlin/dokka), the Kotlin documentation generation tool. If you’re using Dokka in your project, you need to upgrade Dokka together with Kotlin, because older Dokka versions are incompatible with Kotlin 1.0.2. New features in Dokka 0.9.8 include:\n\n* Android Gradle plugin, for generating documentation for Android libraries and applications;\n* Support for generating a javadoc jar file in the Maven plugin.\n\n### Conclusion\n\nYou can see the full list of bugfixes and changes to the compiler, standard library and the tools in the [changelog](https://github.com/JetBrains/kotlin/blob/1.0.2/ChangeLog.md).\n\nWhile working on the release, we received a lot of valuable feedback from the users of the [Early Access Preview builds](https://discuss.kotlinlang.org/t/kotlin-1-0-2-eap/1581). We’re really grateful to everyone who has provided feedback, and we welcome you to join the EAP program for future updates.\n\nAs usual, if you run into any problems with the new release, you’re welcome to ask for help on the [forums](https://discuss.kotlinlang.org/), on Slack (get an invite [here](http://kotlinslackin.herokuapp.com/)), or to report issues in the [issue tracker](https://youtrack.jetbrains.com/issues/KT).\n\n","author":"Dmitry Jemerov","date":"2016-05-13","type":"article","categories":["Kotlin","Release"],"features":["highlightjs"],"description":"","filename":"","lang":"EN","enclosure":null},{"title":"KotlinLifeguard #1","url":"http://blog.makingiants.com/kotlin-lifeguard-1/","body":"\nUsing [@JvmOverloads](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.jvm/-jvm-overloads/) tag helps to avoid multiple constructors with Kotlin\n\n## The headache\n\nIt’s really possible that you had some code like:\n\n```kotlin\nclass MyCustomView : FrameLayout {\n  \n  constructor(context: Context) : super(context) {\n    init()\n  }\n\n  constructor(context: Context, attrs: AttributeSet) : super(context, attrs) {\n    init()\n  }\n\n  constructor(context: Context, attrs: AttributeSet, defStyleAttr: Int)\n  : super(context, attrs, defStyleAttr) {\n    init()\n  }\n\n  fun init() { \n    // ...\n  }\n}\n```\n\nAs you can see there are all the constructors needed for a _custom_ `FrameLayout` but all with same “body”.\n\n![](http://blog.makingiants.com/assets/article_images/hmm.jpg)\n\n# The remedy\n\nRefactored with `@JvmOverloads`:\n\n```kotlin\nclass MyCustomView @JvmOverloads constructor(\n    context: Context,\n    attrs: AttributeSet? = null,\n    defStyleAttr: Int = 0)\n: FrameLayout(context, attrs, defStyleAttr){\n\n  init {\n    // ...\n  }\n}\n```\n\n## Thanks to\n\n* [Kotlin discuss](https://discuss.kotlinlang.org/t/simple-constructors-for-inheritance/1874/2)\n","author":"Daniel Gomez Rico","date":"2016-07-28","type":"article","categories":["Android","Kotlin"],"features":["highlightjs"],"description":"","filename":"","lang":"EN","enclosure":null},{"title":"Why You Must Try Kotlin For Android Development?","url":"https://medium.com/@amitshekhar/why-you-must-try-kotlin-for-android-development-e14d00c8084b#.2w8jdujf8","body":"","author":"Amit Shekhar","date":"2016-11-10","type":"article","categories":["Kotlin"],"features":["highlightjs"],"description":"","filename":"","lang":"EN","enclosure":null},{"title":"Kotlin in Real Projects","url":"https://www.youtube.com/watch?v=lpPbCWpBM3I","body":"\n\n<iframe width=\"960\" height=\"480\" src=\"https://www.youtube.com/embed/lpPbCWpBM3I\" frameborder=\"0\" allowfullscreen></iframe>\n<iframe src=\"https://player.vimeo.com/video/170761906?title=0&byline=0&portrait=0\" width=\"960\" height=\"480\" frameborder=\"0\" allowfullscreen></iframe>\n\n","author":"Anton Keks","date":"2016-11-01","type":"video","categories":["Kotlin"],"features":["highlightjs"],"description":"","filename":"","lang":"EN","enclosure":null},{"title":"Functional Programming with Kotlin","url":"http://blog.jetbrains.com/kotlin/2015/11/webinar-recording-functional-programming-with-kotlin/","body":"\nThe recording of our October 22nd webinar, **Functional Programming with Kotlin**, is now available on [JetBrainsTV YouTube channel](https://youtu.be/AhA-Q7MOre0).\n\nIn this talk, Mike Hearn provides a brief introduction to programming in Kotlin via practical example: creating a textfield with the autocomplete suggestions while typing. Demo project is available on [GitHub](https://github.com/mikehearn/KotlinFPWebinar).\n\nTopics covered include:\n\n*   Use of functional transforms\n*   Immutability\n*   Lazyness and working with lazy infinite sequences\n*   The use of [funKTionale](https://github.com/MarioAriasC/funKTionale), a library that extends Kotlin with a few features known from Haskell\n*   Pattern matching\n*   Reactive user interfaces\n\n<iframe src=\"https://www.youtube.com/embed/AhA-Q7MOre0\" allowfullscreen=\"\" height=\"480\" frameborder=\"0\" width=\"960\"></iframe>\n\nThe video includes the time stamps following the [agenda announced](http://blog.jetbrains.com/kotlin/2015/10/join-live-webinar-functional-programming-with-kotlin/):\n* `00:08` — Intoduction and demo application\n* `05:00` — `apply` function\n* `05:45` — Introduce NGram data class\n* `08:22` — Creating extension methods\n* `09:55` — Working with lazy infinite sequences\n* `10:35` — `map` function\n* `11:10` — `to` function and infix notation\n* `14:35` — Destructuring of data classes\n* `19:20` — `filter`, `let` and `all` functions\n* `23:00` — Debug lazy code\n* `24:20` — Add completions to UI\n* `25:18` — Load data in a functional way\n* `28:30` — Improve performance of the data loading\n* `33:20` — Improve the UI responsiveness in RX style\n* `40:05` — Using [Kovenant](https://github.com/mplatvoet/kovenant) library\n* `42:03` — Using [funKTionale](https://github.com/MarioAriasC/funKTionale) library\n* `44:10` — Currying\n* `45:35` — Questions\n\nAbout the Presenter:\n\n![Mike Hearn](http://i2.wp.com/info.jetbrains.com/rs/426-QVD-114/images/Mike_Hearn_200x200.jpg?resize=100%2C100 \"Mike Hearn\") [Mike Hearn](http://plan99.net/~mike/) is a Java, Kotlin and C++ developer who works on digital currency related software. Prior to that he was a senior software engineer at Google, where he spent over seven years working on a range of products including Earth, Maps, Gmail and the accounts system.\n\nThanks to all the attendees for the questions! If you still have some, please, contact Mike or our team.\n\nYou are welcome to suggest themes for future webinars in comments.\n\n_Let’s kotlin!_\n","author":"Roman Belov","date":"2015-11-05","type":"webinar","categories":["Kotlin","Webinar","Fp","Functional"],"features":["highlightjs"],"description":"","filename":"","lang":"EN","enclosure":null},{"title":"I wrote my website in Kotlin","url":"https://medium.com/lewisrhine/i-wrote-my-website-in-kotlin-cc55263d2028#.k20k8snpp","body":"\nA few weeks ago I thought I should have a [website](http://lewisrhine.com/). Since I am an Android developer, I thought it should be in material design and because I’m a full on fanboy lunatic I thought it should be written on Kotlin.\n\nIf you didn’t know Kotlin can also compile to JavaScript. It’s still experimental but Jetbrain has said they are still committed to it. It’s something we should care about. In case you haven’t noticed JavaScript is taking over the world. While there are plenty of other JavaScript transpilers, if React Native gets as big as it seems I would rather write it in Kotlin over JavaScript.\n\nFor my site, Google’s [Material Design Lite](https://getmdl.io/) seemed like the easiest way to do it.\n\nI whipped up a quick single page front-end framework named Kotlin Material Design Lite… Yeah, I know a boring name. The docs on Kotlin-JavaScript are slim, to say the least. So there is a good chance there are better methods than the ones I came up. It’s also very much not complete. It mostly just has the components I needed. But I do plan to keep working on it and any other contributions are welcome. If nothing else, it is a great way to learn more about Kotlin-JavaScript and be ready for when the tide of JavaScript drowns us all.\n\nThere are three main parts to KMDL.\n\n```kotlin\nfun mdlApp(init: MdlApp.() -> Unit): MdlApp {\n    val app = MdlApp()\n    app.init()\n    return app\n}\n\nclass MdlApp() {\n    private val app = document.getElementById(\"MdlApp\")\n\n    init {\n        requireNotNull(app) { \"No MldApp Element found!\" }\n    }\n\n    fun navigationLayout(content: MdlContent, cssClass: String = \"\", init: Layout.() -> Unit) {\n        val nl = Layout(content, cssClass)\n        nl.init()\n        nl.mainElement.append(nl.content.content.mainElement)\n        app?.append(nl.mainElement)\n    }\n}\n```\n\nThis class looks for a div with an id of “MdlApp”. In Kotlin-JavaScript you interact with the DOM using “document” so when I call “document.getElementById(“MdlApp”)” it searches the HTML for an element with the id of MdlApp and returns it or null if it doesn’t find it.\n\nThe other main part is an abstract class MdlComponent. It’s what’s used to build out all the Material Design Lite Components.\n\n```kotlin\nabstract class MdlComponent(tag: String, classType: String, cssClassId: String = \"\") {\n    val mainElement = document.createElement(tag).apply { this classType \"$cssClassId $classType\" }\n\n    var backgroundColor: MdlColor.Background? = null\n        set(value) {\n            value?.let { mainElement.setAttribute(\"class\", mainElement.getAttribute(\"class\")?.plus(\" $it\")!!) }\n        }\n\n    var textColor: MdlColor.Text? = null\n        set(value) {\n            value?.let { mainElement.setAttribute(\"class\", mainElement.getAttribute(\"class\")?.plus(\" $it\")!!) }\n        }\n\n    fun <T> htmlPram(parent: Element = mainElement): ReadWriteProperty<Any, T> = object : ReadWriteProperty<Any, T> {\n        private var prop: T? = null\n\n        override fun getValue(thisRef: Any, property: KProperty<*>): T {\n            return prop ?: throw IllegalStateException(\"Property ${property.name} should be initialized before get.\")\n        }\n\n        override fun setValue(thisRef: Any, property: KProperty<*>, value: T) {\n            prop = value\n            set(property.name, prop!!)\n        }\n\n        private fun set(name: String, value: T) {\n            parent.setAttribute(name, \"$value\")\n            if (name == \"href\") parent.setAttribute(\"target\" ,\"_blank\")\n        }\n    }\n\n    fun htmlTextPram(text: String = \"\", parent: Element = mainElement): ReadWriteProperty<Any, String> = object : ReadWriteProperty<Any, String> {\n        private var prop: String = text\n\n        init {\n            set(prop)\n        }\n\n        override fun getValue(thisRef: Any, property: KProperty<*>): String = prop\n\n        override fun setValue(thisRef: Any, property: KProperty<*>, value: String) {\n            prop = value\n            set(prop)\n        }\n\n        private fun set(text: String) {\n            parent.textContent = text\n        }\n    }\n\n    fun <T : MdlComponent> appendToMain(initItem: T) = object : ReadWriteProperty<Any, T> {\n        var item = initItem\n\n        init {\n            mainElement.append(item.mainElement)\n        }\n\n        override fun getValue(thisRef: Any, property: KProperty<*>): T = item\n\n        override fun setValue(thisRef: Any, property: KProperty<*>, value: T) {\n            mainElement.append(value.mainElement)\n            item = value\n        }\n    }\n\n    fun <T : MdlComponent> appendToMainIf(condition: Boolean, initItem: T) = object : ReadWriteProperty<Any, T> {\n        var item = initItem\n\n        init {\n            if (condition) mainElement.append(item.mainElement)\n        }\n\n        override fun getValue(thisRef: Any, property: KProperty<*>): T = item\n\n        override fun setValue(thisRef: Any, property: KProperty<*>, value: T) {\n            if (condition) {\n                mainElement.append(value.mainElement)\n                item = value\n            }\n        }\n    }\n\n    operator fun Element.unaryPlus() {\n        mainElement.append(this)\n    }\n}\n```\n\ndocument.createElement is how Kotlin-JavaScript creates elements on the DOM. This class also makes heavy use of delegate properties to make creating the components attributes easier. For example the Img\n\n```kotlin\nclass Img(cssClassId: String = \"\") : MdlComponent(\"img\", cssClassId) {\n    var src: String by htmlPram()\n    var width: Int by htmlPram()\n    var height: Int by htmlPram()\n    var border:Int by htmlPram()\n    var alt: String by htmlPram()\n}\n\n```\n\nThe src property uses the htmlPram delegate which uses the property’s name to set HTML attributes.\n\nNow inside the main function just build out a MdlApp using the mdlApp function.\n\n```kotlin\nfun main(args: Array<String>) {\n    val mdlApp = mdlApp {\n        navigationLayout(About, \"layout\") {\n            header {}\n            drawer(\"drawer\") {\n                mainElement.header(\"drawer-header ${MdlColor.Background.blueGrey(Shade.s300)}\") {\n                    img(\"avatar\") { src = \"images/roundprofile.png\" }\n                    b { textContent = \"Lewis Rhine\" }\n                    append(document.createTextNode(\"Android Developer\"))\n                }\n\n                nav(\"navigation\") {\n                    link { text = \"About\"; materialIcons = \"account_circle\"; onClick { content = About } }\n                    link { text = \"Blog\"; materialIcons = \"book\"; href = \"https://medium.com/lewisrhine\" }\n                    link { text = \"Projects\"; materialIcons = \"build\"; href = \"https://github.com/lewisrhine\" }\n                    link {\n                        text = \"Twitter\"\n                        href = \"https://twitter.com/lewisrhine\"\n                        mainElement.append(document.createElement(\"i\").apply {\n                            setAttribute(\"class\", \"material-icons fa fa-twitter\")\n                        })\n                    }\n                    link {\n                        text = \"Instagram\"\n                        href = \"https://www.instagram.com/lewisrhine\"\n                        mainElement.append(document.createElement(\"i\").apply {\n                            setAttribute(\"class\", \"material-icons fa fa-instagram\")\n                        })\n                    }\n                    link {\n                        text = \"LinkedIn\"\n                        href = \"https://www.linkedin.com/in/lewisrhine\"\n                        mainElement.append(document.createElement(\"i\").apply {\n                            setAttribute(\"class\", \"material-icons fa fa-linkedin\")\n                        })\n                    }\n                    link { text = \"email\"; href = \"mailto:lewisrhine@gmail.com\"; materialIcons = \"email\" }\n                }\n            }\n        }\n    }\n}\n```\n\nThe last part is the MdlContent.\n\n```kotlin\nfun content(title: String, cssClassId: String = \"\", body: Element.() -> Unit)  = Content(title, cssClassId, body)\n\nclass Content(val title: String, cssClassId: String = \"\", body: Element.() -> Unit) : MdlComponent(\"div\", \"mdl-layout__content\", cssClassId) {\n    init {\n        mainElement.body()\n    }\n}\n\ninterface MdlContent {\n    val content: Content\n}\n```\n\nIt’s used to build out content pages for the app.\n\n```kotlin\nobject About : MdlContent {\n    override val content = content(\"About\") {\n        setAttribute(\"style\", \" background: url('images/whoiam.jpg') center / cover; filter: alpha(opacity=60); padding: 10px;\")\n\n        grid {\n            cell(3) {}\n\n            cellCard(6) {\n                title = \"About me\"\n                supportingText = \"Completely self-taught, I began my love for writing code when I was you kid and found out about QBasic on the family computer. In my day to day life, I enjoy keeping up with new developments within the technology and android community. I am very passionate about clean thought out architecture in the code I write. And believe strongly in testing as much as possible. Even on Android where it's not the easiest to accomplish.\"\n            }\n\n            cell(3) {}\n\n            cell(1) {}\n            cell(10) {\n                chip(contact = true) { src = \"images/java-logo.png\"; text = \"Java\" }\n                chip(contact = true) { src = \"images/kotlin-logo.png\"; text = \"Kotlin\" }\n                chip(contact = true) { src = \"images/android-logo.png\"; text = \"Android Native\" }\n                chip(contact = true) { src = \"images/rxjava-logo.png\"; text = \"RxJava\" }\n                chip(contact = true) { src = \"images/javascript-logo.png\"; text = \"JavaScript\" }\n                chip(contact = true) { src = \"images/react-logo.png\"; text = \"React Native\" }\n                chip(contact = true) { src = \"images/unity-logo.png\"; text = \"Unity3D\" }\n                chip { text = \"Junit\" }\n                chip(contact = true) { src = \"images/mockito-logo.png\"; text = \"Mockito\" }\n            }\n            cell(1) {}\n\n            cellCard(4) {\n\n                size()\n                title = \"Rithmio\"\n                supportingText = \"Mar 2016 — present\"\n                mainElement.list {\n                    item(ListIem(\"-At Rithmio I Introduced new technologies like Kotlin and RxJava which have helped to make the team faster and more efficient.\"))\n                    item(ListIem(\"-Rithmio EDGE: I designed a new architecture based on Flux style circular data streams that made the code base more testable and stable.\"))\n                    item(ListIem(\"-Cadence Counter: I built a prototype app from the ground up that had a strict two-week window of completion. I was able to complete it in only a week giving the project an extra week for testing. \"))\n                }\n\n            }\n\n            cellCard(4) {\n                size()\n                title = \"MeetBall\"\n                supportingText = \"Jun 2015 — Mar 2016\"\n                mainElement.list {\n                    item(ListIem(\"-At MeetBall I was the sole Android developer took over code base from a contractor and quickly moved the code a more structured testable state.\"))\n                    item(ListIem(\"-Integrated Beacon awareness into the app using the Radius Networks SDK\"))\n                }\n            }\n\n            cellCard(4) {\n                title = \"Tinker Entertainment\"\n                supportingText = \"Sep 2014 — Nov 2014\"\n                mainElement.list {\n                    item(ListIem(\"While defunct, I picked up this project for my friend’s new company venture when his original developer dropped out. With the game’s code base written in C# and using the Unity3D framework, I quickly adapted myself to the language and provided an initial product release.\"))\n                }\n            }\n        }\n    }\n}\n```\n\nAgain the project, like Kotlin-JavaScript is still experimental but you can take a look at the code and you want to contribute [here](https://github.com/LewisRhine/Kotlin-Material-Design-Lite).\n\n","author":"Lewis Rhine","date":"2017-01-05","type":"article","categories":["Kotlin"],"features":["highlightjs"],"description":"","filename":"","lang":"EN","enclosure":null},{"title":"Algebraic Data Types In Kotlin","url":"http://engineering.pivotal.io/post/algebraic-data-types-in-kotlin/","body":"\n\nLately I have been doing a good amount of reading on functional programming, specifically [Haskell](http://haskellbook.com/) and [Elm](http://elm-lang.org/). As part of this reading, I've been exposed to the wonderful world of type systems more advanced than the ones that I am used to, i.e. the Java type system. Exposure to [algebraic data types (ADTs)](https://en.wikipedia.org/wiki/Algebraic_data_type) is one of the things that I've enjoyed about these readings. In the rest of this article, I will demonstrate how ADTs can be used in the Kotlin type system to assure that you've handled all of the possible outcomes from a business use case. For those already familiar with the [`Either` type](https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-Either.html) much of this will be old news to you.\n\nAlgebraic data types allow me to create a closed set of possible options for a specific type in my domain.\n\n```kotlin\nsealed class CreateSubscriptionResult {\n    class Success(val subscription: Subscription): CreateSubscriptionResult()\n    class Failure(val errors: List<String>): CreateSubscriptionResult()\n}\n```\n\nIn this case I am using the [`sealed` keyword](https://kotlinlang.org/docs/reference/classes.html#sealed-classes) to tell the type system that there will not be any more possible outcomes for a `CreateSubscriptionResult`. Now I can use the `when` keyword to force the consumer of the `CreateSubscriptionResult` to make sure it handles all of the possible outcomes.\n\n```kotlin\nreturn when (result) {\n    is CreateSubscriptionResult.Success ->\n        // Do something on success\n    is CreateSubscriptionResult.Failure ->\n        // Do something on failure\n}\n```\n\nWere I to omit one of the possible outcomes,\n\n```kotlin\nreturn when (result) {\n    is CreateSubscriptionResult.Success ->\n        // Do something on success\n}\n```\n\nthen the Kotlin compiler will tell me that I've forgotten something.\n\n```\nwhen expression must be exhaustive, add necessary 'is Failure' branch or 'else' branch instead\n```\n\nWell isn't that nice. I now can use the type system to remind myself, and my fellow developers, that something is missing and keep those types of bugs from cropping up in my software without a lot of boilerplate code. If another outcome is added at some point, the compiler will tell me that and I can then figure out how to handle it.\n\nBy using the type system to do this, I enable a faster feedback loop than had I written a test for it. Yes I may still need a test for the logic inside of each branch but I would postulate that if I keep it simple enough (like a difference in response code) that a test may be overkill because of the type system assurance. I'll leave that decision up to you.\n\nOne place I have been experimenting with this type of pattern is in my [Spring controllers](https://github.com/mikegehard/user-management-evolution-kotlin/blob/master/applications/ums/src/main/kotlin/com/example/ums/subscriptions/SubscriptionsController.kt#L36-L47). I like how it makes the code that handles the outcomes easy to read and understand. Another benefit is that I now have an explicit contract between the use case and the consumer that outlines all of the possible outcomes for the use case. When I combine this contract with the `when` keyword, the compiler will enforce that the client either handles each outcome or decides to explicitly punt on some by using the `else` keyword.\n\nHave some feedback? I'd love to hear it. Reach out to me on Twitter @mikegehard and we can have a conversation about it.\n\n","author":"Mike Gehard","date":"2016-03-19","type":"article","categories":["Kotlin","Functional Programming"],"features":["highlightjs"],"description":"","filename":"","lang":"EN","enclosure":null},{"title":"Kotlin is cheating on me...","url":"https://hackernoon.com/kotlin-is-cheating-on-me-e048cde4f66#.5vq8chhbz","body":"\n## ... but I’m OK with it.\n\nEarlier this month, I published an account of my very first experience of Android development. It wasn’t pretty.\n\n[**Android is hard** _TL;DR. I have my very first Android app out!_ hackernoon.com](https://hackernoon.com/android-is-hard-b7a5a5549655)\n\nBeing honest pays, and in this case it paid so much that one of the editors at Hackernoon picked my story up, and then some. Numbers were shooting up, I could not be happier. Then something happened.\n\nYou know when you are aimlessly complaining about X on the Internet, and some guy shows up and says “Why don’t you use Y?” Question mark, that’s it. I hate this kind of comments. No evidence for why Y is better than X or why Y — oh, why — would make my life any less miserable. To be fair, pretty much anything is guaranteed to make your life less miserable than Java, so I said what the heck, and tried my luck with Kotlin.\n\nI heard good things about Kotlin, you know, like how it is null-safe, and Java is not, and that is the premier source of bemusement of roughly 99.9% of the people who ever used anything that could run Java.\n\n![](https://cdn-images-1.medium.com/max/800/1*UzblnQYcfXEZlg37__zxWw.png)\n\nWhen you see it...\n\nKotlin has many other nice features, but I was sold at null-safety. Kotlin is also developed by the nice people at JetBrains, who happen to be the same that develop IntelliJ IDEA, the IDE on which Android Studio is based. With the most amazing of _non sequuntur_, Android Studio has an automatic get-Java-the-hell-out-of-my-life plugin that turns your Java code into Kotlin. I haven’t tested it extensively, but it worked very well for me. Granted, it left behind a number of Javaisms, but they were pretty easy to fix.\n\nTo make a long story short, I hit “make it so” to run my app on my phone. I have been around programming long enough that I was not expecting this to work, and yet it did. Within seconds, I had to ask the Internet how to check whether my Kotlin app was really running, or my phone was running the Ghost of Apps Past. After some digging, it suddenly hit me: Kotlin is not only compiled to JVM bytecode, but it also effectively uses much of Java’s and Android’s regular libraries. That makes perfect sense. It’s almost as if Kotlin code is getting transpiled — yes, that’s a word — to Java, and then a regular old boring Java compiler is used, except that it isn’t, it’s much more clever than that, and that’s all that matters.\n\nOn the other hand, Kotlin is effectively lying to me. Whenever I declare a Map, and initialise it with a `mapOf()`, what happens is that I’m given a cleverly disguised `LinkedHashMap`, and that is what you end up using in your code: a regular, old `LinkedHashMap` with all its quirks and methods. Don’t get me wrong, Kotlin is a nice language, but the more I dove into making sure that my newly-converted code still made sense, the more the feeling that I was being cheated grew. In the end, I’m still writing an Android app, and everything is written in Java, and that means that there is an awful lot of things that can be null at runtime. Sure, Kotlin has ways of dealing with that, and very nice ways at that, but I found myself having to use them way more often than I was expecting. To make things worse, there is practically no way of telling in advance what values may be null at runtime, because the Java codebase is so poorly annotated, and so the best advice I got was to always assume that everything that touches Java can be null at any time.\n\nThe single reason for me to switch to Kotlin, vaporised. I let that sink in for a moment...\n\n... and then I still got on with Kotlin because overall it’s a much nicer language to look at.\n\nFor those who are wondering, “_non sequuntur_” is the correct plural of “_non sequitur_”. Get your Latin straight, you Anglophones.\n\n","author":"Andrea Franceschini","date":"2016-12-24","type":"article","categories":["Kotlin"],"features":["highlightjs"],"description":"","filename":"","lang":"EN","enclosure":null},{"title":"A Geospatial Messenger with Kotlin, Spring Boot and PostgreSQL","url":"https://spring.io/blog/2016/03/20/a-geospatial-messenger-with-kotlin-spring-boot-and-postgresql","body":"\n\nFollowing my first [Kotlin blog post](https://spring.io/blog/2016/02/15/developing-spring-boot-applications-with-kotlin), today I want introduce the new Spring Boot + Kotlin application I have developed for my upcoming [Spring I/O 2016 conference](http://www.springio.net/) talk “Developing Geospatial Web Services with Kotlin and Spring Boot”.\n\n# Dealing with native database functionalities\n\nOne of the goal of this application is to see how to take advantage of native database functionalities like we do in NoSQL world. Here we want to use Geospatial support provided by [PostGIS](http://postgis.net/), the spatial database extender for [PostgreSQL](http://postgresql.org/). [Native JSON support](https://www.compose.io/articles/is-postgresql-your-next-json-database/) could also be a good use case.\n\nThis Geospatial Messenger sample application is [available on GitHub](https://github.com/sdeleuze/geospatial-messenger) in 2 flavors:\n- The `master` branch uses [Exposed](https://github.com/JetBrains/Exposed), a Kotlin SQL library with a typesafe API created by JetBrains. It could be compared to [Query DSL SQL](https://github.com/querydsl/querydsl/tree/master/querydsl-sql) or [jOOQ](http://www.jooq.org/) but provides an idiomatic Kotlin API and does not require code generation.\n- The [`spring-data-jdbc-repository`](https://github.com/sdeleuze/geospatial-messenger/tree/spring-data-jdbc-repository) branch is using `spring-data-jdbc-repository`, a community project that allows to use Spring Data [`PagingAndSortingRepository`](https://docs.spring.io/spring-data/data-commons/docs/current/api/org/springframework/data/repository/PagingAndSortingRepository.html) API with raw SQL queries without JPA. I am using [this Jakub Jirutka fork](https://github.com/jirutka/spring-data-jdbc-repository/) which is an improved version of [Tomasz Nurkiewicz original project](https://github.com/nurkiewicz/spring-data-jdbc-repository).\n\nA [Spring Data JPA + Hibernate Spatial variant](https://github.com/sebastianperruolo/spring-gis) would be interesting, so feel free to contribute it with a pull request ;-) Kotlin Query DSL support would be also nice but this is currently not supported (please comment on [this issue](https://github.com/querydsl/querydsl/issues/1828) if you are interested). In this blog post I will focus on the [Exposed](https://github.com/JetBrains/Exposed) variant.\n\n# A tour of Geospatial Messenger code\n\nOur domain model is described easily thanks to these 2 [Kotlin data classes](https://kotlinlang.org/docs/reference/data-classes.html):\n\n```kotlin\ndata class Message(\n    var content  : String,\n    var author   : String,\n    var location : Point? = null,\n    var id       : Int?   = null\n)\n\ndata class User(\n    var userName  : String,\n    var firstName : String,\n    var lastName  : String,\n    var location  : Point? = null\n)\n```\n\nExposed allows us to describe the structure of our tables with a type-safe SQL API quite handy to use (autocomplete, refactoring and error prone):\n\n```kotlin\n    object Messages : Table() {\n        val id       = integer(\"id\").autoIncrement().primaryKey()\n        val content  = text(\"content\")\n        val author   = reference(\"author\", Users.userName)\n        val location = point(\"location\").nullable()\n    }\n\n    object Users : Table() {\n        val userName  = text(\"user_name\").primaryKey()\n        val firstName = text(\"first_name\")\n        val lastName  = text(\"last_name\")\n        val location  = point(\"location\").nullable()\n    }\n```\n\nIt is interesting to notice that Exposed does not support natively PostGIS functionalities like geometry types or geospatial requests. That’s where [Kotlin extensions](https://kotlinlang.org/docs/reference/extensions.html) shine, and allow with a few lines of code to add such support without requiring to use extended classes:\n\n```kotlin\nfun Table.point(name: String, srid: Int = 4326): Column<Point>\n  = registerColumn(name, PointColumnType())\n\ninfix fun ExpressionWithColumnType<*>.within(box: PGbox2d) : Op<Boolean>\n  = WithinOp(this, box)\n```\n\nOur repository is also quite short and very flexible, since it allows you to write any kind of SQL request even with complex `WHERE` clause with a type-safe SQL API. Currently we need to use `db.transaction{ }` wrapper, I have created Exposed issue [#25](https://github.com/JetBrains/Exposed/issues/25) to be able to use regular [Spring transaction management](http://docs.spring.io/autorepo/docs/spring/4.2.x/spring-framework-reference/html/transaction.html) with [`@Transactional`](http://docs.spring.io/autorepo/docs/spring/4.2.x/spring-framework-reference/html/transaction.html#transaction-declarative-annotations) annotation, feel free to add your +1 ;-)\n\nPlease notice that since we are using Spring Framework 4.3, we [no longer need to specify an `@Autowired` annotation in such single-constructor class](https://spring.io/blog/2016/03/04/core-container-refinements-in-spring-framework-4-3#implicit-constructor-injection-for-single-constructor-scenarios).\n\n```kotlin\n@Repository\nopen class UserRepository(val db: Database) {\n\n    open fun createTable() = db.transaction {\n        create(Users)\n    }\n\n    open fun create(user: User) = db.transaction {\n        Users.insert( toRow(user) )\n    }\n\n    open fun updateLocation(u:String, l: Point) = db.transaction {\n        location.srid = 4326\n        Users.update({Users.userName eq u}) { it[Users.location] = l}\n    }\n\n    open fun findAll() = db.transaction {\n        Users.selectAll().map { fromRow(it) }\n    }\n\n    open fun findByBoundingBox(box: PGbox2d) = db.transaction {\n        Users.select { Users.location within box }.map { fromRow(it) }\n    }\n\n    open fun deleteAll() = db.transaction {\n        Users.deleteAll()\n    }\n\n    fun toRow(u: User): Users.(UpdateBuilder<*>) -> Unit = {\n        it[userName] = u.userName\n        it[firstName] = u.firstName\n        it[lastName] = u.lastName\n        it[location] = u.location\n    }\n\n    fun fromRow(r: ResultRow) =\n        User(r[Users.userName],\n             r[Users.firstName],\n             r[Users.lastName],\n             r[Users.location])\n}\n```\n\nControllers are also very concise and use Spring Framework 4.3 upcoming `@GetMapping` / `@PostMapping` annotations which are just method-specific shortcuts for `@RequestMapping` annotations:\n\n```kotlin\n    @RestController\n    @RequestMapping(\"/user\")\n    class UserController(val repo: UserRepository) {\n\n        @PostMapping\n        @ResponseStatus(CREATED)\n        fun create(@RequestBody u: User) { repo.create(u) }\n\n        @GetMapping\n        fun list() = repo.findAll()\n\n        @GetMapping(\"/bbox/{xMin},{yMin},{xMax},{yMax}\")\n        fun findByBoundingBox(@PathVariable xMin:Double,\n                              @PathVariable yMin:Double,\n                              @PathVariable xMax:Double,\n                              @PathVariable yMax:Double)\n                = repo.findByBoundingBox(\n                            PGbox2d(Point(xMin, yMin), Point(xMax, yMax)))\n\n        @PutMapping(\"/{userName}/location/{x},{y}\")\n        @ResponseStatus(NO_CONTENT)\n        fun updateLocation(@PathVariable userName:String,\n                           @PathVariable x: Double,\n                           @PathVariable y: Double)\n                = repo.updateLocation(userName, Point(x, y))\n    }\n```\n\nThe client side is a pure HTML + Javascript application developed with [OpenLayers](http://openlayers.org/) mapping library (see [index.html](https://github.com/sdeleuze/geospatial-messenger/blob/master/src/main/resources/static/index.html) and [map.js](https://github.com/sdeleuze/geospatial-messenger/blob/master/src/main/resources/static/map.js) for more details) that geolocalizes you and creates geolocalized messages sent/received to/from other users thanks to Server-Sent Events.\n\n![Screenshot](https://raw.githubusercontent.com/sdeleuze/geospatial-messenger/master/screenshot.png)\n\nAnd last but not least, the REST API is fully tested and documented thanks to the awesome [Spring REST docs](http://projects.spring.io/spring-restdocs/) project, see [MessageControllerTests](https://github.com/sdeleuze/geospatial-messenger/blob/master/src/test/kotlin/io/spring/messenger/MessageControllerTests.kt) and [index.adoc](https://github.com/sdeleuze/geospatial-messenger/blob/master/src/main/resources/static/index.html) for more details.\n\n# Conclusion\n\nThe main impression I had developing this application is that it was fun, efficient, with a high level of flexibility and safety provided by the SQL API and Kotlin type system and [null safety](https://kotlinlang.org/docs/reference/null-safety.html). The resulting Spring Boot application is a 18 MBytes self-contained executable jar with low memory consumption (the app can run with `-Xmx32m`!!!). Using Spring REST docs was also a pleasure, demonstrating again Kotlin nice Java interoperability.\n\nThe few pain points I have encountered ([array annotation attributes](https://youtrack.jetbrains.com/issue/KT-11235), [Java 8 Stream support](https://youtrack.jetbrains.com/issue/KT-5175), [full callable reference support](https://youtrack.jetbrains.com/issue/KT-6947)), are planned to be fixed in Kotlin 1.1. Exposed library is still young and need to mature, but from my point of view it is promising and shows how Kotlin could be used for building type-safe DSL API ([this HTML type-safe builder](https://kotlinlang.org/docs/reference/type-safe-builders.html) is also a good example).\n\nAnd keep in mind that officially supported [Spring Data projects](http://projects.spring.io/spring-data/) works well with Kotlin as shown in the [spring-boot-kotlin-demo](https://github.com/sdeleuze/spring-boot-kotlin-demo) project in my [previous blog post](https://spring.io/blog/2016/02/15/developing-spring-boot-applications-with-kotlin).\n\nIf you happen to be in Barcelona mid May (never a bad time to be in Barcelona anyway!), don’t miss the chance to join the [Spring I/O conference](http://www.springio.net/). Also, the registration for [SpringOne Platform](http://springoneplatform.io/) (early August, Las Vegas) has opened recently, in case you want to benefit from early bird ticket pricing. The latter is also still open for talk proposals. So if you’re interested to give a talk about Spring or Pivotal-related technologies, feel free to submit!\n\n","author":"Sébastien Deleuze","date":"2016-03-20","type":"article","categories":["Kotlin","Spring"],"features":["highlightjs"],"description":"","filename":"","lang":"EN","enclosure":null},{"title":"Using Kotlin type-safe builders to create a DSL for Forms","url":"https://engineering.facile.it/blog/eng/kotlin-dsl/","body":"\nHere at Facile.it we are constantly dealing with a lot of **forms**: we use them to collect various information and data needed to feed our in-house comparing algorithms. These forms could be **really complex**, having multiple rules and dependencies between fields, and they are likely to be **changed and tuned frequently**.\n\nWhen I joined Facile.it, a lot of forms within the Android app needed to be updated or modified and sticking with the existing strategy would have required me to do **a lot of work** just to add or remove a simple field. So I took a step back and I started thinking about a strategy that would have allowed me to define and structure a form in a more *flexible* and *declarative* way. I wanted to be able to declare the **relationships** between fields, their **validation rules** and their **serialized representation** (how they are sent to the server).\n\nI firstly thought about defining it using some configuration file, maybe written in JSON or YAML. The *problem* with this strategy was that it would also have required me to write a lot code to parse and validate those files to be able to create some sort of representation of the form in Java…but don’t we already have the compiler for this kind of jobs?\n\nI still wanted to be able to have both a **human readable representation** of the form and the right degree of **flexibility** to integrate the form definition into the app code. So I thought that creating a [Domain-Specific Language](https://en.wikipedia.org/wiki/Domain-specific_language) would have been a perfect strategy to solve the problem in an elegant and efficient way. Writing a DSL in Java could have ended up into something like that:\n\n```kotlin\nForm.create()\n    .openSection(sectionId)\n    .field(key1, \"label1\", style, ...)\n    .field(key2, \"label2\", style, ...)\n    .field(key3, \"label3\", style, ...)\n    .closeSection()\n    ...\n    .build()\n```\n\nI don’t think the previous code is readable nor flexible and it requires a lot of boilerplate to be written.\n\n## Kotlin to the rescue! ##\n\nUnlike Java, Kotlin (take a look at my [previous post](https://engineering.facile.it/blog/eng/kotlin-intro/) about it) has a lot of features that makes it really powerful when it comes to write internal DSLs. The results are very similar to Groovy (think about a Gradle file) but thanks to its type system they could be [Type-Safe](https://kotlinlang.org/docs/reference/type-safe-builders.html#type-safe-builders).\n\nThe builders you can write with Kotlin are extremely readable and easy to understand even for people that don’t know either the language or the DSL itself. Here’s how a form built using my final DSL looks like:\n\n```kotlin\nval FORM = form {\n    page(\"Page 1 Title\") {\n        section(\"Section 1 Title\") {\n            field(key = \"fieldKey1\") {\n                checkbox(\"Checkbox Field Label\") {\n                    boolToStringConverter = { if (it == true) \"Yes\" else \"No\" }\n                    rules = { listOf(NotMissing()) }\n                }\n            }\n            field(key = \"fieldKey2\") {\n                picker(\"Picker Field Label\") {\n                    placeHolder = \"Select a value\"\n                    possibleValues = Available(listOf(\n                            1 keyTo \"Value1\",\n                            2 keyTo \"Value2\",\n                            3 keyTo \"Value3\"))\n                    representation = IF_VISIBLE representAs SIMPLE_KEY_TO_VALUE\n                }\n            }\n        }\n        section(\"Section 2 Title\") {\n            field(key = \"fieldKey3\") {\n                picker(\"Picker Field Label\") {\n                    placeHolder = \"Select a value\"\n                    possibleValues = ToBeRetrieved(someWebService.getValues())\n                    representation = IF_VISIBLE representAs SIMPLE_KEY_TO_VALUE\n                }\n            }\n            field(key = \"fieldKey4\") {\n                input(\"Input Text Field Label\") {\n                    inputTextType = InputTextType.EMAIL\n                    rules = { listOf(IsEmail()) }\n                }\n            }\n            field(key = \"fieldKey\") {\n                empty(\"Empty Field\")\n            }\n        }\n        section(\"Section 3 Title\") {\n            field(key = \"fieldKey6\") {\n                toggle(\"Toggle Field Label\") {\n                    boolToStringConverter = { if (it == true) \"OK\" else \"KO\" }\n                    rules = { listOf(NotMissing()) }\n                    representation = ALWAYS representAs SIMPLE_KEY_TO_VALUE\n                }\n            }\n        }\n    }\n}\n```\n\n\nAnd this is the result on Android using my [Form library](https://github.com/brescia123/forms):\n\n![Form screenshot](https://engineering.facile.it/images/kotlin-dsl/form_screen.png)\n\nCool, isn’t it?\n\n## Type-safe builders ##\n\n### Some Kotlin important features ###\n\nTo grasp how Type-safe builders work in Kotlin we need to understand some key Kotlin features and how they can be combined together:\n\n *  **Higher-Order Functions and Lambdas**: in Kotlin we are allowed to write functions that have *functions as parameters or return type* (higher-order functions) and functions that are *not declared*, but are passed immediately as an expression (lambdas). Because of this, we can write things like:\n\n```kotlin\n// Higher-Order Function\nfun transformWith(path: String, function: (String) -> List<String>): List<String> {\n    return function(this)\n}\n\n// Lambda\n{ path: String -> path.split(\"/\") }\n```\n\nThanks to Kotlin syntactic sugar we can use them in these ways:\n\n```kotlin\ntransformWith(\"some/path/to\", { path: String -> path.split(\"/\") }) // -> [some, path, to]\n\n// Functions which have a function as the last parameter can be written as follow\ntransformWith(\"some/path/to\") { path -> path.split(\"/\") } // -> [some, path, to]\n\n// If the lambda has only one parameter it can be ommitted and referenced as \"it\"\ntransformWith(\"some/path/to\") { it.split(\"/\") } // -> [some, path, to]\n```\n\n *  **Extension Functions**: they allow us to *extend* a type with functions without modifying the original class. They are useful to add functionalities to classes we don’t have control on or to create utility methods without the need to create “Utils classes” that contains static methods, as we are used to as Java developers. To continue the previous example we can write:\n\n```kotlin\n// Extension function\nfun String.transformWith(function: (String) -> List<String>) {\n    return function(this)\n}\n\n\"some/path/to\".transformWith { receiverString: String -> receiverString(\"/\") } // -> [some, path, to]\n\n// or more concisely\n\"some/path/to\".transformWith { it.split(\"/\") } // -> [some, path, to]\n```\n\nNote that we are referring to the string inside the closure of the extension function using `this` as it will be the String object on which the method will be called.\n\n *  **Function Literals with Receiver**: similarly to extension functions you are also allowed to define functions with a receiver that will be referred to as `this` inside the literal closure:\n\n```kotlin\nval transformWith: String.() -> List<String> = { this.split(\"/\") }\n\n\"some/path/to\".transformWith() // -> [some, path, to]\n```\n\nTo better understand function literals with receiver you should think of them as follow: *lambda is to normal function as function literal with receiver is to extension function*.\n\n```kotlin\n// lambda\n{ s: String -> s.split(\"/\") }\n// is to\nfun function(s: String): List<String> { return s.split(\"/\") }\n// as\nval functionLiteralWithReceiver = String.() -> List<String> = { this.split(\"/\") }\n// is to\nfun String.extensionFunction(): List<String> { return function(this) }\n```\n\nBasically function literals with receiver are extension functions that can be passed to other functions.\n\n### Wrapping up ###\n\nNow we have all the elements required to understand and write a Type-safe builder.\n\nCombining the above mentioned Kotlin features we can now write a function and name it `form`. This function will take as parameter a function literal with receiver usually called `init()` and will do the follow:\n\n *  create a new Form object\n *  call `init()` on it (that is using it as the receiver of the function literal)\n *  return the built object to the caller\n\n```kotlin\nfun form(init: Form.() -> Unit): Form {\n    val form = Form()\n    form.init()\n    return form\n}\n```\n\nNow let’s imagine that our Form class defines a function `field()` that actually creates a field object and adds it to the list of fields contained within the form:\n\n```kotlin\nclass Form() {\n    val fields: List<Field>\n    ...\n    fun field(key: String) { ... }\n    ...\n}\n```\n\nTaking advantage of Kotlin syntactic sugar we can use `form()` passing it the `init()` function as a lambda and call methods on the Form object to build it as follow:\n\n```kotlin\nval builtForm = form() {\n    // Here we can take advantage of the compiler and, as a result, of the IDE code completion\n    field(\"key1\") // == this.field(\"key1\") where this is the object create by form()\n    field(\"key2\")\n}\nbuiltForm.getFields() // -> [Field(\"key1\"), Field(\"key2\")]\n```\n\nAs you can see Type-Safe builders are an **extremely powerful** and useful feature of Kotlin and they allow you to write very complex DSLs with a **really readable and clear syntax**. They give you a lot of **flexibility** letting you combine multiple builders to create a domain language that can meet your requirements.\n\nIf you want to learn more about this subject check out the official [documentation](https://github.com/Kotlin/kotlinx.html) or, for example, [kotlinx](https://github.com/Kotlin/kotlinx.html), an official project from the Kotlin team that allows you to create HTML documents with a custom DSL entirely written with Type-safe builders.\n","author":"Giacomo Bresciani","date":"2017-02-08","type":"article","categories":["Kotlin"],"features":["highlightjs"],"description":"","filename":"","lang":"EN","enclosure":null},{"title":"JVMLS 2015 - Flexible Types in Kotlin","url":"https://www.youtube.com/watch?v=2IhT8HACc2E","body":"\n\n<iframe width=\"960\" height=\"480\" src=\"https://www.youtube.com/embed/2IhT8HACc2E\" frameborder=\"0\" allowfullscreen></iframe>\n\n","author":"Andrey Breslav","date":"2015-08-12","type":"video","categories":["Kotlin"],"features":["highlightjs"],"description":"","filename":"","lang":"EN","enclosure":null},{"title":"Kotlin: How to Make Your Java Code Base Cleaner and More Readable","url":"https://medium.com/@kford55/kotlin-why-i-feel-its-useful-in-a-java-only-code-base-206bdb37c79#.4jgdz27kr","body":"\nTLDR;\n\nKotlin is a JVM language developed by JetBrains that compiles to Java 6 Bytecode. It is interoperable with Java and allows you to work with both languages in the same project. It lets you take advantage of a lot of great features in a legacy code base, such as lambdas, filters and streams, null safety, and top class IDE support as well. [https://kotlinlang.org](https://kotlinlang.org/)\n\nThis post was inspired by Brent Watson’s ([@brent_watson](https://twitter.com/brent_watson)) presentation at the last New York Android Developers meetup at Facebook where he talked about changing the I/O schedule app into Kotlin. Although most of the talks and articles about Kotlin have been in an Android context, it can still be useful in a regular java environment.\n\nKotlin is a JVM Language built by JetBrains, the same people who make IntelliJ. It was unveiled in 2011 but really starting to pick up traction now, mainly from the Android community. This is for a couple of reasons, first is up until Android 7 you had to use Java 7. If you wanted to get some of the features of Java 8 you had to use third-party libraries such as Retrolambda. The other reason is that it’s a very small library, so you put very little pressure on the method count limit for being a single DEX app. (~65k public methods) Using Kotlin for Android lets you do things like lambdas, higher-order functions, streams and have null safety in your app.\n\nSo why am I writing about it when I work in mainly a non-mobile environment? Because it’s interesting to me and there are a lot of people who are using it within regular Java code as well!\n\nTo start let’s talk about tools. Without tools, languages or libraries overall are useless and won’t get used. Luckily for us! Kotlin was built by JetBrains. The good part about deciding to use Kotlin is that you can do it one file at a time. [Brent](https://twitter.com/brent_watson) talked about how they transitioned their Android app to Kotlin, and they started by converting Unit Tests to Kotlin and then with real source code. It’s very easy to start messing around and using Kotlin. The best part is you don’t have to do anything to convert these files! (Well maybe a little bit)\n\n\n![](https://d262ilb51hltx0.cloudfront.net/max/800/1*ETOr2IP8cjeHohYpi-zYHQ.png)\n\n_IntelliJ’s tool to convert Java files to Kotlin_\n\nCommand-Shift-A, Convert Java File to Kotlin File, and you’re done! It converts everything into working Kotlin code unless you’re using some libraries and frameworks then you’ll have to take a minute and mess around with some things. Either way, it’s still very quick and painless. Now it won’t create the most idiomatic Kotlin code, but it’s a start. And it’s the best place to really start learning Kotlin. Whenever you convert a file you’re able to go through with a full understanding of what the code does and start to learn how Kotlin handles different parts of your Java code.\n\nSo why would we want to even begin to use Kotlin instead of Java? Well, we get a lot of things free out of the box with Kotlin that can make our code a lot cleaner and easier to read. The first thing to recognize is that if you have a class that just has properties, like a class to represent a JSON object, Kotlin has what they call Data Classes. It generates getters/setters, hashCode, toString, and equals in the background and into bytecode. So a large class with a ton of boilerplate collapses to one line.\n\n```kotlin\ndata class User(val name: String, val age: Int)\n```\n\nI found that a lot of methods in classes can collapse to one line due to the null safety features in Kotlin.\n\nWe’ve all seen code like this in any Java code base\n\n```kotlin\nif (someObject != null && someObject.getSomeOtherObject() != null) {\n    String someString =   someObject.getSomeOtherObject().getSomeString();\n        if (someString != null) {\n            return someString;\n        }\n    return “”;\n}\n```\n\nJust so much unnecessary code which can get very confusing, especially when this is everywhere in your code base. In Kotlin it turns into this:\n\n```kotlin\nreturn someObject?.getSomeOtherObject()?.getSomeString() ?: \"\"\n```\n\nSo what we see here are a few things. To give some context you can set variables to either have a null option or not. So in this code sample we’re assuming that someObject can be null, and so can someOtherObject. The ? mark gives you a safe call, so if it is null it just returns null instead of blowing up with a NullPointerException. Now the ?: is called the elvis operator and if the expression on the left side is null, it returns whatever is on the right side. The two code snippets do exactly the same. So imagine going through a lot of the major classes you may have in your legacy Java apps and being able to cut the lines of code down by a huge amount? It would make things much easier to follow, read, and understand.\n\nThis is the major feature that I think is really useful and helpful as you basically eradicate Null Pointer Exceptions. The best part is that IntelliJ is smart enough to know if you are not making a safe call with something that is nullable, so you get compile time errors! Add this to the ability to write lambdas, streams and filters, OOP and functional paradigms... all in Java 6 bytecode! Most things I’ve seen show that it compiles in about the same time as Java, so you won’t see a major increase in compile or build times which is important with some of these big major applications.\n\nOverall as you can probably tell, I think Kotlin is a pretty cool new language that may allow a lot of people to transform some of their older code bases into more concise and easier to read code without much work at all and without the need for it to be all or nothing. Along with this, it’s not as huge of a paradigm shift as something like Scala, so it’s a lot easier to get a team who is new to Kotlin to start using it and understand it.\n\nI didn’t go through everything in the language, so definitely check out the docs and other links I’ll have below.\n\nUseful Links:\n\n* Kotlin Website: [https://kotlinlang.org/](https://kotlinlang.org/)\n* Kotlin Koans (Good interactive tutorial): [https://kotlinlang.org/docs/tutorials/koans.html](https://kotlinlang.org/docs/tutorials/koans.html)\n* Amazing talk by Jake Wharton on Kotlin (Android): [https://www.youtube.com/watch?v=A2LukgT2mKc](https://www.youtube.com/watch?v=A2LukgT2mKc)\n\nThank you! :)\n\n","author":"Kenneth Ford","date":"2016-10-27","type":"article","categories":["Kotlin"],"features":["highlightjs"],"description":"","filename":"","lang":"EN","enclosure":null},{"title":"Andrey Breslav: Kotlin Coroutines, JVMLS 2016","url":"https://www.youtube.com/watch?v=4W3ruTWUhpw","body":"\n\n<iframe width=\"960\" height=\"480\" src=\"https://www.youtube.com/embed/4W3ruTWUhpw\" frameborder=\"0\" allowfullscreen></iframe>\n\n","author":"Andrey Breslav","date":"2016-08-03","type":"video","categories":["Kotlin","Coroutines"],"features":["highlightjs"],"description":"","filename":"","lang":"EN","enclosure":null},{"title":"Spring Tips: the Kotlin Programming Language","url":"https://www.youtube.com/watch?v=90WRtrbRi0Y","body":"\n\nHi Spring fans! In this tip, we’ll quickly look at the Kotlin programming language and some very high-level things you need to know when building Spring Boot and Kotlin applications\n\n<iframe width=\"960\" height=\"480\" src=\"https://www.youtube.com/embed/90WRtrbRi0Y\" frameborder=\"0\" allowfullscreen></iframe>\n\n","author":"Josh Long","date":"2016-10-19","type":"video","categories":["Kotlin"],"features":["highlightjs"],"description":"","filename":"","lang":"EN","enclosure":null},{"title":"PaperParcel with Kotlin","url":"http://www.tutorialforandroid.com/2016/08/paperparcel-with-kotlin.html","body":"\nWhen I started to code in kotlin, one of the libraries that I found that was really useful is [PaperParcel](https://github.com/grandstaish/paperparcel). PaperParcel is a library that would generate Parcelable using annotation. The good thing about it, is that it will reduce the amount of code and mistake you could make if you manually create those classes. Having said that, the library is not purely for Kotlin and it could be used in Java Android project.  \n\nTo use it in kotlin  \nYou will need to add these to your app build gradle dependencies  \n\n```gradle\ncompile 'com.github.grandstaish.paperparcel:paperparcel:1.0.0-rc4'\ncompile 'com.github.grandstaish.paperparcel:paperparcel-kotlin:1.0.0-rc4'\nkapt 'com.github.grandstaish.paperparcel:compiler:1.0.0-rc4'\n```\n\nwhile still in that gradle file, add these before dependencies  \n\n```gradle\nkapt {\n    generateStubs = true\n}\nrepositories {\n    maven { url 'https://jitpack.io' }\n}\n```\n\nNow the fun part, this is taken from my app [Daily Picture Quotes](https://play.google.com/store/apps/details?id=com.monmonja.dailyPictureQuotes)  \n\n```kotlin\n@PaperParcel\ndata class QuoteImage(val id: String = \"\",\n                 val name: String = \"\",\n                 val text_quote: String = \"\",\n                 val url: String = \"\",\n                 val created: String = \"\",\n                 val cursor:String? = \"\") : PaperParcelable {\n    companion object {\n        @JvmField val CREATOR = PaperParcelable.Creator(QuoteImage::class.java)\n    }\n}\n```\n\nThats about it, you can use QuoteImage to pass around Activities or Fragment or use it with your custom class.  \n\nTwo things you have to remember is that your data class name must be supplied in PaperParcelable.Creator and every time you make changes to this data class (atleast for me) you have to do rebuild project.  \n\nIf this interest you then have a check on the [kotlin usage](https://github.com/grandstaish/paperparcel/wiki/Kotlin-Usage) section of their github page.  \n\nHope this helps :)  \n","author":"Almond Joseph Mendoza","date":"2016-08-10","type":"article","categories":["Kotlin","Android"],"features":["highlightjs"],"description":"","filename":"","lang":"EN","enclosure":null},{"title":"Redux for Android using Kotlin","url":"https://www.youtube.com/watch?v=BUAxqiGrKOc","body":"\n<iframe width=\"960\" height=\"480\" src=\"https://www.youtube.com/embed/BUAxqiGrKOc\" frameborder=\"0\" allowfullscreen></iframe>\n","author":"Nevin Chen","date":"2016-11-22","type":"video","categories":["Kotlin","Android"],"features":["highlightjs"],"description":"","filename":"","lang":"ZH","enclosure":null},{"title":"Kotlin 1.0 is finally released!","url":"https://programmingideaswithjake.wordpress.com/2016/02/22/kotlin-1-0-is-finally-released/","body":"\nLast week, there was a wonderful announcement: (see title of post)! No more milestones, betas, or release candidates required! Obviously, release candidates for later versions will be coming out, but now you don’t have to worry about them if you don’t want to.\n\nIf you’re like me and were waiting until release before trying to convince company management to consider Kotlin as a development option, now is the time to speak out!\n\nIn celebration of Kotlin’s proper release, I will be doing a short series of articles describing some of my favorite things about the language. Starting this weekend with a quick overview of smaller features that I don’t have a ton to say about. I’m calling it Kotlin Month, and I only slightly regret that the first one will be in one month while the others are in the next month :P\n\nAlso, you may notice that there’s now a page at the top pertaining to Kotlin articles. This won’t be much more useful than selecting the Kotlin tag from the tag cloud to the right, but it will at least stay there, even if Kotlin posts dwindle far enough to remove the tag from the cloud.\n","author":"Jacob Zimmerman","date":"2016-02-23","type":"article","categories":["Kotlin"],"features":["highlightjs"],"description":"","filename":"","lang":"EN","enclosure":null},{"title":"Scala vs Kotlin: Pimp my library","url":"https://blog.frankel.ch/scala-vs-kotlin/1/","body":"\nI’ve been introduced to the world of immutable data structures with the Scala programming language - to write I’ve been introduced to the <abbr title=\"Functional Programming\">FP</abbr> world would sound too presumptuous. Although I wouldn’t recommend its usage in my day-to-day projects, I’m still grateful to it for what I learned: my Java code is now definitely not the same because Scala made me aware of some failings in both the language **and** my coding practices.\n\nOn the other hand, I became recently much interested in [Kotlin](https://kotlinlang.org/), another language that tries to bridge between the Object-Oriented and Functional worlds. In this serie of articles, I’d like to compare some features of Scala and Kotlin and how each achieve it.\n\nIn this article, I’ll be tackling how both offer a way to improve the usage of _existing_ Java libraries.\n\n## Scala\n\nLet’s start with Scala, as it coined the term [Pimp My Library](http://www.artima.com/weblogs/viewpost.jsp?thread=179766) 10 years ago.\n\nScala’s approach is based on _conversion_. Consider a base type lacking the desired behavior. For example, Java’s `double` primitive type - mapped to Scala’s `scala.Double` type, is pretty limited.\n\nThe first step is to create a new type with said behavior. Therefore, Scala provides a `RichDouble` type to add some methods _e.g._ `isWhole()`.\n\nThe second step is to provide an _implicit_ function that converts from the base type to the improved type. The signature of such a function must follow the following rules:\n\n* Have a single parameter of the base type\n* Return the improved type\n* Be tagged `implicit`\n\nHere’s how the Scala library declares the `Double` to `RichDouble` conversion function:\n\n\n```scala\nprivate[scala] abstract class LowPriorityImplicits {\n    ...\n    implicit def doubleWrapper(x: Double) = new runtime.RichDouble(x)\n    ...\n}\n```\n\nAn alternative is to create an _implicit class_, which among other requirements must have a constructor with a single parameter of base type.\n\nThe final step step is to bring the conversion _in scope_. For conversion functions, it means importing the function in the class file where the conversion will be used. Note that in this particular case, the conversion function is part of the automatic imports (there’s no need to explicitly declare it).\n\nAt this point, if a function is not defined for a type, the compiler will look for an imported conversion function that transforms this type to a new type that provides this function. In that case, the type will be replaced with the conversion function.\n\n```kotlin\nval x = 45d\nval isWhole = x.isWhole // Double has no isWhole() function\n\n// But there's a conversion function in scope which transforms Double to RichDouble\n// And RichDouble has a isWhole() function\nval isWhole = doubleWrapper(x).isWhole\n```\n\n## Kotlin\n\nOne of the main reasons I’m cautious about using Scala is indeed the implicit part: it makes it much harder to reason about the code - just like <abbr title=\"Aspect-Oriented Programming\">AOP</abbr>. Homeopathic usage of AOP is a life saver, widespread usage is counter-productive.\n\nKotlin eschews implicitness: instead of conversions, it provides [extension methods](https://kotlinlang.org/docs/reference/extensions.html#extension-functions) (and properties).\n\nLet’s analyze how to add additional behavior to the `java.lang.Double` type.\n\nThe first step is to provide an extension function: it’s a normal function, but grafted to an existing type. To add the same `isWhole()` function as above, the syntax is the following:\n\n```kotlin\nfun Double.isWhole() = this == Math.floor(this) && !java.lang.Double.isInfinite(this)\n```\n\nAs for Scala, the second step is to bring this function in scope. As of Scala, it’s achieved through an import. If the previous function has been defined in any file of the `ch.frankel.blog` package:\n\n```kotlin\nimport ch.frankel.blog.isWhole\n\nval x = 45.0\nval isWhole = x.isWhole // Double has no isWhole() function\n\n// But there's an extension function in scope for isWhole()\nval isWhole = x == Math.floor(x) && !java.lang.Double.isInfinite(x)\n```\n\nNote that extension methods are resolved **statically**.\n\n> Extensions do not actually modify classes they extend. By defining an extension, you do not insert new members into a class, but merely make new functions callable with the dot-notation on instances of this class.\n> \n> We would like to emphasize that extension functions are dispatched statically, i.e. they are not virtual by receiver type. This means that the extension function being called is determined by the type of the expression on which the function is invoked, not by the type of the result of evaluating that expression at runtime.\n\n## Conclusion\n\nObviously, Scala has one more indirection level - the conversion. I let anyone decide whether this is a good or a bad thing. For me, it makes it harder to reason about the code.\n\nThe other gap is the packaging of the additional functions. While in Scala those are all attached to the enriched type and can be imported as a whole, they have to be imported one by one in Kotlin.\n\n","author":"Nicolas Fränkel","date":"2016-07-10","type":"article","categories":["Kotlin","Scala"],"features":["highlightjs"],"description":"","filename":"","lang":"EN","enclosure":null},{"title":"JMock and Kotlin","url":"http://www.oneeyedmen.com/jmock-and-kotlin.html","body":"\n[JMock](http://www.jmock.org/) may have lost the mocking war, but for the London crowd it's still the go-to mocking tool.\nIt turns out that a little Kotlin fairy-dust can make it even more expressive.\n\nIn [my last post](/mocks-v-approvals-tests-part2.html) we saw a pretty vanilla use of JMock. In fact there was *one* nice\nKotlin'ism, defining an extension method on Mockery. So where in Java we would write\n\n```java\nmockery.checking(new Expectations() { {\n    oneOf(progress).reset(2);\n    oneOf(indexer).createIndex();\n} })\n```\n\nin Kotlin, by defining\n\n```kotlin\nfun Mockery.expecting(block: MyExpectations.() -> Unit) {\n   this.checking(MyExpectations().apply(block))\n}\n```\n\nwe can write\n\n```kotlin\nmockery.expecting {\n    oneOf(progress).reset(2)\n    oneOf(indexer).createIndex()\n}\n```\n\nIn addition, in the name of more readable tests, I had added a subclass of Expectations\nto allow me to write, for example\n\n```kotlin\nmockery.expecting {\n   givenActiveJournalIds(\n       \"1\" to throwException(RuntimeException(\"oops\")),\n       \"2\" to returnValue(journal2))\n   }\n   ...\n```\n\nThis was achieved with\n\n```kotlin\nclass MyExpectations : Expectations() {\n   fun givenActiveJournalIds(vararg idResultPairs: Pair<String, Action>) {\n       allowing(journals).loadActiveIds()\n       will(returnValue(idResultPairs.map { it.first }))\n       idResultPairs.forEach { pair ->\n           allowing(journals).loadJournalWithArticles(pair.first, 99)\n           will(pair.second)\n       }\n   }\n}\n```\n\nwhich is tighter in Kotlin, but nothing that you couldn't do in Java.\n\nLooking at a one of the tests, this plugs together into something like\n\n```kotlin\n@Test fun reports_exceptions_and_continues() {\n   mockery.expecting {\n       val x = RuntimeException(\"oops\")\n\n       givenActiveJournalIds(\n           \"1\" to throwException(x),\n           \"2\" to returnValue(journal2))\n\n       oneOf(progress).reset(2)\n       oneOf(indexer).createIndex()\n\n       never(indexer).index(JournalJson(journal1))\n       oneOf(progress).exception(\"1\", x)\n\n       oneOf(indexer).index(JournalJson(journal2))\n       oneOf(progress).indexed(journal2)\n   }\n   refresher.refresh(journals, indexer, emptySet())\n}\n```\n\nThis isn't bad, but one of JMock's problems is that it doesn't differentiate between interactions\nthat are queries, and those that are operations. In this case the refresher queries the `journals`\nto find what needs to be indexed, then operates on the `indexer` to add them. Introducing\n`givenActiveJournalIds` gives a clue, but it would be nice to see the split more formally.\n\nWhat I'd like to see is\n\n```kotlin\n@Test fun reports_exceptions_and_continues() {\n    val x = RuntimeException(\"oops\")\n    mockery.given {\n        activeJournalIds(\n            \"1\" to throwException(x),\n            \"2\" to returnValue(journal2))\n    }.whenRunning {\n        refresher.refresh(journals, indexer, emptySet())\n    }.thenExpect {\n        oneOf(progress).reset(2)\n        oneOf(indexer).createIndex()\n\n        never(indexer).index(JournalJson(journal1))\n        oneOf(progress).exception(\"1\", x)\n\n        oneOf(indexer).index(JournalJson(journal2))\n        oneOf(progress).indexed(journal2)\n    }\n}\n```\n\nThis can be achieved through 2 extension methods and a little class -\n\n```kotlin\nfun Mockery.expecting(expectations: Expektations.() -> Unit): Mockery {\n    this.checking(Expektations().apply(expectations))\n    return this\n}\n\nfun Mockery.whenRunning(block: () -> Unit) = ThenClause(this, block)\n\nclass ThenClause(private val mockery: Mockery, private val block: () -> Unit) {\n    fun thenExpect(expectations: Expektations.() -> Unit) {\n        mockery.expecting(expectations)\n        block()\n        mockery.assertIsSatisfied()\n    }\n}\n```\n\nActually that trick [can be played in Java 8 too](https://github.com/dmcg/nowthen).\n\nIf you're really eagle-eyed, you may have noticed `Expektations` pop up in that example.\nThat's to support my final trick, an extension method on `Nothing`. Why?\n\nWell what if we wanted to simulate an exception in the indexing?\n\n```kotlin\n@Test fun `reports exceptions in indexing and continues`() {\n    val x = RuntimeException(\"oops\")\n    mockery.given {\n        activeJournalIds(\n            \"1\" to returnValue(journal1),\n            \"2\" to returnValue(journal2))\n    }.whenRunning {\n        refresher.refresh(journals, indexer, emptySet())\n        executor.runUntilIdle()\n    }.thenExpect {\n        oneOf(progress).reset(2)\n        oneOf(indexer).createIndex()\n\n        oneOf(indexer).index(JournalJson(journal1))\n        will(throwException(x))\n        oneOf(progress).exception(\"1\", x)\n\n        oneOf(indexer).index(JournalJson(journal2))\n        oneOf(progress).indexed(journal2)\n    }\n}\n```\n\nThat `will()` as a separate statement has always bothered me about JMock - it should\nbind to the previous statement, but can't because `indexer.index(...)` returns `Unit`\n(`void` in Java). In Kotlin we can define\n\n```kotlin\nclass Expektations: Expectations() {\n    fun Any?.will(action: Action) = super.will(action)\n    // fun Nothing.will(action: Action) = super.will(action) Update 2016-05-17 - looks like this isn't needed, as Unit extends Any\n}\n```\n\nand now within our expectation blocks we can write\n\n``` koklin\n{\n    oneOf(indexer).index(JournalJson(journal1)).will(throwException(x))\n    // or\n    allowing(journals).loadJournalWithArticles(\"1\", 99).will(returnValue(journal1))\n}\n```\n\nWith a bit of work I think that would allow a typed JMock `Action` so that you could only\n`returnValue` with the correct type, but I haven't pulled on that thread yet.\n\nThe final bonus marks in this post go for spotting\n\n```kotlin\n@Test fun `reports exceptions in indexing and continues`()\n```\n\nIgnoring the fact that it breaks [Prism](http://prismjs.com/)'s Kotlin highlighter, this hack was pointed out by\n[Nat Pryce](http://natpryce.com) - backticks allow spaces in method names, giving beautifully\nreadable specs in code and test runners.\n\n","author":"Duncan McGregor","date":"2016-05-01","type":"article","categories":["Unit Testing","Kotlin"],"features":["highlightjs"],"description":"","filename":"","lang":"EN","enclosure":null},{"title":"Android: Improving sign-in experience with Google Sign-In and SmartLock","url":"https://medium.com/@p.tournaris/android-improving-sign-in-experience-with-google-sign-in-and-smartlock-f0bfd789602a#.djgn5w44q","body":"","author":"Pavlos-Petros Tournaris","date":"2016-12-14","type":"article","categories":["Kotlin","Android"],"features":["highlightjs"],"description":"","filename":"","lang":"EN","enclosure":null},{"title":"Functions as Data","url":"http://cloudmark.github.io/Functions-As-Data/","body":"\n\n![Brain](http://cloudmark.github.io/images/func_as_data/brain.png)\n \n Programming languages have evolved largely through a series of abstractions; these abstractions mostly deal with control (e.g. functions) or data.  In the post, [Houses, Arrays and Higher Order Functions](http://cloudmark.github.io/Higher-Order-Functions-On-Arrays/), we have focused on the use of functions as control elements and have delved into the concept of higher order functions.  Today we will revisit functions and focus on their use as data elements.  Using functions to represent data might seem pretty counter intuitive at first but this blurred line between functions as control elements and functions as data elements is a powerful concept.  \n\n                \n# Sets\nIn order to illustrate how functions can be used as data elements we will create a Set library with the following operations: `union`, `intersection` and `difference`.  We will define a set using the characteristic function `T -> Boolean` i.e. a function which takes an element `T` as input and return a `true` or `false` depending on whether the element is contained within the set. Using classic OOP we can define a set as follows: \n\n\n```kotlin\nclass Set<T>(vararg values: T) {\n    var elements: List<T> = values.toList()\n    fun contains(element:T): Boolean = this.elements.contains(element)\n}\n```\n\nIn this case a set is defined as a class with a generic type `T`, we will use the underlying list data structure `elements` to implement the `contains` function.  We can use the OOP representation as follows: \n\n\n```kotlin\nval s1 = Set(1)\nval s2 = Set(2, 3, 4)\n```\n\nUsing functions as data elements we would implement a Set as follows: \n\n```kotlin\nfun <T>setOf(element: T): (T) -> Boolean  = { test -> element!!.equals(test) }\nfun <T>contains(set: (T)->Boolean, element: T): Boolean  = set(element)\n```\n\nThe function `setOf` is a _constructor_ function (as defined by SICP) which takes in an `element` and returns a higher order functions that implements the characteristic function `(T) -> Boolean`.  `contains` just delegates the test to the `setOf` higher order function by calling `set(element)`.  Some observant readers might have noticed that the class `Set` can ingest a number of values whilst the `setOf` function can only ingest one value.  Using the `union` operator (defined further on) we can extends the `setOf` function to accept a variable number of elements `T`.  \n\n```kotlin \nfun <T>setOf(vararg elements: T): (T) -> Boolean {\n    return elements.map { setOf(it) } .reduce { s, t -> union(s, t) }\n}\n```\n\n\nUsing the `setOf` function we can define the set `s1` and `s2` as follows: \n\n```kotlin\nval s1 = setOf(1)\nval s2 = setOf(2, 3, 4)\n```\n\nNote that even though the representation is completely different the end user consuming either library will not be exposed to the underlying details of our implementations (OOP vs Functions). To an end user (except for minor syntactic differences) these two Sets are not different from each another.  \n\n\n# Union\nNow that we have a means of representing a set, let us implement `union` in both representations.  In the OOP approach we would implement union as follows: \n\n```kotlin\nclass Set<T>(vararg values: T) {\n    fun union(other:Set<T>): Set<T> {\n        val unionSet = Set<T>()\n        val elements = ArrayList(this.elements)\n        elements.addAll(other.elements.filter { x -> !this.elements.contains(x) })\n        unionSet.elements = elements\n        return unionSet\n    }\n    ...\n}\n```\n\nIn this case we are using the backing data stucture `elements` to keep track of what is _in_ the set.  We can test this implementation as follows: \n\n\n```kotlin\nval s1 = Set(1)\nval s2 = Set(2, 3, 4)\nprintln(s1.union(s2).contains(1)) // -> true\nprintln(s1.union(s2).contains(2)) // -> true\nprintln(s1.union(s2).contains(3)) // -> true\nprintln(s1.union(s2).contains(4)) // -> true\nprintln(s1.union(s2).contains(5)) // -> false\nprintln(s1.union(s2).contains(0)) // -> false\n```\n\nUsing functions we get a much more pure definition (mathematically speaking):  \n\n\n```kotlin\nfun <T>union(s1: (T)->Boolean, s2: (T)->Boolean): (T)->Boolean = \n        {element -> s1(element) || s2(element) }\n```\n\nAn `element` is contained in the union of set `s1` and `s2` if the `element` is either in set `s1` or `s2`.  This is clearly represented by the line `element -> s1(element) || s2(element)`.  Don't be fooled by the fact that Kotlin does not support structural types, had the language supported structural types our definition would be a bit more concise: \n\n```kotlin\nfun <T>union(s1: Set<T>, s2: Set<T>):Set<T> = \n        {element -> s1(element) || s2(element) }\n```\n\nNeedless to say this is just semantic sugar; regular functions (with milk) will do just fine!  One would use the union operator as follows: \n\n```kotlin\nval s1 = setOf(1)\nval s2 = setOf(2, 3, 4)\nprintln(contains(union(s1, s2), 1)) // -> true\nprintln(contains(union(s1, s2), 2)) // -> true\nprintln(contains(union(s1, s2), 3)) // -> true\nprintln(contains(union(s1, s2), 4)) // -> true\nprintln(contains(union(s1, s2), 5)) // -> false\nprintln(contains(union(s1, s2), 0)) // -> false\n```\n\nNote again that the usage is very similar and an end user would find it hard to believe that the Set is implemented using functions.  \n\n# Intersection \nHaving defined `union`, `intersection` will only be one synaptic leap away.  Let's start off with the OOP version. \n\n```kotlin\nclass Set<T>(vararg values: T) {\n    fun intersection(other:Set<T>): Set<T> {\n        val intersectionSet= Set<T>()\n        val elements = ArrayList<T>()\n        elements.addAll(this.elements.filter { x -> other.contains(x) })\n        intersectionSet.elements = elements\n        return intersectionSet\n    }\n    ...\n}\n```\n\nOne would use the definition above as follows: \n\n```kotlin\nval s3 = Set(1, 2)\nval s4 = Set(2, 3, 4)\nprintln(s3.intersection(s4).contains(1)) // -> false\nprintln(s3.intersection(s4).contains(2)) // -> true\nprintln(s3.intersection(s4).contains(3)) // -> false\nprintln(s3.intersection(s4).contains(4)) // -> false\nprintln(s3.intersection(s4).contains(5)) // -> false\nprintln(s3.intersection(s4).contains(0)) // -> false\n```\n\nUsing functions, we would represent the intersection function as: \n\n```kotlin\nfun <T>intersection(s1: (T)->Boolean, s2: (T)->Boolean): (T)->Boolean = \n        { element-> s1(element) && s2(element) }\n```\n\nNote how close this function is to the original mathematical definition; an `element` is contained in the intersection of Set `s1` and `s2` if the `element` is contained in set `s1` and set `s2`, hence: \n\n```kotlin\nelement -> s1(element) && s2(element)\n```\n\nOne would use the above definition as follows: \n\n```kotlin\nval s3 = setOf(1, 2)\nval s4 = setOf(2, 3, 4)\nprintln(contains(intersection(s3, s4), 1)) // -> false\nprintln(contains(intersection(s3, s4), 2)) // -> true\nprintln(contains(intersection(s3, s4), 3)) // -> false\nprintln(contains(intersection(s3, s4), 4)) // -> false\nprintln(contains(intersection(s3, s4), 5)) // -> false\nprintln(contains(intersection(s3, s4), 0)) // -> false\n```\n\n\n# Difference \nFor completeness let us now implement `difference` in both representations.  In the OOP approach we would implement difference as follows: \n\n```kotlin\nclass Set<T>(vararg values: T) {\n    fun difference(other:Set<T>): Set<T> {\n        val differenceSet= Set<T>()\n        val elements = ArrayList<T>()\n        elements.addAll(this.elements.filter { x -> !other.contains(x) })\n        differenceSet.elements = elements\n        return differenceSet\n    }\n    ...\n}\n```\n\nUsing functions we can implement this using:\n\n```kotlin\nfun <T>difference(s1: (T)->Boolean, s2: (T)->Boolean): (T)->Boolean = \n        {element-> s1(element) && !s2(element) }\n```\n\n\n\n# Set of multiple elements \nBefore we conclude I would like to give an intuition for the function\n\n```kotlin\nfun <T>setOf(vararg elements: T): (T) -> Boolean {\n    return elements.map { setOf(it) } .reduce { s, t -> union(s, t) }\n}\n```\n\nSpecifically how we used `map` and `reduce` to create a _characteristic function_ which accepts multiple elements as follows:   \n\n```kotlin \nval s3 = setOf(2, 3, 4, 7)\n```\n\nWhat `elements.map { setOf(it) }` does is map all `elements` to a characteristic function, hence 2 becomes: \n\n```kotlin\ntest -> 2.equals(test)\n```\n\n3 becomes: \n\n```kotlin\ntest -> 3.equals(test)\n```\n\nand so on.  \n\nThe `reduce` function will combine the characteristic functions as follows: \n\n```kotlin\nunion (\n    union(\n        union(\n            {test -> 2.equals(test)}, \n            {test -> 3.equals(test)}\n        ), \n        {test -> 4.equals(test)}\n    ), \n    {test -> 7.equals(test)}\n)\n```\n\nEach `union` function creates a new characteristic function combining the underlying two characteristic functions.  For e.g. \n\n```kotlin\nunion(\n    {test -> 2.equals(test)}, \n    {test -> 3.equals(test)}\n)\n```\n\n\nwould create the following characteristic function: \n\n```kotlin\n{test -> \n    {test1 -> 2.equals(test1)}(test) || \n    {test2 -> 3.equals(test2)}(test)\n}\n```\n\nIf we want to test whether 2 is in the set union, we would reduce the characteristic function as follows: \n\n```kotlin\nunion({test -> 2.equals(test)}, {test -> 3.equals(test)})(2)\n{test -> \n    {test1 -> 2.equals(test1)}(test) || // 2 here is the element in the set s1 \n    {test2 -> 3.equals(test2)}(test)    // 3 here is the element in the set s2\n}(2) // 2 is the value to test.  \n```\n\nReplace all occurrences of `test` with the value 2, we obtain:  \n\n```\n{test1 -> 2.equals(test1)}(2) || {test2 -> 3.equals(test2)}(2)\n```\n\nReplace all occurrences of `test1` and `test2` with the value 2, we obtain:      \n\n```\n2.equals(2) || 3.equals(2)\ntrue\n```\n\nHence the characteristic function for the set union between `s1` and `s2` when applied to 2 has reduced to true, which is correct.    \n\n\n# Conclusion\nIn this post we have looked at how we can use functions as data elements.  Using functions as a data representation might feel unnatural at first but this blurred boundary between functions as elements of control and functions as elements of data is quite powerful.  I really hope that you find this technique useful.  Stay safe and keep hacking!\n\n  \n\n","author":"Mark Galea","date":"2016-10-19","type":"article","categories":["Kotlin"],"features":["highlightjs"],"description":"","filename":"","lang":"EN","enclosure":null},{"title":"The Road to Gradle Script Kotlin 1.0","url":"https://blog.gradle.org/kotlin-scripting-update","body":"\nFive months ago we [announced the first pre-release of Gradle Script Kotlin](/kotlin-meets-gradle), and we thought now would be a good time to review the progress we’ve made since. We have shipped eight additional pre-releases during that time, and the road to 1.0 is looking clearer every day. So let’s take a look at the ground we’ve covered so far and where we’re going from here, shall we?\n\n## v0.1.0\n\nAs you may recall, this is what our [`hello-world` sample](https://github.com/gradle/gradle-script-kotlin/blob/cc14d3/samples/hello-world/build.gradle.kts) looked like at the time of our first release:\n\n```kotlin\nimport org.gradle.api.plugins.*\nimport org.gradle.script.lang.kotlin.*\n\napply<ApplicationPlugin>()\n\nconfigure<ApplicationPluginConvention> {\n    mainClassName = \"samples.HelloWorld\"\n}\n\nrepositories {\n    jcenter()\n}\n\ndependencies {\n    \"testCompile\"(\"junit:junit:4.12\")\n}\n```\n\nOh, that annoying `org.gradle.script.lang.kotlin.*` import! The publicly condemned, IDE unfriendly, string-based `\"testCompile\"` dependency configuration! And of course—for those souls brave enough to have tried them—the infamous `generateKtsConfig` and `patchIdeaConfig` tasks required to get Kotlin-based build scripts working in IDEA. These were early days, no doubt, and they brought with them a few rough edges.\n\nBut despite its flaws, the programming language and IDE experience in 0.1.0 was already so good it got us hooked. As for the rough edges, we could already see ways to smooth them out, which led to the release of [0.2.0](https://github.com/gradle/gradle-script-kotlin/releases/tag/v0.2.0) one month later.\n\n## v0.2.0\n\nWith [implicit imports](https://github.com/gradle/gradle-script-kotlin/issues/33) and a [tooling-friendly alternative to string-based dependency configurations](https://github.com/gradle/gradle-script-kotlin/issues/36), `hello-world` 0.2.0 started looking clean and concise:\n\n```kotlin\napply<ApplicationPlugin>()\n\nconfigure<ApplicationPluginConvention> {\n    mainClassName = \"samples.HelloWorld\"\n}\n\nrepositories {\n    jcenter()\n}\n\ndependencies {\n    testCompile(\"junit:junit:4.12\")\n}\n```\n\n[Seamless project imports](https://github.com/gradle/gradle-script-kotlin/issues/26) meant that Kotlin-based builds in IDEA started working out of the box, and the days of mistyping `generateKtsConfig` and `patchIdeaConfig` were no more.\n\nPerhaps most importantly, 0.2.0’s [support for build script dependencies and external plugins](https://github.com/gradle/gradle-script-kotlin/issues/29) made Gradle Script Kotlin a viable choice for many real-world projects.\n\n## v0.3.0\n\n[0.3.0](https://github.com/gradle/gradle-script-kotlin/releases/tag/v0.3.0) was a major milestone for the project, as it was the first version to be included in a production Gradle distribution—[Gradle 3.0](https://github.com/gradle/gradle/releases/tag/v3.0.0), no less!\n\nAnd 0.3.0 was all about that [Kotlin](https://kotlin.link/)! The [new Kotlin 1.1-M01 compiler](https://blog.jetbrains.com/kotlin/2016/07/first-glimpse-of-kotlin-1-1-coroutines-type-aliases-and-more/), support for [Kotlin-based plugins](https://github.com/gradle/gradle-script-kotlin/issues/84) and [`buildSrc` directories](https://github.com/gradle/gradle-script-kotlin/issues/86) plus some sugary [Kotlin-Groovy interoperability](https://github.com/gradle/gradle-script-kotlin/issues/103) primitives:\n\n```kotlinnp\ngradle.buildFinished(closureOf<BuildResult> {\n    println(\"$action finished\") // $action refers to BuildResult.getAction()\n})\n```\n\nWith Gradle 3.0 out the door, the #gradle channel of the public [Kotlin Slack](http://kotlinslackin.herokuapp.com/) saw an increase in participation which helped us greatly in prioritizing the work that would come next.\n\n## v0.3.1\n\nWe noticed people struggling with the lack of a more type-safe and IDE-friendly way of configuring dependencies, so [0.3.1](https://github.com/gradle/gradle-script-kotlin/releases/tag/v0.3.1) came with a [much-improved dependencies DSL](https://github.com/gradle/gradle-script-kotlin/issues/107):\n\n```kotlin\ndependencies {\n\n    default(group = \"org.gradle\", name = \"foo\", version = \"1.0\") {\n        isForce = true\n    }\n\n    compile(group = \"org.gradle\", name = \"bar\") {\n        exclude(module = \"foo\")\n    }\n\n    runtime(\"org.gradle:baz:1.0-SNAPSHOT\") {\n        isChanging = true\n        isTransitive = false\n    }\n\n    testCompile(group = \"junit\", name = \"junit\")\n\n    testRuntime(project(path = \":core\")) {\n        exclude(group = \"org.gradle\")\n    }\n}\n```\n\nThe [upgrade to Kotlin 1.1-dev-2053](https://github.com/gradle/gradle-script-kotlin/issues/108) notably enhanced the performance of code assistance within IDEA and thanks to a [valuable member of the community](https://github.com/tyvsmith) the first Gradle Script Kotlin [Android sample](https://github.com/gradle/gradle-script-kotlin/tree/96b6fe/samples/hello-android) was published.\n\n## v0.3.2\n\nWith [0.3.2](https://github.com/gradle/gradle-script-kotlin/releases/tag/v0.3.2) we decided to tackle [the dreaded `it` problem](https://www.youtube.com/watch?v=vv4zh_oPBTw&feature=youtu.be&t=1387) head-on via [runtime code generation of Kotlin extensions](https://github.com/gradle/gradle-script-kotlin/issues/117). What is the dreaded `it` problem? Take the use of [`copySpec`](https://docs.gradle.org/3.1/javadoc/org/gradle/api/Project.html#copySpec(org.gradle.api.Action)) as an example. Prior to 0.3.2, one would have written:\n\n```kotlin\ncopySpec {\n    it.from(\"src/data\")\n    it.include(\"*.properties\")\n}\n```\n\nThis syntax didn’t read very well, and was a departure from the fluid, readable DSL Gradle has long been known for. But never fear—with 0.3.2 `it` was gone:\n\n```kotlin\ncopySpec {\n    from(\"src/data\")\n    include(\"*.properties\")\n}\n```\n\n## v0.3.3 and v0.4.0\n\nThe recently-released versions [0.3.3](https://github.com/gradle/gradle-script-kotlin/releases/tag/v0.3.3) and [0.4.0](https://github.com/gradle/gradle-script-kotlin/releases/tag/v0.4.0) shipped the [first](https://github.com/gradle/gradle-script-kotlin/issues/137) of a series of improvements to [multi-project builds](https://github.com/gradle/gradle-script-kotlin/issues/112) including the ability to [define custom build logic using Kotlin in `buildSrc`](https://github.com/gradle/gradle-script-kotlin/blob/7c74044cd84c4c426f1bca9af9f48bf332620c73/samples/multi-project-with-buildSrc/README.md).\n\n[0.4.0](https://github.com/gradle/gradle-script-kotlin/releases/tag/v0.4.0) is available now and will ship with the forthcoming Gradle 3.2 distribution.\n\n## Toward v1.0.0\n\nWhat’s next, you ask? Here are some of the highlights of our upcoming releases in three key areas:\n\n1.  [Performance](https://github.com/gradle/gradle-script-kotlin/issues/160): Faster project configuration via caching of compiled build scripts ([#31](https://github.com/gradle/gradle-script-kotlin/issues/31)).\n2.  [Usability](https://github.com/gradle/gradle-script-kotlin/issues/54): Type-safe accessors for extensions and conventions contributed by plugins ([#159](https://github.com/gradle/gradle-script-kotlin/issues/159)); Comprehensive documentation ([#106](https://github.com/gradle/gradle-script-kotlin/issues/106)).\n3.  [Convenience](https://github.com/gradle/gradle-script-kotlin/issues/30): Declarative and tooling-friendly application of plugins, a.k.a., the `plugins` block ([#168](https://github.com/gradle/gradle-script-kotlin/issues/168)).\n\nAltogether, here’s how we envision the `hello-world` sample will look in Gradle Script Kotlin 1.0:\n\n```kotlin\nplugins {\n    application\n}\n\napplication {\n    mainClassName = \"samples.HelloWorld\"\n}\n\nrepositories {\n    jcenter()\n}\n\ndependencies {\n    testCompile(\"junit:junit:4.12\")\n}\n```\n\nHow does that look to you? We’d love to hear what you think.\n\nA big thanks to everyone that’s been along for the ride so far, and if you’re just getting started with Gradle Script Kotlin, welcome!\n\n","author":"Rodrigo B. de Oliveira","date":"2016-10-26","type":"article","categories":["Kotlin","Gradle"],"features":["highlightjs"],"description":"","filename":"","lang":"EN","enclosure":null},{"title":"Playing with Spring Boot, Vaadin and Kotlin","url":"https://blog.frankel.ch/playing-with-spring-boot-vaadin-and-kotlin","body":"\nIt’s no mystery that I’m a fan of both Spring Boot and Vaadin. When the [Spring Boot Vaadin add-on](https://github.com/vaadin/spring) became <abbr title=\"General Availability\">GA</abbr>, I was ecstatic. Lately, I became interested in [Kotlin](https://kotlinlang.org/), a JVM-based language offered by JetBrains. Thus, I wanted to check how I could develop a small Spring Boot Vaadin demo app in Kotlin – and learn something in the process. Here are my discoveries, in no particular order.\n\n### Spring needs non-final stuff\n\nIt seems Spring needs `@Configuration` classes and `@Bean` methods to be non-final. As my previous Spring projects were in Java, I never became aware of that because I never use the `final` keyword. However, Kotlin classes and methods are final _by default_: hence, you have to use the open keyword in Kotlin.\n\n```kotlin\n@Configuration\nopen class AppConfiguration {\n    @Bean\n    @UIScope\n    open fun mainScreen() = MainScreen()\n}\n```\n\n### No main class\n\nSpring Boot applications require a class with a `public static void main(String... args)` method to reference a class annotated with `@SpringBootApplication`. In general, those two classes are the same.\n\nKotlin has no concept of such static methods, but offers pure functions and objects. I tried to be creative by having an annotated object referenced by a pure function, both in the same file.\n\n```kotlin\n@SpringBootApplication\nopen class BootVaadinKotlinDemoApplication\n\nfun main(vararg args: String) {\n    SpringApplication.run(arrayOf(BootVaadinKotlinDemoApplication::class.java), args)\n}\n```\n\n### Different entry-point reference\n\nSince the main function is not attached to a class, there’s no main class to reference to launch inside the IDE. Yet, Kotlin creates a .class with the same name as the file name suffixed with `Kt`.\n\nMy file is named `BootVaadinKotlinDemoApplication.kt`, hence the generated class name is `BootVaadinKotlinDemoApplicationKt.class`. This is the class to reference to launch the application in the IDE. Note that there’s no need to bother about that when using `mvn spring-boot:run` on the command-line, as Spring Boot seems to scan for the main method.\n\n### Short and readable bean definition\n\nJava syntax is seen as verbose. I don’t think it’s a big issue when its redundancy is very low compared to the amount of useful code. However, in some cases, even I have to admit it’s a lot of ceremony for not much. When of such case is defining beans with the Java syntax:\n\n```kotlin\n@Bean @UIScope\npublic MainScreen mainScreen() {\n    return new MainScreen();\n}\n```\n\nKotlin cuts through all of the ceremony to keep only the meat:\n\n* No semicolon required\n* No new keyword\n* Block replaced with an equal sign since the body consists of a single expression\n* No return keyword required as there’s no block\n* No return type required as it can easily be inferred\n\n```kotlin\n@Bean @UIScope\nfun mainScreen() = MainScreen()\n```\n\nSpring configuration files are generally quite long and hard to read. Kotlin makes them much shorter, without sacrificing readability.\n\n### The init block is your friend\n\nIn Java, the constructor is used for different operations:\n\n1.  storing arguments into attributes\n2.  passing arguments to the super constructor\n3.  other initialization code\n\nThe first operation is a no-brainer because attributes are part of the class signature in Kotlin. Likewise, calling the super constructor is handled by the class signature. The rest of the initialization code is not part of the class signature and should be part of an `init` block. Most applications do not this part, but Vaadin needs to setup layout and related stuff.\n\n```kotlin\nclass MainScreenPresenter(tablePresenter: TablePresenter,\n                          buttonPresenter: NotificationButtonPresenter,\n                          view: MainScreen, eventBus: EventBus) : Presenter<MainScreen>(view, eventBus) {\n\n    init {\n        view.setComponents(tablePresenter.view, buttonPresenter.view)\n    }\n}\n```\n\n### Use the apply method\n\nKotlin has a standard library offering small dedicated functions. One of them is apply, defined as `inline fun T.apply(f: T.() -> Unit): T (source)`. It’s an extension function, meaning every type will have it as soon as it’s imported into scope. This function requires an argument that is a function and that returns nothing. Inside this function, the object that has been apply-ed is accessible as `this` (and `this` is implicit, as in standard Java code). It allows code like this:\n\n```kotlin\nVerticalLayout(button, table).apply {\n    setSpacing(true)\n    setMargin(true)\n    setSizeFull()\n}\n```\n\n### Factor view and presenter into same file\n\nKotlin makes code extremely small, thus some files might be only a line long (not counting import). Opening different files to check related classes is useless. Packages are a way to organize your code; I think files might be another way in Kotlin. For example, Vaadin views and presenters can be put into the same file.\n\n```kotlin\nclass NotificationButton: Button(\"Click me\")\n\nclass NotificationButtonPresenter(view: NotificationButton, eventBus: EventBus): Presenter<NotificationButton>(view, eventBus) { ... }\n\n```\n\n### Lambdas make great listeners\n\nAs of Java 8, single-method interfaces implemented as anonymous inner classes can be replaced with lambdas. Kotlin offers the same feature plus:\n\n* it allows to omit parentheses if the lambda is the only argument\n* if the lambda has a single argument, its default name is `it` and it doesn’t need to be declared\n\nBoth make for a very readable syntax when used in conjunction with the Vaadin API:\n\n```kotlin\nview.addValueChangeListener {\n    val rowId = it.property.value\n    val rowItem = view.containerDataSource.getItem(rowId)\n    eventBus.publish(SESSION, rowItem)\n}\n```\n\nNote: still, more complex logic should be put into its [own function](https://morevaadin.com/content/lambdas-java-8/).\n\n","author":"Nicolas Frankel","date":"2016-01-10","type":"article","categories":["Kotlin","Spring","Vaadin"],"features":["highlightjs"],"description":"","filename":"","lang":"EN","enclosure":null},{"title":"The Design and Construction of Modern Build Tools","url":"http://www.javamagazine.mozaicreader.com/JanFeb2017","body":"\nA look inside a modern JVM build tool—its architecture and implementation\n\nThe JVM has seen many build tools in the past 20 years. For Java alone, there’s been Ant, Maven, Gradle, Gant, and others, while in JVM languages, sbt is used for Scala, and Leiningen for Clojure. These tools are run by developers and by back-end systems multiple times a day, yet very little is formally documented about how they are implemented, what functionalities they do and should offer, and why.\n\nIn this article, I give an overview of what it takes to create a modern build tool, the kinds of functionality you should expect, and how that functionality is implemented in modern tools. These observations are derived from my experience building software for decades and also from an experimental build tool I am working on called [Kobalt](http://bit.ly/kobaltbuild), which performs builds for the JVM language Kotlin, [previously described](http://bit.ly/2hKDEji) in this magazine.\n\n## Motivation\n\nKobalt was born from my observation that while the Gradle tool was a clear step forward in versatility and expressive build file syntax, it also suffered from several shortcomings, some of them related to its reliance on Groovy. I therefore decided to create a build tool inspired by Gradle but based on Kotlin, JetBrains’ language.\n\nKobalt is not only written in Kotlin, its build files are also valid Kotlin programs with a thin DSL that will look familiar to seasoned Gradle users. (Note that the latest version of Gradle also adopted Kotlin for its build file syntax, and the Groovy build file is going to be phased out, thus validating the approach taken with Kobalt.)\n\nIn this article, I discuss general concepts of build files and demonstrate Kobalt’s take on that feature. For readers unfamiliar with Kotlin, you should be able to follow along because the syntax is similar enough to Java’s.\n\n## Morphology of a Build Tool\n\nThe vast variety of build tools available on the JVM and elsewhere share a common architecture and similar basic functionalities:\n* The user needs to create one (or more) build files describing the steps required to create an application. The syntax to describe these build files is extremely varied: from simple property files to valid programming language source files and everything in between.\n* The build tool parses this build file and turns it into a graph of tasks that need to be executed in a specific order.\n* The tool then executes these tasks in the required order. The tasks can either be coded inside the build tool or require the invocation of external processes. The build tool should allow for tasks to do pretty much anything.\n\nOne of the oldest build tools on the JVM is Ant, which broke from the previous standard, make, that was in use up until that point. Ant introduced XML as the language for build files, which was quite innovative at the time. Ant also came up with the concept of tasks that can be defined either in the XML file or as external tasks implemented in Java that the tool looks up. Even though Ant is still used in legacy software, it is largely considered deprecated today and looked at as the “assembly language” of build tools: very flexible, offering a decent plugin architecture, but a tool that requires a lot of boilerplate for even the simplest build projects.\n\nNow, let’s dive more specifically into what you should expect from your build tool.\n\n## Syntax\n\nLet’s start with the most visible aspect of a build tool: the syntax of its build file.\n\nObviously, I want my build tool to have a clean and intuitive syntax, but you’ll be hard-pressed to find a general consensus on what a “clean syntax” is, so I won’t even try to define it. I would also argue that sometimes syntax is not as important as the ease with which you can write and edit your build file. For example, Maven’s pom.xml file has a verbose syntax, but I’ve found that editing it is pretty easy when I use an editor that’s aware of this file’s schema.\n\nGradle’s popularity came in good part from the fact that the syntax of its build file was Groovy, which is much more concise than XML. My personal experience has been that Gradle’s build files are easy to read but hard to write, and I’ll come back to this point below, but overall, there is a general agreement that the Gradle syntax is a step in the right direction.\n\nWhat is more controversial is the question of whether a build file should be using a purely declarative syntax (for example, XML or JSON) or be a valid program in some programming language.\n\nMy experience has led me to conclude that I want the syntax to look declarative (because it’s sufficient for most of my build files) but that I also want the power of a full programming language should I need it. And I don’t want to be obliged to escape to some other language when I have such a requirement: the build file needs to use the same syntax. This observation came from my realization that I have often wanted to have access to the full power of object-oriented programming in my build files, so that I can create base-class tasks that I can specialize with a few variations here and there. For example, if my project creates several libraries, I want to compile all these libraries with the same flags, but the libraries need to have a different name and version. This kind of problem is trivially solved in object-oriented languages with inheritance and method overriding, so having this kind of flexibility in a build file is desirable.\n\nOn a more general level, complex projects are often made of modules that share a varying degree of common settings and behaviors. The more your build system avoids requiring you to repeat these settings in multiple locations or different files, the easier it will be to maintain and evolve your build.\n\nAll build tools offer, in varying degrees, to help you set up your modules, their dependencies, and their shared parameters. But I can’t say I have found one that makes this “inherit and specialize” aspect very intuitive—not even my own build tool. Maybe the solution is for modules to be represented by actual classes in the programming language of your build files so you can use the familiar “inherit and override” pattern to capture this reuse.\n\nIn the meantime, I think the approach of using a DSL that is a valid program and that offers you all the facilities of a programming language should you ever need them (`if`, `else`, `classes`, `inheritance`, `composition`, and so on) is a clear step in the right direction.\n\n## Dependencies\n\n\nThe #1 job of a build tool is to execute a sequence of tasks in a certain order and to take various actions if any of these tasks fail. It should come as no surprise that all the build tools I have come across (on the JVM or outside) allow you to define tasks and dependencies between these tasks. However, a lot of tools don’t adequately address project dependencies: how do you specify that project C can be built only once projects A and B have been built?\n\nWith Gradle, you need to manipulate multiple build.gradle files that, in turn, refer to multiple settings.gradle files. In this design, dependent modules need to be defined across multiple files with different roles (build.gradle and settings.gradle), which can make keeping track of these dependencies challenging.\n\nWhen I started working on Kobalt, I decided to take a more intuitive approach by making it possible to define multiple projects in one build file, thereby making the dependency tree much more obvious. Here is what this looks like:\n\n```kotlin\nval lib1 = project {\n    name = \"lib1\"\n    version = \"0.1\"\n}\n\nval lib2 = project {\n    name = \"lib2\"\n    version = \"0.1\"\n}\n\nval mainProject = project(lib1, lib2) {\n    name = \"mainProject\"\n    version = \"0.1\"\n}\n```\n\nThe project directive (which is an actual Kotlin function) can take dependent projects as parameters, and Kobalt will build its dependency tree based on that information. All the projects are then sorted topologically, which means the build order can be either “lib1, lib2, mainProject” or “lib2, lib1, mainProject”—both of which are valid.\n\nAlso, note that the previous example is a valid and complete build file (and the repetition can be abbreviated further, but I’m keeping things simple for now).\n\nBeing able to keep the project dependencies in one centralized place makes it much easier to understand and modify a build, even for a complex project. Using multiple build files in the subprojects’ own directories should still be an option, though.\n\n## Make Simple Builds Easy and Complex Builds Possible\n\nA direct consequence of the functionality described in the previous section is that the build tool should let you create build files that are as bare bones as possible.\n\n**Convention over configuration**. Most projects usually contain just one module and are pretty simple in nature, so the build tool should make such build files short, and it should implement as many sensible defaults as possible. Some of these defaults include those shown in Table 1.\n\n| NAME                      | NAME OF THE CURRENT DIRECTORY            |\n|---------------------------|------------------------------------------|\n| VERSION                   | “0.1”                                    |\n| LANGUAGE(S)               | AUTOMATICALLY DETECTED                   |\n| SOURCE DIRECTORIES        | src/main/java, src, src/main/{language}  |\n| MAIN RESOURCES            | src/main/resources                       |\n| TEST DIRECTORIES          | src/test/java, test, src/test/{language} |\n| TEST RESOURCES            | src/test/resources                       |\n| MAVEN REPOSITORIES        | MAVEN CENTRAL, JCENTER                   |\n| BINARY OUTPUT DIRECTORY   | {SOMEROOT}/classes                       |\n| ARTIFACT OUTPUT DIRECTORY |  {SOMEROOT}/libs                         |\n\n**Table 1.** *Sensible defaults for a Java-aware build tool*\n\nWith such defaults, the simplest build file for a project should literally be less than five lines long. And of course, the build tool could perform further analysis to do some additional guessing, such as inferring certain dependencies based\non the imports.\n\nComplex builds. Once you get past simple projects, the ability to easily modify a build is critical. Such modifications can be made statically (with simple changes to the build files) or dynamically (passing certain switches or values to the build run in order to alter certain settings). The latter operation is usually performed with profiles—values that trigger different actions in your build without having to modify your build file.\n\nMaven has native support for profiles, but Gradle relies on the extraction of environment values in Groovy to achieve a similar result, which reduces its flexibility. Profiles in Kobalt combine these two approaches with conditionals. You define profiles as regular Kotlin values, as shown here:\n\n```kotlin\nval experimental = false\nval premium = false\n```\n\nYou can use them in regular conditional statements anywhere in your build file, as shown in the following examples:\n\n\n```kotlin\nval p = project {\n    name = if (experimental) \"project-exp\"\n           else \"project\"\n    version = \"1.3\"\n    ...\n```\n\nProfiles can then be activated on the command line:\n\n```\n./kobaltw -profiles \\\n    experimental,premium assemble\n```\n\nThis is an area where having your build file written in a programming language really brings benefits, because you can insert profile-triggered operations anywhere that is legal in that programming language:\n\n```kotlin\ndependencies {\n    if (experimental)\n        \"com.squareup.okhttp:okhttp:2.5.0\"\n    else\n        \"com.squareup.okhttp:okhttp:2.4.0\"\n}\n```\n\nHere, `if (experimental)` refers to the profile specified on the command line.\n\n## Performance\n\nYou want your build tool to be as fast as possible, which means that the overhead it imposes should be minimal and most of the time building should be expended by the external tools invoked by the build. On top of this obvious requirement, the build tool should also support two important features needed for speed: incremental tasks and parallel builds.\n\n**Incremental tasks**. For the purposes of build tools, a task is incremental if it can detect all by itself whether it needs to run. This is usually determined by calculating whether the output of the current run would be the same as that of the previous run and returning right away if such is the case. Most build tools support incremental tasks to varying degrees, and you can test how well your build tool performs on that scale by running the same command twice in a row and see how much work the build tool performs during the second run.\n\n**Parallel builds.** In contrast to incremental tasks, few build tools support parallel builds. I suspect the reason has a lot more to do with hardware than software; the algorithms to run tasks in parallel in the correct order are well known (if you are curious, look up “topological sorting”), but until recently, running build tasks in parallel wasn’t really worth it and didn’t always result in faster builds because of a simple technological hurdle: mechanical hard drives.\n\nBuild tasks are typically very I/O intensive. They read and write a lot of data to the disk, and with mechanical hard drives, this results in a lot of “thrashing” (the head of the hard drive being moved to different locations of the hard drive in rapid succession). Because build tasks keep being swapped in and out by the scheduler, the hard drive must move its head a lot, which results in slow I/O.\n\nThe situation has changed these past few years with the emergence of solid-state drives, which are much faster at handling this kind of I/O. As a consequence, modern build tools should not only support parallel builds but actually make them the default.\n\nFor example, Figure 1 is a diagram showing the multiple modules and their dependencies in the ktor project, a Kotlin web server.\n\nFrom this diagram, you can see that the core module needs to be built first. Once this is done, several modules can then be built in parallel, such as locations and features (as they both depend on core , but not on each other). As more modules are built, additional modules are scheduled to be built based on the dependency graph in Figure 1.\n\n![Figure 1.](http://i.imgur.com/Dfm29uL.png)\n\n**Figure 1.** *The dependencies in the ktor project*\n\nThe gain in build time with parallel build can be significant. For example, a recent build that was timed at 68 seconds in parallel required 260 seconds in a sequential build—effectively, a 4x differential.\n\n\n## Plugin Architecture\n\n> These days, nobody has time to go to a website, download a package, and manually install it. Build tools should be no exception, and they should self-update.\n\nNo matter how extensive the build tool is, it will never be able to address all the potential scenarios that developers encounter every day, so it also needs to be expandable. This is traditionally achieved by exposing a plug­in architecture that developers can use to extend the tool and have it perform tasks it wasn’t originally designed for. A build tool’s usefulness is directly correlated to the health and size of its plugin ecosystem.\n\nInterestingly, while OSGi is a respectable and well-specified architecture for plugin APIs, I don’t know of any build tool that uses it. Instead, build tools tend to invent their own plugin architecture, which is unfortunate.\n\nThis topic would require an entire book chapter of its own, so I’ll just mention that there are basically two approaches to plugin architecture. The first one is to give plugins full access to the internal structure of your tool, which is the approach adopted by Gradle (driven and facilitated by Gradle’s Groovy foundation).\n\nIn contrast, the Eclipse and IntelliJ IDEA development environments and Kobalt expose documented endpoints that plugins can connect to and use in order to observe and modify values in an environment that the build tool completely controls. I prefer this approach because it’s statically verifiable and much easier to document and maintain.\n\n## Package Management\n\nOn top of being a very versatile and innovative build system, Maven introduced what will most likely be a legacy that will far outlast it: the repository. I’m pretty sure that even if Maven becomes outdated and no longer used, we’ll still be referencing and downloading packages from the various Maven repositories that are available today.\n\nGiven the popularity of these repositories, a modern build tool should do the following:\n\n* Transparently support the automatic downloading of dependencies from these repositories (Maven, Gradle, and Kobalt all do this; Ant requires an additional tool).\n* Make it as easy as possible to make my projects available on these repositories. Maven and Gradle require plugins and quite a bit of boilerplate in your build file; Kobalt natively supports such uploads.\n\n## Auto-Completion in Your IDE\n\nDevelopers spend several hours every day in their IDE, so it stands to reason that they would expect all the facilities offered by their IDE to be available when they edit a build file. Build tools have been moderately successful at this, frequently offering partial syntactical support.\n\nInterestingly, Maven with its POM file has always been very well supported in IDEs because of its reliance on an XML format that’s fully described in an XML schema. The file is verbose, but auto-completion is readily available and reliable, and Maven’s schema is a very good example of how to define a proper XML file with very strict rules (for example, no attributes are ever used, so there’s never any hesitation about how to enter the data).\n\nThe more modern Gradle has been less successful in that area because of its reliance on Groovy and the fact that this language is dynamically typed. Kobalt’s reliance on Kotlin for its build file enables auto-completion to work in IntelliJ IDEA, without requiring any special efforts. Obviously, the upcoming Kotlin-based Gradle will enable similar levels of autocompletion as well.\n\n## Self-Updating\n\nThese days, nobody has time to go to a website, download a package, and manually install it. Build tools should be no exception, and they should self-update (or, at least, make it easy for you to update the tool). If the tool is available on a standard package manager on your system (brew, dpkg, and so on), great. But it should also be able to update itself so that such updates can be uniform across multiple operating systems. However, the tool itself is not the only part of your build that you want to keep updated. Dependencies are very important as well, and your build tool should help you stay current with these by informing you when new releases of dependencies are available.\n\n## Conclusion\n\nSoftware built in 2016 is much more complex than it was 20 years ago, and it’s important to hold our tools to a high standard. Libraries, IDEs, and design patterns are only a few components that need to adapt and improve as our software needs increase. Build tools are no exception, and we should be as demanding of them as we are of every other type of tool we use.\n\nCédric Beust ([@cbeust](https://twitter.com/cbeust)) has been writing Java code since 1996, and he has taken an active role in the development of the language and its libraries through the years. He holds a PhD in computer science from the University of Nice, France. Beust was a member of the expert group that designed annotations for the JVM.\n\n","author":"Cédric Beust","date":"2017-02-03","type":"article","categories":["Kotlin","Kobalt"],"features":["highlightjs"],"description":"","filename":"","lang":"EN","enclosure":null},{"title":"Kotlin + Android","url":"https://speakerdeck.com/dmytrodanylyk/kotlin-plus-android","body":"\n[Slides](https://speakerdeck.com/dmytrodanylyk/kotlin-plus-android)\n","author":"Dmytro Danylyk","date":"2016-04-21","type":"slides","categories":["Kotlin","Android"],"features":["highlightjs"],"description":"","filename":"","lang":"EN","enclosure":null},{"title":"Setting up Kotlin with Android and tests","url":"http://engineering.pivotal.io/post/setting-up-kotlin-with-android-and-tests/","body":"\n\nI recently heard about [Kotlin](https://kotlinlang.org/) with the release of their 1.0 Beta last week. Kotlin is a modern programming language that runs in the JVM and is interoperable with Java. Kotlin can also be used to create Android apps.\n\nI was curious, so I decided to set up a small Android app using Kotlin and try out some different methods of testing.\n\n## Setting up the app\nSetting up a hello word Android app in Kotlin was actually quite easy!  The Kotlin plugin for IntelliJ / Android Studo has a tool for converting your Java code to Kotlin, so you can get started really quickly! I was able to follow this [tutorial](https://kotlinlang.org/docs/tutorials/kotlin-android.html) to get my Android app set up.\n\nTwo points to watch out for:\n\n 1. Make sure you have installed the Kotlin plugins in Android Studio before you start\n\n 1. I had to highlight the text of my java file before selecting \"Convert Java File to Kotlin File\" in order to get the converter to work.\n\n## Android instrumentation tests\nI started by writing a simple Android Instrumentation test in Java (you can freely mix Java files and Kotlin files in your project and it seems to work fine).  Once that was working, I converted it to Kotlin:\n\n```kotlin\nclass MainActivityTest : ActivityInstrumentationTestCase2<MainActivity>(MainActivity::class.java) {\n   private var mainActivity: Activity? = null\n\n   @Throws(Exception::class)\n   override fun setUp() {\n       super.setUp()\n       mainActivity = activity\n   }\n\n   fun test_itDisplaysHelloWorld() {\n       val textView = mainActivity!!.findViewById(R.id.main_text) as TextView\n       val actual = textView.text.toString()\n       Assert.assertEquals(\"Hello World!\", actual)\n   }\n}\n```\n\nThe only trouble I had was that after I converted the file, the Android Studio test runner configuration was broken.  To fix it I had to edit my run configuration in Android Studio by navigating to `Run -> Edit Configurations -> Android Tests` and setting the instrumentation runner to `android.test.InstrumentationTestRunner`.  After that, lo and behold, the test worked fine in Kotlin!\n\n## Robolectric tests\nAfter my resounding success at getting the Android Instrumentation Tests to work, I decided to try my luck at Robolectric.  It turns out, Robolectric pretty much Just Worked too.  Here's a Robolectric test written in Kotlin, equivalent to the instrumentation test above:\n\n```kotlin\n@RunWith(RobolectricGradleTestRunner::class)\n@Config(constants = BuildConfig::class)\nclass ExampleRobolectricTest {\n\n    @Test\n    fun itShouldDisplayHelloWorld() {\n        val activity = Robolectric.setupActivity(MainActivity::class.java)\n        val textView = activity.findViewById(R.id.main_text) as TextView\n\n        assertThat(textView.text).isEqualTo(\"Hello World!\")\n    }\n}\n```\n\n## Unit tests with Spek\n[Spek](https://jetbrains.github.io/spek/) is a testing framwork written in Kotlin with a pretty, rspec-like syntax. I would love to be able to write my Android tests using something like Spek, so I decided to try!\n### Bad news #1: Android Instrumentation tests + Spek\nSpek requires your tests to inherit from a base class called `Spek`.  Android instrumentation tests require your tests to inherit from `InstrumentationTestCase`.  As far as I can tell, this is a deal-breaker for using the two systems together, for the moment.\n\n### Bad news #2: Robolectric tests + Spek\nRobolectric doesn't specifically require your tests to inherit from any particular class, which theoretically opens the door to using it together with Spek.  However, naively combining them doesn't work as expected, as the test runner cannot find any tests.  I think the reason for this is that Robolectric relies on using the RobolectricTestRunner, which extends the `BlockJUnit4ClassRunner` (which identifies tests based on annotations), while Spek runs with it's own `JUnitClassRunner`.\n\nIn the future I may look into writing a RobolectricSpek test runner, but for now, it looks like these two systems do not play nicely together.\n\n### Finally, the good news\nAlthough Spek does not seem to be compatible with either Robolectric or Android instrumentation tests, it actually works fine as a replacement for vanilla JUnit tests.  I think this kind of test is of dubious utility in a typical Android project, since there's usually not a lot of code that can be tested purely with JUnit, but if you have these kinds of tests, you could easily convert them to use Spek.  Here's a sample test I wrote in my hello world app:\n\n```kotlin\nimport org.jetbrains.spek.api.Spek\nimport kotlin.test.assertEquals\n\nclass ExampleUnitTest : Spek() {\n    init {\n        given(\"Two numbers\") {\n            val firstNumber = 3\n            val secondNumber = 5\n            on(\"adding the numbers\") {\n                val result = firstNumber + secondNumber\n                it(\"should return the correct sum\") {\n                    assertEquals(8, result)\n                }\n            }\n        }\n    }\n}\n```\n\n## Conclusion\nKotlin seems like a promising new language with a lot of features that make it nicer to use than Java.  Setting up a \"Hello World\" Android app was extremely simple, and getting tests to run with Robolectric or the Android instrumentation runner was no problem.  I look forward to trying it out more in the future!\n\n","author":"Laura Kogler","date":"2015-11-11","type":"article","categories":["Kotlin","Android"],"features":["highlightjs"],"description":"","filename":"","lang":"EN","enclosure":null},{"title":"Kotlin 1.0.3 Is Here!","url":"https://blog.jetbrains.com/kotlin/2016/06/kotlin-1-0-3-is-here/","body":"\nWe are delighted to present **Kotlin 1.0.3**. This update is not full of brand new and shiny features, it is more about bug fixes, tooling improvements and performance boosts. That’s why you’ll like it ![\uD83D\uDE09](https://s.w.org/images/core/emoji/72x72/1f609.png) Take a look at the full [change log](https://github.com/JetBrains/kotlin/blob/1.0.3/ChangeLog.md) and issues stats by subsystem:\n\n![Kotlin 1.0.3. Fixed issues](https://d3nmt5vlzunoa1.cloudfront.net/kotlin/files/2016/06/Pasted-image-at-2016_06_28-07_25-PM.png)  \n\nSpecifically we want to express our gratitude to our contributors whose commits are included in 1.0.3 namely [Yaroslav Ulanovych](https://github.com/yarulan), [Jake Wharton](https://github.com/JakeWharton) and [Kirill Rakhman](https://github.com/cypressious). Kirill has done more than a dozen improvements to formatter and submitted 20+ commits — great job, Kirill, we really appreciate it. Here we also want to thank each and every one of our EAP users who tested and provided their priceless feedback on 1.0.3 prerelease builds.\n\nAlthough this update is not feature-rich, there are several important improvements and features which are worth highlighting here:\n\n## What’s new in the compiler:\n\n* New option `-jdk-home` to specify the JDK against which the code is compiled\n* Options to specify Kotlin language version (`-language-version`) and target Java version (`-jvm-target`) (will have effect in 1.1, added now for forward compatibility)\n* More efficient bytecode (no more iterator in `indices` loop, avoid unnecessary operations with `Unit`)\n* Various improvements to diagnostic messages\n\n## What’s new in the IDE:\n\n* Autosuggestion for Java to Kotlin conversion for Java code copied from browser and other sources outside of the IDE\n  ![](https://d3nmt5vlzunoa1.cloudfront.net/kotlin/files/2016/06/copypaste.gif)\n* Language injection for strings passed to parameters annotated with @Language. Also predefined Java injections applied in Kotlin code. Read more about using language injections in the [documentation](https://www.jetbrains.com/help/idea/2016.1/using-language-injections.html)\n  ![](https://d3nmt5vlzunoa1.cloudfront.net/kotlin/files/2016/06/inject.gif)\n\n* Completion now always shows non-imported classes and methods and adds imports automatically when they are selected\n  ![](https://d3nmt5vlzunoa1.cloudfront.net/kotlin/files/2016/06/import-1.gif)\n\n* Smart completion works after ‘by’ and ‘in’\n  ![](https://d3nmt5vlzunoa1.cloudfront.net/kotlin/files/2016/06/smart.gif)\n\n* Move Element Left/Right actions work for Kotlin\n  ![](https://d3nmt5vlzunoa1.cloudfront.net/kotlin/files/2016/06/move.gif)\n\n* _Decompile_ button is now available in Kotlin bytecode toolwindow and for .class files compiled with Kotlin\n  ![decompile](https://d3nmt5vlzunoa1.cloudfront.net/kotlin/files/2016/06/decompile.png)\n\n* Now you can navigate from stacktrace to the call site of an inline function\n\n* Inspections and intentions to check and adjust Kotlin configuration in pom.xml files\n* Various Spring support improvements\n\n## How to update\n\nTo update the plugin, use Tools | Kotlin | Configure Kotlin Plugin Updates and press the “Check for updates now” button. Also, don’t forget to update the compiler and standard library version in your Maven and Gradle build scripts.\n\nAs usual, if you run into any problems with the new release, you’re welcome to ask for help on the [forums](https://discuss.kotlinlang.org/), on Slack (get an invite [here](http://kotlinslackin.herokuapp.com/)), or to report issues in the [issue tracker](https://youtrack.jetbrains.com/issues/KT).\n\nLet’s Kotlin!\n\n","author":"Roman Belov","date":"2016-06-30","type":"article","categories":["Kotlin"],"features":["highlightjs"],"description":"","filename":"","lang":"EN","enclosure":null},{"title":"Kotlin Educational Plugin","url":"http://blog.jetbrains.com/kotlin/2016/03/kotlin-educational-plugin/","body":"\n\nWe always said that Kotlin is really easy to learn. And it is! But it’s not only about the language: learning materials make a difference too. Today we are making another important step in this direction. We are happy to present Kotlin Educational Plugin.\n\n[https://youtu.be/0ponbfQhESY](https://youtu.be/0ponbfQhESY)\n\nKotlin Edu is a plugin for IntelliJ IDEA 2016.1 which lets you take learning courses. A course contains a number of tasks, and every task has several placeholders which you need to fill in correctly to solve it.\n\nAt the moment, there is only one course — the well-known Kotlin Koans, which has been available [online](http://try.kotlinlang.org/koans) for some time and gained considerable popularity among Kotlin learners. The offline versions of the Koans has pretty similar user experience but with all strengths of refactorings and intention actions available in IntelliJ IDEA!\n\nIf you have any questions about Kotlin Koans, feel free to ask them in the **#koans** channel [in our Slack](http://blog.jetbrains.com/kotlin/2016/03/kotlin-educational-plugin/kotlinslackin.herokuapp.com).\n\nP.S. If you want to create your own course, contact us directly via [email](mailto:roman.belov@jetbrains.com).\n\n","author":"Roman Belov","date":"2016-03-17","type":"article","categories":["Kotlin","Education"],"features":["highlightjs"],"description":"","filename":"","lang":"EN","enclosure":null},{"title":"Why You Must Try Kotlin For Android Development ?","url":"https://medium.com/@amitshekhar/why-you-must-try-kotlin-for-android-development-e14d00c8084b#.hnaxo3kru","body":"\n![](https://cdn-images-1.medium.com/max/880/1*0M73p2TIq5Wi4lKVaQKZbA.png)\n\n**Kotlin** is a statically typed programming language for the JVM, Android and the browser.\n\n### **Why use Kotlin for Android Development ?**\n\n* **Concise:** Drastically reduce the amount of boilerplate code you need to write.\n* **Safe:** Avoid entire classes of errors such as null pointer exceptions.\n* **Versatile:** Build server-side applications, Android apps or front-end code running in the browser.\n* **Interoperable:** Leverage existing frameworks and libraries of the JVM with 100% Java Interoperability.\n\n### Let’s see the things in more detail ( **Kotlin vs Java** ) **:**\n\n### **Interoperable with Java:** \n\nWhen it comes to give a try to a new language, interoperability is a great thing which can help you. Interoperable means you can reuse any Java class ever written, all Java code can work with Kotlin and vice versa. Learning Kotlin for a Java developer shouldn’t be too hard. Everything you can do with Java, you can do in Kotlin. If you do not know how to do it in Kotlin, then just do it in Java and let the Kotlin plugin convert it to Kotlin. Make sure that you see what happened to your code, so that the next time you can do it yourself.\n\n### **Null Safety:**\n\nKotlin’s type system is aimed at eliminating the danger of null references from code, also known as [**The Billion Dollar Mistake**](https://en.wikipedia.org/wiki/Tony_Hoare#Apologies_and_retractions).\n\nOne of the most common pitfalls in many programming languages, including Java is that of accessing a member of a null references, resulting in null reference exceptions. In Java this would be the equivalent of a NullPointerException or NPE for short.\n\nIn Kotlin, the type system distinguishes between references that can hold null (nullable references) and those that can not (non-null references). For example, a regular variable of type String can’t hold null:\n\n```kotlin\nvar a: String = \"abc\"  \na = null // compilation error\n```\n\nTo allow nulls, you can declare a variable as nullable string, written String?:\n\n```kotlin\nvar b: String? = \"abc\"  \nb = null // ok\n```\n\nNow, if you call a method or access a property on a, it’s guaranteed not to cause an NPE, so you can safely say\n\n```kotlin\nval l = a.length\n```\n\nBut if you want to access the same property on b, that would not be safe, and the compiler reports an error:\n\n```kotlin\nval l = b.length // error: variable ‘b’ can be null\n```\n\nBut you still need to access that property, right? There are a few ways of doing that.\n\nChecking for null in conditions:\n\nFirst, you can explicitly check if b is null, and handle the two options separately:\n\n```kotlin\nval l = if (b != null) b.length else -1\n```\n\nSafe Calls:\n\nYour second option is the safe call operator **(?.)**:\n\n```kotlin\nb?.length\n```\n\nThis returns the length of b if b is not null, and null otherwise.\n\n### **Smart Casting:**\n\n```kotlin\n// Java  \nif (node instanceOf Leaf) {  \n  return ((Leaf) node).symbol;  \n}\n```\n\n```kotlin\n// kotlin  \nif (node is Leaf) {  \n  return node.symbol; // Smart casting, no need of casting  \n}\n```\n\n```kotlin\nif (document is Payable && document.pay()) { // Smart casting  \n  println(\"Payable document ${document.title} was payed for.\")\n}\n```\n\nKotlin uses lazy evaluation just like in Java. So if the document were not a Payable, the second part would not be evaluated in the first place. Hence, if evaluated, Kotlin knows that document is a Payable and uses a smart cast.\n\n### **Default Arguments:** \n\nDefault arguments are a feature you are missing in Java because it’s just so convenient, makes your code more concise, more expressive, more maintainable and more readable.\n\n```kotlin\nclass Developer(val name: String,  \n val age: Int,  \n val someValue: Int = 0,  \n val profile: String = \"\") {  \n}\n```\n\n```kotlin\nval amit = Developer(\"Amit Shekhar\", 22, 10, \"Android Developer\")  \nval anand = Developer(\"Anand Gaurav\", 20, 11)  \nval ravi = Developer(\"Ravi Kumar\", 26)\n```\n\n### **Named Arguments:** \n\nWhen it comes to readability, Named arguments make Kotlin awesome.\n\n```kotlin\nval amit = Developer(\"Amit Shekhar\", age = 22, someValue = 10, profile = \"Android Developer\")\n```\n\n```kotlin\n// This code is not readable.  \nmyString.transform(true, false, false, true, false)\n```\n\n```kotlin\n// the below code is readable as named arguments are present  \nmyString.transform(  \n toLowerCase = true,  \n toUpperCase = false,  \n toCamelCase = false,  \n ellipse = true,   \n normalizeSpacing = false  \n)\n```\n\n### **Functional Programming:** \n\nWhile Java evolved to incorporate several functional programming concepts since Java 8, Kotlin has functional programming baked right in. This includes higher-order functions, lambda expressions, operator overloading, lazy evaluation and lots of useful methods to work with collections.  \n    The combination of lambda expressions and the Kotlin library really makes your coding easier.\n\n```kotlin\nval numbers = arrayListOf(-42, 17, 13, -9, 12)  \nval nonNegative = numbers.filter { it >= 0 }  \nprintln(nonNegative)\n```\n\n```kotlin\nlistOf(1, 2, 3, 4) // list of 1, 2, 3, 4   \n    .map { it * 10 } // maps to to 10, 20, 30, 40  \n    .filter { it > 20 } // filters out 30, 40  \n    .forEach { print(it) } // prints 30, 40\n```\n\n### **Concise Code:** \n\nWhen you use Kotlin instead of Java, there is a huge reduction of code in your project.\n\nSee it in the example:\n\n```java\n// Java  \nButton button = (Button) findViewById(R.id.button);   \nbutton.setOnClickListener(new View.OnClickListener() {   \n [@Override](http://twitter.com/Override \"Twitter profile for @Override\")  \n public void onClick(View view) {  \n /* your code */  \n }  \n});\n```\n\n```kotlin\n// Kotlin  \nval button = findViewById(R.id.fab) as Button   \nbutton.setOnClickListener { view -> /* your code */}\n```\n\n","author":"Amit Shekhar","date":"2016-11-10","type":"article","categories":["Kotlin","Android"],"features":["highlightjs"],"description":"","filename":"","lang":"EN","enclosure":null},{"title":"How to Hot Deploy Java/Kotlin classes in Dev","url":"https://hashnode.com/post/how-to-hot-deploy-javakotlin-classes-in-dev-cim3u5oen00fnek53ho7q1t0v","body":"\nOne thing the majority of JVM developers find annoying is having to constantly restart their container. Make a small change, restart Tomcat/Jetty, wait 30+ seconds for code to build / compile (or several minutes in the case of large monolithic projects), see results; repeat.\n\nCompared to Dart which auto-reloads your changes as soon as you hit save, this is very inefficient and kills productivity.\n\nThere's a commercial solution available called [JRebel](http://zeroturnaround.com/software/jrebel/) that aims to solve this problem, I took it for a test drive for a couple of weeks and managed to cut down several hours rapidly increasing my productivity and leaving me with a lot less time to spend on Hashnode.\n\n![title here](https://res.cloudinary.com/hashnode/image/upload/v1458676272/k10afwmauljxts4kdek7.png)\n\nEven though JRebel was saving me a lot of time and pretty much worked out of the box, I just couldn't justify the price tag - at almost $500 a year, converted to Rands, that's about the price of one month's rental in South Africa for a small flat - a bit heavy; all the time I'm saving, I'm paying over to them. Don't get me wrong, I enjoyed using JRebel, but the price tag is just too much when there are other solutions available.\n\nThere is an open-source alternative which works just as well for what I'm using it for - it's called [Spring Loaded](https://github.com/spring-projects/spring-loaded#readme). It probably won't cover everything that JRebel is doing, but I'm mostly busy in Spring, so it's perfect for my needs.\n\nDownload the [jar](http://repo.spring.io/release/org/springframework/springloaded/1.2.5.RELEASE/springloaded-1.2.5.RELEASE.jar) file, throw it somewhere where you won't accidentally delete it, open your `~/.bash_profile` if you're using OSX or on Linux it would typically be your `~/.bashrc` and add the following line followed by restarting your terminal:\n\n`export MAVEN_OPTS=\"-javaagent:/absolute/path/Code/springloaded-1.2.5.RELEASE.jar -noverify\"`\n\nNow when you run your application using the maven jetty plugin or maven tomcat plugin (`mvn jetty:run`), every time you compile a class, it will be reloaded for you without having to do `Ctrl + C` and restarting `mvn jetty:run`. In Eclipse this will happen automatically if you have auto build turned on, in IntellJ, just assign a shortcut to the compile command (I'm using `Cmd + S`), once you're done with your changes, simply hit `Cmd + S` and you can immediately see your changes without restarts.\n\nHappy coding!!\n\n","author":"Jan Vladimir Mostert","date":"2016-03-22","type":"article","categories":["Deploy","Kotlin"],"features":["highlightjs"],"description":"","filename":"","lang":"EN","enclosure":null},{"title":"Using Mockito for unit testing with Kotlin (1/x)","url":"http://makingiants.com/blog/using-mockito-for-unit-tests-with-kotlin-1x/","body":"\nDependencies:\n\n```gradle\n\n// Android stuff...\ndependencies {\n    //...\n    compile \"org.jetbrains.kotlin:kotlin-stdlib:1.0.0\"\n\n    testCompile 'junit:junit:4.12'\n    testCompile 'org.mockito:mockito-core:2.0.42-beta'\n    testCompile('com.squareup.assertj:assertj-android:1.1.1') {\n        exclude group: 'com.android.support', module: 'support-annotations'\n    }\n}\n\n```\n\n## Little Notes\n\n* All the functions AND PROPERTIES should be open, by default functions and properties are final and mockito cant mock them.\n* **DONT USE** spy functions make tests fail bc of some weird crash (*if someone had use them right comment!!*).\n\n## Example\n\nWe will show:\n\n1. `Settings`: manage settings storage, where to store them and which ones.\n2. `SettingsView`: ...\n3. `SettingsPresenter`: manage the bussiness logic for the settings.\n\nYou may have a class `Settings`:\n\n```kotlin\nopen class Settings(context: Context) {\n    val localCache = LocalCache(context)\n\n    open var playJustWithHeadphones: Boolean\n        get() = localCache.get(\"headphones\", false)\n        set(value) = localCache.put(\"headphones\", value)\n}\n```\n\nThen a presenter that use those settings:\n\n```kotlin\nclass SettingsPresenter {\n    private var mSettings: Settings? = null\n    private var mView: SettingsView? = null\n\n    fun onCreate(view: SettingsView, settings: Settings) {\n        mView = view\n        mSettings = settings\n\n        view.setHeadphonesToggleCheck(settings.playJustWithHeadphones)\n    }\n}\n```\n\nCheck that mocked Settings class **is open** and mocked var property **is open**\n\nThen the tests passing:\n\n```kotlin\nclass SettingsPresenterTests {\n    @Mock lateinit var mockedView: SettingsView\n    @Mock lateinit var mockedSettings: Settings\n    lateinit var presenter: SettingsPresenter\n\n    @Before\n    fun setUp() {\n        MockitoAnnotations.initMocks(this)\n        presenter = SettingsPresenter()\n    }\n\n    @Test\n    fun test_onCreate_updateGui() {\n        Mockito.`when`(mockedSettings.playJustWithHeadphones).thenReturn(true)\n        presenter.onCreate(mockedView, mockedSettings)\n\n        Mockito.verify(mockedView).setHeadphonesToggleCheck(true)\n    }\n}\n```\n\n## Notes\n* Using `lateinit` to let the variables be initialized on `@Before` and avoid using `?` or `!!` all over the tests.\n* `SettingsView` and `Settings` are mocked using `MockitoAnnotations`\n","author":"MAKINGIANTS","date":"2016-02-20","type":"article","categories":["Android","Kotlin"],"features":["highlightjs"],"description":"","filename":"","lang":"EN","enclosure":null},{"title":"Kotlin for Java Developers: 10 Features You Will Love About Kotlin","url":"http://petersommerhoff.com/dev/kotlin/kotlin-for-java-devs/","body":"\n# Kotlin for Java Developers: 10 Features You Will Love About Kotlin\n\nKotlin is a statically typed JVM language built by Jetbrains, the makers of the IntelliJ IDE. [Kotlin](https://kotlinlang.org/) is built upon Java and provides useful features such as null-safety, data classes, extensions, functional concepts, smart casts, operator overloading and more.\n\nThis crash course into Kotlin for Java developers demonstrates the most important advantages that Kotlin has over Java and compares some of the language concepts. You can skim the code snippets and boldly marked parts for a quick overview but I recommend you read the whole article (even though it is rather long).\n\n## Contents\n\n1. Why Would I Care About Kotlin?\n2. Null Safety\n3. Data Classes\n4. Extension Functions\n5. Smart Casts\n6. Type Inference\n7. Functional Programming\n8. Objects (aka Easily Create Singletons)\n9. Default Arguments\n10. Named Arguments\n11. Bonus: Enforcing Best Practices\n12. What Now?\n\n## Why Would I Care About Kotlin?\n\nWhat made me particularly interested in Kotlin is the fact that it is **uber-interoperable with Java** and is backed up by Jetbrains and their popular Java IDE IntelliJ. Why did that make me more interested in Kotlin you ask?\n\nWell, interoperability with Java is majorly important because Java has been one of the [most widely used programming language](http://www.tiobe.com/index.php/content/paperinfo/tpci/index.html) for quite a while now. From a business perspective, this means that most real-world code is written in Java and that companies want to maintain their Java code base as long as possible — typically, the value of the legacy code is in the millions.\n\n**With Kotlin, organizations have the chance to try out a new programming language with minimal risk.** Java files can be converted to equivalent Kotlin files which can then be worked on. Similarly, all types defined in Kotlin (like classes and enums) can be used from within Java just like any other Java type. From a developer point of view, it is great to be able to use the Java libraries that you are used to. You can use Java IO, JavaFX, Apache Commons, Guava and all your own classes right from Kotlin.\n\nAlso, hyperbolically, **a programming language is only as good as its tool support**. This is why the second point speaking in favor of Kotlin for me was that IntelliJ provides built-in language support. It also contains the aforementioned Java-to-Kotlin converter and code generators for Java and JavaScript from Kotlin code.\n\nThese two points also separate Kotlin from other JVM languages such as Scala, Ceylon, Clojure or Groovy.\n\n**Alright, enough talk.** Let’s jump into the actual language features of Kotlin.\n\n## 1) Null Safety\n\n```kotlin\nclass Person {\n    val givenName: String = \"\"\n    val familyName: String = \"\"\n    val address: Address? = null\n}\n```\n\nIn this example, givenName and familyName cannot be null — the program would **fail at compile-time**. You must explicitly make a variable nullable to be able to assign null to it. This is done via the “?” after the variable type. So the address property may be null in the given code.\n\nKotlin also fails at compile-time whenever a NullPointerException may be thrown at run-time — that is, when you try to call a method or reference a property from a nullable type:\n\n```kotlin\nval givenName: String? = null\nval len = givenName.length\n```\n\nIf you try to compile this, the Kotlin compiler will give you an error: “Only safe (?.) or non-null asserted (!!.) calls are allowed on a nullable receiver of type kotlin.String?”. We’ll see how to handle these cases where you _know_ the variable _cannot_ be null in a second.\n\nSo far so good, but what are those safe and non-null asserted calls the compiler is talking about? **Safe calls simply return the value of the call as normally if the callee is not null, and return null otherwise:**\n\n```kotlin\nval givenName: String? = \"\"\nval len = givenName?.length\n```\n\nIn this case, len will be zero as expected. If givenName was null, len would also be assigned null. Thus the return type of givenName?.length is Int?, a nullable integer.\n\nWith non-null asserted calls, you assert to the compiler that you _know_ the variable _cannot_ be null at run-time at the position you use it:\n\n```kotlin\nval givenName: String? = \"Roger\"\nval len = givenName!!.length\n```\n\nTo work with nullable types effectively, the **Elvis operator** comes in handy. It allows you to use a nullable if it is not null and a default value otherwise:\n\n```kotlin\nval text: String? = null\nval len = text?.length ?: -1\n```\n\nIn this example, len will be -1 because the nullable text is in fact null so that the defined default value is used. You may have noticed that this is basically just the widely known _ternary operator_ where the first operand is equal to the expression itself:\n\n```kotlin\nval len = text?.length ?: -1\nval len = text?.length ? text?.length : -1\n```\n\nThese two lines are semantically the same.\n\n## 2) Data Classes\n\nFor simple classes which mainly hold data, you can avoid a lot of boilerplate compared to Java code. Consider the following **typical data class in Java:**\n\n```java\nclass Book {\n    private String title;\n    private Author author;\n\n    public String getTitle() {\n        return title;\n    }\n\n    public void setTitle(String title) {\n        this.title = title;\n    }\n\n    public Author getAuthor() {\n        return author;\n    }\n\n    public void setAuthor(Author author) {\n        this.author = author;\n    }\n}\n```\n\nLots of boilerplate code that you’ll skip when trying to find out what the class really does. **In Kotlin, you can define the same class concisely in one line:**\n\n```kotlin\ndata class Book(var title: String, var author: Author)\n```\n\nKotlin will also **generate useful hashCode(), equals(), and toString()** implementations. Printing a book will create an output like Book(title=Effective Java, author=Author(name=Joshua Bloch)).\n\n**Challenge**: [Write an Author class](http://try.kotlinlang.org/) that will lead to an output like this!\n\nNot only that, it will also allow you to **easily make copies of data classes:**\n\n```kotlin\nval book = Book(\"Effective Java\", Author(\"Joshua Bloch\"))\nval copy = book.copy()\nval puzzlers = book.copy(title = \"Java Puzzlers\")\nval gof = book.copy(title = \"Design Patterns\", author = Author(\"Gang of Four\"))\n```\n\nYou can change arbitrary properties of the copied object by adding named parameters to the copy() method.\n\nOne more goody is the possibility to use **destructuring declarations** on data classes, retrieving the respective property values:\n\n```kotlin\nval book = Book(\"The Phoenix Project\", Author(\"Kevin Behr\"))\nval (title, author) = book\n```\n\n## 3) Extension Functions\n\nKotlin allows us to **extend the functionality of existing classes without inheriting from them**. This is enabled by extension functions and extension properties. Let’s say you want to extend the GridPane class from the JavaFX GUI framework with a method to retrieve the elements in row i and column j:\n\n```kotlin\nfun GridPane.getElementAt(rowIndex: Int, columnIndex: Int): Node? {\n    this.children.forEach {\n        if (GridPane.getColumnIndex(it) == columnIndex && GridPane.getRowIndex(it) == rowIndex) {\n            return it;\n        }\n    }\n\n    return null;\n}\n```\n\nThere are several things to mention here. First, inside the extension function you can refer to the object on which it was called using “this”. Second, you use Kotlin’s forEach() function on the list of child nodes. This is equivalent to the forEach() method included in Java 8 and allows some functional-style programming. Third, inside the forEach(), you can refer to the current element using the implicit loop variable “it”.\n\nNote that the return type comes after the parentheses containing the parameters and is a nullable Node since the method may return null.\n\n**There’s one thing to be aware of:** If you try to call an extension function with the arguments that are also applicable for an existing member function inside the class, the member will always “win” — meaning that it will take precedence and overshadow your extension function.\n\n## 4) Smart Casts\n\nHow often have you already cast objects where it was actually redundant? More often than you can count I bet, like this:\n\n```java\nif (node instanceof Leaf) {\n    return ((Leaf) node).symbol;\n}\n```\n\nThe Kotlin compiler on the other hand is really intelligent when it comes to casts. Meaning: **it will handle all those redundant casts for you**. This is called **smart casts**.\n\nThe equivalent Kotlin code for the code snippet above looks like this:\n\n```kotlin\nif (node is Leaf) {\n    return node.symbol;\n}\n```\n\nThe instanceof operator in Kotlin is called “is”. And, more importantly, there is no need to clutter your code with casts that the compiler can actually take care of.\n\nNow this goes much further than just this simple case:\n\n```kotlin\nif (person !is Student)\n    return\n\nperson.immatriculationNumber\n```\n\nIn this case, if person were not a student, the control flow would never reach line 4. Accordingly, the Kotlin compiler knows that person must be Student object and performs a smart cast.\n\nLet’s look at some **lazily evaluated conditional expressions**:\n\n```kotlin\nif (document is Payable && document.pay()) {  // Smart cast\n    println(\"Payable document ${document.title} was payed for.\")\n}\n```\n\nConditionals like these use lazy evaluation in Kotlin, just like in Java. So if the document were not a Payable, the second part would not be evaluated in the first place. Hence, if evaluated, Kotlin knows that document is a Payable and uses a smart cast.\n\nThe same goes for disjunction:\n\n```kotlin\nif (document !is Payable || document.pay() == false) {  // Smart cast\n    println(\"Cannot pay document ${document.title}.\")\n}\n```\n\nWhen expressions are another place where Kotlin will apply smart casts wherever possible:\n\n```kotlin\nval result = when (expr) {\n    is Expr.Number      -> expr.value\n    is Expr.Sum         -> expr.first + expr.second\n    is Expr.Difference  -> expr.first - expr.second\n    is Expr.Exp         -> Math.pow(expr.base, expr.exponent)\n}\n```\n\nDepending on the type of the object, you can simply use the respective properties in each when block.\n\nNote: For the example above, the Expr class must be a sealed class with only these exact four subclasses.\n\n## 5) Type Inference\n\n**In Kotlin, you don’t have to specify the type of each variable explicitly, even though Kotlin _is_ strongly typed**. You can choose to explicitly define a data type, for example if you don’t want a small integer to be stored in an Int variables but rather a Short or even a Byte. You can do that using the colon notation where the data type stands behind the variable name:\n\n```kotlin\nval list: Iterable<Double> = arrayListOf(1.0, 0.0, 3.1415, 2.718)  // Only need Iterable interface\n\nval arrayList = arrayListOf(\"Kotlin\", \"Scala\", \"Groovy\")  // Type is ArrayList\n```\n\nYou can choose to use explicit types as in Java but you’re also free to write more concise Python-like variable declarations. Explicit types are useful to reference the most general interface (which you should always do).\n\n## 6) Functional Programming\n\nWhile Java evolved to incorporate several functional programming concepts since Java 8, Kotlin has functional programming baked right in. This includes **higher-order functions, lambda expressions, operator overloading, lazy evaluation** and lots of useful methods to work with collections.\n\nThe combination of lambda expressions and the Kotlin library really makes your day easier when working with collections:\n\n```kotlin\nval numbers = arrayListOf(-42, 17, 13, -9, 12)\nval nonNegative = numbers.filter { it >= 0 }\nprintln(nonNegative)\n```\n\nNote that, when using lambda expressions with a single argument, Kotlin creates an implicit variable called “it” which refers to the lambda expression’s only argument. So the second line above is equivalent to:\n\n```kotlin\nval nonNegative = numbers.filter { it -> it >= 0 }\n```\n\nKotlin provides all essential functional facilities such as **filter, map & flatMap, take & drop, first & last, fold & foldRight, forEach, **reduce_,_ and anything else the pragmatic functional programmer’s heart longs for:\n\n```kotlin\nprintln(numbers.take(2))  // First two elements: [-42, 17]\n\nprintln(numbers.drop(2))  // List without first two elements: [13, -9, 12]\n\nprintln(numbers.foldRight(0, { a, b -> a + b }))  // Sum of all elements: -9\n\nnumbers.forEach { print(\"${it * 2} \") }  // -84 34 26 -18 24\n\n---\n\nval genres = listOf(\"Action\", \"Comedy\", \"Thriller\")\nval myKindOfMovies: Iterable<String> = genres.filter { it.length <= 6 }.map { it + \" Movie\" }\nprintln(myKindOfMovies)  // [Action Movie, Comedy Movie]\n\n```\n\n## 7) Objects (aka Easily Create Singletons)\n\nKotlin has a keyword called _object_ which allows us to define an object, similar to a class. But of course, that object then only exists as a **single instance**. **This is a useful way to create singletons** but the feature is not restricted to only singletons.\n\nCreating an object is as simple as this:\n\n```kotlin\nobject CardFactory {\n\n    fun getCard(): Card {\n        // ...\n    }\n}\n```\n\nAnd you can then use that object like a class with static members:\n\n```kotlin\nfun main(args: Array<String>) {\n    val card = CardFactory.getCard()\n}\n```\n\nYou can even **let your objects have superclasses**:\n\n```kotlin\nobject SubmitButtonListener : ActionListener {\n\n    override fun actionPerformed(e: ActionEvent?) {\n        // Submit form...\n    }\n}\n```\n\nThis concept is a powerful extension to the classes, interfaces & enums available in Java because oftentimes, elements of the domain model are inherently objects (they exist only once and thus should always have at most instance at runtime).\n\n## 8) Default Arguments\n\nDefault arguments are a feature I’m dearly missing in Java because it’s just so convenient, makes your code more concise, more expressive, more maintainable, more readable, more everything-that’s-good.\n\nIn Java, you often have to duplicate code in order **define different variants of a method or constructor**. Take a look at this:\n\n```java\npublic class NutritionFacts {\n    private final String foodName;\n    private final int calories;\n    private final int protein;\n    private final int carbohydrates;\n    private final int fat;\n    private final String description;\n\n    public NutritionFacts(String foodName, int calories) {\n        this.foodName = foodName;\n        this.calories = calories;\n        this.protein = -1;\n        this.carbohydrates = -1;\n        this.fat = -1;\n        this.description = \"\";\n    }\n\n    public NutritionFacts(String foodName, int calories, int protein, int carbohydrates, int fat) {\n        this.foodName = foodName;\n        this.calories = calories;\n        this.protein = protein;\n        this.carbohydrates = carbohydrates;\n        this.fat = fat;\n        this.description = \"\";\n    }\n\n    public NutritionFacts(String foodName, int calories, int protein, int carbohydrates, int fat, String description) {\n        this.foodName = foodName;\n        this.calories = calories;\n        this.protein = protein;\n        this.carbohydrates = carbohydrates;\n        this.fat = fat;\n        this.description = description;\n    }\n}\n```\n\nUgh, pretty bad. But it gets even worse if you want to provide more different constructors or add more possible attributes.\n\nThe example above demonstrate the so-called _telescoping anti-pattern_ prevalent in Java. You can improve this design by using the Builder pattern instead.\n\nBut with Kotlin, you can do this even easier using default values for arguments:\n\n```kotlin\nclass NutritionFacts(val foodName: String,\n                     val calories: Int,\n                     val protein: Int = 0,\n                     val carbohydrates: Int = 0,\n                     val fat: Int = 0,\n                     val description: String = \"\") {\n}\n```\n\nThis makes each of the parameters with a default value an _optional parameter_. And it actually gives you many more possibilities to invoke the constructor than the Java class above:\n\n```kotlin\nval pizza = NutritionFacts(\"Pizza\", 442, 12, 27, 24, \"Developer's best friend\")\nval pasta = NutritionFacts(\"Pasta\", 371, 14, 25, 11)\nval noodleSoup = NutritionFacts(\"Noodle Soup\", 210)\n```\n\nNote that you may also want to make this sort of class a _data class_ to have methods like equals() and toString() generated for you.\n\n**In short: You get more for less. And keep your code clean at the same time.**\n\n## 9) Named Arguments\n\nDefault arguments become even more powerful in combination with named arguments:\n\n```kotlin\nval burger = NutritionFacts(\"Hamburger\", calories = 541, fat = 33, protein = 14)\nval rice = NutritionFacts(\"Rice\", 312, carbohydrates = 23, description = \"Tasty, nutritious grains\")\n```\n\n**Anyone reading the code knows what’s going on** without having to look at what the parameters mean. This increases readability and can make you more productive when used correctly. For example, this is especially useful when you have several boolean parameters like this:\n\n```kotlin\nmyString.transform(true, false, false, true, false)\n```\n\nUnless you’ve implemented that function 10 seconds ago, there’s no way you know what’s going on here (there’s no guarantee you know even _if_ you’ve implemented it 10 seconds ago).\n\nMake your life (and that of your fellow developers) easier by using named arguments:\n\n```kotlin\nmyString.transform(\n    toLowerCase = true,\n    toUpperCase = false,\n    toCamelCase = false,\n    ellipse = true,\n    normalizeSpacing = false\n)\n```\n\n## 10) Bonus: Enforcing Best Practices\n\nGenerally, Kotlin enforces many of the best practices you should follow when using Java. You can read about them in Josh Bloch’s book [“Effective Java”](http://www.oracle.com/technetwork/java/effectivejava-136174.html).\n\nFirst of all, the use of **val vs. var** promotes making every variable final that is not supposed to change — while also providing a more concise syntax for it. This is useful when creating immutable objects for example.\n\nThis way, beginners learning the language will also learn to follow this practice right from the start because you tend to think about whether to use **val** or **var** each time and learn to prefer val to var when possible.\n\nNext, Kotlin also supports the principle to either design for inheritance or prohibit it — because in Kotlin, you have to explicitly declare a class as **open** in order to inherit from it. That way, you have to remember to _allow_ inheritance instead of having to remember to _disallow_ it.\n\n## What Now?\n\n**If this overview made you curious** to learn more about Kotlin, you can [check out my 10 beginner tutorial videos for Kotlin](http://petersommerhoff.com/dev/kotlin/kotlin-beginner-tutorial/) or **[go straight to the full course](https://www.udemy.com/kotlin-course/?couponCode=READERSONLY9USD) (with 95% reader discount)**.\n\n**The course is beginner-friendly and starts completely from scratch.** If you already know Java or a comparable language, you’ll still find it a valuable resource to get to know Kotlin.\n\n","author":"Peter Sommerhoff","date":"2015-12-12","type":"article","categories":["Kotlin"],"features":["highlightjs"],"description":"","filename":"","lang":"EN","enclosure":null},{"title":"RxAndroid and Kotlin (Part 1)","url":"https://medium.com/@ahmedrizwan/rxandroid-and-kotlin-part-1-f0382dc26ed8#.bx3rgamfo","body":"\n![](https://d262ilb51hltx0.cloudfront.net/max/2000/1*bTttcFdSLyvWIPg91OaNEw.png)\n\n### RxAndroid and Kotlin (Part 1)\n\nI started with [RxAndroid](https://github.com/ReactiveX/RxAndroid) about a week ago. At first, I didn’t really get it... I mean, I grasped the concept but I didn’t understand where I should be using it. But then after going through a few examples and a few really good articles (links at the end)... I just got it! (to a good extent) And my reaction was pretty much:\n\n![](https://d262ilb51hltx0.cloudfront.net/max/800/1*rjlr5GxQIx8o28U5nhtDxg.gif)\n\n##### *Such Rx. Much Reactive. Wow!*\n\nIn short, you can use Rx almost everywhere — but **you shouldn’t**. You should intelligently figure out where it should go. Because in some instances, Rx can be a 100 times more productive and better than normal imperative programming, and in others, it just isn’t necessary.\n\nI’ll demonstrate a few examples in both **Kotlin** and **Java** so that you get an idea of Rx as well as a comparison of the two languages.\n\n> Now if you’re not familiar with Kotlin, then I suggest that you visit these links\n>\n> [Official Kotlin Website](http://kotlinlang.org)\n>\n> [Getting Started on Android](http://kotlinlang.org/docs/tutorials/kotlin-android.html)\n>\n>[Jake Wharton’s Paper on Kotlin](https://docs.google.com/document/d/1ReS3ep-hjxWA8kZi0YqDbEhCqTt29hG8P44aA9W0DM8/edit?usp=sharing)\n>\n> [My Blog](https://medium.com/@ahmedrizwan/android-programming-with-kotlin-6ce3f9b0cbe6) ;)</pre>\n>\n> Short Summary : Kotlin is an awesometacular alternative to Java, that works amazingly well on Android. And oh, it's developed by JetBrains!\n>\n>P.S. There are no semicolons in Kotlin. \\*_\\*\n\n#### Rx: The Concept\n\nIf you already have a good concept of Rx, then you can skip this topic. Otherwise... read on!\n\nOk so what is Rx? Well... It’s “reactive programming”... Reactive programming is, in easy words, a programming pattern closely related to the **Observer** **Pattern**. In which, Subscribers “react” to the events emmited by the Observable(s).\n\n![](https://d262ilb51hltx0.cloudfront.net/max/800/1*Oa7zxVaeyF4TO6Mres4E5w.png)\n\n\n![](https://d262ilb51hltx0.cloudfront.net/max/400/1*ATqZ5sek2uAPfZMdmsWHSg.png)\n\n##### *Transformations as the subscriber receives data from observable.*\n\nRx is also a subset of **Functional Programming**. Hence often referred to as Functional Reactive Programming. Because... As the subscribers receive data, they can apply a sequence of **transformations** on them. (Similar to what we can do with Streams in Java 8)\n\nWe can even combine/merge different streams too. It’s that **flexible**! So... For now, just remember there are tons of different things we can do with the data we (the subscribers) receive from observables, on the fly!\n\nNow that the concept is somewhat clear, lets come back to RxJava.\n\nIn Rx, the **subscriber** implements three methods to interact with observable\n\n1.  onNext(Data) : Receives the data from Observable\n2.  onError(Exception) : Gets called if an exception is thrown\n3.  onCompleted() : Gets called when the data stream ends\n\nThis can be compared to the **Iterables** in Java. The difference is that iterables are **pull**-based, and Rx observables are **push**-based as the Observable pushes out data to its subscribers. Here’s the comparison table...\n\n![](https://d262ilb51hltx0.cloudfront.net/max/800/1*6xrzAdP_wa6aR80UrNxiIw.png)\n\n> Another thing to note is that Rx is **asynchronous** in nature, meaning subscribers aren’t going to be waiting for other subscribers to finish. They’ll “asynchronously” process the streams.\n\nSo... Observables push out **streams of data** to their subscribers, and subscribers can consume those streams (with the help of the methods listed above)**.** We can understand “streams” a bit better with the help of [Marble Diagrams](http://rxmarbles.com)...\n\n![](https://d262ilb51hltx0.cloudfront.net/max/800/1*2-sTf0tHsmDlent1HLIhrg.png)\n\n##### *A marble diagram representing two different streams.*\n\nThe cirlces on these streams represent **data objects**. And the arrows represent that the data is flowing in one direction (not referring to the boy band), in an orderly fashion! Have a look at this marble diagram...\n\n![](https://d262ilb51hltx0.cloudfront.net/max/800/1*ju5YD8bRZhdCGmptRQdmlw.png)\n\n##### *A mapping of a stream.*\n\nLike I mentioned before, we can **transform** the data (as well as streams) using [**operators**](https://github.com/ReactiveX/RxJava/wiki/Alphabetical-List-of-Observable-Operators) like map, filter, zip etc. The image above represents a simple mapping. So after this transformation, the subscriber to this stream will get the transformed version of the stream. Cool, right?\n\nI think you should now have a good concept of how things work in Rx, so lets get to the actual implementation.\n\n![](https://d262ilb51hltx0.cloudfront.net/max/800/1*-nTq2bHQbJZctDZZoPnBYQ.png)\n\n#### Implementing Observables\n\nThe first thing we have to do is meditate.\n\n![](https://d262ilb51hltx0.cloudfront.net/max/800/1*I6aMRP_WrXdse197zfBh1Q.jpeg)\n\nAfter that, creating an Observable is not that difficult.\n\nThere are a number of ways we can [create observables](https://github.com/ReactiveX/RxJava/wiki/Creating-Observables), I’ll list down just three here.\n\n1.  **Observable.from()** : Creates an observable from an Iterable, a Future, or an Array.\n\n```kotlin\n//Kotlin\nObservable.from(listOf(1, 2, 3, 4, 5))\n//Java\nObservable.from(Arrays.asList(1, 2, 3, 4, 5));\n\n//It will emit these numbers in order : 1 - 2 - 3 - 4 - 5\n//Which should be pretty obvious I guess.\n```\n\n2. **Observable.just()** : Creates observable from an object or several objects\n\n```kotlin\nObservable.just(\"Hello World!\")\n//this will emit \"Hello World!\" to all its subscribers\n```\n\n3. **Observable.create()** : Creates an Observable from scratch by means of a function. We just implement the OnSubscribe interface and tell the observable what it should send to its subscriber(s).\n\n```kotlin\n//Kotlin\nObservable.create(object : Observable.OnSubscribe<Int> {\n    override fun call(subscriber: Subscriber<in Int>) {\n        for(i in 1 .. 5)\n            subscriber.onNext(i)\n\n        subscriber.onCompleted()\n    }\n})\n```\n\nAnd the java version of the same code...\n\n```java\n//Java\nObservable.create(new Observable.OnSubscribe<Integer>() {\n    @Override\n    public void call(final Subscriber<? super Integer> \nsubscriber) {\n        for (int i = 1; i <= 5; i++)\n            subscriber.onNext(i);\n\n        subscriber.onCompleted();\n    }\n});\n\n//Using the implementation above, we're telling the observer what //it should do when a subscriber subscribes to it. Hence the name //\"onSubscribe\".\n```\n\nThe code I’ve written above is equivalent to the example I wrote for Observable.from() but as you can see, we have full control as to what should be emitted and when should the stream end. I can also send caught exceptions with the use of **subscriber.onError(e)**.\n\nNow we need subscribers!\n\n#### Implementing Subscribers\n\nAfter we have implemented our Observables... All we need is a subscriber! For Android, to subscribe to an observable, we first tell the observable about the threads on which we’re going to be subscribing and observing. RxAndroid gives us [**Schedulers**](https://github.com/ReactiveX/RxJava/wiki/The-RxJava-Android-Module), through which we can specify the thread**s**. So lets take a simple “Hello World” observable for example in which I want the subscription to be done on a **worker thread**, and observation on the **main thread**.\n\n```kotlin\n//Kotlin\nObservable.just(\"Hello World\")\n          .subscribeOn(Schedulers.newThread())\n          //each subscription is going to be on a new thread.\n          .observeOn(AndroidSchedulers.mainThread()))\n          //observation on the main thread\n          //Now our subscriber!\n          .subscribe(object:Subscriber<String>(){\n            override fun onCompleted() {\n             //Completed\n            }\n\n            override fun onError(e: Throwable?) {\n             //TODO : Handle error here\n            }\n\n            override fun onNext(t: String?) {\n             Log.e(\"Output\",t);\n            }\n           })\n```\n\n```java\n//Java \nObservable.just(\"Hello World\")\n        .subscribeOn(Schedulers.newThread())\n        .observeOn(AndroidSchedulers.mainThread())\n        .subscribe(new Subscriber<String>() {\n            @Override\n            public void onCompleted() {\n                //Completion\n            }\n\n            @Override\n            public void onError(final Throwable e) {\n                //TODO : Handle error here\n            }\n\n            @Override\n            public void onNext(final String s) {\n                Log.e(\"Output\",s);\n            }\n        });\n\n//You can get more info about schedulers and threading here.\n```\n\nSo... What does it do?\n\nWhen you run this code — It’ll display a log message\n\n```\nOutput: Hello World!\n```\n\nAnd that’s it! This is how simple “subscription” is... You can get more details about subscribe [here](http://reactivex.io/documentation/operators/subscribe.html).\n\n#### A Practical Example : Debounce!\n\nOk by now... You know how to create simple observables, right? So let’s do one of my favorite RxExamples... I want to implement this :\n\n![](https://d262ilb51hltx0.cloudfront.net/max/400/1*lyOcKYAvTjDnArAN4rEDNw.gif)\n\nIn this example, I enter text into an EditText and against this text, a response is triggered automatically —in which I print out the text. Now the response could be a call to an API. So if I trigger this call for every character I enter — that would be a waste because I only need the last one, meaning it should trigger a call only when I stop typing — let’s say after 1 second of typing-inactivity.\n\nSo how do we do this in non-reactive programming?\n\nWell it ain’t pretty!\n\n**Non-Reactive Solution**\n\nI use a Timer, and schedule it to call **run**() method after a 1000 milliseconds delay in **afterTextChanged()** method. Oh and don’t forget to add **runOnUiThread**() in there as well. -_-\n\nConceptually it’s not that difficult but the code becomes very cluttered, even more so in Java!\n\nJava version\n\n```java\n//Java\nTimer timer = new Timer();\n\nfinal TextView textView = (TextView) findViewById(R.id.textView);\nfinal EditText editText = (EditText) findViewById(R.id.editText);\n\neditText.addTextChangedListener(new TextWatcher() {\n    @Override\n    public void beforeTextChanged(CharSequence s, int start, int count,\n                                  int after) {\n    }\n\n    @Override\n    public void onTextChanged(final CharSequence s, int start, int before,\n                              int count) {\n        if (timer != null)\n            timer.cancel();\n    }\n\n    @Override\n    public void afterTextChanged(final Editable s) {\n        timer = new Timer();\n        timer.schedule(new TimerTask() {\n            @Override\n            public void run() {\n                runOnUiThread(new Runnable() {\n                    @Override\n                    public void run() {\n                        textView.setText(\"Output : \" + editText.getText());\n                    }\n                });\n            }\n\n        }, 1000);\n    }\n});\n```\n\nKotlin\n\n```kotlin\n//Kotlin\nvar timer: Timer? = Timer()\n\nval editTextStop = findViewById(R.id.editText) as EditText\neditTextStop.addTextChangedListener(object : TextWatcher {\n    override fun beforeTextChanged(s: CharSequence, start: Int, count: Int, after: Int) = Unit\n\n    override fun onTextChanged(s: CharSequence, start: Int, before: Int, count: Int) {\n            timer?.cancel()\n    }\n\n    override fun afterTextChanged(s: Editable) {\n        timer = Timer()\n        timer!!.schedule(object : TimerTask() {\n            override fun run() {\n                runOnUiThread { textView.setText(\"Output : \" + editTextStop.getText()) }\n            }\n        }, 1000)\n    }\n})\n```\n\n**Reactive Solution**\n\nReactive solution is very boilerplate-free. And there are only 3 steps to it.\n\n1.  Create an observable\n2.  Add Debounce operator with 1000 Milliseconds (1 second) delay\n3.  Subscribe to it\n\nFirst the Java code\n\n```java\n   Observable.create(new Observable.OnSubscribe<String>() {\n                    @Override\n                    public void call(final Subscriber<? super String> subscriber) {\n                        editText.addTextChangedListener(new TextWatcher() {\n                            @Override\n                            public void beforeTextChanged(final CharSequence s, final int start, final int count, final int after) {\n                            }\n\n                            @Override\n                            public void onTextChanged(final CharSequence s, final int start, final int before, final int count) {\n                                subscriber.onNext(s.toString());\n                            }\n\n                            @Override\n                            public void afterTextChanged(final Editable s) {\n                            }\n                        });\n                    }\n                })\n                .debounce(1000, TimeUnit.MILLISECONDS)\n                .observeOn(AndroidSchedulers.mainThread())\n                .subscribe(new Action1<String>() {\n                    @Override\n                    public void call(final String s) {\n                        textView.setText(\"Output : \" + s);\n                    }\n                });\n```\n\n\nNow Kotlin ❤\n\n```kotlin\n        Observable.create(Observable.OnSubscribe<String> { subscriber ->\n            editText.addTextChangedListener(object : TextWatcher {\n                override fun afterTextChanged(s: Editable?) = Unit\n\n                override fun beforeTextChanged(s: CharSequence?, start: Int, count: Int, after: Int) = Unit\n\n                override fun onTextChanged(s: CharSequence, start: Int, before: Int, count: Int)\n                        = subscriber.onNext(s.toString())\n            })\n        }).debounce(1000, TimeUnit.MILLISECONDS)\n                .observeOn(AndroidSchedulers.mainThread())\n                .subscribe({\n                    text ->\n                    textView.text = \"Output : \" + text\n                })\n```\n\n\n#### Even Less Boilerplate →RxBindings!\n\nNow for almost no boilerplate, we can use [**RxBindings**](https://github.com/JakeWharton/RxBinding)which has many super-awesome bindings for UI widgets. And it works on both Java and Kotlin! Using bindings, the code becomes...\n\n```java\n    //Java with Retrolambda and RxBinding\n    RxTextView.afterTextChangeEvents(editText)\n              .debounce(1000,TimeUnit.MILLISECONDS)\n              .observeOn(AndroidSchedulers.mainThread())\n              .subscribe(tvChangeEvent -> {\n                 textView.setText(\"Output : \" + tvChangeEvent.view()\n                            .getText());\n              });\n```\n\n```kotlin\n    //Kotlin with RxBinding\n    RxTextView.afterTextChangeEvents(editText)\n              .debounce(1000, TimeUnit.MILLISECONDS)\n              .observeOn(AndroidSchedulers.mainThread())\n              .subscribe { tvChangeEvent ->\n                        textView.text = \"Output : \" + tvChangeEvent.view().text\n              }\n```\n\nAs you would’ve noticed, there’s very little boilerplate and the code is much more to-the-point. If I were to go back to this code in a few months, it would hardly take me a minute to figure out what’s going on. And that is... Priceless!\n\nHere are some awesome resources for Rx that I recommend. Do check these out! I will further play around with Rx+(Kotlin & Java) and complete part 2, so stay tuned and happy coding!\n\n* [Official Rx Page](http://reactivex.io)\n* [Grokking RxJava Series by Dan Lew](http://blog.danlew.net/2014/09/15/grokking-rxjava-part-1/)\n* [Android Rx, and Kotlin : A case study](http://beust.com/weblog/2015/03/23/android-rx-and-kotlin-a-case-study/)\n* [Replace AsyncTasks with Rx](http://stablekernel.com/blog/replace-asynctask-asynctaskloader-rx-observable-rxjava-android-patterns/)\n* [PhilosophicalHacker Blog on Rx](http://www.philosophicalhacker.com/2015/06/12/an-introduction-to-rxjava-for-android/)\n* [Implementing EventBus in Rx](http://nerds.weddingpartyapp.com/tech/2014/12/24/implementing-an-event-bus-with-rxjava-rxbus/)\n* [RxKotlin](https://github.com/ReactiveX/RxKotlin)\n\n","author":"Ahmed Rizwan","date":"2015-06-27","type":"article","categories":["Kotlin","RxAndroid","Android"],"features":["highlightjs"],"description":"","filename":"","lang":"EN","enclosure":null},{"title":"Few thoughts about Kotlin and why I like it so much","url":"http://blog.dhananjaynene.com/2016/04/few-thoughts-about-kotlin-and-why-i-like-it-so-much/","body":"\nIt doesn't matter how many languages you have learnt, learning yet another one is always a wonderful experience. I have been working for a couple of months with Kotlin. Have got one app to ready for production state and another in the works.\n\nTo cut to the chase, I am really impressed by this language. As in really really impressed. And so I decided that I should write a few posts that can help readers get a better idea and learn about this language. So I started writing out the series and am already onto the third post now. But as I was writing it, I realised what I was writing was really about the mechanics of the language. Not so much about its spirit. Cos when one gets into the tactical nitty gritty details, one tends to miss the forest for the trees. So I decided to pen that here before I start that series (next week), and here's my few thoughts about why I really enjoy the language.\n\nOne of the reasons there is a lot of enthusiasm with the language is because it can be readily used for programming to the Android platform. That is how I ended up learning it. But very soon, my enthusiasm spread into the desktop/server space where I think Kotlin deserves a shout out for a very very credible effort.\n\n[ EDIT: Deleted a few paragraphs]\n\nSo what does Kotlin bring to the table?\n\n* Runs on the JVM\n* Is extremely good at interoperating with existing java code and libraries.\n* Statically typed (thus far far easier to refactor)\n* Has a bit more evolved type system than Java.\n* Is much safer than Java. Nullability is a first class compiler level construct - something that helps address a large number of likely defects aka the billion dollar bug). There is a lot to write home about here.\n* Has a clear system of distinguishing between mutable and immutable structures. While it doesn't make an opinionated stand in favour of immutability, it gives you the programmer enough helpful constructs to chart your course down that path.\n* Has support for type inference which helps reduce your boiler plate and keeps code shorter\n* Has a wonderful story to tell in terms of it providing programmers an ability to write extension functions to existing classes (or for that matter even primitives).\n* Support for Higher Order Functions, Higher kinded types\n* Support for Android programming and JavaScript execution engine (experimental).\n\nDoes that make it the better language? I personally think it has achieved amongst the best set of tradeoffs that are attractive to me (obviously YMMV). And here's why I enjoy it so much.\n\n* Its expressivity is comparable to and superior than python keeping your code short and sweet\n* It being a statically typed language helps enormously speed up refactoring exercises. Even though I have been using it for only two months, I went through at least two brutal refactoring cycles and found Kotlin code to be a pleasure to change.\n* It is safer, lot lot safer than python / java and delegates one of the most frequent tasks of programming ie. null checking to the compiler. Thats a huge effort of the back along with reduction in number of probable defects. Surely nothing to complain about here. And believe me this is a big big plus point.\n* Uses the JVM which is a fine and fast runtime engine\n* It is easy to learn. I actually went through the reference from start to end in 2 days and was a half decent programmer in about a weeks time. Since then I have written functional libraries for Option, Either, Stack, List, HTTP Clients, XML parsing helper libraries, rather complex X.509 certificate trust chain verifiers and a complete Java FX based app. Have started playing around with more functional constructs such as currying, functors etc. Look forward to working more with typeclasses. I just don't think I could have had such a pace of progress with any other language.\n* It is non opinionated. For XML parsing I wanted to ensure very low memory footprint because I wanted to use it on android. I was able to write a library which heavily used mutation even as it maintained very low memory usage by keeping extra object allocation counts down. For another situation I wanted to use immutable functional paradigm, and Kotlin happily let me create my own Option/Either/List classes and use that paradigm end to end. It doesn't get in your way. And focuses on getting work done.\n* I have been interfacing with a large number of java libraries. The interoperability has been an absolute breeze. It is actually refreshing to go through that experience. Doesn't matter if you are dealing with HTTP client APIs, integrating into a Slack HTTP service, interfacing with Java PKCS API, Kotlin does it easily and safely.\n\nIn a nutshell, I can write code that is safer, shorter, uses better building blocks, is easier to grok, gives me all the nice capabilities such as HOFs, lambdas, pretty competent type system that gives me all the feedback necessary when writing code and makes refactoring a breeze, and interoperates nicely and leverages the JVM universe.\n","author":"Dhananjay Nene","date":"2016-04-15","type":"article","categories":["Kotlin"],"features":["highlightjs"],"description":"","filename":"","lang":"EN","enclosure":null},{"title":"Kotlin: a new JVM language you should try","url":"https://opencredo.com/kotlin/","body":"\n## Kotlin 1.0 is here\n\n[JetBrains](https://www.jetbrains.com/) (the people behind IntelliJ IDEA) have [recently announced](http://blog.jetbrains.com/kotlin/2016/02/kotlin-1-0-released-pragmatic-language-for-jvm-and-android/) the first RC for version 1.0 of [Kotlin](https://kotlinlang.org/), a new programming language for the JVM. I say ‘new’, but Kotlin has been in the making for a few years now, and has been used by JetBrains to develop several of their products, including Intellij IDEA. The company [open-sourced](https://github.com/JetBrains/kotlin) Kotlin in 2011, and have worked with the community since then to make the language what it is today.\n\n![Kotlin](https://opencredo.com/wp-content/uploads/2016/02/kronshtadt.jpg)\n\n## What is Kotlin and why you should care\n\nThere is no shortage of [JVM languages](https://en.wikipedia.org/wiki/List_of_JVM_languages) to choose from these days. Kotlin (named after [Kotlin island](https://en.wikipedia.org/wiki/Kotlin_Island), near St. Petersburg, pictured above) positions itself as a pragmatic and easy-to-use alternative to Java, with which it is highly interoperable, to the point where you can mix Kotlin and Java code in the single codebase. The emphasis on interoperability lowers the adoption barrier, which can make Kotlin rather appealing to any Java developer who wished Java was more expressive and less verbose. Kotlin compiles to Java 6-compatible bytecode so you can use the powerful features it offers on older JVM versions (or Android where it has become quite popular already).\n\n## Hello World! with Kotlin\n\nLet’s see some code and compare it with Java and Scala (from which Kotlin has borrowed quite a few language constructs) to get a first impression about the language and highlight a few differences compared to the alternatives.\n\n```kotlin\n// Kotlin\nfun main(args: Array<String>) {\n    println(\"Hello, World!\")\n}\n```\n\n```scala\n// Scala\nobject App {\n  def main(args: Array[String]) {\n    println(\"Hello, world!\")\n  }\n}\n```\n\n```java\n// Java\npublic class App {\n    public static void main(String[] args) {\n        System.out.println(\"Hello, World!\");\n    }\n}\n```\n\nYou can observe almost immediately how compact Kotlin’s version is (even compared to Scala). Kotlin benefits from top-level (or package-level) functions that are not members of a class or object, which is perfect for the `main` function. Since package declaration is omitted the function belongs to the default package.\n\nThere are a few language features shown above that make Kotlin programs somewhat similar to Scala ones:\n\n* Type declarations are defined after function argument names, variable names or function/method names\n* the `Unit` return type (equivalent to Java void) is optional\n* `Array` is a regular generic type\n* The `println()` function, and other print functions, are available implicitly\n* semicolons are optional :)\n\n## Type system\n\nKotlin’s type system is close enough to Java’s to provide a good level of interoperability, although it still empowers developers to produce elegant code in a productive way; for instance, type inference removes the need to declare variable types everywhere. A lot of features in Kotlin have been influenced by the [Effective Java](http://www.oracle.com/technetwork/java/effectivejava-136174.html) series, and try to tackle some of the not-so-great elements that Java has inherited from its early days. Kotlin makes it easier to follow best practice, and prevents some of the more questionable practices completely.\n\nThe key features of Kotlin’s type system (compared to Java) are:\n\n\n* every class inherits from type `Any`, which defines only 3 functions (`equals()`, `hashCode()` and `toString()`), compared to quite a few more in Java’s `Object`\n* all [data types](https://kotlinlang.org/docs/reference/basic-types.html) are represented by classes, including numbers (`Int`, `Long`, `Double`, etc.), characters (`Char`) and booleans (`Boolean`)\n* a class’s primary [constructor](https://kotlinlang.org/docs/reference/classes.html#constructors) can be defined as part of the class declaration\n```kotlin\nclass Foo(val bar: String, val baz: Int)\n```\n* the `new` keyword is missing\n```kotlin\nval foo = Foo(\"bar\", 42)\n```\n* there are no static methods and any static code needs to be defined in a [class companion object](https://kotlinlang.org/docs/reference/object-declarations.html#companion-objects)\n* classes and functions are final by default and have to be declared `open` to be overridable\n* any type can be enhanced by using [extension functions](https://kotlinlang.org/docs/reference/extensions.html) to define additional functions/methods (no more `xUtils` classes)\n* [generics](https://kotlinlang.org/docs/reference/generics.html) have been revamped to make working with variance much easier\n* [objects](https://kotlinlang.org/docs/reference/object-declarations.html) can be used to implement the singleton pattern or to avoid the need for anonymous inner classes\n* [data classes](https://kotlinlang.org/docs/reference/data-classes.html) make it trivial to create Java Bean-style data containers\n```kotlin\ndata class Person(val firstName: String, val lastName: String)\n```\n\n## Functional programming\n\nKotlin is not a functional language but provides decent support for FP elements where they make sense in the OO world. It lifts functions to first-class-citizen status and makes using them very easy (the same sadly can’t be said about Java, even in version 8). Kotlin supports [higher-order functions](https://kotlinlang.org/docs/reference/lambdas.html#higher-order-functions) which means that functions can be passed in as arguments to other functions or returned from functions.\n\n```kotln\n// List.map() is an example of a higher-order function\nfun  List.map(transform: (T) -> R): List {\n  val result = arrayListOf()\n  for (item in this)\n    result.add(transform(item))\n  return result\n}\n```\n\nAdditionally, [lambda expressions](https://kotlinlang.org/docs/reference/lambdas.html#lambda-expression-syntax) and [anonymous functions](https://kotlinlang.org/docs/reference/lambdas.html#anonymous-functions) can be used when function expressions or references are expected.\n\n```kotlin\nval doubled = ints.map { it -> it * 2 }\n```\n\nSome other nice features around working with [functions](https://kotlinlang.org/docs/reference/functions.html#functions) in Kotlin include:\n\n\n* default argument values\n```kotlin\nfun read(b: Array, off: Int = 0, len: Int = b.size()) {...}\n```\n* named arguments\n```kotlin\nread(bytes, len = 100)\n```\n* infix notation\n```kotlin\nval plusOne = value + 1 // plus operator is a function call using infix notation\n```\n* Unit return is optional\n```kotlin\nfun printMe(message: String): Unit { println(message) }\n```\n* single-expression functions\n```kotlin\nfun printMe(message: String): Unit = println(message)\n```\n* tail-recursive functions\n```kotlin\ntailrec fun findFixPoint(x: Double = 1.0): Double = if (x == Math.cos(x)) x else findFixPoint(Math.cos(x))\n```\n\n## Null safety\n\nHandling null references has been quite a chore in Java from the very beginning. In recent versions of the language a few utility classes have been added to make it somewhat more manageable (`Objects` in Java 7 and Optional in Java 8 come to mind), but the language itself doesn’t provide much-needed native support. Kotlin is different as it adopts and further enhances Groovy’s approach to [null-safety](https://kotlinlang.org/docs/reference/null-safety.html) and makes working with object references less of a hassle.\n\nBy default, the compiler will prevent assigning null value to an object reference and you have to explicitly declare a variable as nullable.\n\n```kotlin\nvar a: String = \"abc\"\na = null // compilation error\n\nvar b: String? = \"abc\" // '?' declares variable as nullable\nb = null // ok\n```\n\nWith that initial safety feature in place you can then safely follow nullable object references without worrying about `NullPointerException` (or employing an excessive degree of null-checking). Additionally, the so-called Elvis operator (surely you can see Elvis’ hair do in `?:`) provides a syntactic sugar for defining a default value if a null reference has been encountered.\n\n```kotlin\nval departmentHead = employee?.department?.head?.name ?: \"n/a\"\n```\n\nOn top of that, Kotlin offers safe-casting support, where instead of throwing ClassCastException the expression returns a null value.\n\n```kotlin\nval aInt: Int? = a as? Int\n```\n\n## Collections\n\nUnlike Scala, Kotlin doesn’t provide its own collection framework built from ground up. The rationale behind that choice is Java interoperability. Collections are the bread and butter of software engineering and the team behind Kotlin decided they didn’t want to make it difficult to use Java collections from Kotlin, or to make developers to learn new collection types. [Collections in Kotlin](https://kotlinlang.org/docs/reference/collections.html) reflect those in Java with one difference – Kotlin distinguishes between immutable and mutable collections, favouring immutability (although mutable Java collections are being used behind the scenes).\n\n```kotlin\nval numbers: MutableList = mutableListOf(1, 2, 3)\nval readOnlyView: List = numbers\nprintln(numbers)        // prints \"[1, 2, 3]\"\nnumbers.add(4)\nprintln(readOnlyView)   // prints \"[1, 2, 3, 4]\"\nreadOnlyView.clear()    // -> does not compile\n\nval strings = hashSetOf(\"a\", \"b\", \"c\", \"c\")\nassert(strings.size == 3)\n```\n\nAdditionally, the [collection API in Kotlin](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/index.html) offers a range of easy-to-use extension functions around collection types.\n\n```kotlin\nval items = listOf(1, 2, 3, 4)\nitems.first() == 1\nitems.last() == 4\nitems.filter { it % 2 == 0 }   // returns [2, 4]\nitems.filter { it % 2 == 0 } take 1 forEach { println(it) } // prints out 2\nitems.fold(0) { total, current -> total + current } // returns 10\n```\n\nCreating and using maps is quite convenient too.\n\n```kotlin\nval readWriteMap = hashMapOf(\"foo\" to 1, \"bar\" to 2)\nprintln(readWriteMap[\"foo\"])\nval readOnlyView: Map = HashMap(readWriteMap)\nval doubled = readOnlyView.mapValues { entry -> entry.value * 2 }\nfor ((key, value) in doubled) println(\"$key -> $value\")\n```\n\n## Control flow\n\nKotlin offers some improved [control flow constructs](https://kotlinlang.org/docs/reference/control-flow.html), certainly compared with Java. So for instance, the `if ... else` block is an expression (returns a value).\n\n```kotlin\nval max = if (a > b) a else b\n```\n\nThe `switch` operator (as found in C and Java) has been replaced by `when` expression form, similar to pattern-matching in Scala, that also makes a convenient replacement for `if ... else` chains.\n\n```kotlin\nwhen {\n  x.isOdd() -> print(\"x is odd\")\n  x.isEven() -> print(\"x is even\")\n  else -> print(\"x is funny\")\n}\n```\n\nThe `when` expression supports [smart-casts](https://kotlinlang.org/docs/reference/typecasts.html#smart-casts) too, when combined with matching on the type of the when argument.\n\n```kotlin\nval hasPrefix = when(x) {\n  is String -> x.startsWith(\"prefix\") // x is automatically casted to String\n  else -> false\n}\n```\n\nA `for` loop can iterate over any type that provides an iterator implementing `next()` and `hasNext()`.\n\n```kotlin\nfor (item in collection)\n  print(item)\n\nfor ((index, value) in array.withIndex()) {\n    println(\"the element at $index is $value\")\n}\n```\n\n## Other features\n\nI think we’ve covered quite a lot already, but there are still a few more features worth highlighting to round up the language overview:\n\n* [string templates](https://kotlinlang.org/docs/reference/basic-types.html#string-templates) (known in Scala as string interpolation) make it easy to format string messages easily by resolving variables and expressions\n\n```kotlin\nval s = \"abc\"\nval str = \"$s.length is ${s.length}\" // evaluates to \"abc.length is 3\"\n```\n* [destructuring](https://kotlinlang.org/docs/reference/multi-declarations.html) allows convenient extraction of data class or collection elements\n```kotlin\nval person = Person(\"Rafal\", 22) // I wish I was 22 again!\nval (name, age) = person\n\nfor ((key, value) in map) {\n   // Map.Entry can be destructured too\n}\n```\n* [type checks](https://kotlinlang.org/docs/reference/typecasts.html) support smart-casting\n```koltin\nif (x is String) {\n   print(x.length) // x is automatically cast to String\n}\n```\n* [structural equality](https://kotlinlang.org/docs/reference/equality.html#structural-equality) can be checked simply with the `==` operator (no need to use `equals()`)\n* [referential equality](https://kotlinlang.org/docs/reference/equality.html#referential-equality) can be checked with the `===` operator\n* creating [ranges](https://kotlinlang.org/docs/reference/ranges.html) is supported natively\n```koltin\nfor (i in 1..10 step 2) println(i)\n```\n* predefined [operators can be overloaded](https://kotlinlang.org/docs/reference/operator-overloading.html) (so no crazy operators allowed but still quite powerful)\n* all [exceptions](https://kotlinlang.org/docs/reference/exceptions.html) are unchecked (no more forced exception handling)\n* `try` is an expression\n```koltin\nval a: Int? = try { parseInt(input) } catch (e: NumberFormatException) { null }\n```\n* [type-safe builders](https://kotlinlang.org/docs/reference/type-safe-builders.html) help creating rich DSLs\n```koltin\nhtml {\n  head {\n     title {+\"HTML built with Kotlin\"}\n  }\n  // ...\n}\n```\n\nBy now I’m sure you are overloaded with all this Kotlin knowledge, so I will stop here. I hope I was able to showcase the entire host of very powerful capabilities that Kotlin offers. By all means explore [the language reference](https://kotlinlang.org/docs/reference/) to find out more about various language features.\n\n## Java interoperability\n\nOne of the design goals behind Kotlin has always been to stay close enough to Java to lower the barrier to adoption. Obviously, on the other hand the need to stay interoperable limits the the scope to introduce many new features into the language. I think Kotlin has managed to achieve quite a lot without breaking its ties to the Java world.\n\nMost of the [interoperability](https://kotlinlang.org/docs/reference/java-interop.html) aspects revolve around mapping concepts or types between both languages.\n\nFor instance, since Java doesn’t offer null safety support similar to Kotlin, Java types are treated in a special way and called [platform types](https://kotlinlang.org/docs/reference/java-interop.html#null-safety-and-platform-types). Null checks are relaxed for such types with the risk of `NullPointerExceptions` being thrown at runtime.\n\n```\nval list = ArrayList() // non-null (constructor result)\nlist.add(\"Item\")\nval size = list.size() // non-null (primitive int)\nval item = list[0] // platform type inferred (ordinary Java object)\n\nitem.substring(1) // allowed, may throw an exception if item == null\n\nval nullable: String? = item // allowed, always works\nval notNull: String = item // allowed, may fail at runtime\n```\n\nSimilarly, Java generics are handled in a special way when types are imported to Kotlin and using Java arrays of primitives requires a workaround where specialised classes are used to represent them in Kotlin.\n\nWhen it comes to [Kotlin classes being called from Java](https://kotlinlang.org/docs/reference/java-to-kotlin-interop.html), much of the work required to make them interoperable happens on the Kotlin side. Developers can use an range of annotations to instruct the compiler to produce code that will be usable from Java.\n\n## Tooling\n\nOne of the interesting aspects about Kotlin is that the language has been created by the company behind a popular IDE product. As one might expect IDE support (well, for Intellij IDEA at least) for Kotlin has been very much a part of working on the language itself. The result is a comprehensive [Kotlin support in Intellij IDEA](https://kotlinlang.org/docs/tutorials/getting-started.html) on a par with that for Java. JetBrains also maintains an [Eclipse plugin for Kotlin](https://kotlinlang.org/docs/tutorials/getting-started-eclipse.html) so this open-source IDE should also provide a good level of support.\n\nKotlin creators have resisted the need to redefine much of the external tooling around the language. So for instance Kotlin projects can be built using Maven, Gradle or even Ant so except for the compiler plugin not much else is changing for those coming from the Java background.\n\n## Kotlin ecosystem\n\nThere is a growing community around the language so perhaps not surprisingly one can already find a good selection of open-source libraries and frameworks written in Kotlin. If you want to stick with your favourite Java framework, you don’t have to make a full transition to Kotlin as you can use your existing framework in Kotlin without too much hassle and even mix Java and Kotlin code in a single codebase.\n\nThe official Kotlin website lists several [tools, libraries and frameworks](https://kotlinlang.org/docs/resources.html), covering MVC/Web, HTTP client, dependency injection and text editor support among over things. Also, the [Awesome Kotlin](https://kotlin.link) GitHub website offers a great selection of resources to explore.\n\n## Summary\n\nI believe Kotlin deserves at least a try, especially if you are coming from the Java background. The language brings a lot of good features from Scala and Groovy closer to Java, so you can benefit from the best of both worlds: the vastness of the Java ecosystem with expressiveness and productivity enhanced by constructs and features coming from other languages. If you do want to give Kotlin a go, why don’t you [try it online](http://try.kotlinlang.org/) first or just create a Kotlin project in your favourite IDE and start experimenting with it.\n\nThroughout this post I was covering Kotlin from the perspective of somebody coming from Java as I believe this is a primary expansion area for the new language. It’s worth knowing that Kotlin is also targeting Android development (also Java but still on version 6) as well as (still experimental) JavaScript runtime as an alternative to the JVM. With such a wide range of applications and some great features I reckon Kotlin stands a good chance of attracting quite a few new users.\n\n","author":"Rafal Gancarz","date":"2016-03-03","type":"article","categories":["null","Kotlin"],"features":["highlightjs"],"description":"","filename":"","lang":"EN","enclosure":null},{"title":"Gradle Script Kotlin 0.9.0 Release Notes","url":"https://github.com/gradle/gradle-script-kotlin/releases/tag/v0.9.0","body":"\nGradle Script Kotlin 0.9.0 Release Notes\n========================================\n\nGradle Script Kotlin v0.9.0 is another major step forward in usability, bringing improvements to the DSL, IntelliJ experience, performance, and finally automatic detection of Kotlin based builds.\n\nv0.9.0 is expected to be included in the upcoming Gradle 4.0 RC1.\n\nThe features in this release are also available for immediate use within the latest Gradle Script Kotlin distribution snapshot. To use it, upgrade your Gradle wrapper in the following fashion:\n\n    $ cd $YOUR_PROJECT_ROOT\n    $ gradle wrapper --gradle-distribution-url https://repo.gradle.org/gradle/dist-snapshots/gradle-script-kotlin-4.0-20170518042627+0000-all.zip\n\nUpdates since v0.8.0\n--------------------\n\n * **Automatic detection of Kotlin based builds** ([#37][10037], [#80][10080]). After a little more than an year since the issue was first added to our board this huge usability improvement has finally landed!\n\n    No more `rootProject.buildFileName = 'build.gradle.kts'` boilerplate or `settings.gradle` file required in order to enable Kotlin build script! :tada:\n\n * **Default imports for the whole Gradle API** ([#215][100215], [#347][100347]). To make build scripts more concise, the set of default imports now includes the whole Gradle API as documented in the [Default imports section of the Gradle User Guide](https://docs.gradle.org/current/userguide/writing_build_scripts.html#script-default-imports).\n\n * **Improved Gradle API with type safe setters** ([#341][100341]). Kotlin recognizes mutable JavaBean properties only when both the getter and at least one setter agree on the property type.\n\n     More than 50 strongly typed setters have been recently added to the Gradle API enabling build scripts to migrate from invocation heavy configuration syntax such as:\n\n    ```kotlin\n    val someBuild by tasks.creating(GradleBuild::class) {\n        setDir(file(\"some/path\"))      // NOT RECOGNIZED AS PROPERTY BECAUSE OF UNTYPED SETTER\n        setTasks(listOf(\"foo\", \"bar\")) // NOT RECOGNIZED AS PROPERTY BECAUSE OF UNTYPED SETTER\n    }\n    ```\n\n    to the more declarative:\n\n    ```kotlin\n    val someBuild by tasks.creating(GradleBuild::class) {\n        dir = file(\"some/path\")\n        tasks = listOf(\"foo\", \"bar\")\n    }\n    ```\n\n * **Improved project extension accessors with properties** ([#330][100330]). So one can now write `java.sourceSets` instead of `java().sourceSets` as in `0.8.0`.\n\n * **API documentation** ([#209][100209]). A first cut of this important piece of documentation, generated using [Dokka](https://kotlinlang.org/docs/reference/kotlin-doc.html), is now available at https://gradle.github.io/gradle-script-kotlin-docs/api/.\n\n * **IntelliJ improvements**\n\n   * **Classpath computation is now asynchronous** ([#249][100249]). And should no longer block the UI (pending a fix to [this IntelliJ issue](https://youtrack.jetbrains.com/issue/KT-17771))\n\n   * **Type-safe accessors are correctly included in the classpath given to IntelliJ** ([#340][100340]). Upon changes to the `plugins` block (pending a fix to [this IntelliJ issue](https://youtrack.jetbrains.com/issue/KT-17770))\n\n   * **Source code navigation now works for everything Gradle** ([#281][100281]).\n\n     ![source-code-navigation](https://cloud.githubusercontent.com/assets/51689/25772994/1fb02b2a-324c-11e7-91aa-8c7e51c86d86.gif)\n\n   * **Source code navigation to sources of included Kotlin libraries** ([#96][10096]). As long as there's at least one `buildscript` repository configured that can resolve the Kotlin source artifacts.\n\n * **Miscellaneous**\n\n   * **Polished Android Sample** ([#351][100351]). With all the improvements in this release, our [hello-android sample](https://github.com/gradle/gradle-script-kotlin/tree/master/samples/hello-android) is now boilerplate free:\n\n        ```kotlin\n        buildscript {\n            dependencies {\n                classpath(\"com.android.tools.build:gradle:2.3.1\")\n                classpath(kotlinModule(\"gradle-plugin\"))\n            }\n            repositories {\n                jcenter()\n            }\n        }\n\n        apply {\n            plugin(\"com.android.application\")\n            plugin(\"kotlin-android\")\n        }\n\n        android {\n            buildToolsVersion(\"25.0.0\")\n            compileSdkVersion(23)\n\n            defaultConfig {\n                minSdkVersion(15)\n                targetSdkVersion(23)\n\n                applicationId = \"com.example.kotlingradle\"\n                versionCode = 1\n                versionName = \"1.0\"\n            }\n\n            buildTypes {\n                getByName(\"release\") {\n                    isMinifyEnabled = false\n                    proguardFiles(\"proguard-rules.pro\")\n                }\n            }\n        }\n\n        dependencies {\n            compile(\"com.android.support:appcompat-v7:23.4.0\")\n            compile(\"com.android.support.constraint:constraint-layout:1.0.0-alpha8\")\n            compile(kotlinModule(\"stdlib\"))\n        }\n\n        repositories {\n            jcenter()\n        }\n        ```\n\n        And it works with the latest Android Studio (2.3.2).\n\n   * **Gradle initialization overhead removed** ([#320][100320]). The implementation of type-safe accessors in `0.8.0` added some undue overhead to project configuration even when there was no Kotlin build script involved. This has been fixed.\n\n   * **Idiomatic support for Gradle's `PropertyState<T>` and `ConfigurableFileCollection` properties** ([#344][100344]). Via Kotlin delegated properties:\n\n        ```kotlin\n        open class GreetingPluginExtension(project: Project) {\n\n            // Declare a `PropertyState<String>` backing field\n            private\n            val messageState = project.property<String>()\n\n            // Expose `messageState` as the `message` property whose type is inferred as String\n            var message by messageState\n\n            // Can also be exposed as `Provider<String>` for additional functionality\n            val messageProvider: Provider<String> get() = messageState\n\n            // `outputFiles` property type is inferred as `ConfigurableFileCollection`\n            // with the following behaviour:\n            //  - getting will always return the original instance\n            //  - setting will `setFrom` the source\n            var outputFiles by project.files()\n        }\n        ```\n\n        Check out the [provider-properties sample](/gradle/gradle-script-kotlin/tree/master/samples/provider-properties) for more information.\n\n   * **Better caching behaviour for type-safe accessors** ([#338][338]).\n\n * **Bug fixes**\n\n    * **Setting non-existent Kotlin build script in settings.gradle no longer causes the build to fail** ([#302][100302], [#331][100331]). Following standard Gradle behaviour.\n\n    * **Generated extension accessor for the `publishing` extension will work as expected** ([#327][100327], [#328][100328]). And defer configuration until necessary.\n\n    * **Projects with Kotlin build scripts in `buildSrc` can be edited with the correct classpath in IntelliJ** ([#339][100339]). As build scripts will now be executed in a best-effort manner when computing the classpath.\n\n\n[10037]: https://github.com/gradle/gradle-script-kotlin/issues/37\n[10080]: https://github.com/gradle/gradle-script-kotlin/issues/80\n[100215]: https://github.com/gradle/gradle-script-kotlin/issues/215\n[100347]: https://github.com/gradle/gradle-script-kotlin/issues/347\n[100341]: https://github.com/gradle/gradle-script-kotlin/issues/341\n[100330]: https://github.com/gradle/gradle-script-kotlin/issues/330\n[100209]: https://github.com/gradle/gradle-script-kotlin/issues/209\n[100249]: https://github.com/gradle/gradle-script-kotlin/issues/249\n[100340]: https://github.com/gradle/gradle-script-kotlin/issues/340\n[100281]: https://github.com/gradle/gradle-script-kotlin/issues/281\n[10096]: https://github.com/gradle/gradle-script-kotlin/issues/96\n[100351]: https://github.com/gradle/gradle-script-kotlin/issues/351\n[100320]: https://github.com/gradle/gradle-script-kotlin/issues/320\n[100344]: https://github.com/gradle/gradle-script-kotlin/issues/344\n[100338]: https://github.com/gradle/gradle-script-kotlin/issues/338\n[100302]: https://github.com/gradle/gradle-script-kotlin/issues/302\n[100331]: https://github.com/gradle/gradle-script-kotlin/issues/331\n[100327]: https://github.com/gradle/gradle-script-kotlin/issues/327\n[100328]: https://github.com/gradle/gradle-script-kotlin/issues/328\n[100339]: https://github.com/gradle/gradle-script-kotlin/issues/339\n","author":"Rodrigo B. de Oliveira","date":"2017-05-18","type":"article","categories":["Kotlin","Gradle Script Kotlin"],"features":["highlightjs"],"description":"","filename":"","lang":"EN","enclosure":null},{"title":"A DSL Workbench with Gradle and Kotlin","url":"http://jonnyzzz.com/blog/2016/03/08/gradle-for-dsl/","body":"\n\nEasy to use. This is one of a main tasks to solve then new tool is created. For the world of DSL this\nmostly mean it should be easy to a end-user to use the tool and to be able to run the tool within\na continuous integration build easily.\n\nI found an elegant way to fiddle a DSL tasks into Gradle to make it easy to use. Next I'll cover an example\nof [TeamCity2DSL](https://github.com/jonnyzzz/TeamCity2DSL) where I implemented this approach.\n\nDomain description\n------------------\n\nI will not cover the domain where [TeamCity2DSL](https://github.com/jonnyzzz/TeamCity2DSL) is\napplied. This deserves a dedicated post(s) (link will be included here).\nAll we need to know about TeamCity2DSL here are\n\n- it provides a way to describe build settings with [Kotlin](https://kotlinlang.org/) DSL\n- the DSL is executed to generate XML settings that TeamCity understands\n- it also generates DSL from existing XML settings from TeamCity\n\nHere goes tricks one need to handle to use the TeamCity2DSL\n\n* download TeamCity2DSL classes\n* have Kotlin sources with DSL complied\n* allow an IDE to be used to author/edit DSL code\n\nThis is vital to provide as easy as possible way to run those tasks. This is where our Gradle plugin is used.\n\nTeamCity2DSL Gradle Plugin\n--------------------------\n\nThe plugin does the following set of tricks\n\n* it setups project repositories and dependencies\n* setups dependency on Kotlin runtime and compiler\n* declares `dsl2xml` and `xml2dsl` tasks\n* adds DSL generation output folder as Kotlin sources\n* introduces a dependency on compilation from `dsl2xml` task\n\n\nA Gradle Plugin Usage Example\n-----------------------------\n\nThis is `build.gradle` script that is only required to have both TeamCity2DSL tasks (`dsl2xml` and `xml2dsl`) supported\n\n```groovy\nbuildscript {\n  repositories {\n    jcenter()\n    mavenCentral()\n    maven { url \"https://dl.bintray.com/jonnyzzz/maven\" }\n  }\n\n  dependencies {\n    classpath 'org.jonnyzzz.teamcity.dsl:gradle-plugin:<PLUGIN VERSION>'\n  }\n}\n\napply plugin: 'org.jonnyzzz.teamcity.dsl'\n```\n\n*NOTE*. Replace `<PLUGIN VERSION>` with the latest version\nfrom the [maven repository](https://bintray.com/jonnyzzz/maven/teamcity2dsl/view)\n*NOTE2*. We also assume\n[TeamCity project settings XML files](https://confluence.jetbrains.com/display/TCD10/Storing+Project+Settings+in+Version+Control)\nare located in a `.teamcity` folder.\n\n\nIDE Usages\n----------\n\nThe project opens in IntelliJ IDEA. It detects all dependencies, Kotlin, source roots, library sources, etc.\nNo specific requirements here. It *Just Works*. And again an easy-to-use pattern is implemented.\n\nImplementation Details\n======================\n\nI use [Kotlin](https://kotlinlang.org/) in [TeamCity2DSL](https://github.com/jonnyzzz/TeamCity2DSL).\nThe Gradle plugin is implemented with Kotlin as well.\n\nThe first trick is the plugin itself declares a dependency on\n[Kotlin Gradle plugin](https://kotlinlang.org/docs/reference/using-gradle.html). The version of Kotlin\nis selected from plugin dependency. This allows to avoid\nexplicit configuration for Kotlin.\n```groovy\nproject.apply { config ->\n  config.plugin(\"java\")\n  config.plugin(\"kotlin\")\n}\n```\n\nThe plugin includes DSL dependencies to itself into `compile` configuration. Those jars are predefined and\nwe make Gradle download them from Maven repository.\n```groovy\nval dsl2xml = project.tasks.create(\"dsl2xml\", Dsl2Xml::class.java)\ndsl2xml.dependsOn(project.tasks.getByName(\"classes\"))\n```\n\nNext, we include all `buildScript` block repositories into code repositories. This helps to avoid\nduplicates in repositories declaration.\n```groovy\nproject.buildscript.repositories.forEach { project.repositories.add(it) }\n```\n\nTo add extra source directory we use the following code (that depends on Gradle's Java plugin)\n\n```groovy\nprintln(\"Adding DSL path to Kotlin source set: ${settings.dslPath}\")\nval sourceSets = project.convention.getPlugin(JavaPluginConvention::class.java).sourceSets\n\nprintln(\"Source sets: ${sourceSets.names}\")\nsourceSets.getByName(\"main\").java.srcDir( settings.dslPath!!.path )\n```\n\nWe know Kotlin plugin checks Java output path for kotlin sources too. So we depend here only on Java plugin,\nnot on a private API of the Kotlin plugin.\n\nThe task implementation uses a custom classloader (with `null` parent) to avoid bothering Gradle's tasks\nexecution classpath. This is too complicated, from the other hand, to synchronize dependencies\nof TeamCity2DSL and Gradle. In the future we may consider running an external processes for better stability.\n\nFinally\n=======\n\nWe created a Gradle plugin that helps to use a Kotlin DSL.\n\nEverything that is related to the setup and execution of tasks is now packed as a Gradle Plugin\nleading to easy-to-use and easy-to-adopt solution.\n\nThis pattern could be re-used for other applications.\n\nFeel free to try [TeamCity2DSL](https://github.com/jonnyzzz/TeamCity2DSL) for TeamCity project settings domain.\n\n","author":"Eugene Petrenko","date":"2016-03-08","type":"article","categories":["Gradle","DSL","Teamcity2DSL","Kotlin"],"features":["highlightjs"],"description":"","filename":"","lang":"EN","enclosure":null},{"title":"Kotlin 1.1: What’s coming in the standard library","url":"https://blog.jetbrains.com/kotlin/2017/01/kotlin-1-1-whats-coming-in-the-standard-library/","body":"\nJava 9 is coming and brings [Project Jigsaw](http://openjdk.java.net/projects/jigsaw/spec/sotms/) to the table — the Java platform module system. One of the constraints it imposes is that no two modules can declare public API in the same package. The situation, when there are two modules that contribute to the same package, is called “split” package.\n\nWe face this issue with split packages in our runtime artifacts: first, kotlin-runtime and kotlin-stdlib modules share a lot of kotlin.* packages, second, kotlin-runtime and kotlin-reflect share kotlin.reflect package. What we’re going to do to make our artifacts more friendly to the module system:\n\n1. We merge kotlin-runtime and kotlin-stdlib into the single artifact kotlin-stdlib. Also we’re going to rename kotlin-runtime.jar, shipped in the compiler distribution, to kotlin-stdlib.jar, to reduce the amount of confusion caused by having differently named standard library in different build systems.\n    That rename will happen in two stages: in 1.1 there will be both kotlin-runtime.jar and kotlin-stdlib.jar with the same content in the compiler distribution, and in 1.2 the former will be removed.\n2. In kotlin-reflect module we move all API from kotlin.reflect to kotlin.reflect.full package. Kotlin 1.1 will have the former API deprecated with the replacements suggested, and it will be removed eventually in 1.2.\n    Note that this change will affect only extension functions and properties provided by kotlin-reflect for reflection interfaces and a couple of exception classes. Reflection interfaces themselves are located in the standard library and won’t be moved.\n\nIf you use maven or gradle and depend on kotlin-stdlib, you won’t need to change anything. If you depend on kotlin-runtime, you should replace that dependency with kotlin-stdlib.\n\n## New Standard Library API in 1.1\n\nHere we introduce new functions and classes that are going to be published in Kotlin 1.1.\n\nIf you have already tried these new bits in Kotlin 1.1-Beta or in earlier releases and have some feedback, do not hesitate to share it in our [forum](https://discuss.kotlinlang.org/), [slack](https://kotlinlang.org/community.html) or [issue tracker](https://youtrack.jetbrains.com/issues/KT).\n\n### takeIf() and also()\n\nThese are two general-purpose extension functions applicable to any receiver.\n\n`also` is like `apply`: it takes the receiver, does some action on it, and returns that receiver.\nThe difference is that in the block inside `apply` the receiver is available as `this`,\nwhile in the block inside `also` it’s available as `it` (and you can give it another name if you want).\nThis comes handy when you do not want to shadow `this` from the outer scope:\n\n```kotlin\nfun Block.copy() = Block().also { it.content = this.content }\n```\n\n`takeIf` is like `filter` for a single value. It checks whether the receiver meets the predicate, and\nreturns the receiver, if it does or `null` if it doesn’t.\nCombined with an elvis-operator and early returns it allows to write constructs like:\n\n```kotlin\nval outDirFile = File(outputDir.path).takeIf { it.exists() } ?: return false\n// do something with existing outDirFile\n\nval index = input.indexOf(keyword).takeIf { it >= 0 } ?: error(\"keyword not found\")\n// do something with index of keyword in input string, given that it's found\n```\n\n### groupingBy()\n\nThis API is to group a collection by key and fold each group in the same time. It consists of two parts: `groupingBy` function, and terminal operations — `fold`, `reduce`, `eachCount`.\n\nFirst you invoke `collection.groupingBy { key }` function, which just returns a `Grouping` instance binding the provided key selector to the collection of elements. Then you call one of folding operations available for `Grouping`, which iterates the collection and populates the resulting map with the result of folding elements in each group.\n\nFor example, it can be used to count the frequencies of characters in a text:\n\n```kotlin\nval charFrequencies: Map<Char, Int> = text.groupingBy { it }.eachCount()\n```\n\n### minOf() and maxOf()\n\nThese functions can be used to find the lowest and greatest of two or three given values, where values are primitive numbers or `Comparable` objects. There is also an overload of each function that take an additional `Comparator` instance, if you want to compare objects that are not comparable themselves.\n\n```kotlin\nval list1 = listOf(\"a\", \"b\")\nval list2 = listOf(\"x\", \"y\", \"z\")\nval minSize = minOf(list1.size, list2.size)\nval longestList = maxOf(list1, list2, compareBy { it.size })\n```\n\n### Map.getValue()\n\nThis extension on `Map` returns an existing value corresponding to the given key or throws an exception, mentioning which key was not found.\nIf the map was produced with `withDefault`, this function will return the default value instead of throwing an exception.\n\n```kotlin\nval map = mapOf(\"key\" to 42)\n// returns non-nullable Int value 42\nval value: Int = map.getValue(\"key\")\n// throws NoSuchElementException\nmap.getValue(\"key2\")\n\nval mapWithDefault = map.withDefault { k -> k.length }\n// returns 4\nval value2 = mapWithDefault.getValue(\"key2\")\n```\n\n### Map.minus() operator\n\nIn Kotlin 1.0 you could easily get a copy of a read-only Map with a new key-value pair inserted with the extension operator `Map.plus()`. However to remove a key from the map you have to resort to less straightforward ways to like `Map.filter()` or `Map.filterKeys()`.\nNow `Map.minus()` operator fills this gap. There are 4 overloads available: for removing a single key, a collection of keys, a sequence of keys and an array of keys.\n\n```kotlin\nval map = mapOf(\"key\" to 42)\nval emptyMap = map - \"key\"\n```\n\n### Array-like List instantiation functions\n\nSimilar to the `Array` constructor, there are now functions that create `List` and `MutableList` instances and initialize each element by calling a lambda:\n\n```kotlin\nList(size) { index -> element }\nMutableList(size) { index -> element }\n```\n\n### String to number conversions\n\nThere is a bunch of new extensions on the String class to convert it to a number without throwing an exception on invalid number:\n`String.toIntOrNull(): Int?`, `String.toDoubleOrNull(): Double?` etc.\n\n```kotlin\nval port = System.getenv(\"PORT\")?.toIntOrNull() ?: 80\n```\n\nNote that these functions will box resulting numbers before returning them, since the return type is nullable, and nullable numbers are represented as boxed values.\n\nAlso integer conversion functions, like `Int.toString()`, `String.toInt()`, `String.toIntOrNull()`,\neach got an overload with `radix` parameter, which allows to specify the base of conversion (2 to 36).\n\n### onEach()\n\n`onEach` is a small, but useful extension function for collections and sequences, which allows to perform some action, possibly with side-effects, on each element of the collection/sequence in a chain of operations.\nOn iterables it behaves like `forEach` but also returns the iterable instance further. And on sequences it returns a wrapping sequence, which applies the given action lazily as the elements are being iterated.\n\n```kotlin\ninputDir.walk()\n        .filter { it.isFile && it.name.endsWith(\".txt\") }\n        .onEach { println(\"Moving $it to $outputDir\") }\n        .forEach { moveFile(it, File(outputDir, it.toRelativeString(inputDir))) }\n```\n\n### Map.toMap() and Map.toMutableMap()\n\nThese functions can be used for easy copying of maps:\n\n```kotlin\nclass ImmutablePropertyBag(map: Map<String, Any>) {\n    private val mapCopy = map.toMap()\n}\n```\n\n### Abstract collections\n\nThese abstract classes can be used as base classes when implementing Kotlin collection classes.\nFor implementing read-only collections there are `AbstractCollection`, `AbstractList`, `AbstractSet` and `AbstractMap`, and for mutable collections there are `AbstractMutableCollection`, `AbstractMutableList`, `AbstractMutableSet` and `AbstractMutableMap`.\nOn JVM these abstract mutable collections inherit most of their functionality from JDK’s abstract collections.\n","author":"ilya.gorbunov","date":"2017-01-24","type":"article","categories":["Kotlin"],"features":["highlightjs"],"description":"","filename":"","lang":"EN","enclosure":null},{"title":"Kotlin 1.1-M04 is here!","url":"https://blog.jetbrains.com/kotlin/2016/12/kotlin-1-1-m04-is-here/","body":"\nWe are glad to present you the fourth milestone of the upcoming Kotlin release. We’re wrapping up the development of the version 1.1, with the final release planned for Q1 2017. Most features are already in decent shape, so it is a good time to try it and give us your feedback. We will appreciate it a lot!\n\nAs with other milestone releases, we give **no backwards compatibility guarantees** for new language and library features. Anything introduced in milestone releases of 1.1 is **subject to change** before the final 1.1 release.\n\nPlease do share your feedback regarding the new features or any problems that you may run into with this release, via [YouTrack](https://youtrack.jetbrains.com/issues/KT), [forums](https://discuss.kotlinlang.org) and [Slack](http://kotlinlang.slack.com/).\n\nThis milestone brings a significant rework of coroutine syntax and semantics, making coroutines simpler and more flexible. It also contains standard library enhancements, new language features and compiler plugins, numerous features and improvement in the JS backend, and many other fixes and updates.  \nThe new release also includes all features introduced in the [Kotlin 1.0.6](https://discuss.kotlinlang.org/t/kotlin-1-0-6-eap/2117/10), including updates for compatibility with **Android Studio 2.3 Beta 1**.\n\nThe full changelog is available [here](https://github.com/JetBrains/kotlin/blob/1.1-M04/ChangeLog.md) and some key changes are listed below:  \n\n## Coroutines\n\nWe have significantly re-thought the coroutines design, making it simpler, composable and more powerful:\n\n* All suspending and coroutine builder functions now have intuitive signatures (no more weird transformations to memorise).\n* There is only one basic language concept of suspending functions and the corresponding suspending function types. The special `coroutine` keyword was dropped. The coroutine is now simply an instance of a suspendable computation that is started using `startCoroutine` function from the standard library.\n* Complex suspending functions can be composed out of more primitive suspending functions. In this release they can tail-call other suspend functions, but this restriction will be lifted in the future.\n* Suspending functions can be defined to wrap any callback-style API and can be freely used inside any asynchronous coroutine. The controllers are not needed anymore. The `generate` and `yield` pair, that builds synchronous sequences, restricts suspensions inside generate blocks using `@RestrictsSuspension` annotation.\n* Type inference for coroutines is now implemented. You can omit types in most use-cases for coroutine builders and the types will be inferred automatically.\n\nThe classical `await` suspending function can now be implemented via a tail-call to the `suspendCoroutine` suspending function that is a part of the standard library:\n\n```kotlin\nsuspend fun <T> await(f: CompletableFuture<T>): T =\n    suspendCoroutine<T> { c: Continuation<T> ->\n        f.whenComplete { result, exception ->\n            if (exception == null) // the future has been completed successfully\n                c.resume(result) \n            else // the future has been completed with an exception\n                c.resumeWithException(exception)\n        }\n    }\n```\n\nThe corresponding builder is called `async` and implemented via the `startCoroutine` function:\n\n```kotlin\nfun <T> async(block: suspend () -> T): CompletableFuture<T> {\n    val future = CompletableFuture<T>()\n    block.startCoroutine(completion = object : Continuation<T> {\n        override fun resume(value: T) {\n            future.complete(value)\n        }\n        override fun resumeWithException(exception: Throwable) {\n            future.completeExceptionally(exception)\n        }\n    })\n    return future\n}\n```\n\nAnd they can be used together to write a more naturally-looking code with futures:\n\n```kotlin\nasync {\n    val original = asyncLoadImage(\"...original...\") // creates a Future\n    val overlay = asyncLoadImage(\"...overlay...\")   // creates a Future\n    ...\n    // suspend while awaiting the loading of the images\n    // then run `applyOverlay(...)` when they are both loaded\n    return applyOverlay(original.await(), overlay.await())\n}\n```\n\nHowever, futures are just one of many supported use-cases for coroutines. The full overview of the coroutine implementation and their usage samples are available in the revised [KEEP document](https://github.com/Kotlin/kotlin-coroutines/blob/master/kotlin-coroutines-informal.md).\n\nWe think that now we have got a great design of coroutines for Kotlin, but we realize that it has not been battle-tested enough. Therefore we are going to release it in 1.1 under an opt-in incubation flag. Starting from this milestone you’ll get “This feature is experimental: coroutines” warning when using coroutines. You can turn off this warning with `-Xcoroutines=enable` compiler flag or disable this features with `-Xcoroutines=error` compiler flag. The corresponding setting is also available under Kotlin compiler settings in the IDEA. To set this option for a gradle project you can add `kotlin.coroutines=enable` or `kotlin.coroutines=error` to local.properties file at the root of project.\n\nIf you are using [kotlinx.coroutines](https://github.com/Kotlin/kotlinx.coroutines) library please use updated version `0.2-alpha-1`, adapted to the newest changes in the coroutines design. This version also introduces `yieldAll` method in the generate scope. Please see the [readme file](https://github.com/Kotlin/kotlinx.coroutines/blob/master/README.md) for further details.\n\n## Language features\n\n### Type for properties can be inferred from getter\n\nFor example in the code below the type for the property `foo` will be inferred as `String`. See the issue [KT-550](https://youtrack.jetbrains.com/issue/KT-550) for some more details.\n\n```kotlin\nval foo get() = \"\"\n```\n\n### Floating point related features, fixes and improvements\n\nFloating point number comparisons now use IEEE 754 compliant comparison where the type is known statically to be `Double` or `Float`. For ranges of floating point numbers we’ve introduced specialized `ClosedFloatingPointRange` interface, which provides its own comparison method, so that extension operations employing ranges, like `coerceIn`, could be implemented on top of that. Its instances are obtained with the operator `..` invoked on two `Float` or `Double` values. See [KT-4481](https://youtrack.jetbrains.com/issue/KT-4481) and [KT-14651 for details.](https://youtrack.jetbrains.com/issue/KT-14651)\n\n### Interception of delegated property binding\n\nIt is possible now to intercept delegate to property binding using the `provideDelegate` operator.  \nFor example, if we want to check property name before binding, we can write something like this:\n\n```kotlin\nclass ResourceLoader<T>(id: ResourceID<T>) {\n    operator fun provideDelegate(thisRef: MyUI, property: KProperty<*>): ReadOnlyProperty<MyUI, T> {\n        checkProperty(thisRef, property.name)\n        ... // property creation\n    }\n\n    private fun checkProperty(thisRef: MyUI, name: String) { ... }\n}\n\nfun <T> bindResource(id: ResourceID<T>): ResourceLoader<T> { ... }\n\nclass MyUI {\n    val image by bindResource(ResourceID.image_id)\n    val text by bindResource(ResourceID.text_id)\n}\n```\n\nHere method `provideDelegate` will be called in constructor initializer for class `MyUI`. So, we can check property consistency at the moment of creation. Earlier such checks were only possible at the moment of calling getter or setter.\n\nUnfortunately, the feature is not yet properly documented, but you can use [this draft document](https://github.com/orangy/KEEP/blob/fabb56360f2d7a293ac720cace89cd445da3c919/proposals/attach-to-property.md#createdelegate) as an initial reference.\n\n### Enhanced nullability of some JDK methods\n\nSome functions in JDK have a nullability contract defined in the documentation, some do not accept null values, some never return null, and yet others can return null sometimes.  \nUnfortunately, the JDK does not use any annotations to express such contracts and only states them in the docs. Once before 1.0 we used an external annotations artifact for the JDK which could be supplied to the compiler to alter the signatures of JDK functions, but that approach wasn’t reliable enough.\n\nNow we’re introducing another approach: embedding the information required to enhance the JDK signatures directly into the compiler. As a first step we cover the nullability of a small subset of the API:\n\n* `java.util.Optional` factory and member functions:\n    * `of`: that doesn’t allow null values\n    * `ofNullable`, it takes a nullable value, and return an `Optional` of non-nullable type.\n    * `get` always return non-nullable value.\n* `java.lang.ref.Reference` and all of its inheritors, like `WeakReference` and `SoftReference`:\n    * `get` returns a nullable value, as it can become null at any moment if the referenced object is garbage collected.\n* default methods of JDK’s `Iterator`, `Iterable`, `Collection`, `List`, `Map` which are exposed as platform-dependent functions of Kotlin builtin collection interfaces.\n* java functional types, now they have non-platform types in their invocation methods when they’re constructed with non-platform types.\n\nThese enhancements are safe in most cases. In particular, they are safe when the enhanced type becomes more specific (non-nullable) in return position or more general (nullable) in parameter position. But when the type is changed in the opposite direction, the change will be breaking.  \nWe strive not to introduce such breaking enhancements unless not respecting the correct nullability would lead to an exception in runtime. So for example `Optional.of` now takes a non-nullable argument which is more restrictive, but trying to pass `null` to that method would result in an exception anyway.  \nOn the other hand, we decided not to specify the correct nullability for `File.listFiles` which actually can return null sometimes, because in most cases there’s no meaningful fallback other than to throw another exception.\n\n### Other changes\n\n* Problem of using a non-public member from a public inline function could now be resolved with the `@PublishedApi` annotation. When it’s applied on an _internal_ member, it becomes effectively public and available to invoke from a public inline function.. See [KT-12215](https://youtrack.jetbrains.com/issue/KT-12215) for details.\n* `const val` is now inlined at the call site (see [KT-11734](https://youtrack.jetbrains.com/issue/KT-11734))\n* SAM conversions have now the same priority in overload resolution as regular members. That fixes [KT-11128](https://youtrack.jetbrains.com/issue/KT-11128) and alike.\n* We consider our choice of `mod` name for `%` (remainder) operator a mistake with some not so nice consequences (see e.g. [KT-14650](https://youtrack.jetbrains.com/issue/KT-14650)). Therefore we decided to introduce `rem` operator, deprecate the `mod` and provide all tools to make this transition smooth.\n\n## Standard library\n\n### String to number conversions\n\nThere is a bunch of new extensions on the `String` class to convert it to a number without throwing an exception on invalid number: `String.toIntOrNull(): Int?`, `String.toDoubleOrNull(): Double?` etc.  \nBeware that these functions will box resulting numbers before returning them, as the return type assumes it.\n\nAlso integer conversion functions, like `Int.toString()`, `String.toInt()`, `String.toIntOrNull()`, each got an overload with `radix` parameter, which allows to specify the base of conversion.\n\nWe would like to thank [Daniil Vodopian](https://github.com/voddan) for his substantial contribution to the development of these functions.\n\n### onEach\n\n`onEach` is a small, but useful extension function for collections and sequences, which allows to perform some action, possibly with side-effects, on each element of the collection/sequence in a chain of operations.  \nOn iterables it behaves like `forEach` but also returns the iterable instance further. And on sequences it returns a wrapping sequence, which applies the given action lazily as the elements are being iterated.\n\nThanks to [Christian Brüggemann](https://github.com/cbruegg) for the initial prototype.\n\n## JavaScript backend\n\n### `external` instead of `@native`\n\nFrom this milestone `@native` annotation becomes deprecated and instead you have to use `external` modifier.  \nUnlike the JVM target, the JS one permits to use `external` modifier with classes and properties.  \nNote, that you don’t need to mark members of `external` classes as `external`: this modifier  \nis automatically inherited by the members. So, instead of\n\n```kotlin\n@native fun alert(message: Any?): Unit {}\n```\n\nyou can write\n\n```kotlin\nexternal fun alert(message: Any?)\n```\n\n### Improved import handling\n\nYou can now describe declarations which should be imported from JavaScript modules more precisely.  \nIf you add `@JsModule(\"<module-name>\")` annotation on an external declaration it will be properly imported to a module system (either CommonJS or AMD) during the compilation. For example, with CommonJS the declaration will be imported via `require(...)` function.  \nAdditionally, if you want to import a declaration either as a module or as a global JavaScript object, you can use `@JsNonModule` annotation\n\nLet’s see the full example below. You can import jQuery library to a Kotlin source file like this:\n\n```kotlin\n@JsModule(\"jquery\")\n@JsNonModule\n@JsName(\"$\")\nexternal abstract class JQuery {\n    fun toggle(duration: Int = 0): JQuery\n    fun click(handler: (Event) -> Unit): JQuery\n}\n\n@JsModule(\"jquery\")\n@JsNonModule\n@JsName(\"$\")\nexternal fun JQuery(selector: String): JQuery\n```\n\nIn this case, JQuery will be imported as a module named `jquery` and alternatively, it can be used as a `$`-object, depending on what module system Kotlin compiler is configured to use.\n\nYou can use these declarations in your application like this:\n\n```kotlin\nfun main(args: Array<String>) {\n    JQuery(\".toggle-button\").click {\n        JQuery(\".toggle-panel\").toggle(300)\n    }\n}\n```\n\nYou can check the generated JS code for this snippet for the CommonJS and “plain” module systems [here](https://gist.github.com/ligee/50d30ad9bca5ea925ff7d913ff232004).\n\n## How to Try It\n\n**In Maven/Gradle:** Add [http://dl.bintray.com/kotlin/kotlin-eap-1.1](http://dl.bintray.com/kotlin/kotlin-eap-1.1) as a repository for the build script and your projects; use 1.1-M04 as the version number for the compiler and the standard library.\n\n**In IntelliJ IDEA:** Go to _Tools → Kotlin → Configure Kotlin Plugin Updates_, then select “Early Access Preview 1.1” in the _Update channel_ drop-down list, then press _Check for updates_.\n\nThe **command-line compiler** can be downloaded from the [Github release page](https://github.com/JetBrains/kotlin/releases/tag/v1.1-M04).\n\n**On [try.kotlinlang.org](http://try.kotlinlang.org)**. Use the drop-down list at the bottom-right corner to change the compiler version to 1.1-M04.\n\nMerry Kotlin!\n\n","author":"Ilya Chernikov","date":"2016-12-21","type":"article","categories":["Kotlin"],"features":["highlightjs"],"description":"","filename":"","lang":"EN","enclosure":null},{"title":"Creating an AndroidWear watchface using Kotlin","url":"https://medium.com/@robj.perez/creating-an-androidwear-watchface-using-kotlin-e5f725813fa9#.xcftwvys6","body":"\n### Creating an AndroidWear watchface using Kotlin\n\n![](https://d262ilb51hltx0.cloudfront.net/max/600/1*78W0Fk8Ca3OGCdZiebTvSw.png)\n\nLast week we released our [latest watch face](https://play.google.com/store/apps/details?id=com.meronapps.lcdmodularwatchface) for Android Wear, and it is a little bit special, it is the first done using something different from Java. It is entirely written in Kotlin. In this post I would like to share our experiences while building it and how doing in the language created by Jetbrains has improved the development process.\n\nTo add a little bit of context, [we are](http://meronapps.com) a Madrid based small company which, among other things, have been doing a lot of wearables applications, we have worked with Pebble, Sony smartwatch, Samsung’s Tizen, Apple Watch and, of course, Android Wear. In our Google’s OS take on watches, this is our seventh watch face, and all of them were developed using the ubiquitous Java.\n\nIf you don’t know Kotlin, it is a open sourced language designed by Jetbrains, yes, they are the ones behind the powerful IntelliJ Idea, the IDE which powers Android Studio. Kotlin is yet another language for the JVM and brings a lot of fresh air to JVM development. Since it does not uses any “strange” things like AOT compilation or bytecode generation, it is fully interoperable with Java and it works wherever Java works, so it does in Android. If you haven’t took it a look, I recommend you to do it, you can get started at [https://kotlinlang.org/](https://kotlinlang.org/)\n\nOnce we did the introductions, let’s go to the heart of the post, the learnings from our watch face development.\n\n#### Ready for Production\n\nDuring the development of the watchface, Kotlin 1.0 was officially released, but truth is said, everything worked perfectly. Developer tools are formed by several packages, and all of them worked pretty well even though they were beta versions, which became stable afterwards.\n\nAndroid Studio Kotlin plugin works pretty well, it helps you with code completion, syntax highlighting, code navigation, code conversion from Java and all the candies you can expect from a mature IDE.\n\nKotlin’s Android gradle plugin was perfectly integrated with Android, you just click on Run, and it works on your phone, zero problems. There is just a single issue, the new feature from the Android build tools, Instant Run, doesn’t work yet. This was somehow expected, if you know how it works by patching the dex file, it is expected that the compilation process of Kotlin might has some problems with it.\n\nSince we started using Kotlin when it was about to reach 1.0, the language itself is pretty stable, the syntax changes, if any, didn’t have any impact in our code, we didn’t have any problems the compiler and standard library either.\n\n#### Fully interoperable with Java\n\nOne of the pillars of this language is that it is fully compatible with all the existing Java code, it means that you can use all Android libraries, and if you already have libraries and code, you can call it without any problems nor changes.\n\nThis feature is key to adopt Kotlin in your new developments, in fact, we started by using some of our libraries which we have developed for all of our projects. What it happened, is that we converted all those libraries to Kotlin and now our previous projects are using a library written using kotlin code.\n\n#### No more _if (foo != null)_ and less NullPointerException\n\nIf you are a java developer, you probably have suffered the curse of writing _if (foo != null)_ thousand of times, and when you forget it, a _NullPointerException_ will remind you to write it.\n\nKotlin tries to eliminate this infamous check with some syntax sugar. If a variable can be null, you need to explicit say it, you cannot assign a null to a _String_ type, but you can do it to a _String?_. (note the question mark at the end). You cannot dereference a _?_ variable without explicitly unwrapping it either by using !! or by using a _?_ at the end. If a variable is null and you use a _?_ at the end, it won’t crash with a NPE. That means you can write _rectangle?.size?.width?_, if rectangle or size is null, nothing happens.\n\n#### Fill your listeners using cool lambdas\n\nWhen it comes to java, you know that you are going to put in use you typing skills. Chances are that you are using a modern IDE and it will save you a little bit from that pain, but all the boilerplate code is there.\n\nIf you write Applications which respond to events like an Android application or an UI app, this is particularly notorious when you need to write control _Listeners_. Kotlin does magic in this side, if you need to implement an Interface which has only one method, you can use a Kotlin lambda to do it, saving you hundreds of characters and making your code more expressive with less useless decorations. Let’s see an example to show this better\n\n```java\n// Java (129 characters of boilerplate code)\n\nview.setOnClickListener(new OnClickListener() {\n  @Override\n  public void onClick(View v) {\n    // Do something cool\n  }\n});\n```\n\n```kotlin\n// Kotlin (37 characters to do exactly the same)\n\nview.onClick { // Do something cool }\n```\n\n#### No more findViewById\n\nThis point is specifically related with Android. Kotlin has a library called Android Extensions which will save you from typing useless code.\n\nWhen I started in Android Programming some years ago, I hated why I needed to write so many _findViewById()_ and hated more the typecast of that method. For non Android programmers, that method returns a generic _View_ and you probably will need to cast it to a _Button_ or a _TextView_ to do something useful with it. Among other cool things, the Android Extensions library allows you to use any view from a layout just by using its id. You only need to import the layout like it was another class and all ids will be visible in your code magically.\n\n```java\n// Java\n\nTextView tv = ((TextView)findViewById(R.id.my_textview)).setText(“Java y u make me write so much!”)\n```\n\n```kotlin\n// Kotlin\n\nimport kotlinx.android.synthetic.main_layout.*\nmy_textview.text = \"isn’t kotlin cool?\"\n```\n\n#### Syntax sugar\n\nKotlin has a lot more to offer in terms of making your code more readable and allowing you to type less. Java getters and setters are automatically converted to properties, instead of write _person.getName()_ or _setName(“”)_, Kotlin allows you call that java code by writing _person.name_ or _person.name = “”._\n\nLike modern languages, you don’t need to write the type of a variable when the compiler can infer the type, which can be done most of the times.\n\nAssignments can contain a conditional expresions, Kotlin has mutable and inmutable references, I usually feel safer when a variable is inmutable, sometimes, the value of a variable depends on some condition, and this could force you to make the variable mutable. I think this is better explained by this piece of code.\n\n```java\n// Java\n\nString greeting = null;\nif (isDaytime()) {\n  greeting = “Good Morning”;\n} else {\n  greeting = “good Evening”;\n}\n```\n\nKotlin allows you to write it in this way:\n\n```kotlin\nval greeting = if (isDaytime()) {\n  “Good Morning”\n} else {\n  “Good Evening”\n}\n```\n\nUsing this code, greeting is inmutable and you don’t need to check if it is null when using this variable.\n\n#### Vibrant community\n\nOne of the important things when using a new technology is the how its users communicate themselves. Kotlin community is great, you only need to connect to its slack channels and you will be able to talk with the developers of the language. Moreover, an increasing number of projects are starting to be developed using Kotlin, so you can share your experiences with others and learn by talking with them.\n\n#### Conclusions\n\nI could be talking about the features of Kotlin which we used while developing the watch face for hours, things like the functional features of Kotlin, the pattern matching of “switch” clauses, the bugs that optional types and immutability has saved us time of debugging and so on. In our experience choosing of Kotlin has been a great decision, it made our code more readable and one of the most important outcomes, we enjoyed a lot while developing the application which at the end is all that matters, isn’t it? :).\n\n","author":"Roberto Perez","date":"2016-03-28","type":"article","categories":["Android","Android Wear","Kotlin"],"features":["highlightjs"],"description":"","filename":"","lang":"EN","enclosure":null},{"title":"A Whirlwind Tour of the Kotlin Type Hierarchy","url":"http://natpryce.com/articles/000818.html","body":"\nKotlin has plenty of good [language documentation](https://kotlinlang.org/docs/reference/) and [tutorials](https://kotlinlang.org/docs/tutorials/). But I’ve not found an article that describes in one place how Kotlin’s type hierarchy fits together. That’s a shame, because I find it to be really neat[<sup>1</sup>](#fn1).\n\nKotlin’s type hierarchy has very few rules to learn. Those rules combine together consistently and predictably. Thanks to those rules, Kotlin can provide useful, user extensible language features – null safety, polymorphism, and unreachable code analysis – without resorting to special cases and ad-hoc checks in the compiler and IDE.\n\n## Starting from the Top\n\nAll types of Kotlin object are organised into a hierarchy of subtype/supertype relationships.\n\nAt the “top” of that hierarchy is the abstract class `Any`. For example, the types String and Int are both subtypes of `Any`.\n\n![](http://natpryce.com/articles/000818/any-intrinsics.png)\n\n`Any` is the equivalent of Java’s `Object` class. Unlike Java, Kotlin does not draw a distinction between “primitive” types, that are intrinsic to the language, and user-defined types. They are all part of the same type hierarchy.\n\nIf you define a class that is not explicitly derived from another class, the class will be an immediate subtype of Any.\n\n    class Fruit(val ripeness: Double)\n\n![](http://natpryce.com/articles/000818/any-user-defined-type.png)\n\nIf you do specify a base class for a user-defined class, the base class will be the immediate supertype of the new class, but the ultimate ancestor of the class will be the type Any.\n\n    abstract class Fruit(val ripeness: Double)\n    class Banana(ripeness: Double, val bendiness: Double): \n        Fruit(ripeness)\n    class Peach(ripeness: Double, val fuzziness: Double): \n        Fruit(ripeness)\n\n![](http://natpryce.com/articles/000818/any-user-defined-type-hierarchy.png)\n\nIf your class implements one or more interfaces, it will have multiple immediate supertypes, with Any as the ultimate ancestor.\n\n```kotlin\ninterface ICanGoInASalad\ninterface ICanBeSunDried\n\nclass Tomato(ripeness: Double): \n    Fruit(ripeness), \n    ICanGoInASalad, \n    ICanBeSunDried \n```\n\n![](http://natpryce.com/articles/000818/interfaces.png)\n\nThe Kotlin type checker enforces subtype/supertype relationships.\n\nFor example, you can store a subtype into a supertype variable:\n\n```kotlin\nvar f: Fruit = Banana(bendiness=0.5)\nf = Peach(fuzziness=0.8)\n```\n\nBut you cannot store a supertype value into a subtype variable:\n\n```kotlin\nval b = Banana(bendiness=0.5)\nval f: Fruit = b\nval b2: Banana = f\n// Error: Type mismatch: inferred type is Fruit but Banana was expected \n```\n\n## Nullable Types\n\nUnlike Java, Kotlin distinguishes between “non-null” and “nullable” types. The types we’ve seen so far are all “non-null”. Kotlin does not allow `null` to be used as a value of these types. You’re guaranteed that dereferencing a reference to a value of a “non-null” type will never throw a NullPointerException.\n\nThe type checker rejects code that tries to use null or a nullable type where a non-null type is expected.\n\nFor example:\n\n```kotlin\nvar s : String = null\n// Error: Null can not be a value of a non-null type String\n```\n\nIf you want a value to maybe be null, you need to use the nullable equivalent of the value type, denoted by the suffix ‘?’. For example, the type `String?` is the nullable equivalent `String`, and so allows all String values plus null.\n\n```kotlin\nvar s : String? = null\ns = \"foo\"\ns = null\ns = bar\n```\n\nThe type checker ensures that you never use a nullable value without having first tested that it is not null. Kotlin provides operators to make working with nullable types more convenient. See the [Null Safety section of the Kotlin language reference](https://kotlinlang.org/docs/reference/null-safety.html) for examples.\n\nWhen non-null types are related by subtyping, their nullable equivalents are also related in the same way. For example, because `String` is a subtype of `Any`, `String?` is a subtype of `Any?`, and because `Banana` is a subtype of `Fruit`, `Banana?` is a subtype of `Fruit?`.\n\nJust as `Any` is the root of the non-null type hierarchy, `Any?` is the root of the nullable type hierarchy. Because `Any?` is the supertype of `Any`, `Any?` is the very top of Kotlin’s type hierarchy.\n\n![](http://natpryce.com/articles/000818/parallel-nullable-and-non-nullable-hierarchies.png)\n\nA non-null type is a subtype of its nullable equivalent. For example, `String`, as well as being a subtype of `Any`, is also a subtype of `String?`.\n\n![](http://natpryce.com/articles/000818/nullable-string.png)\n\nThis is why you can store a non-null String value into a nullable String? variable, but you cannot store a nullable String? value into a non-null String variable. Kotlin’s null safety is not enforced by special rules, but is an outcome of the same subtype/supertype rules that apply between non-null types.\n\nThis applies to user-defined type hierarchies as well.\n\n![](http://natpryce.com/articles/000818/nullable-hierarchy.png)\n\n## Unit\n\nKotlin is an expression oriented language. All control flow statements (apart from variable assignment, unusually) are expressions. Kotlin does not have void functions, like Java and C. Functions always return a value. Functions that don’t actually calculate anything – being called for their side effect, for example – return `Unit`, a type that has a single value, also called `Unit`.\n\nMost of the time you don’t need to explicitly specify Unit as a return type or return Unit from functions. If you write a function with a block body and do not specify the result type, the compiler will treat it as a Unit function. Otherwise the compiler will infer it.\n\n```kotlin\nfun example() {\n    println(\"block body and no explicit return type, so returns Unit\")\n}\n\nval u: Unit = example()\n```\n\nThere’s nothing special about `Unit`. Like any other type, it’s a subtype of `Any`. It can be made nullable, so is a subtype of `Unit?`, which is a subtype of `Any?`.\n\n![](http://natpryce.com/articles/000818/nullable-unit.png)\n\nThe type `Unit?` is a strange little edge case, a result of the consistency of Kotlin’s type system. It has only two members: the `Unit` value and `null`. I’ve never found a need to use it explicitly, but the fact that there is no special case for “void” in the type system makes it much easier to treat all kinds of functions generically.\n\n## Nothing\n\nAt the very bottom of the Kotlin type hierarchy is the type `Nothing`.\n\n![](http://natpryce.com/articles/000818/nothing.png)\n\nAs its name suggests, Nothing is a type that has no instances. An expression of type Nothing does not return a value.\n\nNote the distinction between Unit and Nothing. An expression type Unit evaluates to the singleton value Unit. An expression of type Nothing never returns at all.\n\nThis means that any code following an expression of type Nothing is unreachable. The compiler and IDE will warn you about such unreachable code.\n\nWhat kinds of expression evaluate to Nothing? Control flow.[<sup>2</sup>](#fn2)\n\nFor example, the `throw` keyword interrupts the calculation of an expression and throws an exception out of the enclosing function. A throw is therefore an expression of type Nothing.\n\nBy having Nothing as a subtype of every other type, the type system allows any expression in the program to actually fail to calculate a value. This models real world eventualities, such as the JVM running out of memory while calculating an expression, or someone pulling out the computer’s power plug. It also means that we can throw exceptions from within any expression.\n\n```kotlin\nfun formatCell(value: Double): String =\n    if (value.isNaN()) \n        throw IllegalArgumentException(\"$value is not a number\")\n    else \n        value.toString()\n```\n\nIt may come as a surprise to learn that the `return` statement has the type Nothing. Return is a control flow statement that immediately returns a value from the enclosing function, interrupting the evaluation of any expression of which it is a part.\n\n```kotlin\nfun formatCellRounded(value: Double): String =\n    val rounded: Long = if (value.isNaN()) return \"#ERROR\" else Math.round(rounded)\n    rounded.toString()\n```\n\nA function that enters an infinite loop or kills the current process has a result type of Nothing. For example, the Kotlin standard library declares the `exitProcess` function as:\n\n```kotlin\nfun exitProcess(status: Int): Nothing\n```\n\nIf you write your own function that returns Nothing, the compiler will check for unreachable code after a call to your function just as it does with built-in control flow statements.\n\n```kotlin\ninline fun forever(action: ()->Unit): Nothing {\n    while(true) action()\n}\n\nfun example() {\n    forever {\n        println(\"doing...\")\n    }\n    println(\"done\") // Warning: Unreachable code\n}\n```\n\nLike null safety, unreachable code analysis is not implemented by ad-hoc, special-case checks in the IDE and compiler, as it has to be in Java. It’s a function of the type system.\n\n## Nullable Nothing?\n\n`Nothing`, like any other type, can be made nullable, giving the type `Nothing?`. `Nothing?` can _only_ contain one value: `null`. In fact, `Nothing?` _is_ the type of `null`.\n\n`Nothing?` is the ultimate subtype of all nullable types, which lets the value `null` be used as a value of any nullable type.\n\n![](http://natpryce.com/articles/000818/nullable-nothing.png)\n\n## Conclusion\n\nWhen you consider it all at once, Kotlin’s entire type hierarchy can feel quite complicated.\n\n![](http://natpryce.com/articles/000818/entire-hierarchy.png)\n\nBut never fear!\n\nI hope this article has demonstrated that Kotlin has a simple and consistent type system. There are few rules to learn: a hierarchy of supertype/subtype relationships with `Any?` at the top and `Nothing` at the bottom, and subtype relationships between non-null and nullable types. That’s it. There are no special cases. Useful language features like null safety, object-oriented polymorphism, and unreachable code analysis all result from these simple, predictable rules. Thanks to this consistency, Kotlin’s type checker is a powerful tool that helps you write concise, correct programs.\n\n\n1. <a name=\"fn1\"></a> “Neat” meaning “done with or demonstrating skill or efficiency”, rather than the [Kevin Costner backstage at a Madonna show](https://www.youtube.com/watch?v=wvZhW47mGNE) sense of the word.\n\n2. <a name=\"fn2\"></a> Apart from loops, which are statements. Variable assignments are also statements.\n\n\n\n","author":"Nat Pryce","date":"2016-10-28","type":"article","categories":["Kotlin"],"features":["highlightjs"],"description":"","filename":"","lang":"EN","enclosure":null},{"title":"The Reactive Scrabble benchmarks","url":"http://akarnokd.blogspot.com.by/2016/12/the-reactive-scrabble-benchmarks.html","body":"\n### Introduction\n\nIn the past year, I've been posting benchmark results under the mysterious Shakespeare Plays (Reactive) Scrabble name. In this blog post, I'll explain what this benchmark is, where does it come from, how it works, what the intent is and how to apply it to your favorite and not-yet-benchmarked library.  \n\n### History\n\nThe benchmark was [designed and developed](https://github.com/JosePaumard/jdk8-stream-rx-comparison) by [Jose Paumard](https://twitter.com/JosePaumard) and results presented in his [2015 Devoxx talk](https://www.youtube.com/watch?v=fabN6HNZ2qY) (a bit long but worth watching). The benchmark measures how fast a certain data-processing library can find the most valuable word from a set of words taken from (one of) Shakespeare's work based on the rules and point schema of Scrabble. RxJava at the time was in its 1.0.x version and to my surprise, it performed poorly compared to Java 8 Streams:  \n\n[![](https://4.bp.blogspot.com/-GfETGQdChZo/WGJLllf3ddI/AAAAAAAAHiA/4d0vZHnioPE-yeQu1RY8OaULmi-gfQvQACLcB/s640/jose_scrabble_results.png)](https://4.bp.blogspot.com/-GfETGQdChZo/WGJLllf3ddI/AAAAAAAAHiA/4d0vZHnioPE-yeQu1RY8OaULmi-gfQvQACLcB/s1600/jose_scrabble_results.png)\n\n[https://youtu.be/fabN6HNZ2qY?t=8369](https://youtu.be/fabN6HNZ2qY?t=8369)\n\nThe benchmark, utilizing JMH, is completely synchronous; no thread hopping happens yet RxJava performs 10x slower, or more likely, it has 10x more overhead in the associated set of operators. In addition, Jose also added a parallel-stream version which runs the main \"loop\" in parallel before joining for the final result.  \n\nMore disappointingly, RxJava 2 developer preview the time was terrible as well (relatively, [measured](https://twitter.com/akarnokd/status/696291409209487360) on a weak CPU in February).  \n\nTherefore, instead of blaming the benchmark or the author, I set out on a quest to understand the benchmark's expectations and improve RxJava 2's performance and if possible, port that back to RxJava 1.  \n\n### The original Stream-benchmark\n\nPerhaps the most easy way to understand how the computation in the benchmark works, Let's see the original, non-parallel `Stream` version of it. Since going sequential or parallel requires only a `sequential()` or `parallel()` operator on a `Stream`, they both extend an abstract superclass containing the majority of the code and only get specialized for the operation mode in two additional classes.  \n\n[ShakespearePlaysScrabbleWithStreamBeta.java](https://github.com/akarnokd/akarnokd-misc/blob/master/src/jmh/java/hu/akarnokd/comparison/scrabble/ShakespearePlaysScrabbleWithStreamsBeta.java)  \n\nI added postfix \"Beta\" - meaning alternate version in this context - to distinguish between a version that has a slight difference in one of the computation steps. I'll explain why when I describe the original RxJava-benchmark down below.  \n\nThe benchmark is built in a somewhat unconventional, perhaps over-functionalized manner and I had a bit of trouble putting the functionality back together in my head. It isn't that complicated though.  \n\nThe inputs to the benchmark are hidden in a base class' fields `shakespeareWords` (`HashSet<String>`), `scrabbleWords` (`HashSet<String>`), `letterScore` (`int[]`) and `scrabbleAvailableLetters` (`int[]`). `shakespeareWords` contains all the words, lowercased, of Shakespeare's work. `scrabbleWords` contains the allowed words, lowercased, by Scrabble itself. `letterscore` contains the scores of the scores of letters through a-z and `scrabbleAvailableLetters` (seems to me) is there to limit the score if the particular letter appears multiple times in a word.  \n\nThe benchmark, due to dependencies of one step on the other, is written in \"backwards\" order, starting with a function that finds the score of a letter. Given an English letter with code `96-121`, the function maps it to the `0-25` range and gets the score from the array.  \n\n```java\nIntUnaryOperator scoreOfALetter = letter -> letterScores[letter - 'a'];\n```\n\nThe next function, given a histogram of letters in a word in the form of a `Map.Entry` (where the key is the letter and the value is the number of occurrence in the word), calculates a bounded score of that letter in the word.\n\n```java\nToIntFunction<Entry<Integer, Long>> letterScore =\n    entry ->\n        letterScores[entry.getKey() - 'a'] *\n        Integer.min(\n            entry.getValue().intValue(),\n            scrabbleAvailableLetters[entry.getKey() - 'a']\n        );\n```\n\nFor that, we need the actual histogram of words which is computed by the following function:  \n\n```java\nFunction<String, Map<Integer, Long>> histoOfLetters =\n    word -> word.chars()\n                .boxed()\n                .collect(\n                    Collectors.groupingBy(\n                        Function.identity(),\n                        Collectors.counting()\n                    )\n                );\n```\n\nThis is where a particular dataflow library comes into play. Given a word as Java `String`, split it into individual characters and count how many of each character is in that word. For example, \"jezebel\" will count `1-j`, `3-e`, `1-z`, `1-b` and `1-l`. In the Stream version, the `IntStream` of characters provided by `String` itself is converted into a boxed `Stream<Integer>` and grouped into a `Map` by a counting standard collector with no key mapping. Note that the return type of the function is `Map` and not `Stream<Map>`.  \n\nThe next function calculates the blank score of a character occurrence:  \n\n```java\nToLongFunction<Entry<Integer, Long>> blank =\n    entry ->\n        Long.max(\n            0L,\n            entry.getValue() -\n                scrabbleAvailableLetters[entry.getKey() - 'a']\n        );\n```\n\nGiven an entry from the histogram above, it gives bonus points if the particular letter occurs more than its score in the `scrabbleAvailableLetters` array. For example, if the letter '`d`' appears twice, the `scrabbleAvailableLetters` for it is 1 and this computes to 1. If the letter 'e' appears twice, the array entry for it is 12 and the function computes 0.  \n\nThe next function combines the `histoOfLetters` with the `blank` function to compute the number of blanks in an entire word:  \n\n```java\nFunction<String, Long> nBlanks =\n    word -> histoOfLetters.apply(word)\n                          .entrySet().stream()\n                          .mapToLong(blank)\n                          .sum();\n```\n\nHere the histogram of the letters in the given word is computed and returned in a `Map<Integer, Long>`, then each entry of this `Map` is streamed, mapped into the blank letter value and then summed up into a final value. (Honestly, I'm not familiar with the rules of Scrabble and this last two functions seem to be extra convolution to have the computation work harder.)  \nThe follow-up function takes the result of `nBlanks` and checks if a word can be written with 2 or less blanks:  \n\n```java\nPredicate<String> checkBlanks = word -> nBlanks.apply(word) <= 2;\n```\n\nThe next 2 functions pick the first 3 and last 3 letters of a word:  \n\n```java\nFunction<String, IntStream> first3 = word -> word.chars().limit(3);\nFunction<String, IntStream> last3 = word -> word.chars().skip(Integer.max(0, word.length() - 4));\n```\n\nThese won't stay separated and are immediately combined back together:  \n\n```java\nFunction<String, IntStream> toBeMaxed =\n    word -> Stream.of(first3.apply(word), last3.apply(word))\n                  .flatMapToInt(Function.identity());\n```\n\nPractically, the first 3 and last 3 letters (with possibly overlap for shorter words) are concatenated back into a single IntStream via `flatMapToInt`, i.e., \"jezebel\" will stream letter-by-letter as \"jezbel\".  \n\nGiven the merged character stream, we compute the maximum score of the letters:  \n\n```java\nToIntFunction<String> bonusForDoubleLetter =\n     word -> toBeMaxed.apply(word)\n                      .map(scoreOfALetter)\n                      .max()\n                      .orElse(0);\n```\n\nNote that `IntStream.max()` returns `Optional`.  \n\nWe then calculate the final score of a word:  \n\n```java\nFunction<String, Integer> score3 =\n    word ->\n        2 * (score2.apply(word) + bonusForDoubleLetter.applyAsInt(word))\n        + (word.length() == 7 ? 50 : 0);\n```\n\nThis involves a bonus 50 points for words with length 7 and twice the score of the base word and the double letter bonus. Note that both `score2` and `bonusForDoubleLetter` are evaluated once and multiplied by the literal two.  \n\nNow we reach the actual \"loop\" for calculating the scores of each word in the Shakespeare word set:  \n\n```java\nFunction<Function<String, Integer>, Map<Integer, List<String>>> buildHistoOnScore =\n    score -> shakespeareWords.stream()\n             .filter(scrabbleWords::contains)\n             .filter(checkBlanks)\n             .collect(\n                 Collectors.groupingBy(\n                     score,\n                     () -> new TreeMap<Integer, List<String>>(Comparator.reverseOrder()),\n                     Collectors.toList()\n                 )\n             );\n```\n\nThis is an odd function because it takes another function, the score function as input, returns a `Map` keyed by a score and a list of words that have that score. The body takes the set of `shakespeareWords`, streams it (the parallel version has `parallelStream()`) here, filters out those that are in the allowed Scrabble words set, filters out those that have less than two blank score, then groups the \"remaining\" words based on their computed score into a reverse-ordered `TreeMap` with `Integer` key and `List` elements - all with the help of standard `Stream Collectors`.  \n\nFinally, we are not interested in all words but only the top 3 scoring set of words:  \n\n```java\nList<Entry<Integer, List<String>>> finalList =\n                buildHistoOnScore.apply(score3)\n                    .entrySet()\n                    .stream()\n                    .limit(3)\n                    .collect(Collectors.toList());\n```\n\nWe apply the `score3` function to the \"loop\" and put the top 3 entries into the final list. If all went well, we should get the following entries:  \n\n```\n120 = jezebel, quickly\n118 = zephyrs\n116 = equinox\n```\n\n### The original RxJava benchmark\n\nGiven the fact that RxJava and Java Streams have quite similar APIs and equivalent operators, the original RxJava benchmark was written with an odd set of helper components and changes to the pattern of the functions above.  \n\nThe first oddity is the introduction of a functional style of counting: `LongWrapper`  \n\n```java\ninterface LongWrapper {\n    long get();\n \n    default LongWrapper incAndSet() {\n        return () -> get() + 1;\n    }\n}\n \nLongWrapper zero = () -> 0;\nLongWrapper one = zero.incAndSet();\n```\n\n(This over-functionalization is a recurring theme with Jose, see this year's [JavaOne video](https://www.youtube.com/watch?v=Y4XkWSAm2XU) for example.)  \n\nThe second oddity that many return types that were scalar in the `Stream` version above were turned into `Observable`s - which adds unnecessary overhead and no operational benefit. So let's see how the original benchmark looks like with RxJava 1:  \n\nFirst, the `letterScore` now returns a single element `Observable` with the score value:  \n\n```java\nFunc1<Integer, Observable<Integer>> scoreOfALetter\n    letter -> Observable.just(letterScores[letter - 'a']);\n \nFunc1<Entry<Integer, LongWrapper>, Observable<Integer>> letterScore =\n    entry ->\n        Observable.just(\n            letterScores[entry.getKey() - 'a'] *\n            Integer.min(\n                (int)entry.getValue().get(),\n                scrabbleAvailableLetters[entry.getKey() - 'a']\n            )\n        );\n```\n\nThis has cascading effects as depending functions now have to deal with an `Observable`. RxJava doesn't have the direct means to stream the characters of a `String` so a helper indirection was introduced by reusing `Stream`'s tools and turning that into an `Iterable` RxJava can understand: \n\n```java\nFunc1<String, Observable<Integer>> toIntegerObservable =\n    string -> Observable.from(\n        IterableSpliterator.of(string.chars().boxed().spliterator()));\n```\n\nBuilding the histogram now uses the `LongWrapper` and RxJava's `collect()` operator to build the `Map` with it:  \n\n```java\nFunc1<String, Observable<HashMap<Integer, LongWrapper>>> histoOfLetters =\n    word -> toIntegerObservable.call(word)\n            .collect(\n                () -> new HashMap<>(),\n                (HashMap<Integer, LongWrapper> map, Integer value) -> {\n                    LongWrapper newValue = map.get(value) ;\n                    if (newValue == null) {\n                        newValue = () -> 0L ;\n                    }\n                    map.put(value, newValue.incAndSet()) ;\n                }\n             );\n```\n\nCalculating blanks also return `Observable` instead of a scalar value:  \n\n\n```java\nFunc1<Entry<Integer, LongWrapper>, Observable<long>> blank =\n    entry ->\n        Observable.just(\n            Long.max(\n                0L,\n                entry.getValue().get() -\n                    scrabbleAvailableLetters[entry.getKey() - 'a']\n            )\n        );\n \nFunc1<String, Observable<Long>> nBlanks =\n    word -> histoOfLetters.call(word)\n            .flatMap(map -> Observable.from(() -> map.entrySet().iterator()))\n            .flatMap(blank)\n            .reduce(Long::sum);\n \nFunc1<String, Observable<Boolean>> checkBlanks =\n     word -> nBlanks.call(word)\n                    .flatMap(l -> Observable.just(l <= 2L));\n```\n\nNow calculating the scores:  \n\n```java\nFunc1<String, Observable<Integer>> score2 =\n     word -> histoOfLetters.call(word)\n             .flatMap(map -> Observable.from(() -> map.entrySet().iterator()))\n             .flatMap(letterScore)\n             .reduce(Integer::sum);\n \nFunc1<String, Observable<Integer>> first3 =\n     word -> Observable.from(\n              IterableSpliterator.of(word.chars().boxed().limit(3).spliterator()));\n \n \nFunc1<String, Observable<Integer>> last3 =\n    word -> Observable.from(\n                IterableSpliterator.of(word.chars().boxed().skip(3).spliterator()));\n \n \nFunc1<String, Observable<Integer>> toBeMaxed =\n    word -> Observable.just(first3.call(word), last3.call(word))\n                .flatMap(observable -> observable);\n \nFunc1<String, Observable<Integer>> bonusForDoubleLetter =\n    word -> toBeMaxed.call(word)\n            .flatMap(scoreOfALetter)\n            .reduce(Integer::max);\n```\n\n(Note that `last3` returns the letters 4..n instead of the last 3 letters, not sure if this was intentional or not. Changing it to really return the last 3 letters has no measurable performance difference.)  \n\nThen we compute the final score per word:  \n\n```java\nFunc1<String, Observable<Integer>> score3 =\n    word ->\n        Observable.just(\n            score2.call(word),\n            score2.call(word),\n            bonusForDoubleLetter.call(word),\n            bonusForDoubleLetter.call(word),\n            Observable.just(word.length() == 7 ? 50 : 0)\n        )\n        .flatMap(observable -> observable)\n        .reduce(Integer::sum);\n```\n\nRemember the \"times 2\" from the `Stream` benchmark, here both scores are streamed again instead of multiplying their result by 2 (via map). This inconsistency with the original `Stream` alone is responsible of ~30% overhead with the original RxJava 1 benchmark. For comparison, when the same double-streaming is applied to the original Stream benchmark, its measured sample time goes from **27 ms/op** up to **39 ms/op**.  \n\nLastly, the processing of the entire Shakespeare word set and picking the top 3:  \n\n```java\nFunc1<Func1<String, Observable<Integer>>, Observable<TreeMap<Integer, List<String>>>>\nbuildHistoOnScore =\n     score -> Observable.from(() -> shakespeareWords.iterator())\n              .filter(scrabbleWords::contains)\n              .filter(word -> checkBlanks.call(word).toBlocking().first())\n              .collect(\n                  () -> new TreeMap<Integer, List<String>>(Comparator.reverseOrder()),\n                  (TreeMap<Integer, List<String>> map, String word) -> {\n                      Integer key = score.call(word).toBlocking().first();\n                      List<String> list = map.get(key);\n                      if (list == null) {\n                          list = new ArrayList<>();\n                          map.put(key, list);\n                      }\n                      list.add(word);\n                  }\n               );\n \nList<Entry<Integer, List<String>>> finalList2 =\n    buildHistoOnScore.call(score3)\n    .flatMap(map -> Observable.from(() -> map.entrySet().iterator()))\n    .take(3)\n    .collect(\n        () -> new ArrayList<Entry<Integer, List<String>>>(),\n        (list, entry) -> {\n            list.add(entry);\n        }\n    )\n    .toBlocking()\n    .first();\n```\n\nHere, we need to go blocking to get the first (and) only value for the `checkBlanks` as well as getting the only List of results of the final list of top 3 scores and words. The collector function taking the `TreeMap` and the current entry had to be explicitly typed because for some reason Eclipse can't properly infer the types in that expression.  \n\n### The optimized version\n\nThe mistakes and drawbacks of the original RxJava version has been identified over a long period of time and the optimized benchmark is still \"under optimization\". Using the right operator for the right job is essential in synchronous processing and some are better suited for this type of work and have less overhead due to their need to support an asynchronous operation mode. The other important thing is to know when to use a reactive type and when to stick to a scalar value.  \n\nAs mentioned above, the original RxJava benchmark had a bunch of the functions return `Observable` with a scalar value for no apparent benefit. Changing these back to scalar functions - just like the Stream version helps avoid unnecessary indirection and allocation:  \n\n```java\nFunc1<Integer, Integer> scoreOfALetter = letter -> letterScores[letter - 'a'];\n```\n\nStreaming the characters of a word is the hottest operation and is executed several tens of thousands of time. Instead of the `Stream-Spliterator` indirection, one can simply index-map a string into its characters:  \n\n```java\nword -> Observable.range(0, word.length()).map(i -> (int)word.charAt(i));\n```\n\nInstead of the convoluted `LongWrapper` and its lambda-capture overhead, we can define a simple mutable container for the histogram:  \n\n```java\npublic final class MutableLong {\n \n    public long value;\n \n    public void incAndSet() {\n        value++;\n    }\n}\n \nFunc1<String, Observable<HashMap<Integer, MutableLong>>> histoOfLetters =\n     word -> toIntegerObservable.call(word)\n             .collect(\n                 () -> new HashMap<>(),\n                 (HashMap<Integer, MutableLong> map, Integer value) -> {\n                     MutableLong newValue = map.get(value);\n                     if (newValue == null) {\n                         newValue = new MutableLong();\n                         map.put(value, newValue);\n                     }\n                     newValue.incAndSet();\n                 }\n \n              );\n```\n\nThe next optimization is the use of `flatMapIterable` and there is no need to get the iterator of an `entySet()` but just iterate it since it already implements `Iterable`:  \n\n```java\nFunc1<String, Observable<Long>> nBlanks =\n    word -> MathObservable.sumLong(\n                histoOfLetters.call(word)\n                .flatMapIterable(map -> map.entrySet())\n                .map(blank)\n            );\n```\n\nIn addition, `reduce()` has some overhead because of constant boxing and unboxing of a sum or max value of the stream and can be replaced by a dedicated operator from the [RxJavaMath](https://github.com/ReactiveX/RxJavaMath) library: `MathObservable.sumLong()`.  \n\nIn synchronous scenarios, `concat` works better than `merge/flatMap` most of the time:  \n\n```kotlin\nFunc1<String, Observable<Integer>> toBeMaxed =\n    word -> Observable.concat(first3.call(word), last3.call(word));\n \nFunc1<String, Observable<Integer>> score3 =\n    word ->\n        MathObservable.sumInteger(\n            Observable.concat(\n                score2.call(word).map(v -> v * 2),\n                bonusForDoubleLetter.call(word).map(v -> v * 2),\n                Observable.just(word.length() == 7 ? 50 : 0)\n            )\n        );\n```\n\nNote the use of `map(v -> v * 2)` to multiply the two score components instead of streaming them again.  \n\nIn addition, there were several internal optimizations to RxJava to improve performance with this type of usage: `concat(o1, o2, ...)` received a dedicated operator instead of delegating to the `Observable` of `Observable`s overload. The `toBlocking().first()` overhead has been improved as well. Currently, the optimized benchmark with RxJava 1.2.4 runs under **67 ms/op**, the \"Beta\" benchmark runs under **100 ms/op** and the original benchmark runs under **170 ms/op**.  \n\n### Benchmarking other libraries\n\nFollowing similar patterns, other streaming libraries (synchronous and asynchronous) were benchmarked over the year. The following subsections summarize what it takes to have them do the Scrabble computation with the functional structures above, how they perform and why are they at the speed they are.  \n\n[![](https://4.bp.blogspot.com/-V_cLB3fnjQM/WGJ4q3uAqBI/AAAAAAAAHiQ/TpuXI4nHu0gvPBXsrvKGk0y4w4C8Hn6vACLcB/s640/Scrabble_12_14.jpg)](https://4.bp.blogspot.com/-V_cLB3fnjQM/WGJ4q3uAqBI/AAAAAAAAHiQ/TpuXI4nHu0gvPBXsrvKGk0y4w4C8Hn6vACLcB/s1600/Scrabble_12_14.jpg)\n\n[https://twitter.com/akarnokd/status/808995627237601280](https://twitter.com/akarnokd/status/808995627237601280)\n\n#### Kotlin\n\nKotlin has its own, rich synchronous streaming standard library and performs quite well in the optimized benchmark: **20 ms/op**. It requires a [separate project](https://github.com/akarnokd/akarnokd-misc-kotlin/blob/master/src/main/kotlin/hu/akarnokd/kotlin/scrabble/ScrabbleKotlin.kt#L195) due to a complete separate JVM language which works best under IntelliJ. I'm not deeply familiar with Kotlin thus I'm not sure what it makes that much faster than `Stream` (or IxJava).  \n\nThe streaming part of the language is certainly well optimized but it is also possible using `HashMap` with primitive types gets custom implementation. The streaming standard library is very rich and the whole Scrabble logic could be expressed without building new operators or invoking external libraries.  \n\n#### IxJava\n\nIxJava, short for _Iterable eXtensions_ for Java started out as a companion library to Reactive4Java, the first black-box re-implementation of the Rx.NET library on the JVM (2011). Since then, it has been rewritten from scratch based on the advanced ideas of RxJava 2. The [optimized benchmark](https://github.com/akarnokd/akarnokd-misc/blob/master/src/jmh/java/hu/akarnokd/comparison/scrabble/ShakespearePlaysScrabbleWithIxOpt.java) runs around **23 ms/op**, 3 ms faster than the `Stream` version. Currently, this is the fastest Java library to do the Scrabble benchmark and has all the operators built in for the task. It features less allocation and less indirection, plus there are optimizations for certain shapes of inputs (constant-scalar, single-element sources).  \n\n#### RxJava 2\n\nRxJava is the de-facto standard reactive library for Java 6+ and version 2 supports the Reactive-Streams initiative with its `Flowable` type. Version 2 was rewritten from scratch in late 2015 and then has been drastically re-architected in mid 2016. The late 2015 version performed poorly with the scrabble benchmark but still 2 times faster than RxJava 1 at the time. Since the dataflow types in RxJava have to anticipate asynchronous and/or backpressured usage with largely the same code path, they have a noticeable overhead when using them in a pure synchronous manner.  \n\nTherefore, the Scrabble benchmark is implemented for the [backpressure-enabled Flowable](https://github.com/akarnokd/akarnokd-misc/blob/master/src/jmh/java/hu/akarnokd/comparison/scrabble/ShakespearePlaysScrabbleWithRxJava2FlowableOpt.java) and the [backpressure-lacking (but otherwise similarly advanced) Observable](https://github.com/akarnokd/akarnokd-misc/blob/master/src/jmh/java/hu/akarnokd/comparison/scrabble/ShakespearePlaysScrabbleWithRxJava2ObservableOpt.java) types. They perform **27.75 ms/op** and **26.83 ms/op** respectively. Unfortunately, the main RxJava library lacks dedicated operators such as streaming the characters of a `String` and summing up a stream of numbers and these were implemented in the [RxJava 2 Extensions](https://github.com/akarnokd/RxJava2Extensions) companion library. The additional performance improvement over RxJava 1.x come from the much leaner architecture with fewer indirections, fewer allocations, dedicated `concat(source1, source2, ...)` operator, a very low overhead `blockingFirst()` and generally the operator fusion many operators participate in. In the late release-candidate phase, it was decided certain operators return `Single`, `Completable` or `Maybe` instead of its own type. The change did not affect the benchmark result in any measurable way (but the code had to change to work with the new types of course).  \n\nIn addition, the extension library features a `ParallelFlowable` type that allows parallel computations over a regular `Flowable` sequence, somewhat similar to parallel Streams. The parallelization happens for the set of Shakespeare words and requires a manual reduction back to sequential reactive type:  \n\n```kotlin\nFunction<Function<String, Flowable<Integer>>, Flowable<TreeMap<Integer, List<String>>>>\nbuildHistoOnScore =\n    score ->\n        ParallelFlowable.from(Flowable.fromIterable(shakespeareWords))\n        .runOn(scheduler)\n        .filter(scrabbleWords::contains)\n        .filter(word -> checkBlanks.apply(word).blockingFirst())\n        .collect(\n            () -> new TreeMap<Integer, List<String>>(Comparator.reverseOrder()),\n            (TreeMap<Integer, List<String>> map, String word) -> {\n                Integer key = score.apply(word).blockingFirst();\n                List<String> list = map.get(key);\n                if (list == null) {\n                    list = new ArrayList<>();\n                    map.put(key, list);\n                }\n                list.add(word);\n            }\n        )\n        .reduce((m1, m2) -> {\n            for (Map.Entry<Integer, List<String>> e : m2.entrySet()) {\n                 List<String> list = m1.get(e.getKey());\n                 if (list == null) {\n                     m1.put(e.getKey(), e.getValue());\n                 } else {\n                     list.addAll(e.getValue());\n                 }\n            }\n            return m1;\n        });\n```\n\nThe parallel version measures **7.23 ms/op** compared to the Java parallel Streams version with **6.71 ms/op**.  \n\n#### Reactor 3\n\nPivotal's Reactor-Core library is practically RxJava 2 under a different company banner and implementation differences due to being Java 8+, originally contributed by me and as of today, the relevant components of Reactor 3 required by the Scrabble benchmark still uses my algorithms. The few implementation differences come from the use of atomic field updaters instead of atomic classes (such as AtomicInteger) which reduces the allocation amount even further. Unfortunately, even though the same field updaters are available for Java 6 and Android, certain devices don't play nicely with the underlying reflection mechanics. The [optimized benchmark code](https://github.com/akarnokd/akarnokd-misc/blob/master/src/jmh/java/hu/akarnokd/comparison/scrabble/ShakespearePlaysScrabbleWithReactor3Opt.java) uses custom implementation for streaming the characters of a word and finding the sum/max of a sequence.  \n\nGiven this difference, Reactor measures **27.39 ms/op**, putting it between RxJava 2's `Observable` and `Flowable`, somewhat expectedly.  \n\nReactor 3 has direct support for converting to its parallel type, `ParallelFlux`, which is also practically the same as RxJava 2 Extensions' `ParallelFlowable`. The [ParallelFlux' benchmark](https://github.com/akarnokd/akarnokd-misc/blob/master/src/jmh/java/hu/akarnokd/comparison/scrabble/ShakespearePlaysScrabbleWithReactor3ParallelOpt.java) clocks in at **8,53 ms/op**, however, that 1 ms difference to RxJava 2 is certainly odd and unclear why.  \n\n#### Guava\n\nGoogle Guava is library with lots of features, among other things, offering sub-library with a fluent-API support with `FluentIterable`. It has a limited set of streaming operators and the implementation has some unccessary overhead in it. The design reminds me of RxJava 1's Observable where there is a mandatory indirection to an inner type.  \n\nGiven the limited API, the [optimized benchmark code](https://github.com/akarnokd/akarnokd-misc/blob/master/src/jmh/java/hu/akarnokd/comparison/scrabble/ShakespearePlaysScrabbleWithGuavaOpt.java) uses custom operators such as streaming the characters of a word, custom `sum`/`max` and custom `collect()` operators, all written with the vocabulary of `FluentIterable` by me. Therefore, the measured `35.98 ms/op` is not entirely the achievement of the library authors.  \n\nInterestingly, the backpressure-enabled, async capable `Flowable`/`Flux` outperforms the sync-only and thus theoretically lower overhead `FluentIterable`.  \n\n#### Ix.NET\n\nWhen the Rx.NET was developed several years ago, they implemented its dual, the Interactive eXtensions building a rich API over their standard, synchronous streaming IEnumerable interface.  \n\nIx.NET is well optimized, most likely due to the nice language features (`yield return`) and great compiler (state machine building around `yield return`). Even though .NET supports \"primitive specialization\", their JIT compiler is not a runtime optimizing compiler and this is likely why the ported [Scrabble benchmark measures](https://github.com/akarnokd/akarnokd-misc-dotnet/blob/master/akarnokd-misc-dotnet/ShakespearePlaysScrabbleIxNET.cs) only **45.4 ms/op**.  \n\nUnfortunately, there were some missing operators from Ix.NET I had to write manually, such as the now-typically needed streaming of characters and the `reduce()` operator to support sum/max. (There is no need for custom sum because of the primitive specialization of `reduce()` provided automatically.)  \n\n#### Reactor.NET\n\nAbout a year ago, there was a non-zero chance I had to learn and include C# development in my professional line of work. Unfortunately, Rx.NET was and still is an old library with a significant performance overhead due to its synchronous ties, namely returning an `IDisposable` from `Subscribe()` instead of injecting it via an `OnSubscribe()` like all the other 3rd generation (inspired) libraries do. When 3.x didn't change the architecture, I decided instead of battling them over advancing, I could just roll my own library. Since in early 2016 I was involved with Pivotal's Reactor and its third-the-size API surface, I started working on [Reactor-Core.NET](https://github.com/reactor/reactor-core-dotnet) with all the 4th generation goodies RxJava 2 and Reactor now feature. Unfortunately, the risk of me doing C# faded and I took over leading RxJava, sending this project into sleep.  \n\nRegardless, enough operators were implemented already so the [Scrabble benchmark for it](https://github.com/akarnokd/akarnokd-misc-dotnet/blob/master/akarnokd-misc-dotnet/ShakespearePlaysScrabbleReactorCore.cs) is available and measures **80.51 ms/op**. It may be party due to the .NET platform and also due to a less-than-optimal implementation for streaming characters.  \n\n#### JOOLambda\n\nBack to the Java land, [this library](https://github.com/jOOQ/jOOL) is part of the JOOx family of extension libraries, supporting JVM operations such as JDBC-based database interactions to extending the standard Java Stream with features. This, unfortunately, means wrapping a `Stream` or their `Seq` type and thus adding a level of indirection. This wouldn't be much of a problem but the API lacks operators that stay in the Seq type for tasks such as collect or sum/max. Therefore, these operators had to be emulated with other operators. A second unfortunate property of JOOLambda is the difficulty of extending it (even non-fluently). I could't find any way of implementing my own operator directly (as with the Rx style and Ix-style APIs) and the closest thing wanted me to implement 70+ standard `Stream` operators again.  \n\nI believe it is still interesting to show how a convenient `collect()` operator can be implemented if there is no `reduce()` or even `scan()` to help us:  \n\n```java\nFunction<String, Seq<HashMap<Integer, MutableLong>>> histoOfLetters =\n    word -> {\n        HashMap<Integer, MutableLong> map = new HashMap<>();\n        return charSeq.apply(word)\n               .map(value -> {\n                    MutableLong newValue = map.get(value);\n                    if (newValue == null) {\n                        newValue = new MutableLong();\n                        map.put(value, newValue);\n                    }\n                    newValue.incAndSet();\n                    return map;\n               })\n               .skip(Long.MAX_VALUE)\n               .append(map);\n        };\n```\n\nFirst, the resulting `HashMap` is instantiated, knowing that this function will be invoked sequentially, non-recursively thus there won't be any clash between computations of different words. Second, we stream the characters of the word, map each character into the histogram inside the map. We need only a single element of the `HashMap` but there is no `takeLast()` operator to ignore all but the very last time the map is forwarded. Instead, we skip all elements and concatenate the single `HashMap` again to the now empty `Seq`.  \n\nSumming up values is none the less convoluted with JOOL:  \n\n```kotlin\nFunction<String, Seq<Integer>> score2 =\n    word -> {\n        int[] sum = { 0 };\n        return histoOfLetters.apply(word)\n               .flatMap(map -> Seq.seq(map.entrySet()))\n               .map(letterScore)\n               .map(v -> sum[0] += v)\n               .skip(Long.MAX_VALUE)\n               .append(0)\n               .map(v -> sum[0]);\n    };\n```\n\nWe setup a single element array to be the accumulator for the summing, stream the histogram and sum up the letter scores into this array. We then skip all of it and concatenate 0 followed by mapping (this zero) to the contents of the sum array. Note that `append(sum[0])` is evaluated at assembly time (before the sum actually happens) yielding the initial zero every time.  \n\nThe code measures **86-92 ms/op**, however, this might not be that bad because when I'm writing this post, I've noticed a [missing optimization](https://github.com/akarnokd/akarnokd-misc/blob/master/src/jmh/java/hu/akarnokd/comparison/scrabble/ShakespearePlaysScrabbleWithJOOLOpt.java#L54) that adds unnecessary burden to a core computation - my bad. No worries, I'll remeasure everything again next year since some libraries have since updated their code.  \n\n#### Cyclops-React\n\n[This is an odd library](https://github.com/aol/cyclops-react), developed mainly by one person. Looking at the Github site I'm sure it used to say Reactive-Streams in the title. I've come across this library a month or so back when the author posted an extensive post about the benefits of it by extending Java Stream with [missing features and reactive concepts](https://medium.com/@johnmcclean/java-8-streams-10-missing-features-ec82ee90b6c0#.j17ift5f9). When I see \"library\" and \"Reactive-Streams\" I jump - writing a reactive library is a very difficult task. It turns out, the library's call in of \"Reactive-Streams\" was a bit misleading. It is no more reactive than IxJava, which is a completely synchronous streaming API, with the exception that there is a wrapper/converter to a Reactive-Streams Publisher. IxJava has that one but only in various other reactive libraries: `Flux.fromIterable()` and `Flowable.fromIterable()`.  \n\nThat aside, it is still a kind of dataflow library and as such can be benchmarked with Scrabble. Cyclops-React builds on top of JOOLambda and my first [naive implementation](https://github.com/akarnokd/akarnokd-misc/blob/master/src/jmh/java/hu/akarnokd/comparison/scrabble/ShakespearePlaysScrabbleWithCyclopsReactOpt.java) performed similarly to JOOLambda (to be precise, I measured Cyclops-React first, then JOOLambda to see where the poor performance might come from).  \n\nCyclops-React at the time didn't have any `collect()`/`reduce()` operators but it has `scan` (called `scanLeft`) and `takeLast` (called `takeRight`), allowing me to build the necessary computation steps:  \n\n```kotlin\nFunction<String, ReactiveSeq<HashMap<Integer, MutableLong>>> histoOfLetters =\n    word ->  toIntegerIx.apply(word)\n             .scanLeft(new HashMap<Integer, MutableLong>(), (map, value) -> {\n                 MutableLong newValue = map.get(value) ;\n                 if (newValue == null) {\n                     newValue = new MutableLong();\n                     map.put(value, newValue);\n                 }\n                 newValue.incAndSet();\n                 return map;\n             })\n             .takeRight(1);\n```\n\nFrom allocation perspective, this is very similar to JOOLambda's workaround since the `HashMap` is instantiated when the outer function is called and not for the consumer of the aggregation like with RxJava's `collect()` operator. One convenience though is the `takeRight(1)` that picks the very last value of the map (as `scan` emits it every time a new source comes up).  \n\nThe first benchmarks with version 1.0.3 yielded **108 ms/op**. The diagram at the beginning of this section lists it twice. The author of Cyclops-React and I tried to work out a better optimization, but due to the different understanding what the Scrabble benchmark represents, we didn't come to an agreement on the proper optimization (he practically wanted to remove `ReactiveSeq`, the base type of the library, and basically benchmark Java Stream again; I want to measure the overhead of ReactiveSeq itself).  \n\nSince then, version 1.0.5 has been released with library optimizations and my code runs under **54 ms/op** while having the same structure as before. The author has also run a few Scrabble benchmarks of his own [that show lower overhead](https://twitter.com/cyclops_aol/status/809544009236496384), comparable to `Stream` now. If he achieved it by honoring the structure, that's fantastic. If he practically skipped his own type as the workhorse, that's bad.  \n\n#### Rx.NET\n\nThe first, modern reactive library was designed and developed more than 8 years ago at Microsoft. Since then, Rx.NET has become open source, had 3 major releases, and helps (drives?) famous technologies such as Cortana.  \n\nIt's a bit sad it couldn't evolve beyond its 1st generation reactive architecture. First, it has heavily invested developers who are quite comfortable with how it is implemented, second, the .NET platform has absorbed its base interface types, `IObservable` and `IObserver`, that have the unfortunate design of requiring a synchronous `IDisposable` to be returned. Luckily, the 4th generation architecture works on the .NET platform and the community driven [Reactive-Streams.NET](https://github.com/reactive-streams/reactive-streams-dotnet) initiative may give some hope there as well.  \n\nThis unfortunate design remnant is visible in the [Scrabble benchmark](https://github.com/akarnokd/akarnokd-misc-dotnet/blob/master/akarnokd-misc-dotnet/ShakespearePlaysScrabbleRxNET.cs): **413 ms/op**. The main overhead comes from the trampolining the `range()` and enumerable-to-Observable conversion have. This trampolining is necessary to solve the synchronous cancellation problem RxJava solved by having a stateful consumer with a flag and callback mechanism indicating cancellation (which lead to the Subscription injection method in Reactive-Streams).  \n\nInterestingly, I've [implemented](https://github.com/akarnokd/akarnokd-misc-dotnet/tree/master/akarnokd-misc-dotnet/observablex) a minimalist, non-backpressured type `Ox`, similar to RxJava 2's Observable type and [it measures](https://github.com/akarnokd/akarnokd-misc-dotnet/blob/master/akarnokd-misc-dotnet/ShakespearePlaysScrabbleOx.cs) **45 ms/op**, practically in par with the Ix.NET benchmark.  \n\n#### Swave\n\nPerhaps [this library](https://github.com/sirthias/swave/) is the youngest of the \"reactive\" libraries. It's implementation resembles of Akka-Stream with the graph-like internal workings, but it is not a native Reactive-Streams library. It has conversion from and to Publisher but steps themselves aren't Publishers. This adds interoperation overhead. In addition, the library is part of the _Yoda-family_ of reactive libraries; there is no `retry`. (Maybe because for retry to work, one needs to hold onto the chain that establishes the flow and allow resubscribing without the need for manual reassembing the entire flow.) The library is written in Scala entirely and I gave up on trying to call it from a Java project, hence a separate project for it.  \n\nThe library itself appears to be single developer only and the documentation is lacking a bit at the moment - not that I can't find operators on my own but a few times it was unclear I'm fighting with the Scala compiler (through IntelliJ) or with this library (you know, when IntelliJ says all is okay but then the build fails with a compilation error due to implicits). The library, version 0.5 at least, didn't have `collect`, `reduce`, `sum`, `max` but it does have `takeLast` and the emulations mentioned before work.  \n\nNone the less, I managed [to port the benchmark](https://github.com/akarnokd/akarnokd-misc-scala/blob/master/src/main/scala/ScrabbleWithSwave.scala) to Scala and run it, getting a surprising **781 ms/op**. Since I can't read Scala code, I can only speculate this comes from the graph-architecture overhead and/or some mandatory asynchronous-ness implicitly present.  \n\n#### Akka-Stream\n\nI've read so much goodness about Akka-Stream, about the technologies and frameworks it supports, its advanced and high performance optimizations over the flow-graph, the vibrant community and developer base around it, the spearheading of the Reactive-Streams initiative itself yet it constantly fails to deliver for me. In addition I've recently found out Akka-Stream is just inspired by Reactive-Streams and the reason they provide converter/wrapper to a Publisher instead of implementing it at every step is because working Reactive-Streams' deferred nature is too hard. Also I couldn't find any means for retrying an Akka-Stream `Source` so it could be yet another Yoda-library (so how does it support resilience then?).  \n\nAt least Akka-Stream has a Java DSL so I could implement the [Scrabble benchmark](https://github.com/akarnokd/akarnokd-misc/blob/master/src/jmh/java/hu/akarnokd/comparison/scrabble/ShakespearePlaysScrabbleWithAkkaStreamOpt.java) within the familiar Java context. The DSL doesn't have `collect` but supports `reduce` (thus sum and max requires minimal work). Therefore, the collect operations were implemented with the same `map+drop(Long.MAX_VALUE)+concat(map)`.  \n\nThe benchmark results are \"mind-blasting\": **5563 ms/op**, that is, it takes about 5.5 seconds to compute the Scrabble answer once. Since Akka-Stream is originally written in Scala, I don't know for sure the source of this overhead but I have a few ideas: the graph-overhead, the mandatory asynchronous nature and perhaps the \"fusion optimization\" they employ that wastes time [trying to optimize](https://github.com/akka/akka/issues/20218) a graph that can't be further optimized.  \n\nThis problem seem to hit any use case that has `flatMap` in it - one of the most common operator involved in Microservices composition. Of course, one can blame the synchronous nature Scrabble use case which is not the target for Akka-Stream, however, its interoperation capabilities through Reactive-Streams Publisher shows some serious trouble (ops/s, larger is better):  \n\n[![](https://2.bp.blogspot.com/-Ln91ysLDeC0/WGKwuJHW3kI/AAAAAAAAHiw/MU3rVRtMqmgZowQyRnuKmOJExEfdpBFawCLcB/s640/akka-rx-crossperf.png)](https://2.bp.blogspot.com/-Ln91ysLDeC0/WGKwuJHW3kI/AAAAAAAAHiw/MU3rVRtMqmgZowQyRnuKmOJExEfdpBFawCLcB/s1600/akka-rx-crossperf.png)\n\nHere, [the task is to deliver](https://github.com/akarnokd/akarnokd-misc/blob/master/src/jmh/java/hu/akarnokd/comparison/AkkaStreamsCrossMapPerf.java) 1M elements (part of an Integer array) from one thread to another where the work is divided between Akka-Stream and RxJava 2: one delivers `count` number of `1M/count` items, and the other flattens the latter sub-section back to a single stream at the other side. Surprisingly, using Rx as the driver or middle worker improves throughput significantly (but not always). This benchmark stresses mostly the optimizer of Akka-Stream. Do people `flatMap` with Akka-Stream at all and nobody noticed this?  \n\n### Conclusion\n\nWriting a reactive library is hard, writing a benchmark to measure those libraries is at best non-trivial. Figuring out why some of them is extremely fast while others are extremely slow requires mastery in both synchronous and asynchronous design and development.  \n\nInstead of getting mad at the Scrabble benchmark a year ago, I invested time and effort into improving and optimizing libraries that I could effect and thanks to it, those libraries are now considerably better at this benchmark and in general use due to the deep architectural and conceptional improvements.  \n\nI must warn the reader about interpreting the results of the Scrabble benchmarks as the ultimate ranking of the libraries. The fact that libraries perform as they do in this particular benchmark doesn't mean they perform the same in any other situations with other type of tasks. The computation and/or IO overhead may hide the subtle differences in those cases, evening the field between them at the end.  \n\n","author":"Dávid Karnok","date":"2016-12-27","type":"article","categories":["Kotlin"],"features":["highlightjs"],"description":"","filename":"","lang":"EN","enclosure":null},{"title":"Kotlin: How to Make a Java Developer's Life Easier?","url":"https://anadea.info/blog/kotlin-how-to-make-java-developers-life-easier","body":"\n![Kotlin](https://anadea.info/uploads/image_attachment/image/1025/xKotlin.jpg.pagespeed.ic.Wy-yOp4EYc.jpg)\n\nOn February 15, 2016 JetBrains company released version 1.0 of [Kotlin](https://kotlinlang.org/), a programming language that has been in development for about 5 years. This language works on JVM. We've already talked about [what Java is](https://anadea.info/blog/java-myths-realities-and-prospects-for-application-development) with our developer Alexander Mihalchenko. Today, we met again with Alexander, this time to discuss Kotlin - why Kotlin is good and if there are any drawbacks of using this language, both for developers and for entrepreneurs.\n\n**Hello, Alex.**  \nHi to you too.\n\n**So, what is Kotlin?**  \nKotlin is a programming language, developed by JetBrains company, running on the Java platform. It uses JDK, like Java itself but has a different syntax. The idea isn't new, there are already existing languages that do the same - Scala and Closure, for example. They appeared mainly because of issues with Java in terms of syntax. In other words, Java is a good, reliable and powerful language, you can use it to build server-side applications. However, its syntax, let's say, is unnecessarily wordy. The fact is that Java's developers upgrade it in a rather inertly manner. They are keeping maximal backward compatibility and consider that, when uses move to a new version of Java, a code written back in '95 should work for them anyway. They even have a slogan: \"write once, run anywhere\". Of course, this is more about cross-platform benefits of Java...\n\n**... but they decided to dig deeper?**  \nYes, the code written on one version of Java will work on all following versions.\n\n**A bold aspiration!**  \nIn fact, this is where the problem lies - they do not throw old things from the language. This slows down the development of Java. Over time, various trash comes up. There's even a label for outdated classes, which marks them inside the JDK. According to documentation, when such label appears it means that the old functionality may be ceased in the next versions, but I'm not aware of any occasions when it actually happened.\n\n**Do developers recognize that these outdated methods aren't used anymore?**  \nThey understand and even insist that these methods should not be used. But as far as there is a software apps written on old versions, it's not possible to simply remove the old code. All those applications will get broken.\n\n**So, what did Kotlin get rid of?**  \nKotlin and other JVM-languages help developers to write programs with less code. In addition to everything that exists in Java, they provide things from the world of functional programming. This greatly facilitates code writing, makes it more concise and expressive. The less code we write, the less of it needs to be maintained and the fewer tests we have to write. Actually, the majority of programming languages emerged because of this particular reason - to change Java syntax, make it more convenient and more pragmatic.\n\n**Is the Kotlin language in a high demand now?**  \nCurrently, it is not very popular - the language is young, its community hasn't come together yet. Due to immaturity of Kotlin vs Scala they can't compete so far. Scala is a more powerful programming language with a long history. Scala has already passed the stage of fixing major errors and it has been updated to include a bunch of interesting stuff, while this have yet to be done for Kotlin. More mature languages have the upper hand in that for now. Nevertheless, Kotlin has a lot of ambitions. The language has been in development for five years. Developers tried to make it pragmatic and avoid mistakes that have been made in Java. So, that \"write once\" won’t be the major rule and the language will be easier to develop. In the future, they promise a lot of interesting features that will cover functionality currently available in Scala.\n\n**Is it true that, like Java, Kotlin will suit better to large-scale projects?**  \nYes. By the syntax, it can be used just as an addition to Java. We can take the Java stack for server applications and simply replace Java with Kotlin. Everything will work and it'll be easier to write code. The question is what to choose instead of Java. Today, I think, the majority of developers will pick Scala.\n\n**What's your personal opinion? Do you prefer Kotlin or Scala?**  \nI like both languages. I think Kotlin will go further in respect of Android. Surely it's possible to write Android apps on Scala but there is a problem - a large runtime. It pulls behind a heap of libraries and because of that the size of apk-files increases. Kotlin already has the smallest runtime among the other languages (except Java). Typically, it's Java plus \"something\" and that \"something\" is an overhead that is trailed behind the language. Kotlin has smallest one - about 700 KB, while in Scala it is a few megabytes.\n\n**What are the disadvantages of Kotlin?**  \nI haven't yet come across any bugs myself and I had no problems with compiler or anything else as well. As for the syntax, it coped with all challenges I have encountered. The thing it yields to Scala is dealing with multithreading. Java, by the way, also loses in this. There is Future API in Scala. It allows you to perform asynchronous tasks in several streams. As a result, you get a normal code instead of hash of various sections operating in different streams without any visible relation between them. Scala structures all of it through the means of syntax. In Kotlin, something similar is promised to be implemented in version 1.1. But generally, I like to use Kotlin due to its solid syntax.\n\n**What can you say about safety of Kotlin?**  \nHere's the thing: all the code written in Kotlin is then converted into a Java code. It adds nothing from itself. Accordingly, Kotlin is safe to the same extent as Java. If we are speaking about safety of writing code, I really like Null safety in Kotlin programming. The compiler can warn coder that the reference may be empty. If we try to do anything with it, an error occurs at the compiling stage. In Java, application simply crushes at the implementation stage.\n\n**What can Kotlin offer to business? What benefits does it provide to entrepreneurs?**  \nFor business, the key benefit of Kotlin vs Java is the fact that the development on Kotlin is cheaper. Why? It requires to write less code and as a result you get fewer code to maintain. This means that it is easier to write code and consequently the application can be developed faster. Time is money, after all.\n\n**Small projects and Kotlin.**  \nIf we are speaking about small desktop apps, for commercial use it is better to choose C++. Yet again, Kotlin code is subsequently compiled to Java bytecode, therefore, as far as Java is good in some area, so good Kotlin as well. Kotlin is more helpful for writing programs, so it brings direct benefits primarily to coders.\n\n**Thank you very much for the interview, Alex. It was interesting!**  \nMy pleasure.\n\n## Summary\n\nIn fact, Kotlin's direct purpose is to facilitate life of coders, give them opportunity to use one code line where Java needs five lines. As Alexander said, it's like changing an old Ford Focus to a brand new BMW M3 - when you feel that flight you won't come back to the old wheels.\n\nOne of the undoubted advantages of Kotlin is the full compatibility with Java, including backwards one. All libraries for Java will work on Kotlin and vice versa. Also, this language reveals the charms of Closure and Scala for Android developers. Entrepreneurs will be pleased as well as now software projects will be delivered faster and cheaper.\n\nThe only drawback of the language is its young age. However, considering the fact that JetBrains spent five years on its development, they will unlikely abandon their brainchild any time soon. Therefore, it is a good idea to start adopting Kotlin right now, especially if you're developing apps for Android.\n\n","author":"Stanislav Sinitsky, Alexander Mikhalchenko","date":"2016-12-07","type":"article","categories":["Kotlin"],"features":["highlightjs"],"description":"","filename":"","lang":"EN","enclosure":null},{"title":"Kotlin 1.1 Beta 2 is here","url":"https://blog.jetbrains.com/kotlin/2017/02/kotlin-1-1-beta-2-is-here/","body":"\nWe’re happy to announce the second beta of Kotlin 1.1. Please give the new version a try – your feedback is essential for ensuring that we can deliver a quality release.\n\nSince the first beta release, we’ve mostly been focused on stability, bugfixes, and improving the key focus areas of this release: coroutine support and the JavaScript backend. The full list of changes since 1.1 Beta can be found in the [changelog](https://github.com/JetBrains/kotlin/blob/0e1b61b422bd0d006158d8b68fa34e960853c5c6/ChangeLog.md). And if you’re interested in a recap of everything added in version 1.1, check out our [what’s new page](https://kotlinlang.org/docs/reference/whatsnew11.html).\n\n## Migration Notes\n\nFor JavaScript projects, we’ve changed the name of the artifact for the standard library. Instead of `kotlin-js-library`, it is now `kotlin-stdlib-js`. You’ll need to update your Maven and Gradle scripts accordingly when you update to 1.1 beta 2 or a newer build.\n\nIn addition to that, testing support classes (in the package `kotlin.test`) for JavaScript are now packaged as a separate artifact, as it was previously done for the Java version. If you’re using kotlin.test in your JS project, add a dependency on `kotlin-test-js`.\n\nThe coroutines APIs in the Kotlin standard library have been moved to the `kotlin.coroutines.experimental` package; you need to update your imports if you’ve used these APIs in your code. See [Andrey’s forum post](https://discuss.kotlinlang.org/t/experimental-status-of-coroutines-in-1-1-and-related-compatibility-concerns/2236) for the background on this change.\n\nWe’ve also made it easier to enable the experimental coroutine support in your Gradle projects. Instead of editing gradle.properties, you can add the following snippet to your build.gradle:\n\n```kotlin\nkotlin {\n    experimental {\n        coroutines 'enable'\n    }\n}\n```\n\nIf you’re using the [kotlinx.coroutines library](https://github.com/kotlin/kotlinx.coroutines), please update your dependency to version `0.6-beta`. Earlier versions of the library are incompatible with this Kotlin update.\n\n## New Features\n\nWe did add a few last-minute features in this beta. Here are the most important ones:\n\n* The compiler now reports a warning if you declare an extension that has the same signature as a member of the same class and will always be shadowed (for example, `String.length()`)\n* Type inference for member references passed to generic functions is now much improved ([KT-10711](https://youtrack.jetbrains.com/issue/KT-10711))\n* The `minus` operator can now be used with maps, returning a copy of the map with the given keys removed. The `-=` operator can be used on mutable maps to remove the given keys from the map.\n* It is now possible to access the delegate instance of a delegated property using `KPropertyN.getDelegate()` (see [KT-8384](https://youtrack.jetbrains.com/issue/KT-8384) for details);\n* Intention (contributed by Kirill Rakhman) to merge two nested `if` statements;\n* Support for building Android projects when the Jack toolchain is enabled (`jackOptions { true }`);\n* Intention (contributed by Kirill Rakhman) to generate `View` constructors in Android applications.\n\n## Source Compatibility with Kotlin 1.0\n\nAnother area to which we paid a lot of attention in this update is **source compatibility with Kotlin 1.0**. This allows you to try Kotlin 1.1, even if your team is using Kotlin 1.0, without worrying that you’ll break the build by using some of the features added in the new release.\n\nTo enable the compatibility mode:\n\n* For Maven, Ant and the command-line compiler, set the `-language-version` compiler argument to 1.0.\n* In a Gradle build, add `kotlinOptions { languageVersion = \"1.0\" }` to your `compileKotlin` task.\n* In the IDE, specify the language version in the Kotlin facet settings or in Settings | Build, Execution, Deployment | Compiler | Kotlin Compiler\n\n## How to try it\n\n**In Maven/Gradle:** Add `http://dl.bintray.com/kotlin/kotlin-eap-1.1` as a repository for the build script and your projects; use `1.1.0-beta-38` as the version number for the compiler and the standard library.\n\n**In IntelliJ IDEA:** Go to _Tools → Kotlin → Configure Kotlin Plugin Updates_, then select “Early Access Preview 1.1” in the _Update channel_ drop-down list, then press _Check for updates_.\n\nThe command-line compiler can be downloaded from the [Github release page](https://github.com/JetBrains/kotlin/releases/tag/v1.1-beta2).\n\n**On [try.kotlinlang.org](http://try.kotlinlang.org/)**. Will be available soon.\n\nLet’s Kotlin!\n","author":"Dmitry Jemerov","date":"2017-02-02","type":"article","categories":["Kotlin"],"features":["highlightjs"],"description":"","filename":"","lang":"EN","enclosure":null},{"title":"PultusORM : Sqlite ORM for Kotlin","url":"https://medium.com/@sakibsami/https-medium-com-sakibsami-pultusorm-sqlite-orm-for-kotlin-2e01ed9ddcf6#.645u2wr6n","body":"\nFew days back I was developing a Kotlin desktop application and needed a database system like Sqlite to store data. I started searching on google & github for a Sqlite ORM library and after spending few hours I figure out [some library](https://github.com/Heapy/awesome-kotlin#database) but no one fulfil my requirements. So I decide to write one by myself. As I am too lazy so I tried to develop something easier and straightforward. I don’t want the developer to write some queries and use the ORM system. So I develop the library keep in mind that not only me but everyone needs something easy, something more handy, something more flexible which will do everything. Ok I have started writing PultusORM a sqlite ORM library for Kotlin.\n\n[PultusORM](https://github.com/s4kibs4mi/PultusORM) is an opensource project available on github under MIT license.\n\nInstallation is as easy as eating a slice of pizza ;) [Have a look](https://github.com/s4kibs4mi/PultusORM#usages).\n\nIf you are done with installation move forward to write some code & query some data.\n\nLike other application you don’t need to write a model class extending any other class -_- I am too lazy to extend something :/ . So what do you have to do ? Just write a class having some properties (Must be primitive types till now). Initiate a connection with the database just by providing database name or alone with database path, everything else handled for you.\n\n```kotlin\nclass Post {\n  @PrimaryKey\n  @AutoIncrement\n  var postId: Int = 0\n  var postTitle: String? = null\n  var postAuthor: String? = null\n}\n\nval pultusORM: PultusORM = PultusORM(\"blog.db\") // specifying path is optional\nval post: Post = Post()\npost.postTitle = \"Welcome to Kotlin\"\npost.postAuthor = \"Sakib Sami\"\n\npultusORM.save(post)  // Table will be created on fly if not exists\n```\n\nSometimes I feel like queries should be async which will give me a callback with execution result. Well you have that option in PultusORM. All queries having callback option are async. For this you just need to implement Callback interface and pass it as callback parameter, its that simple. Do you still think eating pizza is more easier than this ? Maybe not !!!\n\nOk tired of eating pizza ? need some drinks ? Lassi is my favourite. Maybe you don’t dislike it but you have other options. In PultusORM there are lots of option for data retrieval. You can fetch all data of a specific class. Or you can fetch based on some options. Options like **equal, not equal, and, or, in, between, less, greater, sort, group** are ready for you. Not enough !!! want some more mouthwatering ? Feel free to [create a issue](https://github.com/s4kibs4mi/PultusORM/issues/new).\n\nLunch time is so confusing.I think should I eat some pizza or rice !!! But I like both. So day by day I keep changing food items. PultusORM also provide you data update support using all the condition options above as well as callback option which is async.\n\nAfter reading this article you may want to delete this as its too boring !!! In medium you can’t but PultusORM won’t disappoint you. You have option to delete data from data store.\n\nIf you wish you can see the full [menu card](https://github.com/s4kibs4mi/PultusORM/wiki). Hope you will love developing apps using it.\n\nRepository : [https://github.com/s4kibs4mi/PultusORM](https://github.com/s4kibs4mi/PultusORM)\n\nWiki : [https://github.com/s4kibs4mi/PultusORM/wiki](https://github.com/s4kibs4mi/PultusORM/wiki)\n\n","author":"Sakib Sami","date":"2016-10-07","type":"article","categories":["Kotlin"],"features":["highlightjs"],"description":"","filename":"","lang":"EN","enclosure":null},{"title":"Kotlin Lang","url":"https://speakerdeck.com/developer/kotlin-lang","body":"\n\n[Slides](https://speakerdeck.com/developer/kotlin-lang)\n\n","author":"Jemo Mgebrishvili","date":"2016-11-20","type":"slides","categories":["Kotlin","Android"],"features":["highlightjs"],"description":"","filename":"","lang":"EN","enclosure":null},{"title":"Neural Networks in Kotlin (part 2)","url":"http://beust.com/weblog/2016/05/30/neural-networks-in-kotlin-part-2/","body":"\nIn the [previous installment](http://beust.com/weblog/2016/05/27/neural-network-in-kotlin/), I introduced a mystery class `NeuralNetwork` which is capable of calculating different results depending on the data that you train it with. In this article, we’ll take a closer look at this neural network and crunch a few numbers.\n\n## Neural networks overview\n\nA neural network is a graph of neurons made of successive layers. The graph is typically split in three parts: the leftmost column of neurons is called the “input layer”, the rightmost columns of neurons is the “output layer” and all the neurons in-between are the “hidden” layer. This hidden layer is the most important part of your graph since it’s responsible for making the calculations. There can be any numbers of hidden layers and any number of neurons in each of them (note that the Kotlin class I wrote for this series of articles only uses one hidden layer).\n\nEach edge that connects two neurons has a weight which is used to calculate the output of this neuron. The calculation is a simple addition of each input value multiplied by its weight. Let’s take a look at a quick example:\n\n![](https://docs.google.com/drawings/d/1lnkGCoJ5DsJcXlqXnjmE0oGM6l1wHrf9pRuN-8ZU7Xc/pub?w=480&h=360)  \n\nThis network has two input values, one hidden layer of size two and one output. Our first calculation is therefore:\n\n```kotlin\nw11-output = 2 * 0.1 + (-3) * (-0.2) = 0.8\nw12-output = 2 * (-0.4) + (-3) * 0.3 = -1.7\n```\n\nWe’re not quite done: the actual outputs of neurons (also called “activations”) are typically passed to a normalization function first. To get a general intuition for this function, you can think of it as a way to constrain the outputs within the [-1, 1] range, which prevents the values flowing through the network from overflowing or underflowing. Also, it’s useful in practice for this function to have additional properties connected to its derivative but I’ll skip over this part for now. This function is called the “activation function” and the implementation I used in the `NeuralNetwork` class is the [hyperbolic tangent, `tanh`](http://mathworld.wolfram.com/HyperbolicTangent.html).\n\nIn order to remain general, I’ll just refer to the activation function as `f()`. We therefore refine our first calculations as follows:\n\n```kotlin\nw11-output = f(2 * 0.1 + (-3) * (-0.2))\nw12-output = f(2 * (-0.4) + (-3) * 0.3)\n```\n\nThere are a few additional details to this calculation in actual neural networks but I’ll skip those for now.\n\nNow that we have all our activations for the hidden layer, we are ready to move to the next layer, which happens to be the ouput layer, so we’re almost done:\n\n```kotlin\noutput = f(0.1 * w11-output - 0.2 * w12-output\n       = 0.42\n```\n\nAs you can see, calculating the output of a neural network is fairly straightforward and fast, much faster than actually training that network. Once you have created your networks and you are satisfied with its results, you can just pass around the characteristics of that network (weights, sizes, ...) and any device (even phones) can then use that network.\n\n## Revisiting the xor network\n\nLet’s go back to the `xor` network we created in the first episode. I created this network as follows:\n\n```kotlin\nNeuralNetwork(inputSize = 2, hiddenSize = 2, outputSize = 1)\n```\n\nWe only need two inputs (the two bits) and one output (the result of `a xor b`). These two values are fixed. What is not fixed is the size of the hidden layer, and I decided to pick 2 here, for no particular reason. It’s interesting to tweak these values and see whether your neural network performs better of worse based on these values and there is actually a great deal of both intuition and arbitrary choices that go into these decisions. These values that you use to configure your network before you run it are called “hyper parameters”, in contrast to the other values which get updated while your network runs (e.g. the weights).\n\nLet’s now take a look at the weights that our `xor` network came up with, which you can display by running the Kotlin application with <tt>--log 2</tt>:\n\n```plain\nInput weights:\n-1.21 -3.36\n-1.20 -3.34\n1.12 1.67\n \nOutput weights:\n3.31\n-2.85 \n```\n\nLet’s put these values on the visual representation of our graph to get a better idea:\n\n![](https://docs.google.com/drawings/d/1vzNDxpKkIP0h6pp8KglUn55a-pLE5PIAaO204ZNqYR0/pub?w=960&h=720)  \n\nYou will notice that the network above contains a neuron called “bias” that I haven’t introduced yet. And I’m not going to just yet besides saying that this bias helps the network avoid edge cases and learn more rapidly. For now, just accept it as an additional neuron whose output is not influenced by the previous layers.\n\nLet’s run the graph manually on the input (1,0), which should produce 1:\n\n```kotlin\nhidden1-1 = 1 * -1.21\nhidden1-2 = 0 * -1.20\nbias1     = 1 * 1.12\n \noutput1 = tanh(-1.21 + 1.12) = -0.09\n \nhidden2-1 = 1 * -3.36\nhidden2-2 = 0 * -3.34\nbias2     = 1 * 1.67\n \noutput2 = tanh(-3.36 + 1.6) = -0.94\n \n// Now that we have the outputs of the hidden layer, we can caculate\n// our final result by combining them with the output weights:\n \nfinalOutput = tanh(output1 * 3.31 + output2 * (-2.85))\n            = 0.98\n```\n\nWe have just verified that if we input `(0,1)` into the network, we’ll receive `0.98` in output. Feel free to calculate the other three inputs yourself or maybe just run the `NeuralNetwork` class with a log level of 2, which will show you all these calculations.\n\n## Revisiting the parity network\n\nSo the calculations hold up but it’s still a bit hard to understand where these weights come from and why they interact in the way they do. Elucidating this will be the topic of the next installment but before I wrap up this article, I’d like to take a quick look at the parity network because its content might look a bit more intuitive to the human eye, while the `xor` network detailed above still seems mysterious.\n\nIf you train the parity network and you ask the `NeuralNetwotk` class to dump its output, here are the weights that you’ll get:\n\n```plain\nInput weights:\n0.36 -0.36\n0.10 -0.09\n0.30 -0.30\n-2.23 -1.04\n0.57 -0.58\n \nOutput weights:\n-1.65\n-1.64 \n``` \n\nIf you pay attention, you will notice an interesting detail about these numbers: the weights of the first three neurons of our hidden layer cancel each other out while the two inputs of the fourth neuron reinforce each other. It’s pretty clear that the network has learned that when you are testing the parity of a number in binary format, the only bit that really matters is the least significant one (the last one). All the others can simply be ignored, so the network has learned from the training data that the best way to get close to the desired output is to only pay attention to that last bit and cancel all the other ones out so they don’t take part in the final result.\n\n## Wrapping up\n\nThis last result is quite remarkable if you think about it, because it really looks like the network learned how to test parity at the formal level (“The output of the network should be the value of the least significant bit, ignore all the others”), inferring that result just from the numeric data we trained it with. Understanding how the network learned how to modify itself to reach this level will be the topic of the next installment of the series.\n\n","author":"Cédric Beust","date":"2016-05-30","type":"article","categories":["Kotlin"],"features":["highlightjs"],"description":"","filename":"","lang":"EN","enclosure":null},{"title":"Easy DSL design with Kotlin","url":"https://blog.frankel.ch/easy-dsl-design-with-kotlin/","body":"\nIn Android, every tutorial teaching you the basics describe how to design screen through XML files. It’s also possible to achieve the same result with Java (or any JVM-based language). Android screen design is not the only domain where XML and Java are valid options. For example, Spring configuration and Vaadin screen design allow both. In all those domains, there’s however a trade-off involved: on one hand, XML has a quite rigid structure enforced by an XML-schema while Java gives power to do pretty well anything at the cost of readability. “With great power comes great responsibility”. In the latter case, it’s up to the individual developer to exercise his/her judgement in order to keep the code as readable as possible.\n\n[Domain-Specific Languages](https://en.wikipedia.org/wiki/Domain-specific_language) sit between those two ends of the spectrum, as they offer a structured syntax close to the problem at hand but with the full support of the underlying language constructs when necessary. As an example, the AssertJ library provides a DSL for assertions, using a fluent API. The following snippet is taken from its documentation:\n\n```kotlin\n// entry point for all assertThat methods and utility methods (e.g. entry)\nimport static org.assertj.core.api.Assertions.*;\n\n// collection specific assertions (there are plenty more)\n// in the examples below fellowshipOfTheRing is a List<TolkienCharacter>\nassertThat(fellowshipOfTheRing).hasSize(9)\n                               .contains(frodo, sam)\n                               .doesNotContain(sauron);\n```\n\nDSLs can be provided in any language, even if some feel more natural. Scala naturally comes to mind, but Kotlin is also quite a great match. Getting back to Android, Jetbrains provides the excellent Anko library to design Android screen using a Kotlin-based DSL. The following snippet highlights Anko (taken from the doc):\n\n<a name=\"anko\"></a>\n\n```kotlin\nverticalLayout {\n    val name = editText()\n    button(\"Say Hello\") {\n        onClick { toast(\"Hello, ${name.text}!\") }\n    }\n}\n```\n\nThere are two Kotlin language constructs required for that.\n\n## Extension functions\n\nI already wrote about extension functions, so I’ll be pretty quick about it. In essence, [extension functions](/extension-functions-for-more-consistent-apis/) are a way to add behavior to an **existing** type.\n\nFor example, `String` has methods to set in lower/upper case but nothing to capitalize. With extension functions, it’s quite easy to fill the gap:\n\n```kotlin\nfun String.toCapitalCase() = when {\n    length < 2 -> toUpperCase()\n    else -> this[0].toUpperCase() + substring(1).toLowerCase()\n}\n```\n\nAt this point, usage is straightforward: `\"foo\".toCapitalCase()`.\n\nThe important point is the usage of `this` in the above snippet: it refers to the actual string instance.\n\n## Function types\n\nIn Kotlin, function **are** types. Among all consequences, this means functions can be passed as function parameters.\n\n```kotlin\nfun doSomethingWithInt(value: Int, f: (Int) -> Unit) {\n    value.apply(f);\n}\n```\n\nThe above function can be now passed any function that takes an `Int` as a parameter and returns `Unit` _e.g._ `{ print(it) }`. It’s called like that:\n\n```kotlin\ndoSomethingWithInt(5, { print(it) })\n```\n\nNow, Kotlin offers syntactic sugar when calling methods: if the lambda is the **last** parameter in a function call, it can be separated from the other arguments like this:\n\n```kotlin\ndoSomethingWithInt(5) { print(it) }\n```\n\n## Putting it all together\n\nGetting back to the [Anko snippet above](#anko), let’s check how the `verticalLayout { ... }` method is defined:\n\n```kotlin\ninline fun ViewManager.verticalLayout(theme: Int = 0, init: _LinearLayout.() -> Unit): LinearLayout {\n    return ankoView(`$Anko$Factories$CustomViews`.VERTICAL_LAYOUT_FACTORY, theme, init)\n}\n```\n\nAs seen in the first paragraph, the `init` parameter is an extension function defined on the `_LinearLayout` type. `this` used in its context will refer to the instance of this latter type.\n\nThe second paragraph explained what represents the content of the braces: the `init` parameter function.\n\n## Conclusion\n\nHopefully, this post show how easy it is to create DSL with Kotlin thanks to its syntax.\n\nI developed one such DSL to create GUI for the [Vaadin](https://vaadin.com/) framework: the name is Kaadin and the result is [available online](https://nfrankel.github.io/kaadin/).\n\n","author":"Nicolas Fränkel","date":"2016-10-30","type":"article","categories":["Kotlin"],"features":["highlightjs"],"description":"","filename":"","lang":"EN","enclosure":null},{"title":"Exploring an Either Monad in Kotlin","url":"https://blog.exallium.com/exploring-an-either-monad-in-kotlin-92618b9c4623#.nlt1cxd96","body":"\nRecently, I was enlightened. I finally, fully grasped how the Either Monad works. At least I think I do. In this post, I am looking to report my findings, both for the education of others of this powerful tool, as well as to see if my understanding of this monadic concept really holds water.\n\n### What’s an Either Monad?\n\nAn Either Monad consists of two basic types, Left and Right. It is, essentially, the If/Else statement of the Monad world. Left signifies that something went wrong, while Right signifies that things are working as they should. Just remember, that you want your code to be all right. As the monad passes through different bindings and is worked with, it can either report a Left, and, essentially, skip the rest of the call chain, or it can report Right and continue in fashion.\n\n### But wait, what’s a Monad?\n\nThink of a Monad as a box. In this box, you can store stuff. A Monad is simply a data wrapper with a few different, unifying properties. For example, the Java8 Optional is considered a Monad, as is Kotlin’s ? types and Haskell’s Maybe, among others.\n\nMonads follow some simple rules. They include two sequencing functions, a return function and a fail function. The sequencing functions are, in my example, noted as bind and seq.\n\nBind will take a Monad and, if all is well, apply a function to it’s contents, and return another Monad of the same general type. For example, an Either Monadic bind operation will always return another Either Monad, though the type of the data being wrapped might have changed, say from int to bool.\n\nSeq will take a Monad and return the monad passed to it. It is a way to finish a chain of operations and ignore the result, and instead pick up from a new source Monad.\n\nReturn simply takes a variable, and returns it wrapped in a new Monad.\n\nFail takes a string, and throws an exception with it as the message. It’s type returns the Monad in question in order to be compliant with the bind function.\n\nAn example, written in Kotlin:\n\n```kotlin\nsealed class Either<L, R> {\n    class Left<L, R>(val l: L) : Either<L, R>() {\n        override fun toString(): String = \"Left $l\"\n    }\n    \n    class Right<L, R>(val r: R) : Either<L, R>() {\n        override fun toString(): String = \"Right $r\"\n    }\n    \n    infix fun <Rp> bind(f: (R) -> (Either<L, Rp>)): Either<L, Rp> {\n        return when (this) {\n            is Either.Left<L, R> -> Left<L, Rp>(this.l)\n            is Either.Right<L, R> -> f(this.r)\n        }\n    }\n    \n    infix fun <Rp> seq(e: Either<L, Rp>): Either<L, Rp> = e\n    \n    companion object {\n        fun <L, R> ret(a: R) = Either.Right<L, R>(a)\n        fun <L, R> fail(msg: String): Either.Right<L, R> = throw Exception(msg)\n    }\n}\n```\n\nHere, we have a Sealed class. This is because we only ever want to have two options for the Either monad, Left or Right. Each of these simply define a toString method, for convenience.\n\nWe have two methods within either, which represent the aforementioned bind and sequence functions. (In Haskell, these are (>>=) and (>>), respectively). These are infix methods, who’s usage is explained in the sample usage code below.\n\nThe bind method simply takes a function. If the Either in context is Left, we simply return a Left of proper type. If it is Right, then we apply the function to it.\n\nThe seq method simply returns whatever its input is.\n\nWe then have the two other functions required for a monad defined as static functions, as these are “creation” methods. Ret simply returns a new Right instance for whatever value is passed in a. Fail throws an exception with the message as defined in the parameter.\n\nRet is a convenience function for creating new Rights. Fail is a convenience function for throwing basic exceptions. For example, you can easily fail from within a bind, as shown in usage.\n\n### Using this class\n\nHere are some examples of usage. Note the use in some places of bind as an infix operator. Also note that there is a lot of Type parameters in the code. This is due to Either needing to know information about both the left and right hand side of a given instance. I believe that this is ok. It’s not as concise as I would like it to be, but it’s a trade-off for strong typing.\n\n```kotlin\nfun main(args: Array<String>) {\n    \n    // Simple bind, from one R type to another\n    println(Either.Right<String, Int>(5) bind { it -> Either.ret<String, Boolean>(true)} )\n    \n    // Simple bind, demonstrating left pass-through\n    println(Either.Left<String, Int>(\"error\").bind({ it -> Either.ret<String, Int>(it + 1) }))\n    \n    // Simple bind, demonstrating conditions\n    val right = Either.Right<String, Int>(5)\n    val condition = { it: Int -> if (it > 3) {\n        Either.Left<String, Int>(\"number is too big\")\n    } else {\n        Either.Right<String, Int>(it * 2)\n    }}\n    \n    // Examples utilizing this condition.\n    println(right bind condition)\n    println(Either.Right<String, Int>(2).bind(condition).bind(condition).seq(Either.Right<String, Float>(2.0f)))\n    \n    // Demonstration of Fail\n    try {\n        println(Either.Right<String, Int>(5) bind { Either.fail<String, Int>(\"asdf\") })\n    } catch (e: Exception) {\n        println(\"exception: ${e.message}\")\n    }\n}\n```\n\n### Monads as a concept, not a base class\n\nOne mistake often made when someone is learning about Monads is that there should be some sort of Monad base class. I believe that this is driven by backgrounds in object oriented programming. OOP does not translate very well into a functional context. While there is definitely a class definition of a Monad in Haskell, because of the differences in the language, functional paradigm, and really just the strength and power of the Haskell type system, it does not translate well to a Java interface. Specifically when the data within the Monad changes, the type system is lacking in some ways to completely express, say, the bind function, when we move from an R value of Int to an R value of boolean.\n\nThus, Monads should be understood as a general concept, not as some base class we extend. They are not really meant to be interoperable with each other. Each Monad is a unique tool that provides it’s own benefits, such as the aforementioned Java8 Optional, or Haskell’s State monad. Each would need to be explicitly written, and not be expected to co-mingle.\n\n### Conclusion\n\nMonads are powerful. Really powerful. They’ve started to take the OOP world by storm, from simple language conventions like Nullability in Kotlin, to the advent of RxJava over the last year or so. As we move into a more multi-processed world, where core count continues to rise and processor speeds continue to stagnate, it will be more important than ever to understand Functional programming concepts, whether it be immutability, pure functions, or this, the Monad.\n\nThanks for reading.\n\n","author":"Alex Hart","date":"2016-11-22","type":"article","categories":["Kotlin","FP"],"features":["highlightjs"],"description":"","filename":"","lang":"EN","enclosure":null},{"title":"JDK7/8 features in Kotlin 1.0","url":"https://discuss.kotlinlang.org/t/jdk7-8-features-in-kotlin-1-0/1625","body":"\nCurrently it's rather inconvenient to use those methods of mapped builtin types, that were added in JDK8. These include `Collection.stream()`, `Map.getOrDefault(K, V)`, etc. We have several long-standing issues related in our tracker: [KT-9194](https://youtrack.jetbrains.com/issue/KT-9194), [KT-5175](https://youtrack.jetbrains.com/issue/KT-5175) and [KT-10864](https://youtrack.jetbrains.com/issue/KT-10864).\n\nThis happens because Kotlin targets JDK 1.6 as the minimum JDK version, so it can't expose those members of builtin types that are not available in JDK 1.6.\nWe plan to remove the limitation in Kotlin 1.1 by exposing all builtin type members available in the target platform (excluding some blacklisted exceptions), but as a short-term fix we could provide a way to call these methods via extensions.\n\nWe have collected those extensions in a small Kotlin library: [kotlinx.support](https://github.com/Kotlin/kotlinx.support).\nIt consists of two artifacts: **kotlinx-support-jdk8** and **kotlinx-support-jdk7**. The former has a dependency on the latter, so if you target JDK8 you could only reference kotlinx-support-jdk8 and have the latter as a transitive dependency.\n\nThese artifacts are available for downloading from the maven repository on bintray [https://bintray.com/kotlin/kotlinx.support/kotlinx.support](https://bintray.com/kotlin/kotlinx.support/kotlinx.support) and also on jcenter [https://bintray.com/bintray/jcenter?filterByPkgName=kotlinx.support](https://bintray.com/bintray/jcenter?filterByPkgName=kotlinx.support).\n\n### kotlinx-support-jdk8\n\nThis library provides extensions to call default methods of collection interfaces introduced in JDK8.\n\n```kotlin\nimport kotlinx.support.jdk8.collections.*\nimport kotlinx.support.jdk8.text.*\n\n// some quite more verbose way to say 'listOf<String>().flatMap { it.asIterable() }'\nval chars = listOf(\"abc\", \"def\").stream()\n                .flatMap { it.chars().boxed().map { it.toChar() } }\n                .collect(Collectors.toList<Char>())\n```\n\n### kotlinx-support-jdk7\n\nThis library exposes `Throwable` methods to work with suppressed exceptions, and introduces [long-awaited](https://youtrack.jetbrains.com/issue/KT-5899) `use` extension for `AutoCloseable`. Note that this `use` being imported explicitly has precedence over `use` from Standard Library and thus can be used for `Closeable` as well.\n\n```kotlin\nimport kotlinx.support.jdk7.use\n\nclass Resource(val faultyClose: Boolean = false) : Closeable {\n\n    override fun close() {\n        if (faultyClose)\n            throw IOException(\"Close failed\")\n    }\n}\n\n// the IOException thrown by 'close' would be added\n// to the list of suppressed exceptions of IllegalStateException\n// thrown from lambda passed to 'use'\nval result = Resource(faultyClose = true).use {\n    throw IllegalStateException(\"operation failed\")\n}\n```\n\n","author":"Ilya Gorbunov","date":"2016-04-21","type":"article","categories":["Kotlin"],"features":["highlightjs"],"description":"","filename":"","lang":"EN","enclosure":null},{"title":"Kotlin — Love at first line","url":"https://medium.com/@dime.kotevski/kotlin-love-at-first-line-7127befe240f#.p5hp6dxlh","body":"\n## Kotlin — Love at first line\n\nKotlin 1.0 has been [released](https://blog.jetbrains.com/kotlin/2016/02/kotlin-1-0-released-pragmatic-language-for-jvm-and-android/)\n a few days ago and it’s time to check out its awesome features.\n\nFor those of you who might have been living under a rock and don’t know what Kotlin is — Kotlin is a new JVM programming language that tries to “fill in the gaps” that Java has. It’s 100% interoperable with Java — meaning that you can have a mixed project that contains Kotlin & Java classes. The classes are compiled to Java bytecode, and that bytecode is “runnable” on Java6+, which makes it runnable on Android.\n\nThe language is awesome, and combined with the [Anko](https://github.com/Kotlin/anko) library it’s even [awesome-er*](http://www.urbandictionary.com/define.php?term=Awesome-er). I won’t be explaining the syntax of the language (for that you have the official [page](https://kotlinlang.org/)). I’m just going to try and expose a few of it’s awesome features.\n\n### [Single-Expression functions](https://kotlinlang.org/docs/reference/functions.html#single-expression-functions)\n\nIf we have a function that boils down to a single expression, we can use the single-expression function syntax:\n\n    override fun equals(other: Any?) = other is Task && other.id == id\n\n### [Extensions](https://kotlinlang.org/docs/reference/extensions.html)\n\nExtensions allow us to extend any existing class by adding functions and properties without the need to inherit from that class.\n\n```kotlin\nfun ViewGroup.inflate(\n    @LayoutRes layoutRes: Int,\n    attachToRoot: Boolean = false) =\n\n    LayoutInflater\n        .from(context)\n        .inflate(layoutRes, this, attachToRoot)\n```\n\nThe extension function above adds the **.inflate(...)** method to the ViewGroup class, so instead of doing this every time:\n\n\n```kotlin\nval view = LayoutInflater\n    .from(parent)\n    .inflate(R.layout.todo_list_item, parent, false)\n```\n\nnow we can just do this:\n\n\n```kotlin\nval view = parent.inflate(R.layout.todo_list_item)\n```\n\nor:\n\n\n```kotlin\nval view = parent.inflate(R.layout.todo_list_item,\n    attachToRoot = true)\n```\n\nI guess you already noticed that Kotlin also supports [default arguments](https://kotlinlang.org/docs/reference/functions.html#default-arguments).\n\n### [Lambda](https://kotlinlang.org/docs/reference/lambdas.html#lambda-expressions-and-anonymous-functions)\n\nIntentionally left blank.\n\n### [Optionals / Null safety](https://kotlinlang.org/docs/reference/null-safety.html)\n\nForget about NullPointerExceptions. Kotlin has 2 types of variables, nullable and non-nullable. If we declare our variable as non-nullable — the compiler won’t let us assign a null value to it. Only nullable variables can be null.\n\n\n```kotlin\nvar nonNullable: String = \"This is a title\" // Non-nullable variable\nvar nullable: String? = null // Nullable variable\n```\n\nIn case of the *nonNullable* variable, we can safely call methods on it, without any null checks, because it *cannot have a null value*.\n\nIn case of the *nullable* variable, we can safely call methods with the help of the *safe-trasversal operator (?.)*, and forget about null checks:\n\n\n```kotlin\nval length = nullable?.length\n```\n\nThe code above won’t fail, even if the *nullable* variable has a null value. In that case, the value of the *length* variable will be *null*.\n\n### [Elvis operator](https://kotlinlang.org/docs/reference/null-safety.html#elvis-operator)\n\nThe result of a **safe call (?.)** is always a nullable variable. So in cases where we are calling a method on a null variable — the result will be null.\n\nThat can be inconvenient sometimes. For example, in the code sample above, we want our **length** variable to be a non-null variable because it’s logical for it to have a value of 0 in case of a null string.\n\nIn cases like that, we can use the **elvis operator ( ?: )**.\n\n\n```kotlin\nval length = nullable?.length ?: 0\n```\n\nThe elvis operator will use the left side value if it’s not null. In case the left side value is null, it will use the right non-nullable value.\n\nYou can even use it to make your sanity checks more readable.\n\n\n```kotlin\n    ...\n}\n```\n\nWith help of the elvis operator, the same method in Kotlin will look like this:\n\n\n```kotlin\npublic fun myMethod(str: String?) {\n    // Sanity check\n    str ?: return\n\n    ...\n}\n```\n\nThe great part of using this is that the compiler will **smart cast** our **str** variable to a non-nullable variable after the “*str ?: return*” line.\n\n### [Optional getters/setters](https://kotlinlang.org/docs/reference/properties.html#properties-and-fields)\n\nUnlike in Java, where we are used to define all of our class properties **_private_** and write getters and setters, in Kotlin we write getters and setters only if we want to have some custom behaviour.\n\nThe simplest definition looks like this:\n\n\n```kotlin\nclass Task {\n   var completed = false\n}\n```\n\nAnd we can access the property:\n\n\n```kotlin\nval task = Task()\nif (task.completed) ...\n```\n\nIf we wan’t to expose just the getter and allow setting the value only from within the class:\n\n\n```kotlin\nvar completed = false\n    private set\n```\n\nAnd if we want to have completely custom behaviour:\n\n\n```kotlin\nvar completedInt = 0\nvar completed: Boolean\n    get() = completedInt == 1\n    set(value) { completedInt = if (value) 1 else 0 }\n```\n\n### [Lazy properties](https://kotlinlang.org/docs/reference/delegated-properties.html#lazy)\n\nKotlin allows us to declare lazy properties — properties that are initialized when we first access them.\n\n\n```kotlin\nprivate val recyclerView by lazy {\n    find<RecyclerView>(R.id.task_list_new)\n}\n```\n\nWhen we first access the **recyclerView** property, the lambda expression is evaluated and the returned value from the lamdba is saved and returned in that and every subsequent call.\n\n### [Observable properties](https://kotlinlang.org/docs/reference/delegated-properties.html#observable)\n\nIn Kotlin we can observe properties. The syntax for declaring such properties is the following:\n\n\n```kotlin\nvar tasks by Delegates.observable(mutableListOf<Task>()) {\n    prop, old, new ->\n        notifyDataSetChanged()\n        dataChangedListener?.invoke()\n}\n```\n\nThis means that we are going to be notified every time the value of our property changes (the provided lambda will be called).\n\n\n## [Anko extensions](https://github.com/Kotlin/anko)\n\nAnko is a great library and has a lot of great extensions. I will list a couple.\n\n### find<T>(id: Int)\n\nIt replaces the findViewById(int id) method. This extension function returns the view already cast to the given type T, so there is no need to cast it.\n\n\n```kotlin\nval recyclerView = find<RecyclerView>(R.id.task_list_new)\n```\n\n### [SQLite](https://github.com/Kotlin/anko/blob/master/doc/SQLITE.md#anko-heart-sqlite)\n\nAnko has great support for SQLite databases. For a complete overview, check their [guide](https://github.com/Kotlin/anko/blob/master/doc/SQLITE.md#anko-heart-sqlite). I will just show you one example:\n\n\n```kotlin\nfun allTasks() = use {\n    select(table)\n        .orderBy(completed)\n        .orderBy(priority, SqlOrderDirection.DESC)\n        .exec {\n            parseList(parser)\n        }\n}\n```\n\nThe **use {...}** function opens the database for us, and closes it after the given lambda executes. So we don’t have to worry about closing it anymore and can forget about all those **try {...} catch(...) {...} finally {...}** blocks. Inside the lambda that we pass to the **use** function, **this** references our database. That is the power of Kotlin’s **type-safe builders**. Read more about them [here](http://blog.jetbrains.com/kotlin/2011/10/dsls-in-kotlin-part-1-whats-in-the-toolbox-builders/) and [here](https://kotlinlang.org/docs/reference/type-safe-builders.html).\n\nThe **select(...)...exec {}** call chain, selects data from the database. And the **parseList(parser)** call parses the rows of data and returns a list of objects, that our **parser** returns. The definition of our **parser** is:\n\n\n```kotlin\nval parser = rowParser {\n    id: Int, name: String, priority: Int, completed: Int ->\n    Task(id, name, priority, completed)\n}\n```\n\n","author":"Dimitar Kotevski","date":"2016-02-21","type":"article","categories":["Anko","Android","Kotlin"],"features":["highlightjs"],"description":"","filename":"","lang":"EN","enclosure":null},{"title":"A Developer’s Look at Kotlin","url":"http://insights.dice.com/2016/09/09/developers-look-kotlin/","body":"\n![shutterstock_379642018](http://insights.dice.com/wp-content/uploads/2016/09/shutterstock_379642018.jpg)\n\nNamed after an island near St. Petersburg, Russia (take a gander at its spectacular sunset, above), [Kotlin](https://kotlinlang.org/) is a statically typed open-source programming language that runs on the JVM, just like Java. JetBrains released version 1 in February 2016, after five years of development.\n\nOriginally coded by a team of Russian developers, Kotlin positions itself as an industrial-strength object-oriented language superior to Java. It uses Java code from the existing Java Class Library, and developers can use it to develop Android apps or generate JavaScript source code. You [can run it online in Intelli Idea](http://try.kotlinlang.org/#/Examples/Hello,%20world!/Simplest%20version/Simplest%20version.kt), the JetBrains IDE.\n\nHere are some additional features that make Kotlin different from Java:\n\n### The Language\n\nWith Kotlin, a main function is needed at the package level:\n\n```kotlin\n// Simplest version\n\nfun main(args: Array<String>) {\n    println(\"Hello World!\")\n}\n\n// Second one with return type and returned value\n\nfun main(args: Array<String>) : Int {\n    println(\"Hello, world!\")\n    return 0\n}\n```\n\nEither of the above works. (Comments are either /* .. */ for blocks or // for single lines, and you can nest block comments.) In the below, note how variable declarations are the Pascal way around; var means mutable (i.e., it can be changed), while val declares them read-only, so you must assign a value there:\n\n```kotlin\nval a: Int = 10000 // read-only\nval b: Int = 0x0F   // hexadecimal read-only\nvar c = 0b1011 // binary also type inferred\n\nprintln(\"a = $a b = $b c = $c\")\n```\n\nThis outputs:\n\n```\na = 10000 b = 15 c = 11\n```\n\nNote that primitive types (Int etc) in Kotlin are objects (unlike in Java), so this works:\n\n```kotlin\nprintln(0x0e.toString())\n```\n\nSyntax is straightforward, but make sure that expressions have brackets. Ifs can be used as expressions or statements and blocks. Anything inside { } can have a value. Else is optional inside statements, but mandatory in expressions:\n\n```kotlin\nvar max: Int\n\nif (a > b)\n    max = a\nelse\n    max = b\n\n// Expression\n\nval max = if (a > b) a else b\n```\n\nThe switch statement is called when, but is more flexible, as it supports arbitrary expressions as constants:\n\n```kotlin\nfun cases(obj: Any) {\n\n    when (obj) {\n        1           -> print(\"One\")\n        \"Hello\"     -> print(\"Greeting\")\n        is Long     -> print(\"Long\") // checks if type is long\n        !is String  -> print(\"Not a string\") if type is not a string\n        else        -> print(\"Unknown\")\n    }\n}\n```\n\n### Objects and Classes\n\nThe example below shows a simple Dice class with a constructor that passes in the maximum dice value. Two private immutable properties hold the Java.util.Random instance and the maxvalue. Note that the declaration of the Random instance does not use new. A public function Roll() is called for Random; this uses the single line function form with = instead of return.\n\nIn the main function, an instance of this dice class is created and a for loop calls Roll() ten times:\n\n```kotlin\nimport java.util.Random;\n\nclass Dice (maxValue : Int) {\n    private val rnd : Random = Random()\n    private val maxvalue: Int\n    \n    init {\n        maxvalue = maxValue\n    }\n    \n    public fun Roll() : Int = rnd.nextInt(maxvalue) + 1\n}\n\nfun main(args: Array<String>) : Unit {\n    val dice: Dice= Dice(6)\n    \n    for (i in 1..10) {\n        println(dice.Roll())\n    }\n}\n```\n\nThe constructor (called a primary constructor) is part of the class header. It can’t contain any code except in an init { } section. It’s also possible to do this without init by initializing the maxvalue property directly; the init can then be removed.\n\n```kotlin\nprivate val maxvalue: Int = maxValue\n```\n\n### Delegated Properties\n\nProperties can have getters and setters, though immutable ones only get a getter. Usually properties are either reading from or writing to a backing field; getters and setters can extend this via delegated properties. The syntax of a class declaration in this case looks like this:\n\n```kotlin\nclass Example {\n    var p: String by Delegate()\n}\n```\n\nThere are a couple of delegate types. Let’s start off with ‘Lazy’ for lazy initialization, which calls a lambda expression on the first access; this value is used on subsequent ones. Here’s lazy in use:\n\n```kotlin\nclass LazySample {\n    var inc: Int = 10;\n    val lazy: String by lazy {\n        println(\"Assigned!\")\n        (inc++).toString()\n    }\n}\n\nfun main(args: Array<String>) {\n    val sample = LazySample()\n    println(\"lazy = ${sample.lazy}\")\n    println(\"lazy = ${sample.lazy}\")\n    println(\"inc = ${sample.inc}\")\n}\n\n```\n\nThe output is:\n\n```\nAssigned!\nlazy = 10\nlazy = 10\ninc = 11\n```\n\nThis shows that despite accessing sample.lazy twice, only the first access initialized the value. If you comment out the three printlns and run it, you’ll see that there’s no assignment printed, as lazy is never assigned a value. That “by lazy” defers it until reading.\n\nNext up on the delegate types: ‘observable.’ In this example, a TaxRate value has been made ‘observable,’ and defaults to the value passed in: 18.5. But changing it explicitly invokes the handler, which prints out that it has changed. It can be very useful when you need to find out what is changing a property:\n\n```kotlin\nimport kotlin.properties.Delegates\n\nclass TaxRate {\n    var value: Float by Delegates.observable(18.5f) { d, old, new ->\n        println(\"Rate changed from $old% to $new%\")\n    }\n}\n\nfun main(args: Array<String>) {\n    val rate = TaxRate()\n    rate.value = 19.0f\n}\n\n```\n\nThis outputs:\n\n```\nRate changed from 18.5% to 19.0%\n```\n\n### Conclusions\n\nI’m a great believer that reduced cognitive load is good for programmers. It’s easier to understand code with simpler, more powerful syntax, and Kotlin certainly delivers on that.\n\nKotlin has been compared to Scala, though is somewhat simpler and compiles a lot faster. It’s not quite a snapshot of the language, [but the Idioms page](http://kotlinlang.org/docs/reference/idioms.html) tells you a lot about features and syntax in one go.\n\nAny developers wanting to know differences between Kotlin and Java at a glance can refer to the [Comparison to Java page](https://kotlinlang.org/docs/reference/comparison-to-java.html) via Kotlin’s reference materials.\n\n","author":"David Bolton","date":"2016-09-09","type":"article","categories":["Kotlin"],"features":["highlightjs"],"description":"","filename":"","lang":"EN","enclosure":null},{"title":"Swift vs Kotlin for real iOS/Android apps","url":"http://angelolloqui.com/blog/38-Swift-vs-Kotlin-for-real-iOS-Android-apps","body":"\n\n[**Swift**](https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/index.html) and [**Kotlin**](https://kotlinlang.org/docs/reference/) are two great languages for iOS and Android development respectively. They both have very **modern features and syntax** that can help enormously to build native apps. But, how do they both compare to each other? Are they similar? Can we reuse more code between platforms if we adopt them in our projects? \n\nThose are the questions we will explore in this post together with some real app code examples implementing the same features in both languages.\n\n### Side to side\n\nAs commented, both languages are very similar. In fact, they are so similar that **I will focus on the differences** rather than the similarities in this post. Before exploring the code samples, let’s cover **the most relevant ones** that will pop up when translating between them:\n\n*   **Swift Enums are more powerful**: In Swift, enums are very powerful and first-class type. They can contain different associated values per case (discrete union types), computed properties and most of the features of `structs`. Because of that, it is frequent to see patterns like [the `Result` enum](https://www.natashatherobot.com/swift-generics-box/) that are not common in Kotlin due to language limitations (_UPDATE: A similar pattern can be implemented in Kotlin by [using `sealed class` instead of `enum`](https://kotlinlang.org/docs/reference/classes.html#sealed-classes), but it is more complicated that the Swift counterpart_)\n\n*   **Swift has no `data class`**: One interesting construction in Kotlin is `data class`. It allows you to declare containers of information that automatically implement things like equality and copying. Very common pattern when dealing with plain objects that has no counterpart in Swift.\n\n*   **Swift does not have delegated classes or delegated properties**: A very interesting feature of Kotlin are delegated classes and properties. With them, you can forward invocation of methods to another class automatically, or define behaviors for properties such as `lazy`, `obsrvable`, etc. You can even create your own property delegates. In Swift, things like `lazy` are modifiers implemented in the language, so that means that you can not create your own but you are limited to the ones provided.\n\n*   **Swift does not allow annotations**: Coming from the Java world, Kotlin has full support for annotations. However, in Swift that is not considered at all, so annotations like `@Inject` or `@Test` that are so common in Java libraries do not have any counterpart in Swift.\n\n*   **Kotlin classes are final by default**: Kotlin classes are by default closed for extension, so you have to add `open` in any class you expect to be extended with inheritance.\n\n*   **Kotlin has no `struct` or passing data by value**: In Swift you can decide whether to use a `class` or a `struct` for your data. The decision is not trivial, and results in different implementation details. Structs are always passed by value, meaning that every time you call a method with it, return a struct, assign a struct,... the values are actually copied to the new variable, and any modification will only affect the modified variable and not the others. Besides that, structs do not allow inheritance, so they tend to be a perfect candidate for data classes. In Kotlin, there is no `struct` type and the language follows the same pattern than Java, where basic types (String, Int,...) are passed by value, but the rest are passed by reference.\n\n*   **Kotlin has no tuples**: Tuples are not implemented in Kotlin, so you will find yourself creating small `data classes` as counterpart for Swift tuples.\n\n*   **Kotlin has no `typealias`**: I just found out that it is in the roadmap for 1.1 but at the moment (Kotlin 1.0.4) there is no `typealias`, so patterns like the one I explained [in this previous post](http://angelolloqui.com/blog/37-Swifty-names-for-modules-protocols-and-implementation-classes) are not possible yet.\n\n*   **Kotlin has no `guard` statement**: In Swift, `guard` statements are a more expressive way for checking conditions of some function than the standard `if` sentence. In Kotlin, you need to stay with the `if` check and reverse the condition.\n\nThere are also other differences when comparing both languages. Things like exceptions, pattern matching, constructors, `if let` sentences, loop iteration, casting,... work in slightly different ways, but in general they follow the same principles and they have very similar syntaxes.\n\nOne last difference to mention when working for iOS/Android is that the Operative System offers different **runtime environments and libraries to developers**. A couple of points to highlight:\n\n*   **Memory management**: Kotlin assumes the existence of a Garbage Collector (provided by the Dalvik runtime in Android) and therefore memory management is transparent for the developer. On the other hand, Swift manages memory with a Reference Count approach (ARC) so you will need to think about memory ownership and retain cycles.\n\n*   **System frameworks and libraries are very different**: When accessing system frameworks or libraries like networking, UI, etc. they both offer very different APIs so the resulting code will look pretty different.\n\nThe list of differences might look long, but trust me, the amount of features shared by both is much longer. I suggest you read [swift-is-like-kotlin](https://nilhcem.github.io/swift-is-like-kotlin/) for an extensive comparison of different features of the languages side to side to get the feeling about it and some of the syntactic differences.\n\n### MVVM + Rx + Coordinators\n\nOK, so we have some differences in the language and big differences in the system frameworks and libraries, especially in UI. But can we still reuse code? And can we increase code reuse somehow?\n\nThe answer is yes, we can still reuse the code, and yes, we can increase code reuse by properly **splitting responsibilities and isolating dependencies**. In other words, we need to carefully chose a proper app architecture, because a wrong choice will highly limit the amount of code reused.\n\nThere are multiple architectural patterns out there (MVC, MVP, MVVM, VIPER, FLUX,...), each of them with their own benefits/drawbacks and best usage scenarios. I am not going to explore or compare them here because that is out of the scope of this post, but let me quickly review the one that I chose for this sample project: MVVM + Rx + Coordinators.\n\nIn MVVM, the code is split in **Model**, **View** and **ViewModel**. Views include `UIViewController`/`Activities`/`Fragments`, while ViewModel is a new entity introduced to map the model into data that can be consumed by the View layer easily. The main benefit of this pattern is that the **Model and the ViewModel are completely agnostic from UI**, and it is the UI the one that will “listen” for changes in the ViewModel and not the other way around. Code in View layers get shorter, as they do not need to apply any logic but **just display what the ViewModel provides**. This is a good feature for our case because we mentioned that UI code will be pretty different for both apps, so then we can keep those differences isolated and as short as possible.\n\nThe addition of **[Rx](http://reactivex.io/)** gives us a very powerful framework to “listen” for the ViewModel changes, and at the same time keep consistency between platforms since there are [RxSwift](https://github.com/ReactiveX/RxSwift) and [RxJava](https://github.com/ReactiveX/RxJava) counterparts following the same conventions. They also have platform dependent additions ([RxCocoa](https://github.com/ReactiveX/RxSwift/tree/master/RxCocoa) and [RxAndroid](https://github.com/ReactiveX/RxAndroid)), but we will keep those **limited to the View layer**.\n\nFinally, I have added a **Coordinator layer**. This layer is sometimes also called Router, and it basically glues the different parts together and handles the navigation between them. The usage of coordinators helps us **building the dependency tree and isolating the navigation logic** out of the View layer.\n\n### Example code snippets:\n\nFor this post we will explore a very simple app consuming the [OpenTable API as exposed here](https://github.com/sosedoff/opentable). The app will just present a list of restaurants, add some pagination when scrolling to the end of the table, and open a simple restaurant detail. I should also mention that I kept the connector to the API in an external library, not dependent to Rx, in case we want to build a different app without Rx but reusing the OpenTable connector, but we could have added the Rx dependency there as well to simplify the callbacks.\n\nHere are some of the different parts side to side:\n\n##### RestaurantSearch\n\n```swift\n//RestaurantSearch.swift\npublic struct RestaurantSearch {\n    public let totalResults: Int\n    public let currentPage: Int\n    public let resultsPerPage: Int\n    public let restaurants: [Restaurant]\n}\n\nextension RestaurantSearch: Unboxable {\n    public init(unboxer: Unboxer) {\n        self.totalResults = unboxer.unbox(key: \"total_entries\")\n        self.currentPage = unboxer.unbox(key: \"current_page\")\n        self.resultsPerPage = unboxer.unbox(key: \"per_page\")\n        self.restaurants = unboxer.unbox(key: \"restaurants\")\n    }\n}\n```\n\n\n```kotlin\n//RestaurantSearch.kt\npublic data class RestaurantSearch(\n       @JsonProperty(\"total_entries\") public val totalResults: Int,\n       @JsonProperty(\"restaurants\") public val restaurants: Array<Restaurant>,\n       @JsonProperty(\"current_page\") public val currentPage: Int,\n       @JsonProperty(\"per_page\") public val resultsPerPage: Int\n)\n```\n\nString similarity: **47.45%**\n\n`RestaurantSearch` is a data class containing a search response. You can see in this particular case that both have the **same external API, but a different internal implementation**. In the Swift case we are using [Unbox](https://github.com/johnsundell/unbox) for JSON mapping, while in Kotlin we use [Jackson](https://github.com/FasterXML/jackson). Here we can see the first issue that was commented above: library differences. The good news are that it is an implementation detail that will not affect how you use the object at all, and that you could probably find (or build) a different mapping library that looks in the same way (or at least much more similar) in both platforms.\n\n##### RestaurantService\n\n\n\n```swift\n//RestaurantService.swift\npublic class RestaurantService {\n    let networkSession: URLSession\n    let baseUrl: URL\n\n    public init(urlSession: URLSession = URLSession.shared,\n        baseUrl: URL = URL(string: \"http://opentable.herokuapp.com/api/\")!) {\n        self.networkSession = urlSession\n        self.baseUrl = baseUrl\n    }\n\n    public func findRestaurants(priceRange: Int? = nil,\n                         name: String? = nil,\n                         address: String? = nil,\n                         state: String? = nil,\n                         city: String? = nil,\n                         zip: String? = nil,\n                         country: String? = nil,\n                         page: Int = 1,\n                         pageSize: Int = 25) -> ServiceTask<RestaurantSearch> {\n\n        var params = [RequestParameter]()\n        params.append(RequestParameter(\"price\", priceRange))\n        params.append(RequestParameter(\"name\", name))\n        params.append(RequestParameter(\"address\", address))\n        params.append(RequestParameter(\"state\", state))\n        params.append(RequestParameter(\"city\", city))\n        params.append(RequestParameter(\"zip\", zip))\n        params.append(RequestParameter(\"country\", country))\n        params.append(RequestParameter(\"page\", page))\n        params.append(RequestParameter(\"per_page\", pageSize))\n\n        return NetworkRequestServiceTask<RestaurantSearch>(\n            networkSession: networkSession,\n            baseUrl: baseUrl,\n            endpoint: \"restaurants\",\n            params: params)\n    }\n\n    public func findRestaurant(restaurantId: Int) -> ServiceTask<Restaurant> {\n        return NetworkRequestServiceTask<Restaurant>(\n            networkSession: networkSession,\n            baseUrl: baseUrl,\n            endpoint: \"restaurants/\\(restaurantId)\")\n    }\n}\n```\n\n```kotlin\n//RestaurantService.kt\npublic class RestaurantService(\n        val networkSession: HttpVolleySession = HttpVolleySession.getInstance(null, null),\n        val baseUrl: String = \"http://opentable.herokuapp.com/api/\") {\n\n    public fun findRestaurants(priceRange: Int? = null,\n                         name: String? = null,\n                         address: String? = null,\n                         state: String? = null,\n                         city: String? = null,\n                         zip: String? = null,\n                         country: String? = null,\n                         page: Int = 1,\n                         pageSize: Int = 25): ServiceTask<RestaurantSearch> {\n\n        val params = arrayListOf<RequestParameter>()\n        params.add(RequestParameter(\"price\", priceRange))\n        params.add(RequestParameter(\"name\", name))\n        params.add(RequestParameter(\"address\", address))\n        params.add(RequestParameter(\"state\", state))\n        params.add(RequestParameter(\"city\", city))\n        params.add(RequestParameter(\"zip\", zip))\n        params.add(RequestParameter(\"country\", country))\n        params.add(RequestParameter(\"page\", page))\n        params.add(RequestParameter(\"per_page\", pageSize))\n\n        return NetworkRequestServiceTask(clazz = RestaurantSearch::class.java,\n                networkSession = networkSession,\n                baseUrl = baseUrl,\n                endpoint = \"restaurants\",\n                params = params)\n    }\n\n    public fun findRestaurant(restaurantId: Int): ServiceTask<Restaurant> {\n        return NetworkRequestServiceTask(clazz = Restaurant::class.java,\n                networkSession = networkSession,\n                baseUrl = baseUrl,\n                endpoint = \"restaurants/${restaurantId}\")\n    }\n}\n```\n\nString similarity: **87.62%**\n\n`RestaurantService` is a class that provides access to the OpenTable API. It provides a couple of methods to make search queries, and return a `ServiceTask` object that encapsulates the networking request and mapping. The resulting code as you can see is **almost identical**, except for the usage of a `UrlSession` vs a `VolleySession` and **minor syntactic differences**. Of course, once again the implementation details of the `NetworkRequestServiceTask` will be different in both platforms to deal with the networking libraries, but API wise they are the same and the `NetworkRequestServiceTask` and its dependencies can be reused across projects.\n\n##### RestaurantListState\n\n```swift\n//RestaurantListState.swift\nstruct RestaurantsListState {\n    let restaurants: [Restaurant]\n    let page: Int?\n    let lastPage: Int?\n    let totalResults: Int?\n    let error: Error?\n    let isLoading: Bool\n\n    private init(restaurants:[Restaurant] = [], page: Int? = nil, lastPage: Int? = nil, totalResults: Int? = nil, error: Error? = nil, loading: Bool = false) {\n        self.restaurants = restaurants\n        self.page = page\n        self.lastPage = lastPage\n        self.totalResults = totalResults\n        self.error = error\n        self.isLoading = loading\n    }\n\n    static func notLoaded() -> Restaurants.List.State {\n        return Restaurants.List.State()\n    }\n\n    static func loading(page: Int, previousState: Restaurants.List.State) -> Restaurants.List.State {\n        return Restaurants.List.State(restaurants: previousState.restaurants, page: page, lastPage: previousState.lastPage, totalResults: previousState.totalResults, loading: true)\n    }\n\n    static func loaded(restaurants: [Restaurant], lastPage: Int, totalResults: Int) -> Restaurants.List.State {\n        return Restaurants.List.State(restaurants: restaurants, lastPage: lastPage, totalResults: totalResults)\n    }\n\n    static func failedLoad(error: Error, previousState: Restaurants.List.State) -> Restaurants.List.State {\n        return Restaurants.List.State(restaurants: previousState.restaurants, page: previousState.page, error: error)\n    }\n\n    var isLoaded: Bool { return lastPage != nil && totalResults != nil && isLoading == false }\n    var isNotLoaded: Bool { return page == nil && lastPage == nil && isLoading == false }\n    var isFailed: Bool { return error != nil }\n\n}\n```\n\n```kotlin\n//RestaurantListState.kt\ndata class RestaurantsListState private constructor(\n       val restaurants: Array<Restaurant> = arrayOf(),\n       val page: Int? = null,\n       val lastPage: Int? = null,\n       val totalResults: Int? = null,\n       val error: Error? = null,\n       val isLoading: Boolean = false) {\n\n   companion object {\n       fun notLoaded(): RestaurantsListState {\n           return RestaurantsListState()\n       }\n       fun loading(page: Int, previousState: RestaurantsListState): RestaurantsListState {\n           return RestaurantsListState(restaurants = previousState.restaurants, page = page, lastPage = previousState.lastPage, totalResults = previousState.totalResults, isLoading = true)\n       }\n       fun loaded(restaurants: Array<Restaurant>, lastPage: Int, totalResults: Int): RestaurantsListState {\n           return RestaurantsListState(restaurants = restaurants, lastPage = lastPage, totalResults = totalResults)\n       }\n       fun failedLoad(error: Error, previousState: RestaurantsListState): RestaurantsListState {\n           return RestaurantsListState(restaurants = previousState.restaurants, page = previousState.page, error = error)\n       }\n   }\n\n   val isLoaded: Boolean get() = lastPage != null && totalResults != null && isLoading == false\n   val isNotLoaded: Boolean get() = page == null && lastPage == null && isLoading == false\n   val isFailed: Boolean get() = error != null\n\n}\n```\n\nString similarity: **77.33%**\n\nHere he have `RestaurantListState`, which is just a plain class holding state information used by the ViewModel. In this particular case, there are no dependencies to any other library or system framework, and therefore the **code is again very similar** except for the minor differences commented above (ex: `static` methods vs `companion` methods or `struct` vs `data class`)\n\n##### RestaurantListViewModel\n\n\n\n```swift\n//RestaurantListViewModel.swift\nclass RestaurantsListViewModel {\n    private let restaurantService: RestaurantService\n    private let state = BehaviorSubject<Restaurants.List.State>(value: .notLoaded())\n\n    var stateObservable: Observable<Restaurants.List.State> { return state.asObservable() }\n    var stateValue: Restaurants.List.State { return try! state.value() }\n\n    init(restaurantService: RestaurantService) {\n        self.restaurantService = restaurantService\n    }\n\n    func loadNextPage() {\n        let nextPage = (stateValue.lastPage ?? 0) + 1\n        loadPage(nextPage)\n    }\n\n    private func loadPage(_ page: Int) {\n        guard !stateValue.isLoading else { return }\n\n        state.onNext(.loading(page: page, previousState: stateValue))\n\n        restaurantService.findRestaurants(country: \"US\", page: page)\n            .onCompletion { [weak self] (result: RestaurantSearch?) in\n                if let strongSelf = self {\n                    let restaurants = strongSelf.stateValue.restaurants\n                    strongSelf.state.onNext(.loaded(\n                        restaurants: restaurants + (result?.restaurants ?? []),\n                        lastPage: page,\n                        totalResults: result?.totalResults ?? restaurants.count))\n                }\n            }.onError { [weak self] (error) in\n                if let strongSelf = self {\n                    strongSelf.state.onNext(.failedLoad(error: error, previousState: strongSelf.stateValue))\n                }\n            }.execute()\n    }\n}\n```\n\n```kotlin\n    //RestaurantListViewModel.kt\n    class RestaurantsListViewModel(\n           private val restaurantService: RestaurantService) {\n       private val state = BehaviorSubject.create(RestaurantsListState.notLoaded())\n\n       val stateObservable: Observable<RestaurantsListState> get() = state.asObservable()\n       val stateValue: RestaurantsListState get() = state.value\n\n       fun loadNextPage() {\n           val nextPage = (stateValue.lastPage ?: 0) + 1\n           loadPage(nextPage)\n       }\n\n       private fun loadPage(page: Int) {\n           if (stateValue.isLoading) {\n               return\n           }\n\n           state.onNext(RestaurantsListState.loading(page = page, previousState = stateValue))\n\n           restaurantService.findRestaurants(country = \"US\", page = page)\n                .onCompletion { result ->\n                    val restaurants = stateValue.restaurants\n                    this.state.onNext(RestaurantsListState.loaded(\n                        restaurants = restaurants + (result?.restaurants ?: arrayOf()),\n                        lastPage = page,\n                        totalResults = result?.totalResults ?: restaurants.size))\n                }.onError { error ->\n                    this.state.onNext(RestaurantsListState.failedLoad(error = error, previousState = stateValue))\n                }.execute()\n       }\n    }\n```\n\nString similarity: **77.25%**\n\nThis class corresponds to the ViewModel that will be used by the list of restaurants screen. As you can see, once again **code fully resembles to each other**, with the small difference of memory management and `guard` statement in the Swift case. Very interesting to note as well is that this is the first code snippet using Rx. You can see how they both share the same methods and objects, so the resulting code is equivalent in both platforms. Thanks Rx for keeping consistency!\n\n##### RestaurantsCoordinator\n\n```swift\n//RestaurantsCoordinator.swift\nclass RestaurantsCoordinator: BaseCoordinator {\n    static var identifier = CoordinatorIdentifier<Restaurants.Coordinator>(identifier: \"RestaurantsCoordinator\")\n    private let restaurantService: RestaurantService\n\n    init(parentCoordinator: Coordinator?, restaurantService: RestaurantService = RestaurantService()) {\n        self.restaurantService = restaurantService\n        super.init(parentCoordinator: parentCoordinator)\n    }\n\n    override func start() {\n        let vm = Restaurants.List.ViewModel(restaurantService: restaurantService)\n        let vc = Restaurants.List.ViewController.newController(coordinator: self, viewModel: vm)\n        presentViewController(viewController: vc)\n    }\n\n    func openRestaurant(restaurant: Restaurant) {\n        let vm = Restaurants.Detail.ViewModel(restaurantService: restaurantService, restaurant: restaurant)\n        let vc = Restaurants.Detail.ViewController(coordinator: self, viewModel: vm)\n        presentViewController(viewController: vc)\n    }\n}\n\n```\n\n```kotlin\n//RestaurantsCoordinator.kt\nclass RestaurantsCoordinator(context: Context, parentCoordinator: Coordinator?, val restaurantService: RestaurantService = RestaurantService()): BaseCoordinator(context, parentCoordinator) {\n   companion object {\n       val identifier = CoordinatorIdentifier<RestaurantsCoordinator>(identifier = \"RestaurantsCoordinator\")\n   }\n\n   override fun start() {\n       val vm = RestaurantsListViewModel(restaurantService = restaurantService)\n       val intent = RestaurantsListActivity.newIntent(coordinator = this, viewModel = vm)\n       presentActivity(intent)\n   }\n\n   fun openRestaurant(restaurant: Restaurant) {\n       val vm = RestaurantsDetailViewModel(restaurantService = restaurantService, restaurant = restaurant)\n       val intent = RestaurantsDetailActivity.newIntent(coordinator = this, viewModel = vm)\n       presentActivity(intent)\n   }\n}\n```\n\nString similarity: **70.40%**\n\n`RestaurantsCoordinator` is the class responsible of navigation and coordination between the different parts in the MVVM. It basically instantiates new views, view models and services when needed, and present them in screen. Check it out because even if the navigation in both platforms is handled differently, **the resulting code is so similar that you can barely notice the differences** except for the constructors and statics.\n\n##### RestaurantsListView\n\n\n\n```kotlin\n//RestaurantsListViewController.swift\nclass RestaurantsListViewController: UIViewController {\n    fileprivate var viewModel: Restaurants.List.ViewModel!\n    fileprivate var coordinator: Restaurants.Coordinator!\n    fileprivate let disposeBag = DisposeBag()\n    @IBOutlet weak var tableView: UITableView!\n    @IBOutlet weak var searchTitle: UILabel!\n\n    static func newController(coordinator: Restaurants.Coordinator, viewModel: Restaurants.List.ViewModel) -> UIViewController {\n        let vc = R.storyboard.restaurantsListViewController.instantiateInitialViewController()!\n        vc.viewModel = viewModel\n        vc.coordinator = coordinator\n        return vc\n    }\n\n    override func viewDidLoad() {\n        super.viewDidLoad()\n\n        tableView.register(R.nib.restaurantTableViewCell)\n        tableView.register(R.nib.loadingTableViewCell)\n        tableView.register(R.nib.errorTableViewCell)\n\n        viewModel.stateObservable.subscribe(onNext: { [unowned self] state in\n            if let results = state.totalResults {\n                self.searchTitle.text = \"Number of restaurants: \\(results)\"\n            }\n            else if state.isLoading {\n                self.searchTitle.text = \"Loading restaurants\"\n            }\n        }).addDisposableTo(disposeBag)\n\n        //Data\n        cellDataObservable.bindTo(tableView.rx.items(dataSource: tableDataSource))\n            .addDisposableTo(disposeBag)\n\n        //Item selection\n        tableView.rx.modelSelected(CellData.self).subscribe(onNext: { [unowned self] (data) in\n            if  let restaurant = data.restaurant {\n                self.coordinator.openRestaurant(restaurant: restaurant)\n            }\n        }).addDisposableTo(disposeBag)\n\n        //Page loading\n        tableView.rx.willDisplayCell.filter { [unowned self] (cell, indexPath) -> Bool in\n            indexPath.row == self.viewModel.stateValue.restaurants.count - 1\n        }.subscribe(onNext: { [unowned self] (data) in\n            self.viewModel.loadNextPage()\n        }).addDisposableTo(disposeBag)\n    }\n\n    override func viewWillAppear(_ animated: Bool) {\n        super.viewWillAppear(animated)\n        if viewModel.stateValue.isNotLoaded || viewModel.stateValue.isFailed {\n            viewModel.loadNextPage()\n        }\n    }\n}\n\n//MARK: Table view management\nextension Restaurants.List.ViewController {\n    enum CellData {\n        case restaurant(Restaurant)\n        case loading\n        case error(Error)\n\n        var restaurant: Restaurant? {\n            guard case .restaurant(let restaurant) = self else { return nil }\n            return restaurant\n        }        \n    }\n\n    struct SectionOfData: SectionModelType {\n        typealias Item = CellData\n        var items: [Item]\n\n        init(items: [Item]) {\n            self.items = items\n            self.identity = identity\n        }\n        init(original: SectionOfData, items: [Item]) {\n            self = original\n            self.items = items\n        }\n    }\n\n    fileprivate var cellDataObservable: Observable<[SectionOfData]> {\n        return viewModel.stateObservable.map { [weak self] (state) -> [SectionOfData] in\n            let restaurants: [CellData] = state.restaurants.map { .restaurant($0) }\n            var sections = [SectionOfData(items: restaurants)]\n            if self?.viewModel.stateValue.isLoading ?? false {\n                sections.append(SectionOfData(items: [.loading]))\n            }\n            else if let err = self?.viewModel.stateValue.error {\n                sections.append(SectionOfData(items: [.error(err)]))\n            }\n            return sections\n        }\n    }\n\n    fileprivate var tableDataSource: RxTableViewSectionedDataSource<SectionOfData> {\n        let dataSource = RxTableViewSectionedDataSource<SectionOfData>()\n        dataSource.configureCell = { ds, tv, ip, item in\n            switch item {\n            case .restaurant(let restaurant):\n                let cell = tv.dequeueReusableCell(withIdentifier: R.nib.restaurantTableViewCell, for: ip)!\n                cell.configure(restaurant: restaurant)\n                return cell\n\n            case .loading:\n                let cell = tv.dequeueReusableCell(withIdentifier: R.nib.loadingTableViewCell, for: ip)!\n                cell.configure(message: \"Loading restaurants\")\n                return cell\n\n            case .error(let err):\n                let cell = tv.dequeueReusableCell(withIdentifier: R.nib.errorTableViewCell, for: ip)!\n                cell.configure(error: err)\n                return cell\n            }\n        }\n        return dataSource\n    }\n\n}\n```\n\n```kotlin\n//RestaurantsListActivity.kt\nclass RestaurantsListActivity : AppCompatActivity() {\n   enum class Sections { restaurant, loading, error }\n\n   lateinit var coordinator: RestaurantsCoordinator\n   lateinit var viewModel: RestaurantsListViewModel\n\n   companion object {\n       fun newIntent(coordinator: RestaurantsCoordinator, viewModel: RestaurantsListViewModel, @LayoutRes layoutId: Int = R.layout.restaurants_list_activity): Intent {\n           val intent = Intent(coordinator.context, RestaurantsListActivity::class.java)\n           ActivityInjector.register(intent) { activity: RestaurantsListActivity ->\n               activity.coordinator = coordinator\n               activity.viewModel = viewModel\n               activity.setContentView(layoutId)\n           }\n           return intent\n       }\n   }\n\n   override fun onCreate(savedInstanceState: Bundle?) {\n       super.onCreate(savedInstanceState)\n       ActivityInjector.inject(this)\n\n       viewModel.stateObservable.subscribe {\n           if (it.totalResults != null) {\n               search_title.text = \"Number of restaurants: ${it.totalResults}\"\n           }\n           else if (it.isLoading) {\n               search_title.text = \"Loading restaurants\"\n           }\n       }\n\n       recyclerView.adapter = recyclerViewAdapter\n       recyclerView.layoutManager = layoutManager\n\n       //Item selection\n       recyclerViewAdapter.modelSelected.subscribe { data ->\n           val restaurant = data.restaurant\n           if (restaurant != null) {\n               this.coordinator.openRestaurant(restaurant = restaurant)\n           }\n       }\n\n       //Page loading\n       RxRecyclerView.scrollEvents(recyclerView).filter { event ->\n           layoutManager.findLastVisibleItemPosition() == viewModel.stateValue.restaurants.size - 1\n       }.subscribe {\n           viewModel.loadNextPage()\n       }\n   }\n\n   override fun onResume() {\n       super.onResume()\n       if (viewModel.stateValue.isNotLoaded || viewModel.stateValue.isFailed) {\n           viewModel.loadNextPage()\n       }\n   }\n\n   override fun onDestroy() {\n       super.onDestroy()\n       if (isFinishing) {        //Only unregister when explicit finish happens\n           ActivityInjector.unregister(intent)\n       }\n   }\n\n   // List management\n   data class CellData(val restaurant: Restaurant? = null, val loading: Boolean = false, val error: Error? = null)\n\n   val cellDataObservable: Observable<List<SectionModelType<CellData>>> by lazy {\n       viewModel.stateObservable.flatMap { state ->\n           val restaurants = state.restaurants?.map { CellData(restaurant = it) } ?: listOf()\n           val sections = arrayListOf(SectionModelType<CellData>(restaurants, Sections.restaurant.ordinal))\n           if (viewModel.stateValue.isLoading) {\n               sections.add(SectionModelType<CellData>(listOf(CellData(loading = true)), Sections.loading.ordinal))\n           }\n           else if (viewModel.stateValue.isFailed) {\n               sections.add(SectionModelType<CellData>(listOf(CellData(error = viewModel.stateValue.error)), Sections.error.ordinal))\n           }\n           Observable.just(sections.toList())\n       }\n   }\n\n   val recyclerViewAdapter: RxRecyclerViewAdapter<CellData> by lazy {\n       RxRecyclerViewAdapter(cellDataObservable)\n               .useLayoutId { type ->\n                   if (type == Sections.restaurant.ordinal) {\n                       R.layout.restaurant_cell_layout\n                   }\n                   else if (type == Sections.loading.ordinal) {\n                       R.layout.loading_cell_layout\n                   }\n                   else {\n                       R.layout.error_cell_layout\n                   }\n               }\n               .configureItem { view, data, position, type ->\n                   if (type == Sections.restaurant.ordinal) {\n                       val restaurant = data.restaurant\n                       if (restaurant != null) {\n                           view.pictureImageView.loadImage(restaurant)\n                           view.nameTextView.setText(restaurant.name)\n                           view.addressTextView.setText(restaurant.address)\n                           var price = \"\"\n                           kotlin.repeat(restaurant.price) {\n                               price = price + \"€\"\n                           }\n                           view.priceTextView.setText(price)\n                       }\n                   }\n                   else if (type == Sections.error.ordinal) {\n                       view.textView.setText(data.error?.message)\n                   }\n               }\n   }\n\n   val layoutManager = LinearLayoutManager(this)\n\n}\n```\n\nString similarity: **52.27%**\n\nOK, so here is the big deal. So far, code was very similar and can be easily shared (with small editions) from one to the other platform. However, as we warned above, the UI code will be very different. How much? You can compare it by yourself...\n\nBasically, they **both share a common approach** in which they have a constructor receiving the dependencies (for a very simple Dependency Injection); a view creation method (`viewDidLoad` / `onCreate`) that basically subscribes to the ViewModel observables and configures the list; a view appear method (`viewWillAppear` / `onResume`) that will load new results; and a set of methods and types to deal with the information from the list, which by the way could have been moved partially to the ViewModel probably.\n\nAs you can see, **they are similar (especially conceptually) but not equal**, so all in all I would say that you could use one as a template for the other, but you will still need to write about half of the code, but judge it yourself. \n\nOf course, if you create your own wrappers around the UI components, you could actually achieve a much higher code reuse rate by exposing similar APIs, but you will need to develop them and they will introduce extra learning steps for new developers (like I did for networking in the `NetworkServiceTask`, use a similar API with different implementations)\n\n<u>Off-topic</u>: note how the usage of Kotlin extensions removed all of the `findViewById` so typical (and error prone) in Android UI classes, and in iOS the usage of [R.swift](https://github.com/mac-cain13/R.swift) is also cleaning up many of the hardcoded strings.\n\n##### Layout\n\nIn this case I am not copying the layout code because **it is completely different**. In iOS, I have used Interface Builder to set my views, while in Android it uses layout XMLs.\n\n### Conclusion\n\n**Swift and Kotlin are great languages**, both adding a lot of added value to their corresponding alternative for mobile apps (Objective-C / Java). They are **safer** thanks to a strict strongly typed system that includes nullability in it. They are both very **pleasant** to work with because of a impressive type inference compiler and a beautiful and modern syntax. They both have very **powerful features**, like extensions, immutability and functional programming additions that allow new and better patterns and constructions to emerge.\n\nHowever, **although very similar**, they are not identical. **They have a few differences intrinsic to the language and the SO/runtime** where they run that makes impossible to use the exact same code in both platforms. Nevertheless, if we structure our code with a good pattern and **separation of concerns**, we can certainly get very similar code in most of our classes, keeping the main differences when interacting with system APIs like UI or Networking isolated. \n\nWe have seen a few examples of different parts of the app using MVVM + Rx + Coordinators, and we can see how code resembles to each other in the example classes (between 50% to 90% code matching, not counting layout). In fact, it is so similar that I made most of one platform as a copy+paste+edit from the other one, **saving a lot of time and reducing bugs** as both will behave almost identically. An added benefit is that Kotlin developers will be able to read/write Swift with ease and vice versa, which helps **consolidating teams, practices and code across platforms**, but still writing **fully native and high quality apps** with small differences to **adapt to different user’s expectations** derived from the platform itself (which is a big difference with other cross platform solutions out there like [ReactNative](https://facebook.github.io/react-native/), [Xamarin](https://www.xamarin.com/) or [PhoneGap/Cordova](http://phonegap.com/))\n\nNote: String similarity calculated with [Tools4Noobs](https://www.tools4noobs.com/online_tools/string_similarity/)\n\n","author":"Angel G. Olloqui","date":"2016-10-18","type":"article","categories":["Kotlin","Swift"],"features":["highlightjs"],"description":"","filename":"","lang":"EN","enclosure":null},{"title":"10 Kotlin Tutorials for Beginners: Dive Into Kotlin Programming","url":"http://petersommerhoff.com/dev/kotlin/kotlin-beginner-tutorial/","body":"\n\n# 10 Kotlin Tutorials for Beginners: Dive Into Kotlin Programming\n\nThere is a serious lack of Kotlin tutorials for beginners![The first Kotlin tutorial for beginners](http://petersommerhoff.com/wp-content/uploads/2016/02/kotlin-programming-course-300x169.png). You only find experienced Java developers hacking down Kotlin code in record time. Don’t get me wrong — those are really great for other experienced developers and I enjoy watching them. But for beginners, they are just voodoo code appearing on the screen like magic.\n\nKotlin is actually a great language to learn first, if only the necessary tutorials were out there. So I decided to create a course that even total beginners can follow. Check out the first 10 Kotlin tutorials below or [check out the whole course](https://www.udemy.com/kotlin-course/?couponCode=AMAZINGREADERS25) (it’s $25 with the 50% reader discount).\n\n## #1: A Brief Overview of Kotlin\n\nLearn where Kotlin comes from, the language concepts it incorporates, and _why you should learn it_.\n\n<iframe src=\"https://www.youtube.com/embed/AcwzpPLV5HY?feature=oembed\" allowfullscreen=\"\" height=\"540\" frameborder=\"0\" width=\"960\"></iframe>\n\n##  #2: Try It Out in 30 Seconds\n\nThis is a quick video for those who cannot wait to dive into code. Learn how to use the [Kotlin online editor](http://try.kotlinlang.org/) to try out some of the language basics.\n\n<iframe src=\"https://www.youtube.com/embed/kdorCemb2v8?feature=oembed\" allowfullscreen=\"\" height=\"540\" frameborder=\"0\" width=\"960\"></iframe>\n\n## #3: Installing the JDK\n\nIf you already have the Java Development Kit (JDK) installed, you can happily skip this step. If not, just follow this video and use [this link](http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html) that is mentioned in the video.\n\n<iframe src=\"https://www.youtube.com/embed/2rOYygAEEQQ?feature=oembed\" allowfullscreen=\"\" height=\"540\" frameborder=\"0\" width=\"960\"></iframe>\n\n## #4: Installing IntelliJ\n\nIf you don’t already have IntelliJ, you should change that right away — I really learned to love this powerful IDE. This tutorial guides you through the download and installation process. And [here’s the link](http://www.jetbrains.com/idea/) mentioned in the video.\n\n<iframe src=\"https://www.youtube.com/embed/EbGHqY5EJvU?feature=oembed\" allowfullscreen=\"\" height=\"540\" frameborder=\"0\" width=\"960\"></iframe>\n\n## #5: Setting Up IntelliJ\n\nThis tutorial covers just the most basic layout settings: how you can adjust the theme and font in IntelliJ to your favorite style.\n\n<iframe src=\"https://www.youtube.com/embed/TtIKESmXTXQ?feature=oembed\" allowfullscreen=\"\" height=\"540\" frameborder=\"0\" width=\"960\"></iframe>\n\n## #6: Using Kotlin Interactively in The REPL\n\nThe Kotlin REPL allows us to use Kotlin interpreter-style, so that we can put in an expression (or any line of code) and see what Kotlin does with it. It’s great to try out some basic expressions and calculations.\n\n<iframe src=\"https://www.youtube.com/embed/wDkWaHYiLWk?feature=oembed\" allowfullscreen=\"\" height=\"540\" frameborder=\"0\" width=\"960\"></iframe>\n\n## #7: Variables\n\nIt’s time to learn about variables in Kotlin. This tutorial covers how to create and use variables of different types and the differences of the val and var keywords (to create immutable and mutable variables, respectively).\n\n<iframe src=\"https://www.youtube.com/embed/Nz-lMqxfUUs?feature=oembed\" allowfullscreen=\"\" height=\"540\" frameborder=\"0\" width=\"960\"></iframe>\n\n## #8: Basic Types & Strings\n\nThis tutorial covers all the basic types in Kotlin including strings. In the video, I go through the differences between the different data types for storing integer values, floating point numbers, text and logical values.\n\n<iframe src=\"https://www.youtube.com/embed/8JhPR-vojiI?feature=oembed\" allowfullscreen=\"\" height=\"540\" frameborder=\"0\" width=\"960\"></iframe>\n\n## #9: Nullable Variables\n\nKotlin gets rid of the worst enemy of all Java developers — the NullPointerException. In Kotlin, you can use nullable types to decide which variables can be set to null and which cannot. By default, a variable just cannot be assigned to null.\n\n<iframe src=\"https://www.youtube.com/embed/PYwJ-07I9as?feature=oembed\" allowfullscreen=\"\" height=\"540\" frameborder=\"0\" width=\"960\"></iframe>\n\n## #10: Your First Standalone Application\n\nThis tutorial covers how you can create a main() function in Kotlin to define the entry-point to your applications. Once you have made it through this lecture, you’re ready to go and really dive into development with Kotlin.\n\n<iframe src=\"https://www.youtube.com/embed/wqUfs89N5yg?feature=oembed\" allowfullscreen=\"\" height=\"540\" frameborder=\"0\" width=\"960\"></iframe>\n\n## Continue Learning...\n\nIf you’re as excited about Kotlin as I am, you can get my whole course on Udemy for $25 using [this coupon link](https://www.udemy.com/kotlin-course/?couponCode=AMAZINGREADERS25).\n\nInside the course, you’ll go from the basics to more advanced topics. These include:\n\n* Conditional expressions using _if_ and _when_\n* Loops using _for_ and _while_\n* Arrays and lists\n* Functions\n* Classes, objects, interfaces, inheritance and all you need to know about object-orientation\n* Functional programming in Kotlin\n* Several coding challenges and quizzes for you to test what you’ve learned\n\nThe course will be improved and extended based on student feedback and I’ll be there to help you personally whenever you get stuck. That way, there is no excuse for not learning Kotlin — even if you’re a total beginner.\n\n[Join the course now (50% discount for my readers)](https://www.udemy.com/kotlin-course/?couponCode=AMAZINGREADERS25)\n\n## Any Thoughts?\n\nWhat do you think about Kotlin? Is it “better than Java” or just yet another JVM language for you?\n\nWhat else do you want to learn about Kotlin? Let me know in the comments and I’ll respond to you personally.\n\n","author":"Peter Sommerhoff","date":"2016-02-02","type":"article","categories":["Kotlin","Videos"],"features":["highlightjs"],"description":"","filename":"","lang":"EN","enclosure":null},{"title":"Exploring the Kotlin Standard Library - Part 2","url":"http://jamie.mccrindle.org/2013/01/exploring-kotlin-standard-library-part-2.html","body":"\nIn [Part 1](http://jamie.mccrindle.org/2013/01/exploring-kotlin-standard-library-part-1.html) of this series, I went through the default Kotlin namespace. In Part 2 I'll be going over [kotlin.io](http://jetbrains.github.com/kotlin/versions/snapshot/apidocs/kotlin/io/package-summary.html).\n\nMost of the public function in kotlin.io are overloaded versions of print and println, which all delegate to System.out.\n\nkotlin.io also introduces readLine for reading lines from stdin and the use method. The use method is a great example of a general purpose extension method. The signature illustrates how to create an extension method that will apply to every class that implements Closeable:\n\n```kotlin\npublic inline fun <T: Closeable, R> T.use(block: (T)-> R) : R\n```\n\nThe iterate method from the default namespace works very well with the readLine method. A function to count the number of lines from stdin would look as follows:\n\n```kotlin\nfun main(args: Array<String>) = iterate{ readLine() }.count({ true })\n```\n\nThe following example uses the 'use' method to read the text from a reader while managing its lifecycle:\n\n```kotlin\n// gets the contents fo the reader and then closes it\nvar contents = reader.use { it.readText() }\n```\n\nThe use method will return whatever the closure returns (in this case, the contents of the reader as a String).\n\nkotlin.io extends java.io.File, java.io.InputStream, java.io.OutputStream, java.io.Reader, java.io.Writer, java.io.BufferedReader and java.net.URL.\n\nFor reading files or streams, the API docs distinguish between those methods that can be used on huge amounts of data and those that can't. Those that can't are the ones that wait for the entire file to be read before returning a result e.g. readLines, whereas the those that use a closure or iterator pull data lazily. The following calls should not be used with huge amounts of data\n\n* readBytes\n* readLines\n* readText\n\nThe following can be used for huge amounts of data:\n\n* copyTo\n* forEachBlock\n* forEachLine\n\nFor InputStreams, Readers and Writers, the caller is typically responsible for closing the various streams, the exception being the useLines method.\n\nThe Kotlin stdlib enhances with java.io.File with a number of useful methods: copyTo, forEachBlock, forEachLine, isDescendant, listFiles, readBytes, readLines, readText, reader, recurse, relativePath, writeBytes, writeText\n\nThe following is an example of copyTo being used:\n\n```kotlin\nFile(\"/tmp/from.txt\").copyTo(File(\"/tmp/to.txt\"))\n```\n\nNote the following:\n\n* copyTo only works on files (not directories)\n* copyTo will create the target directory\n* copyTo will overwrite the target file\n* if the source file can't be found a FileNotFoundException will be thrown\n* copyTo will block until the file is written\n\nAs an example, the forEachBlock method could be used to provide a version of copyTo that reports progress as the target file is written as follows:\n\n```kotlin\n/**\n * Copies a file and calls the closure with the current number of bytes read as each block is read\n * to indicate progress\n */\npublic fun File.copyToWithProgress(file: File, closure : (Long) -> Unit) {\n    file.directory.mkdirs()\n    val output = FileOutputStream(file)\n    output.use{\n        var length = 0.toLong()\n        this.forEachBlock { bytes, size ->\n            length += size\n            output.write(bytes, 0, size)\n            closure(length)\n        }\n    }\n}\n```\n\nHere are a few more examples of what can be done with kotlin.io\n\n```kotlin\n// forEachLine\n//\n// reads all the lines from a file and prints them out\nFile(\"/tmp/from.txt\").forEachLine { println(it) }\n\n// isDescendent\n//\n// Confirms that from.txt is a descendant of /tmp\nval isDescendent = File(\"/tmp/from.txt\").isDescendant(File(\"/tmp\"))\n\n// listFiles\n//\n// Lists all the subdirectories in /tmp\nval files = File(\"/tmp\").listFiles{ it.isDirectory() }\n\n// readBytes\n//\n// reads all the bytes from /tmp/from.bin\nval bytes = File(\"/tmp/from.bin\").readBytes()\n\n// readLines\n//\n// reads all the lines from /tmp/from.txt into a list\n// and then runs through each line in the list and prints it out\nval lines = File(\"/tmp/from.txt\").readLines()\nlines.forEach { println(it) }\n\n// readText\n//\n// reads all the text from /tmp/from.txt into a string\n// and then checks if it contains a multiline string\nval text = File(\"/tmp/from.txt\").readText()\nval found = text.contains(\"hello\\nworld\\n!\")\n\n// reader\n//\n// creates a reader and calls useLines on it\nval fileReader = File(\"/tmp/from.txt\").reader().useLines {\n    // same as calling forEachLine\n}\n\n// recurse\n//\n// recurse through all the files in /tmp and print out their names\nFile(\"/tmp\").recurse { println(it.name) }\n\n// relativePath\n//\n// returns nested/directory/file.txt\nFile(\"/tmp\").relativePath(File(\"/tmp/nested/directory/file.txt\"))\n\n// writeBytes\n//\n// write Hello World as bytes to /tmp/helloworld.bin\nFile(\"/tmp/helloworld.bin\").writeBytes(\"Hello World!\".getBytes())\n\n// writeText\n//\n// write Hello World as bytes to /tmp/helloworld.txt\nFile(\"/tmp/helloworld.txt\").writeText(\"Hello World!\")\n```\n\n","author":"Jamie McCrindle","date":"2013-01-25","type":"article","categories":["Kotlin"],"features":["highlightjs"],"description":"","filename":"","lang":"EN","enclosure":null},{"title":"Kotlin 1.0 Released: Pragmatic Language for JVM and Android","url":"http://blog.jetbrains.com/kotlin/2016/02/kotlin-1-0-released-pragmatic-language-for-jvm-and-android/","body":"\nThis is it. 1.0 is here!\n\nIt’s been a long and exciting road but we’ve finally reached the first big 1.0, and we’re celebrating the release by also presenting you with the new logo:\n\n![Kotlin logo](http://i0.wp.com/blog.jetbrains.com/kotlin/files/2016/02/1_0_Banner.png?resize=640%2C320)\n\nSee discussions on [Reddit](https://www.reddit.com/r/programming/comments/45wcnd/kotlin_10_released_pragmatic_language_for_jvm_and/) and [Hacker News](https://news.ycombinator.com/item?id=11103087)\n\n## What is Kotlin?\n\nKotlin is a pragmatic programming language for JVM and Android that combines OO and functional features and is focused on **interoperability**, **safety**, **clarity** and **tooling** support.\n\nBeing a general-purpose language, Kotlin **works everywhere where Java works**: server-side applications, mobile applications (Android), desktop applications. It works with all major tools and services such as\n\n* IntelliJ IDEA, Android Studio and Eclipse\n* Maven, Gradle and Ant\n* Spring Boot (Kotlin support released today!)\n* GitHub, Slack and even Minecraft :)\n\nOne of the key focuses of Kotlin has been interoperability and seamless support for **mixed Java+Kotlin projects**, making adoption easier leading to less boilerplate code and more type-safety. Additionally, Kotlin has an **extensive standard library** that makes everyday tasks easy and smooth while keeping the bytecode footprint [low](http://www.methodscount.com/?lib=org.jetbrains.kotlin%3Akotlin-stdlib%3A1.0.0-rc-1036). Of course, **any Java library can be used in Kotlin**, too; and vice versa. \n\n## What does pragmatic mean?\n\nUnderstanding one’s core values is crucial for any long-running project. If I were to choose one word to describe Kotlin’s design, it would be **pragmatism**. This is why, early on, we said that Kotlin is not so much about invention or research. We ended up inventing quite a few things, but this was never the point of the project. Of course we were building a **type system that prevents bugs**, and **abstraction mechanisms that facilitate code reuse**, as anybody in our position would. But our (pragmatic) way of doing it was through **focusing on use cases** to make the language a **good tool**.\n\nIn particular, this approach lead us immediately to the notion that **interoperability with existing code and infrastructure is crucial**. Re-writing the world the right way, all from scratch — who never wished to? I did, quite a few times :) And Kotlin would have been a whole lot easier to design and develop if not for the Java interop, Maven integration, Android compatibility! It would definitely be more elegant in many ways. But elegance, though highly appreciated, is not the primary goal here, **the primary goal is being useful**. And the less our users have to re-learn, re-invent, re-do from scratch, the more they can re-use, the better.\n\n— ***So, why doesn’t Kotlin have its own package manager, or its own build system?***\n— Because there’s already Maven and Gradle, and re-using their huge number of plugins is crucial for many projects.\n— ***Why did we invest a lot of time and effort into making JDK-compatible collection interfaces, when it was so much easier to just redesign collections from scratch?***\n— Because tons and tons of Java code work with JDK collections, and converting data on the boundary would be a pain.\n— ***Why does Kotlin support Java 6 byte code?***\n— Because many people are still running Java 6 (Android, most notably, but not only Android).\n\nFor us pragmatism is about **creating user experience**, not a language or a library alone. Many of the language design decisions were made under constraints like “Won’t this impede incremental compilation?”, “What if this increases APK method counts?”, “How will the IDE highlight this as-you-type?”, and many more like these. As a result, we are proud of our **tooling as well as the language**.\n\n## Is it mature enough and ready for production?\n\nYes. And it has been for quite some time. At JetBrains, we’ve not only been implementing the compiler and tooling but have also been using Kotlin **in real-life projects** on a rather extensive scale over the last two years. In addition to JetBrains, there are quite a few companies that have been using Kotlin **in production** for some time now.\n\nIn fact, one of the reasons it took us a long time to reach 1.0 was because we paid extra attention to validating our design decisions in practice. This was and is necessary, because moving forward the compiler will be **backwards compatible** and future versions of Kotlin must not break existing code. As such, whatever choices we’ve made we need to stick with them.\n\nReaching this milestone was something we couldn’t have done without the valuable **help of early adopters**. We want to thank each any every one of you for your bravery, energy and enthusiasm!\n\n## Who’s behind Kotlin?\n\nFirst and foremost, Kotlin is an Open Source language\n\n* Developed on [GitHub](https://github.com/JetBrains/kotlin) **under Apache 2.0 Open-Source license**;\n* With **over 100 contributors** to date.\n\nJetBrains is the main backer of Kotlin at the moment: we have invested a lot of effort into developing it and **we are committed to the project for the long run**. We wrote it out of our own need to use in our own products. And we’re happy to say that to date, **close to 10 JetBrains products**, which include IntelliJ IDEA, [JetBrains Rider](https://blog.jetbrains.com/dotnet/2016/01/13/project-rider-a-csharp-ide/), JetBrains Account & E-Shop, YouTrack as well as some of our smaller IDE’s and some internal projects are using Kotlin. So **it’s here to stay**!\n\nSince 2012 we kept Kotlin’s development very open: talking to the community all the time, gathering and addressing lots of feedback.\n\nMoving forward we are planning to set up a centralized venue for design proposals and discussions, to make the process even more visible and organized. Standardization efforts have not been started for Kotlin so far, but we realize that we’ll need to do it rather sooner than later.\n\nLanguage design and overall steering of the project is done by the team employed at JetBrains. We currently have **over 20 people working full time** on Kotlin, which also yet another testament to JetBrains’ commitment to Kotlin.\n\n## The numbers\n\nLet’s take a look at some numbers:\n\n* **11K+** people were using Kotlin last month and near **5K** last week alone;\n* **Hundreds** of [StackOverflow answers](http://stackoverflow.com/questions/tagged/kotlin);\n* **Two books**: [Kotlin in Action](https://www.manning.com/books/kotlin-in-action) and [Kotlin for Android Developers](https://leanpub.com/kotlin-for-android-developers);\n* **About 1400 people** on [Slack](http://kotlinlang.slack.com/) ([get an invite](http://kotlinslackin.herokuapp.com/));\n* **Over 500K** lines of Kotlin code in projects such as IntelliJ IDEA and Rider.\n\nTalking about lines of code, the number of these in open repositories on GitHub is **growing exponentially over time** (JetBrains’ projects excluded):\n\n\n![Kotlin GitHub Adoption](http://blog.jetbrains.com/kotlin/files/2016/02/KotlinAdoption.gif)\n\nAnd of course we have a growing list of **companies using Kotlin** including Prezi and Expedia. By the way, if you’re using Kotlin, make sure you send us a [Pull Request](https://github.com/JetBrains/kotlin-web-site/blob/master/_data/companies-using-kotlin.yml).\n\n## The upcoming roadmap\n\nAs of 1.0, we are committed to long-term **backward compatibility** of the language and its standard library (`kotlin-stdlib`):\n\n* **a newer compiler will work with older binaries** (but older compilers may not understand newer binaries, like javac 1.6 can’t read classes compiled by javac 1.8);\n* **older binaries will keep working with newer binaries at runtime** (newer code may require newer dependencies, though).\n\nThis applies to the JVM/Android support only. The JavaScript support remains experimental for now and will have its own release later on.\n\nAs for the plans, our nearest goals are (apart from bug fixes):\n\nConstant performance improvements for the Kotlin toolchain (this includes, for example, incremental compilation in Gradle, that is in the works now);\nJavaScript support (including cross-compilation into both JVM and JS where possible);\nSupport generating Java 8 byte code with optimized lambdas, etc (Java 6 will be actively supported as long as Android users need it).\nTooling updates and bug fixes will be released as incremental updates, i.e. 1.0.X. Bigger changes will first go though an Early Access Program (EAP) and then will be released as 1.1.\n\n## How to start\n\nThe easiest way to play with the language is through its **online mini-IDE**: [try.kotl.in](https://try.kotlinlang.org/), including [Koans](http://try.kotlinlang.org/koans) — a set of introductory problems which **guide you through the basics** of the language.\n\nTo use Kotlin on your machine (and Koans can be completed [offline](https://kotlinlang.org/docs/tutorials/koans.html) as well):\n\n* **IntelliJ IDEA** ([Ultimate or Community](https://www.jetbrains.com/idea/download/)): just create a Kotlin project or a Kotlin file in a Java project;\n* **Android Studio**: install the plugin through ***Plugin Manager***;\n* **Eclipse**: install the plugin through [Marketplace](https://marketplace.eclipse.org/content/kotlin-plugin-eclipse).\n\nNOTE: If you are running an older version, you may need to update your Kotlin plugin to 1.0.\n\nTo get up to speed with concepts, language **docs and tutorials** are available from the [official web site](https://kotlinlang.org/). Great articles and presentations given by members of our community can be found in the [Digest of 2015](http://blog.jetbrains.com/kotlin/2016/01/kotlin-digest-2015/).\n\nIf you’re introducing Kotlin to your Java project, you can make use of the **Java-to-Kotlin converter** built into the IDE, helping migration easier class by class.\n\nLast but not least, make sure you join the discussions on our [Forum](https://devnet.jetbrains.com/community/kotlin) or [Slack](http://kotlinslackin.herokuapp.com/).\n\nOnce again, **we want to thank everyone**. We couldn’t have done this without the community.\n\nHave a nice Kotlin! **Now** :)\n\nP.S. See discussions on [Reddit](https://www.reddit.com/r/programming/comments/45wcnd/kotlin_10_released_pragmatic_language_for_jvm_and/) and [Hacker News](https://news.ycombinator.com/item?id=11103087)\n","author":"Andrey Breslav","date":"2016-02-15","type":"article","categories":["JetBrains","Kotlin"],"features":["highlightjs"],"description":"","filename":"","lang":"EN","enclosure":null},{"title":"Kotlin Night London","url":"https://www.youtube.com/watch?list=PLoo7Ank5cc7FaemZS4sZC0oFnSbdJ-PiH&v=TMZD1GxAC8E","body":"\n[Announce](https://blog.jetbrains.com/kotlin/2016/09/kotlin-night-in-london/) | [Post in Kotlin Blog](https://blog.jetbrains.com/kotlin/2016/11/kotlin-night-in-london-recordings/)\n\n<iframe width=\"960\" height=\"480\" src=\"https://www.youtube.com/embed/videoseries?list=PLoo7Ank5cc7FaemZS4sZC0oFnSbdJ-PiH\" frameborder=\"0\" allowfullscreen></iframe>\n\n","author":"JetBrains","date":"2016-11-15","type":"video","categories":["Kotlin"],"features":["highlightjs"],"description":"","filename":"","lang":"EN","enclosure":null},{"title":"Kotlin Native","url":"https://medium.com/@octskyward/kotlin-native-310ffac94af2#.3oep6gxpa","body":"\n### Kotlin Native\n\nA frequent question about Kotlin is if/when it will support compilation to native binaries that run without a JVM. Usually this takes the form of a more technical question like, “will the Kotlin compiler get an LLVM backend?”\n\nI am not on the JetBrains team and I believe they’ve already made up their minds to do this, but I don’t personally think this feature would be the best way to solve the problems that are driving these questions.\n\nLuckily, there are better ways that can. Kotlin doesn’t need an LLVM backend: the wider JVM community is producing all the needed puzzle pieces already. Someone just has to put them together.\n\n### Why do people want native binaries?\n\nHere’s an entirely unscientific summary of the top reasons why people so often request a native backend for managed languages, based on conversations I’ve had over the years:\n\n1. They think the code would run faster or use less memory\n2. They want better startup time\n3. They think deploying programs that have only one file is simpler\n4. They want to avoid garbage collection\n5. They want to run on iOS, which forbids JIT compilers by policy\n6. They want better native-code interop\n\nThis list covers two of the three reasons cited by [the Scala Native website](http://www.scala-native.org/) for why it exists. The other reason is that Scala Native is extending the language to support C++ like constructs that are normally forbidden by the JVM, like forced stack allocation, but building a better C++ is already being handled by Rust. I suspect that trying to convert Scala or Kotlin into C++/Rust competitors wouldn’t go well.\n\nSometimes people think a ‘native’ version of a managed language would fix problems that have nothing to do with compiler technology, like [this guy](https://news.ycombinator.com/item?id=11226023) who believes it would change font rendering. I’ve seen ‘native’ become a mythical cure-all for any frustration or problem the user might have ... which isn’t surprising, given that most people have no experience with managed-to-native technologies.\n\n### A ‘Kotlin Native’ would make slower code\n\nIt is a common belief that code compiled by an ahead-of-time compiler must be faster or less memory hungry than just-in-time compiled code. I used to believe this too. It makes sense: C++ apps run fast, and C++ compilers are very slow. It stands to reason that the compilers are slow because they’re spending a lot of time optimising the code they’re producing. Surely, a compiler that can only grab a handful of spare cycles here and there whilst the app is running can never do such a good job?\n\nUnfortunately, performance is subtle and often unintuitive. C++ compilers are slow mostly due to the #include and generics model the language uses, not due to optimisations. And a team at Oracle is adding ahead of time compilation to HotSpot. They gave a tech talk about it last year called “[Java goes AOT](https://www.youtube.com/watch?v=Xybzyv8qbOc)”. Plain old AOT seems to give around 10%–20% slower code, depending on the kind of app (in the talk this is the difference between tiered and non-tiered). The reason is that virtual machines that support deoptimization, as the JVM does, can make speculative optimisations that aren’t always correct. Programs written in higher level languages benefit from this technique more, for instance Scala code benefits more than Java code does. The AOT compiler they’re using (Graal) isn’t weak or amateur: it’s competitive with GCC when compiling C code. It’s just that these advanced optimisations are really powerful.\n\nIt’s for this reason that the HotSpot AOT mode actually supports using a mix of AOT and JIT compiled code. The app can be compiled ahead of time so the interpreter isn’t used, but in a way that self-profiles. Then the JIT compiler is still invoked at runtime to recompile the hot spots, winning back most of the performance loss. You get a much less severe warmup period, whilst still obtaining the best peak performance.\n\nAndroid has learned the same lesson. The replacement for Dalvik that was introduced in Marshmallow (ART) started out as a pure AOT compiler. In Android N, it will start using a mix of AOT and JIT compilation.\n\nAdditionally, the shortest path to a Kotlin-specific native compiler backend would be LLVM. LLVM is primarily used to compile C and C++. Many optimisations that can really help high level managed languages like Kotlin simply don’t apply to C++, so LLVM doesn’t implement them at all. That’d result in an even bigger speed hit.\n\n> **Sidenote**: the .NET virtual machine does not have an interpreter nor does it support speculative optimisations. It’s really just a regular compiler that happens to run the first time a method is called. This is why Microsoft has tended to be more interested in AOT compilation than the Java space has been: they never exploited the potential of JIT compilation, so they have less to lose from abandoning it.\n\nWhat about other forms of bloat, like memory usage, binary size and startup time?\n\nEven those are complicated. Most of the memory usage of apps written in managed languages like Kotlin, Scala, Java, C# etc comes from their reliance on object identity, garbage collection, unicode strings and other things that native compilation doesn’t affect.\n\nWorse, native CPU code is a lot larger than JVM bytecode. Larger code bloats downloads and uses more RAM, lowering cache utilisation. An AOT compiled “Hello World” Java app doesn’t start any faster than the regular interpreted version because even though the interpreter runs far fewer instructions per second than the CPU can, each instruction does a lot more and takes much less space in memory. Runtime of a hello world app is only about 80 milliseconds anyway, which is a relevant cost only if you’re making tiny tools for a UNIX shell.\n\nAnd whilst hauling around a couple of JIT compilers and three garbage collectors adds bloat, that’s not inherent to using a virtual machine rather than compiling to native. It’s just that HotSpot is a one-size-fits-all program that is designed to run on everything from laptops to giant servers. You can make much smaller virtual machines if you’re willing to specialise.\n\n### Enter Avian\n\n> “Avian is a lightweight virtual machine and class library designed to provide a useful subset of Java’s features, suitable for building self-contained applications.”\n\nSo says [the website](https://readytalk.github.io/avian/). They aren’t joking. The example app demos use of the native UI toolkit on Windows, MacOS X or Linux. It’s not a trivial Hello World app at all, yet it’s a standalone self-contained binary that clocks in at only one megabyte. In contrast, “Hello World” in Go generates a binary that is 1.1mb in size, despite doing much less.\n\nAvian can get these tiny sizes because it’s fully focused on doing so: it implements optimisations and features the standard HotSpot JVM lacks, like the use of LZMA compression and ProGuard to strip the standard libraries. Yet it still provides a garbage collector and a JIT compiler.\n\nFor people who want to use Kotlin to write small, self contained command line apps of the kind Go is sometimes used for, a much simpler and better solution than an LLVM backend would be to make a fully integrated Avian/Kotlin combination. Avian is hard to use right now — you’re expected to be familiar with native-world tools like GCC and make. Making a one-click JetBrains style GUI would yield programs that _look_ to the user like they were AOT compiled: they’re single executables that only require the base OS. And using SWT you can build GUIs that look native on every platform because under the hood they _are_ native. But you wouldn’t need to abandon the benefits of JIT compilation or garbage collection.\n\n### Losing garbage collection\n\nSometimes the people requesting a native backend want it because they want to avoid GC, and associate “native” with “not garbage collected”. There is no connection between these things: you can have garbage collected C++ and you can do manual memory management in Java (and some high performance libraries do).\n\nThe problem with extensively mixing techniques is that it forks the language. A library that assumes garbage collection cannot be used without a collector and likewise, a library that expects manual management becomes a lot harder to use from code that expects a GC. You’d have to introduce smart pointers and other C++ like constructs to the language to make it really convenient.\n\nI wouldn’t like to see Kotlin splinter into two different languages, Kotlin-GC and Kotlin-Manual. That would hurt the community and ecosystem for questionable benefits.\n\nAnd the benefits _are_ questionable. Many devs who think they can’t tolerate GC are basing their opinions on old/crappy GCs in mobile phones or (worse) web browsers. This impression is heightened by the fact that some well known garbage collected apps are written by people who just don’t seem to care about performance at all, like Minecraft or Eclipse, leading people to blame GC for what is in reality just badly written code. But there are counterexamples that show it doesn’t have to be this way: Unreal Engine is written in C++ and has used a core garbage collected game heap since version 3. It powers many of the worlds AAA titles. They can hit 60 frames per second and they are using a very basic GC. Tim Sweeney’s secret is that he cares about performance and productivity simultaneously. If they can do it, so can you.\n\n### iOS and native code interop\n\nThe final reasons people want a native compiler backend are iOS support and to make native code interop easier.\n\niOS is a good reason. That platform bans JIT compilers because it helps Apple enforce their incredibly rigid policies. But doing a native backend at the language level is the wrong approach. RoboVM is a project that built a JVM bytecode to ARM AOT compiler, and although RoboVM is now a dead project due to being acquired by Microsoft, old versions of its code are still available under an open source license. It works for any JVM language and doesn’t really suffer from this generality: a Scala or Kotlin specific ARM compiler wouldn’t do much different.\n\nBut that’s probably not the long term direction the JVM platform will go in for iOS. As HotSpot itself is getting support for AOT compilation, and HotSpot has an ARM backend too, and there’s an official OpenJDK mobile project that’s already made an iOS (interpreter only) mobile version, it would make sense for them to plug these things together and end up with a mode in which HotSpot can generate AOT iOS binaries too. I wouldn’t be surprised to see something like this announced between Java 9 and 10.\n\nThe final reason is native code interop. If you compile to native, so the reasoning goes, it’ll be easier to use C/C++ libraries like the ones your operating system provides.\n\nBut the existence of projects like JNA seem to disprove this — you can have convenient interop without generating native code yourself. And there are some exciting techniques for working with native libraries coming up:\n\n*   The OpenJDK Panama project is adding support for things like inline assembly, pointers and struct layouts directly to Java and HotSpot. Yes, if you check out the Panama branch of the hotspot repository you can actually define assembly snippets in Java and they’ll be inlined directly into usage sites, just like an __asm__ block in C would. Panama also provides a clang-based tool that parses C/C++ headers and auto generates the equivalent Java declarations. All this should be automatically available to Kotlin and Scala users too.\n*   The Graal/Truffle research projects are creating [Sulong](http://github.com/graalvm/sulong/), which is a way to JIT compile LLVM bitcode on top of the JVM. There is a simple C API that exists when code is run on top of Sulong that allows for near zero-overhead interop with managed code.\n\n### Conclusion\n\nKotlin doesn’t need an LLVM backend, and by extension I believe neither does Scala. Creating such a thing would be a huge and ongoing drain of manpower, take a long time, and end up duplicating work already being done elsewhere in the JVM ecosystem ... very likely with worse results.\n\nInstead, I think the right direction for the community to go is:\n\n1.  Building a simple IntelliJ plugin that uses Avian to spit out tiny, self contained binaries, for when weight is more important than features. This would present some strong competition to Go in the command line tools space.\n2.  Using the AOT mode being added to HotSpot to eliminate warmup times and (hopefully) support iOS, for times when AOT compilation really is the only solution.\n3.  Waiting for JVM upgrades to reduce memory usage, support better native interop and so on. Don’t try to duplicate these efforts at the language level.\n4.  Educating the developer community about how to write high performance garbage collected apps _outside_ of the server context.\n\nThis approach isn’t flawless: the AOT mode being added to HotSpot is planned to be a commercial feature, and big upgrades like Panama are long term projects. But adding an LLVM backend to the Kotlin or Scala compilers would be a long term project too, it’d mean sacrificing other features that might be more useful, and it would likely never close the performance gap.\n\nAs always in engineering, there are no solutions — only trade offs. I’d rather have more features in the core Kotlin language/tooling than a native backend, and let other teams tackle the varying challenges involved.\n\n","author":"Mike Hearn","date":"2016-06-17","type":"article","categories":["Kotlin"],"features":["highlightjs"],"description":"","filename":"","lang":"EN","enclosure":null},{"title":"Java vs. Kotlin: Should You Be Using Kotlin for Android Development?","url":"https://code.tutsplus.com/articles/java-vs-kotlin-should-you-be-using-kotlin-for-android-development--cms-27846","body":"","author":"Jessica Thornsby","date":"2016-12-12","type":"article","categories":["Kotlin","Android"],"features":["highlightjs"],"description":"","filename":"","lang":"EN","enclosure":null},{"title":"Ubuntu Make 16.03 Released With Eclipse JEE And IntelliJ IDEA EAP Support, More","url":"http://www.webupd8.org/2016/03/ubuntu-make-1603-released-with-eclipse.html","body":"\n[Ubuntu Make](https://github.com/ubuntu/ubuntu-make) is a command line tool created by Canonical, which allows installing various development tools on Ubuntu. It can be used to install Android Studio, Unity3D, IntelliJ IDEA, Firefox Development Edition, Node.js and much more.\n\n**Ubuntu Make 16.03, released today, adds support for [Eclipse JEE](http://www.eclipse.org/downloads/packages/eclipse-ide-java-ee-developers/mars2) and [IntelliJ IDEA EAP](https://www.jetbrains.com/support/eap/), as well as for the [Kotlin compiler](https://kotlinlang.org/), along with various fixes, such as:**\n\n* fix Unity3D on lts mesa;\n* fix VSCode license page due to server changes;\n* fix Android-NDK not working due to server changes (download is now for 64bit only);\n* fix Clang support due to server changes;\n* fix Intellij .desktop file.\n\nA complete changelog can be found [HERE](https://github.com/ubuntu/ubuntu-make/blob/master/debian/changelog).\n\n![Ubuntu Make Eclipse Java EE IDE](https://2.bp.blogspot.com/-IxqVQB8bEqM/Vvu4uaN9s4I/AAAAAAAAXeY/LC8Uj6BECD8_GBY0DIDpho0-BxlUVDFVA/s1600/ubuntumake-eclipse-jee-ide.png)\n\nTo install the the newly added Eclipse JEE in Ubuntu using the latest Ubuntu Make (after installing Ubuntu Make, obviously), use the following command:\n\n`umake ide eclipse-jee`\n\nFor IntelliJ IDEA EAP, use:\n\n`umake ide idea --eap`\n\nTo install the Kotlin language compiler, use:\n\n`umake kotlin kotlin-lang`\n\nIf you want to remove any package installed using Ubuntu Make, simply append \"--remove\" to the command you used to install it. For example, to remove eclipse-jee, you would use:\n\n`umake ide eclipse-jee --remove`\n\nTo see all Ubuntu Make can do, type:\n\n```bash\numake --help\n# and\nman umake\n```\n\n## Install Ubuntu Make\n\nUbuntu Make is available in the official Ubuntu repositories (starting with Ubuntu 15.04) however, it's not the latest version, as you can see [HERE](https://launchpad.net/ubuntu/+source/ubuntu-make) (though the latest Ubuntu Mate 16.03 will probably make it into Ubuntu 16.04 Xenial Xerus).\n\n**To install the latest Ubuntu Make, in Ubuntu (16.04, 15.10 and 14.04), Linux Mint 17.x and derivatives, you can use its PPA. Add the PPA and install Ubuntu Make by using the following commands:**\n\n```bash\nsudo add-apt-repository ppa:ubuntu-desktop/ubuntu-make\nsudo apt-get update\nsudo apt-get install ubuntu-make\n```\n\nIf you want to help with the Ubuntu Make development, report bugs, etc., check out its [GitHub page](https://github.com/ubuntu/ubuntu-make).\n\n_via [didrocks](http://blog.didrocks.fr/post/Ubuntu-Make-16.03-features-Eclipse-JEE%2C-Intellij-EAP%2C-Kotlin-and-a-bunch-of-fixes!2)_\n\n","author":"Alin Andrei","date":"2016-03-30","type":"article","categories":["Kotlin","Ubuntu"],"features":["highlightjs"],"description":"","filename":"","lang":"EN","enclosure":null},{"title":"Why Kotlin is my next programming language","url":"https://medium.com/@octskyward/why-kotlin-is-my-next-programming-language-c25c001e26e3","body":"\n\n![](https://d262ilb51hltx0.cloudfront.net/max/1600/1*YnF7hY2ymS54iTNLuxVT8A.jpeg)\n_A lighthouse on Kotlin Island, Russia_\n\n## An ode to the language you’ve never heard of\n\n[Kotlin](http://kotlinlang.org/) is a new programming language from [JetBrains](http://jetbrains.com%5C), the maker of the world’s best IDEs. After much searching, I have settled on it as the programming language I will probably use for the next 5–10 years or so.\n\nI like Kotlin a lot and think it will be a very successful project. Someone who saw me using it in my open source work asked me to write about it, so in this article I’ll explain why I think Kotlin is good. Then I will discuss some of the problems and hiccups you may encounter if you start using it today. Finally, I’ll argue that now Kotlin is on the scene you should consider using the JVM if you aren’t already (e.g. because you use Go or Node).\n\n### Why Kotlin is good\n\nAt first this article may seem strange: normally language advocacy articles start by listing all the cool features the new language has. This article does not; we will get to them later.\n\nI am going to start by telling you about other things, because [a 2013 study showed that language features matter little compared to ecosystem issues](http://sns.cs.princeton.edu/docs/asr-oopsla13.pdf) when developers evaluate programming languages. That tallies with my own experience, so, here we go:\n\n**Kotlin compiles to JVM bytecode or JavaScript**. It is not a language you will write a kernel in. It is of greatest interest to people who work with Java today, although it could appeal to _all_ programmers who use a garbage collected runtime, including people who currently use Scala, Go, Python, Ruby and JavaScript.\n\n**Kotlin comes from industry**, not academia. It solves problems faced by working programmers today. As an example, the type system helps you avoid null pointer exceptions.\n\n**Kotlin costs nothing to adopt!** It’s open source, but that’s not what I mean here. What I mean is there’s a high quality, one-click Java to Kotlin converter tool, and a strong focus on Java binary compatibility. You can convert an existing Java project one file at a time and everything will still compile, even for complex programs that run to millions of lines of code. This is how I am adopting Kotlin and I expect it to be how most developers do.\n\nAs an obvious implication of the above, **Kotlin programs can use all existing Java frameworks and libraries**, even advanced frameworks that rely on annotation processing. The interop is seamless and does not require wrappers or adapter layers. It integrates with Maven, Gradle and other build systems.\n\nIt is approachable and **it can be learned in a few hours** by simply reading the language reference. The syntax is lean and intuitive. Kotlin looks a lot like Scala, but is simpler. The language balances terseness and readability well.\n\n**It enforces no particular philosophy of programming**, such as overly functional or OOP styling.\n\nIt **imposes no runtime overhead.** The standard library is small and tight: it consists mostly of focused extensions to the Java standard library. Heavy use of compile-time inlining means functional constructs like pipelines of map/filter/reduce compile similarly to an imperative version of the same code.\n\nCombined with the appearance of frameworks like [Anko](https://github.com/JetBrains/anko) and [Kovenant](http://kovenant.komponents.nl/android/features/), this resource lightness means **Kotlin is starting to become popular with Android developers**. If you’re working on Android, you will soon be in good company. You can read [a report written by a developer at Square](https://docs.google.com/document/d/1ReS3ep-hjxWA8kZi0YqDbEhCqTt29hG8P44aA9W0DM8/edit?hl=en&forcehl=1) on their experience with Kotlin and Android.\n\nKotlin allows you to keep using your productivity enhancing tools. If you use IntelliJ, **IDE interop is entirely seamless**: code can be refactored, searched, navigated and auto completed as if the Kotlin code was Java and vice-versa. There is full support for debugging, unit testing, profiling and so on.\n\nBeyond Android, I think **Kotlin is highly suitable for enterprise Java shops**. If you spend all day working on big Java codebases at even bigger companies, you should investigate Kotlin because:\n\n* It has **strong commercial support from an established company**. JetBrains is committed to the project, has a large and highly competent team working on it, has a stable business model and is even converting parts of their own flagship product to use it. Kotlin is unlikely to be abandoned any time soon.\n* **Adopting Kotlin is low risk**: it can be trialled in a small part of your code base by one or two enthusiastic team members without disrupting the rest of your project: Kotlin classes export a Java API that looks identical to that of regular Java code.\n* Because Kotlin focuses on readable syntax, **code reviews are not a problem**: they can still be done by team members who aren’t familiar with the language.\n* **It targets** **Java 6**, so you can use it even if your deployment makes upgrading to a newer JVM difficult.\n\nEarlier this year I presented Kotlin to a team of Java and .NET architects at Swiss Re, a large reinsurance company. I started by defining a simple Java class with a few fields, toString, equals, hashCode etc. It was about 50 lines of code. By the time we had finished converting it to Kotlin (mostly automatically), it had shrunk to just one line of code. I then demoed other time saving features. They were enthusiastic and saw it as a potentially strong competitor to C# for their own projects.\n\nI think Kotlin hits the sweet spot for enterprise Java devs, so even though Kotlin is free I expect JetBrains to make a killing from increased sales of the commercial version of their IDE. This will incentivise them to keep improving it according to the wishes of their customers.\n\nContrast this with many other language developers who are subsidised by unrelated products, meaning they have little reason to respond to the demands of their users when those demands conflict with pre-held ideologies.\n\n","author":"Mike Hearn","date":"2015-07-06","type":"article","categories":["Kotlin"],"features":["highlightjs"],"description":"","filename":"","lang":"EN","enclosure":null},{"title":"Why Kotlin is the next big thing for Java developers","url":"https://jaxenter.com/kotlin-next-big-thing-java-developers-129319.html","body":"\n> Kotlin already looks like a tool that is going to improve productivity significantly. We anticipate that it is definitely going to reduce the pain points faced by Java developers. Here is why we think Kotlin will be the next big thing for the Java community.\n\nKotlin is a high-performance language, it runs on the JVM and uses existing Java libraries and tools. Plus, Java can also interact with Kotlin components seamlessly. The primary goal of Kotlin is to make it useful for practical, real-life projects; one can easily learn it compared to other JVM-based languages (such as Scala). Since Java has a deep interoperability with Kotlin, Java developers may be more attracted to learn and test it.\n\nKotlin also has a strong commercial support and stable business model. From a developer’s perspective, Kotlin is very promising and gets better [with every release](https://jaxenter.com/kotlin-1-0-4-is-here-129315.html). So we can safely predict that Kotlin will be the next big thing for the Java community.\n\n## Is Kotlin a good fit for Java developers?\n\nAll that JetBrains wanted was to provide a useful language that solves existing problems. Kotlin has the following objectives which will help users solve or avoid existing issues in Java and ultimately perform better.\n\n* Provides an intuitive language that can infer from codes written by developers and do a lot of work on behalf of developers.\n* Improves productivity by reducing the effort needed to write code. For example, a 50 lines (approx.) code written in Java can be reduced to 2/3 (approx.) lines in Kotlin.\n* Prevents null pointer exceptions.\n* Provides quick code compilation.\n* Reduces learning time for developers by providing documentation and support.\n* Kotlin code syntax is easy to understand, so the code review is simple even for a newcomer.\n* Runtime overhead is also low as the standard library is small and compact.\n\nApart from the above-mentioned advantages, Kotlin also provides easy code conversion between Java and Kotlin, easy IDE integration, full debugging, refactoring and profiling etc. Therefore, we anticipate that Kotlin is definitely going to reduce the pain points faced by the Java developers.\n\n## The Kotlin features Java developers should love\n\nThese are the features Java developers should love:\n\n**No more null pointer exceptions**\n\nThis is probably the most important feature. The null pointer exception is one of the most dreaded, unsolved issues developers face. Kotlin’s type system does not compile code that assigns or returns null. See the example below.\n\n```kotlin\nval name: String = null // tries to assign null, won't compile\nstephen getName() : String = null // tries to return null, won't compile\n```\n\nSince every method call on a nullable type can potentially cause a null pointer exception, the Kotlin compiler forces the developer to use the Elvis operator whenever the call result is assigned to a non-null type.\n\n**Less code**\n\nKotlin compiler can infer or understand from the code written by a developer and can develop or write the remaining code. Java requires the developer to explicitly write everything which consumes a lot of time and effort. Kotlin saves effort and time and improves productivity.\n\nFor example, the Kotlin compiler can infer types in variable declarations, as well as compiler-generated getters/setters/equals/hashCode. On the other hand, the Java compiler does not infer as much and requires the developer to explicitly write code.\n\n**Easy to learn and use **\n\nSince there is nothing revolutionary about Kotlin, any software developer can learn and use it, especially the Java and Scala developers. The main reason is that Kotlin is dependent on Java in many ways and extensively uses the Java library.\n\nAlso, Kotlin was inspired by Scala and according to many people, it looks a lot like Scala. The code uses the JVM and the Javac, the primary Java compiler. The learning curve for Java developers is not steep and they can leverage the Kotlin documentation and get started quickly with coding.\n\n**Backward compatible**\n\nKotlin offers backward compatibility for Java versions 6 and 7. It states on its blog that over the next few releases, it is going to speed up development workflow, reduce the size of the runtime library and provide more tooling support. Kotlin introduced a feature known as incremental [compilation](https://jaxenter.com/kotlin-1-0-4-is-here-129315.html) in its Gradle build plug-in. This enables Kotlin to compile and build only the changes in the code and not the whole code over. This is going to save a lot of time.\n\n**IDE interoperability**\n\nKotlin has a lot of supports for enhancing productivity. It is highly interoperable with the IDEs, so refactoring, debugging, searching, unit testing are very easy to perform.\n\nMaybe a Java developer can convert part of his Java code into Kotlin and see how it performs. No matter what path you choose, Kotlin is definitely going to make a good impression on you.\n\n## Conclusion\n\nKotlin already looks like a tool that is going to improve productivity significantly. Many developers are positive about Kotlin enabling them to achieve a breakthrough in their productivity.\n\nThere are many online discussions which claim that Kotlin solves many Java pain points without really reinventing how coding should be done. What are the challenges ahead? First, it needs to impress companies like Google, which is a huge Java user and has been working on other alternatives to Java.\n\nIt will be interesting to watch how Kotlin accomplishes its plans and how it faces forthcoming challenges.\n\n","author":"Nitin Y","date":"2016-09-23","type":"article","categories":["Kotlin"],"features":["highlightjs"],"description":"","filename":"","lang":"EN","enclosure":null},{"title":"Kotlin for Java developers","url":"https://www.youtube.com/watch?v=vmjfIRsawlg","body":"\n<iframe width=\"960\" height=\"480\" src=\"https://www.youtube.com/embed/vmjfIRsawlg\" frameborder=\"0\" allowfullscreen></iframe>\n\n","author":"Hadi Hariri","date":"2014-12-11","type":"video","categories":["Kotlin"],"features":["highlightjs"],"description":"","filename":"","lang":"EN","enclosure":null},{"title":"Kotlin & Android: A Brass Tacks Experiment, Part 6","url":"https://medium.com/@CodingDoug/kotlin-android-a-brass-tacks-experiment-part-6-49fea0ed3a7#.53axmkcxt","body":"\n![](https://d262ilb51hltx0.cloudfront.net/max/1600/1*UN-S8ELMC2kpHf4tJKfbLQ.png)\n\n_Disclaimer: I am a Google employee, but the views expressed in this article are not those of my employer._\n\n### Kotlin & Android: A Brass Tacks Experiment, Part 6\n\nAlright! We’re nearing the end of this series about experimenting with Kotlin to make view creation easier during Android app development. (Please [jump back to the beginning](https://medium.com/p/kotlin-android-a-brass-tacks-experiment-part-1-3e5028491bcc) if you landed here prematurely.) So far we’ve learned a bunch of features of the Kotlin® language that help implement the type-safe builder pattern, including:\n\n* Lambda with receiver & reified types ([part 2](https://medium.com/p/kotlin-android-a-brass-tacks-experiment-part-2-c67661cfdf5f))\n* Extension functions ([part 4](https://medium.com/p/kotlin-android-a-brass-tacks-experiment-part-4-4b7b501fa457))\n* Extension properties ([part 5](https://medium.com/p/kotlin-android-a-brass-tacks-experiment-part-5-bd79eb9c85d4))\n\nThese have all been instrumental in creating a “domain specific language” for expressing the programmatic creation of view hierarchies in a declarative fashion. For example, using all these techniques combined, we can write this to create two TextViews stacked on top of each other with some padding:\n\n```kotlin\nv<LinearLayout> {\n    layoutParams = LayoutParams(MATCH_PARENT, WRAP_CONTENT)\n    orientation = VERTICAL\n    padLeft = dp_i(16f)\n\n    v<TextView> {\n        layoutParams = LayoutParams(WRAP_CONTENT, WRAP_CONTENT)\n        text = \"Hello\"\n    }\n    v<TextView> {\n        layoutParams = LayoutParams(WRAP_CONTENT, WRAP_CONTENT)\n        text = \"World\"\n    }\n}\n```\n\nThis is pretty good on its own, and it definitely beats writing out all these view creations and associations traditionally. Now, to wrap up the coding part of this experiment, let’s do a couple more things to tighten up the syntax _even more!_\n\n**How do we assign values to specialized layout parameter properties?**\n\nIt’s not immediately evident from the code above, but there is a problem if you want to assign some attributes of the layout parameters specific to LinearLayout. Up until now we have only specified the height and width of a view using the [LinearLayout.LayoutParams](http://developer.android.com/reference/android/widget/LinearLayout.LayoutParams.html) class constructor, and assigned that new object to the layoutParams synthetic property of a view. But what if we also wanted to assign values to the “gravity” property of the layout parameters? It might make sense to try it like this:\n\n```kotlin\nlayoutParams = LinearLayout.LayoutParams(WRAP_CONTENT, WRAP_CONTENT)\nlayoutParams.gravity = Gravity.CENTER  // oops, compiler says no\n```\n\nBut the compiler won’t allow that because the layoutParams property of View is of type ViewGroup.LayoutParams, the superclass of all other LayoutParams. In order to use layoutParams as a LinearLayout.LayoutParams, it will need to be downcast.\n\nInstead of casting and assigning to another value as you would in the Java® language, we can use a Kotlin stdlib function called “[with](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/with.html)” to make it easier to deal with layoutParams. The “with” function takes an object parameter along with lambda with receiver and executes that lambda against the given object. This description may not sound interesting, but it allows a syntax like this:\n\n```kotlin\nv<TextView> {\n    with(layoutParams as LinearLayout.LayoutParams) {\n        width = WRAP_CONTENT\n        height = WRAP_CONTENT\n        gravity = CENTER\n    }\n    text = \"Hello\"\n}\n```\n\nNotice how we’re able to simultaneously cast layoutParams to LinearLayout.LayoutParams, then use that as the receiver inside the lambda for abbreviated access to its properties.\n\nAnother subtle thing to be aware of here is that an Android view container will automatically create and assign a correctly typed layout parameter object to layoutParams when a child view is added to it. In our case, adding a TextView child to a LinearLayout will _automatically_ create and assign a LinearLayout.LayoutParams to the TextView’s layoutParams property. This means we don’t actually need to create a new LayoutParams object — we can just access the one that’s already provided by the parent LinearLayout. Please remember that this only happens when adding a child view to a parent ViewGroup. The outermost ViewGroup will not have layout parameters assigned automatically because it’s not yet attached to its own parent!\n\nAll that said, this is not exactly the _most_ desirable syntax for layout parameters, but it’s the most straightforward way I could find to specify specialized layout parameters inside the lambdas we have for creating views.\n\n**And now, for my last trick, I’ll make the “v” functions disappear!**\n\nThe “v” functions we’ve been using so far are pretty convenient, but what if we want to further shortcut their syntax? It would be even more convenient to take the layout from above and pattern it like this:\n\n```kotlin\nlinearLayout {\n    textView {\n        // properties...\n    }\n    textView {\n        // properties...\n    }\n}\n```\n\nThis looks even more natural, and makes for easy reading. It also looks very similar to the Android Gradle configuration language. The trick to getting a syntax like this is to effectively create a sort of alias for each type of view we want to use. So, to create a structure like above, we need a function called “linearLayout” that works like “v<LinearLayout>” and a function called “textView” that works like “v<TextView>”. Kotlin makes this pretty easy to set up:\n\n```kotlin\nfun ViewGroup.linearLayout(init: LinearLayout.() -> Unit) = v(init)\nfun Context.linearLayout(init: LinearLayout.() -> Unit) = v(init)\n\nfun ViewGroup.textView(init: TextView.() -> Unit) = v(init)\nfun Context.textView(init: TextView.() -> Unit) = v(init)\n```\n\nHere, I defined two functions for each type of view in order to account for the different v functions that could be invoked, depending on the starting point of a Context or a ViewGroup parent. The Kotlin language feature that makes these declarations possible is called _single expression function_. This is a special syntax for functions that allows you to:\n\n1.  Omit the usual curly braces for the function body.\n2.  Infer the return type based on the return type of the expression.\n3.  Omit the return keyword.\n\nNow, let’s use these convenience functions to recreate the view hierarchy from the beginning of this article:\n\n```kotlin\nlinearLayout {\n    layoutParams = LayoutParams(MATCH_PARENT, WRAP_CONTENT)\n    orientation = VERTICAL\n    padLeft = dp_i(16f)\n\n    textView {\n        layoutParams = LayoutParams(WRAP_CONTENT, WRAP_CONTENT)\n        text = \"Hello\"\n    }\n    textView {\n        layoutParams = LayoutParams(WRAP_CONTENT, WRAP_CONTENT)\n        text = \"World\"\n    }\n}\n```\n\nWow, we’ve come a long way since our humble beginnings in part 2! (As long as you’re willing to define alias functions for each type of view you want to build.)\n\n**But the novelty of this technique is not all that novel after all!**\n\nSome readers of this series have pointed out that this method using the type-safe builder pattern for building view hierarchies is really close to that of a project called [Anko](https://github.com/Kotlin/anko). I actually set out on this series without having any knowledge of it, and it wasn’t until I was finished with the first two parts of this series that one of my colleagues pointed this out to me. Anko provides a more comprehensive solution for building views than what I’ve been experimenting with here. Even after seeing it, I was still pretty interested in going through the process of discovering Kotlin language features and how they could be applied to Android development. If you’ve been following this series, I hope you’ve also enjoyed discovering these things!\n\n**So, are we really any better off with this technique?**\n\nYou might be wondering now if it’s better in general to create your Android views programmatically like this in Kotlin than the traditional XML layout resources. Up till now, it certainly seems like a big win to use Kotlin in this way. So, for the next part in this series, I’ll compare the two techniques with each other to see how they compare to each other. Also, I’ll provide a sample project that you can use to easily compare equivalent implementations.\n\nDon’t forget that you can follow me [here on Medium](https://medium.com/@CodingDoug) to get [the next part to this series](https://medium.com/p/kotlin-android-a-brass-tacks-experiment-wrap-up-2b37e3ac8957) (in addition to future blogs and series!). And for even faster updates, [follow me on Twitter](https://twitter.com/CodingDoug)!\n\n","author":"Doug Stevenson","date":"2016-03-08","type":"article","categories":["Android","Kotlin"],"features":["highlightjs"],"description":"","filename":"","lang":"EN","enclosure":null},{"title":"Exploring the Kotlin standard library","url":"http://beust.com/weblog/2015/10/30/exploring-the-kotlin-standard-library/","body":"\n[Standard.kt](https://github.com/JetBrains/kotlin/blob/master/libraries/stdlib/src/kotlin/util/Standard.kt) is part of the Kotlin library and it defines some essential functions. What’s really striking about this source file is that it’s less than fifty lines long and that each of the function it defines (less than ten) is a one liner. Yet, each of these functions is very powerful. Here is a quick overview of the most important ones.\n\n## let()\n\n```kotlin\nfun <T, R> T.let(f: (T) -> R): R = f(this)\n```\n\n`let()` is a scoping function: use it whenever you want to define a variable for a specific scope of your code but not beyond. It’s extremely useful to keep your code nicely self-contained so that you don’t have variables “leaking out”: being accessible past the point where they should be.\n\n```kotlin\nDbConnection.getConnection().let { connection ->\n}\n// connection is no longer visible here\n```\n\n`let()` can also be used as an alternative to testing against null:\n\n```kotlin\nval map : Map<String, Config> = ...\nval config = map[key]\n// config is a \"Config?\"\nconfig?.let {\n    // This whole block will not be executed if \"config\" is null.\n    // Additionally, \"it\" has now been cast to a \"Config\" (no question mark)\n}\n```\n\n## apply()\n\n```kotlin\nfun <T> T.apply(f: T.() -> Unit): T { f(); return this }\n```\n\n`apply()` defines an extension function on all types. When you invoke it, it calls the closure passed in parameter and then returns the receiver object that closure ran on. Sounds complicated? It’s actually very simple and extremely useful. Here is an example:\n\n\n```kotlin\nFile(dir).apply { mkdirs() }\n```\n\nThis snippet turns a `String` into a `File` object, calls `mkdirs()` on it and then returns the file. The equivalent Java code is a bit verbose:\n\n```java\nFile makeDir(String path) {\n  File result = new File(path);\n  result.mkdirs();\n  return result;\n}\n```\n\n`apply()` turns this kind of ubiquitous code into a one liner.\n\n## with()\n\n```kotlin\nfun <T, R> with(receiver: T, f: T.() -> R): R = receiver.f()\n```\n\n`with()` is convenient when you find yourself having to call multiple different methods on the same object. Instead of repeating the variable containing this object on each line, you can instead “factor it out” with a with call:\n\n```kotlin\nval w = Window()\nwith(w) {\n  setWidth(100)\n  setHeight(200)\n  setBackground(RED)\n}\n```\n\n## run()\n\n```kotlin\nfun <T, R> T.run(f: T.() -> R): R = f()\n```\n\n`run()` is another interesting one liner from the standard library. Its definition is so simple that it looks almost useless but it’s actually a combination of `with()` and `let()`, which reinforces what I was saying earlier about the fact that because all these functions from the standard library are regular functions, they can be easily combined to create more powerful expressions.\n\n## Tying it all together\n\nOf course, it’s actually possible (and encouraged) to combine these functions:\n\n```kotlin\nfun configurationFor(id: String) = map[id]?.let { config ->\n  config.apply {\n    buildType = \"DEBUG\"\n    version = \"1.2\"\n  }\n}\n```\n\n This code looks up a Config object from an id and if one is found, sets a few additional properties on it and then returns it. But we can simplify this code even further. This time, I’m providing a fully self-contained snippet so you can copy and paste it directly into [Try Kotlin](http://try.kotlinlang.org/) in order to run it yourself:\n\n```kotlin\nclass Config(var buildType: String, var version: String)\n\nval map = hashMapOf<String, Config>()\n\nfun configurationFor(id: String) = map[id]?.let { config ->\n    config.apply {\n        buildType = \"DEBUG\"\n        version = \"1.2\"\n    }\n}\n```\n\nDon’t you feel that this combination of `let()` and `apply()` feels a bit boilerplatey? Let’s rewrite it a bit more idiomatically:\n\n```kotlin\nfun configurationFor(id: String) = map[id]?.apply {\n    buildType = \"DEBUG\"\n    version = \"1.2\"\n}\n```\n\n Let’s unpack this rather dense snippet:\n\n* Looking up a value on a hash map can be done either with `get()` or with the bracket notation, which is preferred.\n* Since the key might not be present in the map, we use the safe dereference operator `?.` which guarantees that we will only enter `apply()` if the result is non null.\n* Inside the `apply()` block, the this object is a `Config`, which lets us invoke functions on this object without any prefix. In this case, all we have is properties, but obviously, you could invoke regular functions just as well.\n* Once that code has run, the altered `Config` is returned.\n\n## use()\n\n```kotlin\nfun <T : Closeable, R> T.use(block: (T) -> R): R\n```\n\nAnother interesting function of the standard library is [use()](https://github.com/JetBrains/kotlin/blob/master/libraries/stdlib/src/kotlin/io/ReadWrite.kt#L154), which gives us the equivalent of [Java’s try-with-resources](https://docs.oracle.com/javase/tutorial/essential/exceptions/tryResourceClose.html) and of C#’s [using](https://msdn.microsoft.com/en-us/library/yh598w02.aspx?f=255&MSPPError=-2147217396) statement.\n\nThis function applies to all objects of type `Closeable` and it automatically closes its receiver on exit. Note that as opposed to Java and C#, Kotlin’s `use()` is a regular library function and **not** directly baked in the language with a special syntax. This is made possible by Kotlin’s extension functions and closure syntax used coinjointly.\n\n```java\n// Java 1.7 and above\nProperties prop = new Properties();\ntry (FileInputStream fis = new FileInputStream(\"config.properties\")) {\n    prop.load(fis);\n}\n// fis automatically closed\n```\n\n```kotlin\n// Kotlin\nval prop = Properties()\nFileInputStream(\"config.properties\").use {\n    prop.load(it)\n}\n// FileInputStream automatically closed\n```\n\nBecause Kotlin’s version is just a regular function, it’s actually much more composable than Java’s. For example, did you want to return this prop object after loading it?\n\n```kotlin\n// Kotlin\nfun readProperties() = Properties().apply {\n    FileInputStream(\"config.properties\").use { fis ->\n        load(fis)\n    }\n}\n```\n\nThe `apply()` call tells us that the type of this expression is that of the object `apply()` is invoked on, which is `Properties`. Inside this block, `this` is now of type `Properties`, which allows us to call `load()` on it directly. In between, we create a `FileInputStream` that we use to populate this property object. And once we call `use()` on it, that `FileInputStream` will be automatically closed before this function returns, saving us from the ugly `try/catch/finally` combo that Java requires.\n\nYou will find a lot of these constructs in the [Kobalt build tool](http://beust.com/kobalt) code, feel free to browse it.\n\n","author":"Cédric Beust","date":"2015-10-30","type":"article","categories":["Kotlin"],"features":["highlightjs"],"description":"","filename":"","lang":"EN","enclosure":null},{"title":"Kotlin & Android: A Brass Tacks Experiment, Part 1.","url":"https://medium.com/@CodingDoug/kotlin-android-a-brass-tacks-experiment-part-1-3e5028491bcc#.5c7ixfzdv","body":"\n![](https://d262ilb51hltx0.cloudfront.net/max/800/1*UN-S8ELMC2kpHf4tJKfbLQ.png)\n_Disclaimer: I am a Google employee, but the views expressed in this article are not those of my employer._\n\n### Kotlin & Android: A Brass Tacks Experiment, Part 1\n\nOne topic that’s been gaining popularity over the past year in the world of Android development is the [Kotlin](https://kotlinlang.org/)® language for the [JVM](https://en.wikipedia.org/wiki/Java_virtual_machine) from [JetBrains](https://www.jetbrains.com/). JetBrains is the same crew who created [IntelliJ Idea](https://www.jetbrains.com/idea/), which is the foundation for [Android Studio](http://developer.android.com/tools/studio/index.html). Kotlin takes aim at the age and perceived uncoolness of the Java® language with fresh and popular language features. I imagine that the crew at JetBrains imagines it could potentially become a replacement for Java® programming for all kinds of development on the JVM. Because it’s 100% inter-operable with the Java language, you can choose to use as much or as little Kotlin in your project as you like. And because it has a relatively small standard library, it’s suitable for development on mobile devices with limited resources.\n\nKotlin can do anything the Java language can do and more, but often with a more concise and pleasant syntax. There is full IDE support in IntelliJ and Android Studio. Because I’ve been deeply involved with Android since 2009, my specific interest in Kotlin is to discover what it _uniquely_ offers to Android developers. So I’m cutting through the hype in this blog series and getting down and dirty with Kotlin’s best language features, to see if I can make something truly useful.\n\nIn this first of a series of blog posts, I’ll go over the cleanest possible path to get Kotlin integrated into a new Android project. But if you’re looking to get straight to the code already, then go ahead and jump to [part 2](https://medium.com/@CodingDoug/kotlin-android-a-brass-tacks-experiment-part-2-c67661cfdf5f)!\n\n#### Configuring an Android Project with Kotlin\n\nThe [official docs](https://kotlinlang.org/docs/tutorials/kotlin-android.html) on getting started with Kotlin will show you how to install the Kotlin IDE plugin, and use that to modify an Android project’s Gradle config to add support for compiling Kotlin source. I don’t recommend this particular process, because I found the result of the automation to be less than satisfactory. While the changes it makes to the project’s Gradle build files might technically work, they don’t seem to be consistent with the way that new Android projects are typically set up.\n\nTo be frank, I have never been a fan of any Android Studio plugin that tries to guess changes to make to Android builds — more often than not, they botch things up, and I have to redo everything it did to clean it up to my liking. Gradle build files are actually source code, and automated processes are not really good at making changes to existing code! So, if you’re picky like me, take the extra minute to configure your project manually.\n\nIf you want to follow along, we’ll take four quick steps to get up and running:\n\n1. Create a new Android project.\n2. Modify the Gradle scripts to include the Kotlin Gradle plugin and standard library.\n3. Apply the Kotlin plugin for IntelliJ or Studio.\n4. Convert a Java class to Kotlin.\n\nFirst, create a new Android project using a template that adds an activity. When you have that, there are just five important lines of code to add across two build.gradle files, which I will highlight below. Let’s modify the top level build.gradle buildscript stanza with a couple of new lines:\n\n```kotlin\nbuildscript {\n    ext.kotlin_version = '1.0.0'\n    repositories {\n        jcenter()\n    }\n    dependencies {\n        classpath 'com.android.tools.build:gradle:1.5.0'\n        classpath \"org.jetbrains.kotlin:kotlin-gradle-plugin:$kotlin_version\"\n    }\n}\n```\n\nThis adds the Kotlin Gradle plugin into the build. Note the definition of the Kotlin version string defined in ext.kotlin_version. We’ll use it twice: once here in the buildscript classpath, and once in the app compile dependencies, and it must be the same in both places. You should of course use the latest version published via Maven. You can find the latest version documented [here](https://kotlinlang.org/docs/reference/using-maven.html).\n\nNext, apply the kotlin-android plugin after the Android plugin in the app’s own build.gradle after the standard Android plugin. This makes the project Kotlin-aware and adds a Kotlin compile step to the build, so that all the classes generated by both the Java and Kotlin languages get bundled together in the final app:\n\n```kotlin\napply plugin: 'com.android.application'\napply plugin: 'kotlin-android'\n```\n\nBy convention, Kotlin files want to live under src/main/kotlin, but they could also live alongside Java files in src/main/java. So, let’s be conventional and tell Gradle to recognize a new source directory for Kotlin source within the Android project definition:\n\n```kotlin\nandroid {\n    sourceSets {\n        main.java.srcDirs += 'src/main/kotlin'\n    }\n}\n```\n\nDon’t forget to create that directory because we’ll use it later. You’ll also need a compile dependency on Kotlin’s standard library, using the version variable from the buildscript:\n\n```kotlin\ndependencies {\n    compile \"org.jetbrains.kotlin:kotlin-stdlib:$kotlin_version\"\n}\n```\n\nBut how big is this library we’re adding? This is a great question. Every Android developer should be asking this question every time a new compile dependency is added. However, we’ll save that discussion for a later post in the series.\n\nAt this point, you should be able to do a command line Gradle build as you would normally with gradlew, and you can also build and deploy an APK from Android Studio. Nothing should change except the size of the app, which grows with the Kotlin standard library.\n\nSo that’s the Kotlin Gradle plugin, and adding it to your project like this is sufficient to build and run Kotlin code in the project. But you’ll probably also want IDE support for Kotlin language features. If you haven’t already installed the Kotlin plugin for IntelliJ or Android Studio, now is a good time for that.\n\nInstalling the IDE plugin is just like any other. You can find that under Preferences → Plugins → Install JetBrains plugin. Be sure to restart the IDE after installation. With that, you’re done with setup. I’ve found that the IDE support for Kotlin is almost as good as for the Java language, but I would expect as much, since JetBrains makes both the IDE and Kotlin!\n\n#### From Java to Kotlin the Easy Way\n\nOne interesting feature of the IDE plugin is its action for converting Java source to Kotlin source. The plugin is smart enough to replace Java idioms with Kotlin idioms while retaining full runtime compatibility. If you’ve created a new Android project to try this out, go find the main activity that was generated for you, select it in the project explorer on the left, and invoke the IDE action called “Convert Java File to Kotlin File”. You can do that by bringing up the action selector with Command-Shift-A (on OSX), then typing that action name. The plugin also provides a finger-bending keyboard shortcut for this action (on OSX it’s Option-Shift-Command-K). So, enjoy typing that! Note that the [official documentation for this conversion](https://kotlinlang.org/docs/tutorials/kotlin-android.html) currently does not suggest 100% correct behavior for this action, but I haven’t encountered a problem so far.\n\nIf you convert a Java file like this, you’ll end up with a Kotlin .kt file in place of the original .java file like this:\n\n![](https://d262ilb51hltx0.cloudfront.net/max/800/1*IPZCPTYVWIku8lAI0G9FGw.png)\n\n_MainActivity converted from Java to Kotlin_\n\nNotice that MainActivity has a Kotlin K logo on it now (but the file extension .kt is hidden here). Since we configured and created a dedicated source folder for Kotlin, as you can also see above, why don’t we move the newly converted Kotlin file to the space for Kotlin? It’s just like refactoring a Java file by moving it into a new folder or package by dragging it in the project explorer. Be sure to retain the existing package name of the class in the kotlin source directory so that the project still runs.\n\nIf you only want to use Kotlin in a project, you are free to delete the java source dir completely and put all Kotlin files in the kotlin space. With that, your project will look something like this:\n\n![](https://d262ilb51hltx0.cloudfront.net/max/800/1*N5JYjlzzAcvzeSpTJ0TK6g.png)\n\n_MainActivity moved from java source dir to kotlin source dir_\n\nI’m sure you’ve already started to dig around in the converted activity, so you’ve probably already got a taste for what Kotlin looks like. I’ll point out a couple things that look different from the Java language. You’ll never see the keyword “new” in Kotlin; constructors are invoked simply by treating the name of the class as a function and passing it arguments. Also, the types of variables are typically missing from a declaration with val (final) or var (variable), and Kotlin can usually figure out what the type is.\n\nI’ll leave it up to you to make the initial leap from Java world to Kotlin world, and we’ll continue [next time](https://medium.com/@CodingDoug/kotlin-android-a-brass-tacks-experiment-part-2-c67661cfdf5f) with the beginning of a small project to see what Kotlin can uniquely offer Android developers. If you follow me, [@CodingDoug](https://medium.com/@CodingDoug), here on Medium, or [the same on Twitter](https://twitter.com/codingdoug), you’ll get notified as soon as new parts are available in this series!\n\n","author":"Doug Stevenson","date":"2016-02-01","type":"article","categories":["Kotlin","Android"],"features":["highlightjs"],"description":"","filename":"","lang":"EN","enclosure":null},{"title":"SDCast #41: в гостях Андрей Бреслав, руководитель проекта Kotlin в компании JetBrains","url":"https://sdcast.ksdaemon.ru/2016/03/sdcast-41/","body":"\n![sd-podcast-logo](https://sdcast.ksdaemon.ru/wp-content/uploads/2014/06/sd-podcast-logo-200x200.png) Рад представить вам 41-й выпуск подкаста! Этот эпизод посвящен языку Kotlin, у меня в гостях Андрей Бреслав, руководитель проекта Kotlin в компании JetBrains.\n\nВ начале выпуска мы поговорили о том, зачем вообще нужен еще один язык, Андрей рассказал про историю и предпосылки появления Kotlin, как все начиналось и развивалось.\n\nОбсудили так же общие теоретические аспекты разработки языков программирования: чем разработка языка отличается от разработки каких-либо других программных продуктов, какие компоненты являются основой для построения языка, на какие аспекты следует обращать особое внимание и как правильно заложить архитектуру.\n\nТак же Андрей рассказал, почему в качестве платформы была выбрана JVM, рассказал некоторые технические подробности реализации проекта. Подробно рассказал про interop с Java, о том, как можно начать использовать Kotlin в уже существующем проекте на Java сейчас, и как они у себя, в компании JetBrains уже начали это делать.\n\nНе обошли мы сторой и социальную составляющую проекта. Код языка Kotlin выложен в open source на github. Андрей рассказал про сообщество, которое сформировалось вокруг проекта, и как они с ним взаимодействуют, обсуждают запросы на новый функционал, баг-репорты и все прочее.\n\nВ завершение выпуска, Андрей поделился планами по развитию языка как в ближайшем будущем, так и в долгосрочной перспективе.\n\nСсылки на ресурсы по темам выпуска:\n\n* Андрей в соц сетях:\n  * [Twitter](https://twitter.com/abreslav)\n  * [Facebook](https://fb.com/abreslav)\n  * [ВКонтакте](https://vk.com/abreslav)\n  * [LinkedIn](https://www.linkedin.com/in/abreslav)\n* [Основной сайт проекта kotlinlang.org](https://kotlinlang.org/)\n* [Репозиторий на github](https://github.com/JetBrains/kotlin)\n* [Пост в блоге проекта о релизе 1.0](http://blog.jetbrains.com/kotlin/2016/02/kotlin-1-0-released-pragmatic-language-for-jvm-and-android/)\n* Несколько видео докладов про Kotlin Андрея Бреслава и Дмитрия Жемерова:\n  * [Что такое Kotlin? Введение](https://www.youtube.com/watch?v=HWyd1gYMkl0)\n  * [Kotlin: самое сложное — совместимость](https://www.youtube.com/watch?v=LWFx4QWrTyo)\n  * [Kotlin для Android: коротко и ясно](https://www.youtube.com/watch?v=VU_L2_XGQ9s)\n  * [Kotlin: сессия вопросов и ответов со встречи JUG.ru 04.03.2016](https://www.youtube.com/watch?v=YOmdOTlhZa8)\n\n\n","author":"Андрей Бреслав, Константин Буркалев","date":"2016-03-11","type":"article","categories":["Kotlin","Podcast"],"features":["highlightjs"],"description":"","filename":"","lang":"RU","enclosure":{"url":"https://sdcast.ksdaemon.ru/podlove/file/159/s/download/SDCast-41.ogg","size":22683272}},{"title":"Kotlin 1.0.1 is Here!","url":"http://blog.jetbrains.com/kotlin/2016/03/kotlin-1-0-1-is-here/","body":"\nIt’s been a month since we released Kotlin 1.0, and while our user base roughly doubled during this time, we prepared the first bugfix update.\n\nKotlin 1.0.1 starts a series of 1.0.X versions delivering safe bug fixes and performance improvements to the language (as well as other parts of the project), and new features to our tools and integrations. This time it’s only relatively small IDE features, but bigger things are on the horizon for 1.0.2 and later.\n\n## Changes in 1.0.1\n\nPlease find the full change log [here](https://github.com/JetBrains/kotlin/blob/1.0.1/Changelog.md). Some numbers and highlights:\n\n\n* it’s 47 fixes in the compiler, library and Gradle plugin improvements (performance),\n* Compatibility with Gradle 2.12,\n* IDE features:\n    * Compatibility with IDEA 2016,\n    * Kotlin Education Plugin (for IDEA 2016),\n    * [KT-9752](https://youtrack.jetbrains.com/issue/KT-9752) More usable file chooser for “Move declaration to another file”,\n    * [KT-9697](https://youtrack.jetbrains.com/issue/KT-9697) Move method to companion object and back,\n* and 39 assorted fixes in the IDE.\n\nWe thank the participants of the EAP who tried the preview builds and reported feedback. Please join the [EAP](https://discuss.kotlinlang.org/t/kotlin-1-0-1-eap/1525) and let’s make Kotlin better together!\n\n","author":"Andrey Breslav","date":"2016-03-16","type":"article","categories":["Kotlin","Release"],"features":["highlightjs"],"description":"","filename":"","lang":"EN","enclosure":null},{"title":"Quasar and Kotlin - a Powerful Match","url":"http://blog.paralleluniverse.co/2015/06/04/quasar-kotlin/","body":"\nJune 04, 2015\n\nFollowing the release of [Kotlin M12](http://blog.jetbrains.com/kotlin/2015/05/kotlin-m12-is-out/) and of [Quasar 0.7.0](http://blog.paralleluniverse.co/2015/05/29/quasar-pulsar-0-7-0/) introducing support for it, let’s now have a closer look at how Kotlin and Quasar work together.\n\n[Kotlin](http://kotlinlang.org/) is JetBrains’ fun, statically-typed, safe, interoperable and expressive language targeting the JVM, Android and JavaScript. Pragmatic and efficient, it also features an excellent [IntelliJ Idea](https://www.jetbrains.com/idea/) integration from the start (which is my own and many other folks’ favourite IDE BTW). Finally our joint work with the Kotlin team has made Quasar on Kotlin smooth, natural and fast.\n\nEnabling Quasar support for Kotlin in your project is as easy as adding `quasar-kotlin` as a dependency and using one of Kotlin plugins for build systems, for example [Gradle’s](http://kotlinlang.org/docs/reference/using-gradle.html). We’ll start from a bird’s-eye view of our [ping-pong actor test](https://github.com/puniverse/quasar/blob/master/quasar-kotlin/src/test/kotlin/co/paralleluniverse/kotlin/actors/PingPong.kt) and then we’ll zoom in:\n\n```kotlin\ndata class Msg(val txt: String, val from: ActorRef<Any?>)\n\nclass Ping(val n: Int) : Actor() {\n    Suspendable override fun doRun() {\n        val pong = ActorRegistry.getActor<Any?>(\"pong\")\n        for(i in 1..n) {\n            pong.send(Msg(\"ping\", self()))          // Fiber-blocking\n            receive {                               // Fiber-blocking\n                when (it) {\n                    \"pong\" -> println(\"Ping received pong\")\n                    else -> null                    // Discard\n                }\n            }\n        }\n        pong.send(\"finished\")                       // Fiber-blocking\n        println(\"Ping exiting\")\n    }\n}\n\nclass Pong() : Actor() {\n    Suspendable override fun doRun() {\n        while (true) {\n            // snippet Kotlin Actors example\n            receive(1000, TimeUnit.MILLISECONDS) {  // Fiber-blocking\n                when (it) {\n                    is Msg -> {\n                        if (it.txt == \"ping\")\n                            it.from.send(\"pong\")    // Fiber-blocking\n                    }\n                    \"finished\" -> {\n                        println(\"Pong received 'finished', exiting\")\n                        return                      // Non-local return, exit actor\n                    }\n                    is Timeout -> {\n                        println(\"Pong timeout in 'receive', exiting\")\n                        return                      // Non-local return, exit actor\n                    }\n                    else -> defer()\n                }\n            }\n            // end of snippet\n        }\n    }\n}\n\npublic class Tests {\n    Test public fun testActors() {\n        spawn(register(\"pong\", Pong()))\n        spawn(Ping(3))\n    }\n}\n```\n\n## Data\n\n```kotlin\ndata class Msg(val txt: String = \"Hello\", val from: ActorRef<Any?>)\n```\n\nYes, Kotlin supports [data classes](http://kotlinlang.org/docs/reference/data-classes.html). This means that when you need a one-liner to hold some info, it can be a one-liner for real. Kotlin will generate sensible `equals`, `hashCode`, `toString` as well as deconstruction support, so that you can easily write:\n\n```kotlin\nval myMsg = Msg(txt = \"Hi\", from = me)\n// ...\nval (txt, from) = myMsg\n```\n\nAdd to that type inference, a shorter construction syntax for class instances (no `new` needed), default parameter values, invocation with named arguments and support for immutability with `val` declarations and you’ve got a full toolbox for your message-crafting actor needs (and more). Should you need to copy your message in full or in part:\n\n```kotlin\nval myNewMsg = myMsg.copy(txt = \"Howdy\")\n```\n\n`Pair` and `Triple` are included in the standard library, too <sup id=\"fnref:bigger-tuples\">[1](#fn:bigger-tuples)</sup>.\n\n`ActorRef<Any?>` represents a reference to a Quasar actor whose `send` can accept values of any type, including `null`s. `Any` is the utmost super-type in Kotlin and the question mark specifies that it is _nullable_ here (the default in Kotlin is non-nullable). If a value is of a non-nullable type, Kotlin will check against nulls at compile time for Kotlin code, and at runtime for values produced by Java invocations <sup id=\"fnref:java-interop\">[2](#fn:java-interop)</sup>.\n\n## Classes\n\n```kotlin\nclass Ping(val n: Int) : Actor()\n```\n\n`Ping` inherits from the base `Actor` Kotlin class <sup id=\"fnref:untyped-actors\">[3](#fn:untyped-actors)</sup> and it is _final_. This is the default in Kotlin because designing for inheritance is difficult and control over class hierarchies is important, so inheritance support must be declared explicitly through the `open` class modifier.\n\nIn Kotlin you can define your primary constructor without specifying a body and declare its parameters as properties by prefixing `val` (immutable) or `var` (mutable), which you need to do if you plan to use them not only during initialization but in methods too. A parent class’ constructor invocation is inline with inheritance declaration, and a short `:` is enough to specify that.\n\nWe declare `n` as a property because our actor is going to use it in its `doRun` execution body:\n\n```kotlin\nSuspendable override fun doRun() {\n      // ...\n}\n```\n\nThe `override` modifier is mandatory and the `Suspendable` annotation allows our actor’s fiber to invoke fiber-blocking calls such as `send` and `receive`. [Kotlin annotations](http://kotlinlang.org/docs/reference/annotations.html) don’t need to be preceded by `@` in most situations, which allow them to appear naturally as user-defined modifiers. Kotlin also supports [JSR-269 annotation processing](http://blog.jetbrains.com/kotlin/2015/05/kapt-annotation-processing-for-kotlin/).\n\n## Fiber-blocking Kotlin actors\n\n```kotlin\nval pong = ActorRegistry.getActor<Any?>(\"pong\")\nfor(i in 1..n) {\n    pong.send(Msg(\"ping\", self()))          // Fiber-blocking\n    receive {                               // Fiber-blocking\n        when (it) {\n            \"pong\" -> println(\"Ping received pong\")\n            else -> null                    // Discard\n        }\n    }\n}\npong.send(\"finished\")                       // Fiber-blocking\n```\n\n`Ping` leads the game here: it gets a reference to `Pong` from the global registry, then `send`s and `receive`s ping pongs `n` times, after which it tells `Pong` to bail out before quitting itself. It’s once again as simple as it was with regular threads: just straightforward imperative constructs and blocking calls, only much more efficient thanks to fibers.\n\nKotlin makes it even sweeter though. Apart from the nice looping construct with [ranges](http://kotlinlang.org/docs/reference/ranges.html), let’s have a deeper look at the [_selective receive_](http://docs.paralleluniverse.co/quasar/#sending-and-receiving-messages-actorref) block:\n\n```kotlin\nreceive {                               // Fiber-blocking\n    when (it) {\n        \"pong\" -> println(\"Ping received pong\")\n        else -> null                    // Discard\n    }\n}\n```\n\nIt feels like a new construct, doesn’t it? This neat small DSL employs no less than 3 advanced Kotlin features: [lambdas](http://kotlinlang.org/docs/reference/lambdas.html) with [inline functions](http://kotlinlang.org/docs/reference/inline-functions.html) and the type-safe [matching `when` expression](http://kotlinlang.org/docs/reference/control-flow.html#when-expression).\n\nThe block following `receive` is actually a single-argument _lambda_ for which Kotlin provides an extremely compact syntax. You can even avoid naming the argument: it’ll be called `it` as in this case, and of course you can skip brackets along the way. This is `receive`’s Kotlin signature:\n\n```kotlin\ninline protected fun receive(proc: (Any) -> Any?)\n```\n\n`proc` is a selection and transformation function: it can accept (and possibly transform), discard or delay an incoming message. If a message is accepted, it is returned by the `receive` call.\n\nHere `proc` contains only a matching `when` expression, which is type-checked for matching exhaustiveness and, of course, type correctness <sup id=\"fnref:when\">[4](#fn:when)</sup>. Yielding `null` in `proc` discards the value and _doesn’t_ return from `receive`; calling `defer()` will skip the message in the current `receive` call, leaving it in the mailbox, while producing any other value (even `Unit` like the `println` statement in the `\"pong\"` branch) will make the `receive` call return and control flow will proceed to the next iteration in the `for` loop.\n\nLet’s take a glance at `Pong`’s main loop:\n\n```kotlin\nreceive(1000, TimeUnit.MILLISECONDS) {  // Fiber-blocking\n    when (it) {\n        is Msg -> {\n            if (it.txt == \"ping\")\n                it.from.send(\"pong\")    // Fiber-blocking\n        }\n        \"finished\" -> {\n            println(\"Pong received 'finished', exiting\")\n            return                      // Non-local return, exit actor\n        }\n        is Timeout -> {\n            println(\"Pong timeout in 'receive', exiting\")\n            return                      // Non-local return, exit actor\n        }\n        else -> defer()\n    }\n}\n```\n\nIn this case we’re calling a selective receive with a timeout <sup id=\"fnref:receive\">[5](#fn:receive)</sup>. Two more notable Kotlin features and two API features work together here to make this code short, readable and powerful. As for Kotlin:\n\n* `is Msg` is a type check that performs a _smart cast_, so that `it` acquires the `Msg` type in its clause and properties can be accessed as simply as `it.txt` and `it.from`.\n* `return` in the _inline lambda_ performs a _non-local return_, that is it makes the `doRun` invocation return, after which the actor will quit <sup id=\"fnref:only-inline\">[6](#fn:only-inline)</sup>.\n\nThe Kotlin Actors API adds the following:\n\n* `defer()` implements _selective receive_ by skipping messages in the current `receive` call.\n* A `Timeout` message can be used to handle timeouts directly in the processing lambda if you so wish, without even returning from the `receive` call.\n\n## Now with plain, healthy fibers\n\nThere’s now a neat Kotlin port of the `quasar-gradle-template` in the `kotlin` branch. I built it very quickly by copying and pasting the previous Java source to a new Kotlin file in IntelliJ Idea and confirming Kotlin conversion! Of course then I polished it to my tastes and added the semantics that were missing in Java, and here’s the result:\n\n```kotlin\npackage testgrp\n\n// ...\n\nfun doAll(): Int? {\n    val increasingToEcho = Channels.newIntChannel(0) // Synchronizing channel (buffer = 0)\n    val echoToIncreasing = Channels.newIntChannel(0) // Synchronizing channel (buffer = 0)\n\n    val increasing = Fiber(SuspendableCallable(@Suspendable {\n        var curr = 0\n        for (i in 0..9) {\n            Fiber.sleep(1000)\n            println(\"INCREASER sending: \" + curr)\n            increasingToEcho.send(curr)\n            curr = echoToIncreasing.receive()\n            println(\"INCREASER received: \" + curr)\n            curr++\n            println(\"INCREASER now: \" + curr)\n        }\n        println(\"INCREASER closing channel and exiting\")\n        increasingToEcho.close()\n        curr;\n    })).start()\n\n    val echo = Fiber(SuspendableCallable(@Suspendable {\n        val curr: Int?\n        while (true) {\n            Fiber.sleep(1000)\n            curr = increasingToEcho.receive()\n            println(\"ECHO received: \" + curr)\n\n            if (curr != null) {\n                println(\"ECHO sending: \" + curr)\n                echoToIncreasing.send(curr)\n            } else {\n                println(\"ECHO detected closed channel, closing and exiting\")\n                echoToIncreasing.close()\n                break\n            }\n        }\n    })).start()\n\n    increasing.join()\n    echo.join()\n\n    return increasing.get()\n}\n\npublic fun main(args: Array<String>) {\n    doAll()\n}\n```\n\nWait, where are the classes? Functions can be toplevel in Kotlin: a class is generated for each package with static methods corresponding to toplevel functions. We’re not doing real OOP here, so we won’t define classes and Kotlin allows us to skip them altogether if we don’t need them. That makes sense and eliminates boilerplate, doesn’t it?\n\nAs for the packages, they are completely _disjoint_ from source files organization in directories and that allows freedom and convenience. Of course with great powers comes great responsibility but why should I bother creating directories only in order to use packages, when my project is made of a single source file (or a handful of them)? And since Kotlin is very concise, this situation will arise more often than you think.\n\nNow, where are the types instead? This example is strongly typed but most of the types are inferred. There are only a handful of them:\n\n```kotlin\nfun doAll(): Int?\n```\n\nIn Kotlin, `public` and `protected` functions need to be _explicitly typed_ both in the argument and return type because they _are public API_ and we don’t want to alter it by mistake because we changed the body (and type inference has adjusted types consequently without us noticing) <sup id=\"fnref:public-api\">[7](#fn:public-api)</sup>.\n\nIn this case though, this function has _module-level_ access (“internal”). Why does it still need to be fully typed? Because it has a block body which can have complex control flow and type inference could easily confuse the reader (and hinder maintainability).\n\n```kotlin\nval increasing = Fiber(SuspendableCallable(@Suspendable {\n```\n\nWhat’s happening here? We’re passing a `Suspendable`-annotated lambda instead of a full blown object expression (which is more pleasant than Java’s anonymous classes anyway), similarly to what we’d do with Java 8 lambdas. The `SuspendableCallable` constructor helps Kotlin’s type inference engine to interoperate with Java functional interfaces (this will be simplified very soon so that there’ll be no need to explicitly mention `SuspendableCallable`). Finally we don’t need to declare actual type parameters for `Fiber` (no ugly _diamonds_ either, sorry for people that like them) and of course not even for the `increasing` local.\n\n```kotlin\nvar curr: Int?\n```\n\nSince we know that the value of the `curr` mutable local value will come from Java, we know it could become `null` (and at some point it actually needs to, in order to represent a closed Quasar channel). We’re telling Kotlin that in advance, so that it won’t emit fail-fast runtime checks that will trigger an exception when `curr` gets assigned a `null` value.\n\nBy contrast no type declaration is needed by the `curr` mutable local in the `increasing` fiber, because it will be inferred to be `Int` and since it will be managed completely within Kotlin code, the compiler will check statically that it will never become `null`:\n\n```kotlin\nvar curr = 0 // Int\n```\n\n## What else is there?\n\nKotlin has loads of other advanced and convenient features that make it a pleasure to use not just with Quasar but in every occasion:\n\n* Type-checking covers [null safety](http://kotlinlang.org/docs/reference/null-safety.html) and allows [smart type casts](http://kotlinlang.org/docs/reference/typecasts.html); imperative programmers will enjoy [returns and jumps](http://kotlinlang.org/docs/reference/returns.html) and [ranges](http://kotlinlang.org/docs/reference/ranges.html) as well as [excellent Java interoperability](http://kotlinlang.org/docs/reference/java-interop.html) and [unchecked exceptions](http://kotlinlang.org/docs/reference/exceptions.html#checked-exceptions).\n* Functional guys will appreciate [higher-order functions and local functions](http://kotlinlang.org/docs/reference/functions.html) as well as [first-class method](http://kotlinlang.org/docs/reference/reflection.html#function-references) and [property accessor](http://kotlinlang.org/docs/reference/reflection.html#property-references) references.\n* DSL craftpeople will make good use of functional features, convenient syntax shortcuts and [type-safe builders](http://kotlinlang.org/docs/reference/type-safe-builders.html).\n* OOP has no shortage of tools either: [extension functions](http://kotlinlang.org/docs/reference/extensions.html), [trait-like interfaces](http://kotlinlang.org/docs/reference/interfaces.html), [compact and common sense inheritance with sensible defaults](http://kotlinlang.org/docs/reference/classes.html), [singleton objects](http://kotlinlang.org/docs/reference/object-declarations.html#object-expressions), [object expressions](http://kotlinlang.org/docs/reference/object-declarations.html#object-expressions), [generics with declaration-site variance and type projections](http://kotlinlang.org/docs/reference/generics.html), [feature-rich enums](http://kotlinlang.org/docs/reference/enum-classes.html), [delegation](http://kotlinlang.org/docs/reference/delegation.html), [properties accessors](http://kotlinlang.org/docs/reference/properties.html#getters-and-setters) and [delegated properties](http://kotlinlang.org/docs/reference/delegated-properties.html).\n\n* * *\n\n1. If you need bigger tuples it’s probably an hint that you’d better give them a more specific name for readability’s sake. [↩](#fnref:bigger-tuples)\n2. See [Java interoperability, platform types](http://kotlinlang.org/docs/reference/java-interop.html) and [null safety](http://kotlinlang.org/docs/reference/null-safety.html). [↩](#fnref:java-interop)\n3. Kotlin actors are always untyped because typed actors are useful only in very simple cases, like short-lived transient actors, but not so much in more complex situations. [↩](#fnref:untyped-actors)\n4. `when` supports type maching, value matching against arbitrary expressions and range matching; see [control flow](http://kotlinlang.org/docs/reference/control-flow.html). [↩](#fnref:when)\n5. The timeout overload is `inline protected fun receive(timeout: Long, unit: TimeUnit?, proc: (Any) -> Any?)` and it is non-blocking if the timeout is 0. [↩](#fnref:receive)\n6. This is possible only with inline lambdas. [↩](#fnref:only-inline)\n7. This is likely to become only a warning in the future. [↩](#fnref:public-api)\n\n\n","author":"Fabio","date":"2015-06-04","type":"article","categories":["Kotlin","Quasar","Fibers"],"features":["highlightjs"],"description":"","filename":"","lang":"EN","enclosure":null},{"title":"Kotlin ternary operator","url":"https://gist.github.com/naixx/9d94c1498c4d45ffda3a","body":"\n## Motivation\n\nKotlin is very expressive language, but like Scala it lacks of ternary operator. Currently language provided alternative `if` looks a bit verbose. \n\n```kotlin\nval result = if (myExpression) 1 else 2\n```\nCompared to a classical Java or C++ variant\n\n```java\nint result = myExpression ? 1 : 2\n```\n\nUnlike Scala, Kotlin allows only fixed names for operators, so we cant fully reproduce classic syntax, but we can have something similar\n\n```kotlin\nval result = myExpression % 1 / 2\n\n```\n\nIf you want to use complex boolean expression, you can wrap it in braces\n\n```kotlin\nval result = (a == null && b > 5) % 1 / 2\n```\n\nThe impact I see here is temporary object creation, probably `inline` can't help.\n\n```kotlin\nclass Ternary<T>(val expr: Boolean, val then: T) {\n    public fun div(elze: T): T = if (expr) then else elze\n}\n\npublic fun <T> Boolean.mod(a: T): Ternary<T> = Ternary(this, a)\n```\n\n","author":"naixx","date":"2016-11-30","type":"article","categories":["Kotlin"],"features":["highlightjs"],"description":"","filename":"","lang":"EN","enclosure":null},{"title":"Concurrency Primitives in Kotlin","url":"https://blog.egorand.me/concurrency-primitives-in-kotlin/","body":"\nI've recently started reading [\"Android Concurrency\" by G. Blake Meike](https://www.goodreads.com/book/show/26260944-android-concurrency), and so far I can highly recommend this great book: it contains quite a lot of insight into how various Android concurrency mechanisms work, when to prefer one approach over the other and how to get the best of the tools at your disposal. I decided to follow along with the code examples and recreate them on my computer, and since I'm deeply in love with Kotlin, I thought it would be a great idea to translate the examples into Kotlin on the go. In one of the first chapters the author revisits concurrency basics in Java, and when I started rewriting the code examples in Kotlin, I was quite surprised to find out that:\n\n* There's no `synchronized` keyword in Kotlin\n* There's no `volatile` keyword in Kotlin\n* Kotlin's `Any`, which is analogous to Java's `Object`, doesn't have `wait()`, `notify()` and `notifyAll()` methods\n\nSo how does concurrency work in Kotlin? This question has been asked on the [Kotlin forum](https://discuss.kotlinlang.org/t/concurrency-in-kotlin/858) and here's the answer from Andrey Breslav, Kotlin Project Lead:\n\n> Kotlin deliberately has no constructs for concurrency built into the language. We believe this should be handled by libraries.\n\nAlthough Kotlin doesn't have these things built into the language, it still provides quite a bunch of low-level concurrency tools. Let's take a look at what's in store.\n\n### Creating Threads\n\nThere are two ways to create a thread in Java: extending the `Thread` class, or instantiating it and passing a `Runnable` through the constructor. Since you can easily use Java classes in Kotlin, both solutions work just fine. Here's how you'd subclass `Thread`:\n\n```kotlin\nobject : Thread() {  \n  override fun run() {\n    println(\"running from Thread: ${Thread.currentThread()}\")\n  }\n}.start()\n```\n\nThis code uses Kotlin's [`Object Expressions`](https://kotlinlang.org/docs/reference/object-declarations.html#object-expressions) to create an anonymous class and override the `run()` method. And here's how to pass a `Runnable` to a newly created instance of `Thread`:\n\n```kotlin\nThread({  \n  println(\"running from lambda: ${Thread.currentThread()}\")\n}).start()\n```\n\nYou don't see a `Runnable` here: in Kotlin it can easily be replaced with a [lambda expression](https://kotlinlang.org/docs/reference/lambdas.html#lambda-expressions-and-anonymous-functions). Is there a better way? Sure! Here's how you can instantiate and start a thread Kotlin-style:\n\n```kotlin\nthread(start = true) {  \n  println(\"running from thread(): ${Thread.currentThread()}\")\n}\n```\n\nNeat, isn't it? We're using the `thread()` function, which magically hides away all the boilerplate code. In fact, there's zero magic inside `thread()`:\n\n```kotlin\npublic fun thread(start: Boolean = true, isDaemon: Boolean = false, contextClassLoader: ClassLoader? = null, name: String? = null, priority: Int = -1, block: () -> Unit): Thread {  \n  val thread = object : Thread() {\n    public override fun run() {\n      block()\n    }\n  }\n  if (isDaemon)\n    thread.isDaemon = true\n  if (priority > 0)\n    thread.priority = priority\n  if (name != null)\n    thread.name = name\n  if (contextClassLoader != null)\n    thread.contextClassLoader = contextClassLoader\n  if (start)\n    thread.start()\n  return thread\n}\n```\n\nIt's just a very convenient wrapper function that's a joy to use.\n\n### Synchronized Methods and Blocks\n\n`synchronized` is not a keyword in Kotlin, it's replaced with an [`@Synchronized`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.jvm/-synchronized/) annotation. The declaration of a synchronized method in Kotlin will look like this:\n\n```kotlin\n@Synchronized fun synchronizedMethod() {\n  println(\"inside a synchronized method: ${Thread.currentThread()}\")\n}\n```\n\nThe annotation has the same effect as Java's `synchronized`: it'll mark the JVM method as synchronized. For synchronized blocks you'll have to use the [`synchronized()`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/synchronized.html) function, which takes a `lock` as the parameter:\n\n```kotlin\nfun methodWithSynchronizedBlock() {  \n  println(\"outside of a synchronized block: ${Thread.currentThread()}\")\n  synchronized(this) {\n    println(\"inside a synchronized block: ${Thread.currentThread()}\")\n  }\n}\n```\n\nThe code looks and behaves pretty similar to the Java variant.\n\n### Volatile Fields\n\nSame story, there's no `volatile` keyword in Kotlin, but there's the [`@Volatile`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.jvm/-volatile/index.html) annotation:\n\n```kotlin\n@Volatile private var running = false\n\nfun start() {  \n  running = true\n  thread(start = true) {\n    while (running) {\n      println(\"Still running: ${Thread.currentThread()}\")\n    }\n  }\n}\n\nfun stop() {  \n  running = false\n  println(\"Stopped: ${Thread.currentThread()}\")\n}\n```\n\nThe behavior is similar to `@Synchronized`: `@Volatile` will mark the JVM backing field as volatile.\n\n### wait(), notify() and notifyAll()\n\nEvery class in Kotlin inherits from `Any`, but `Any` doesn't declare `wait()`, `notify()` and `notifyAll()`, meaning that these methods can't be called on a Kotlin class. But you still can use an instance of `java.lang.Object` as a lock and call the methods on it. Here's a solution to the Producer/Consumer problem that uses `Object` as the lock:\n\n```kotlin\nprivate val lock = java.lang.Object()\n\nfun produce() = synchronized(lock) {  \n  while (items >= maxItems) {\n    lock.wait()\n  }\n  Thread.sleep(rand.nextInt(100).toLong())\n  items++\n  println(\"Produced, count is $items: ${Thread.currentThread()}\")\n  lock.notifyAll()\n}\n\nfun consume() = synchronized(lock) {  \n  while (items <= 0) {\n    lock.wait()\n  }\n  Thread.sleep(rand.nextInt(100).toLong())\n  items--\n  println(\"Consumed, count is $items: ${Thread.currentThread()}\")\n  lock.notifyAll()\n}\n```\n\nDoes it look hacky? Well, it is. Truth is that if you're relying on such low-level constructs in your code - most likely you're doing something wrong. Nowadays there's a ton of high-level concurrency mechanisms for every purpose in both Java and Kotlin. [Here's](http://stackoverflow.com/questions/35520583/why-there-are-no-constructs-for-concurrency-in-kotlin) a great Stackoverflow answer that provides a list of tools available for writing concurrent code in Kotlin.\n\nAll code samples from this article are available on [GitHub](https://github.com/Egorand/kotlin-concurrency-primitives).\n\n### Conclusion\n\nAlthough they're not used frequently, it's still important to know and understand the basic concurrency tools. Turns out those work a bit differently in Kotlin than in Java, but all major mechanisms are supported. And remember that Kotlin interacts really well with Java, so you can just rely on Java classes if the Kotlin counterparts are missing. Have fun!\n\nIf you've enjoyed this short article, please share it with your network using one of the buttons below. Thanks, and have a Merry Christmas!\n\n","author":"Egor Andreevici","date":"2016-12-23","type":"article","categories":["Kotlin"],"features":["highlightjs"],"description":"","filename":"","lang":"EN","enclosure":null},{"title":"Solving the Josephus problem in Kotlin","url":"https://blog.frankel.ch/solving-the-josephus-problem-in-kotlin","body":"\nI recently stumbled upon a [post](http://www.danvk.org/josephus.html) telling about the [Josephus problem](https://en.wikipedia.org/wiki/Josephus_problem) and trying to solve it in different scripting languages. For the sake of brevity, here’s the problem (taken from the referenced post):\n\n> Flavius Josephus was a roman historian of Jewish origin. During the Jewish-Roman wars of the first century AD, he was in a cave with fellow soldiers, 40 men in all, surrounded by enemy Roman troops. They decided to commit suicide by standing in a ring and counting off each third man. Each man so designated was to commit suicide...Josephus, not wanting to die, managed to place himself in the position of the last survivor.\n\n> In the general version of the problem, there are n soldiers numbered from 1 to n and each k-th soldier will be eliminated. The count starts from the first soldier. What is the number of the last survivor?\n\nIt seemed like a good challenge to test my building Kotlin skills. Here’s the solution I’ve come up with. First, the test class, using TestNG and a data provider – it’s the perfect use-case:\n\n```kotlin\nclass JosephusTest {\n\n    @DataProvider\n    fun data(): Array<Array<Int>> {\n        return arrayOf(\n                arrayOf(2, 1, 0),\n                arrayOf(3, 1, 0),\n                arrayOf(10, 1, 0),\n                arrayOf(3, 2, 0),\n                arrayOf(4, 2, 1)\n        )\n    }\n\n    @Test(dataProvider = \"data\")\n    fun circle_of_size_and_step_should_survive_position(size: Int, step: Int, expectedPosition: Int) {\n        val circle = Circle(size, step)\n        val survivor = circle.findSurvivor()\n        assertEquals(survivor.position, expectedPosition)\n    }\n}\n```\n\nNow, the code:\n\n```kotlin\nclass Soldier(val position: Int) {\n    var state = State.Living\n    lateinit var next: Soldier\n    fun suicide() {\n        state = State.Dead\n    }\n    fun isDead() = state == State.Dead\n}\n\nenum class State {\n    Living, Dead\n}\n\nclass Circle(private val size: Int, private val step: Int) {\n\n    private val first = Soldier(0)\n\n    init {\n        var person = first\n        while (person.position < size - 1) {\n            person = createNext(person)\n        }\n        val last = person\n        last.next = first\n    }\n\n    private fun createNext(soldier: Soldier): Soldier {\n        val new = Soldier(soldier.position + 1)\n        soldier.next = new\n        return new\n    }\n\n    fun findSurvivor(): Soldier {\n        var soldier: Soldier = first\n        var numberOfDead = 0\n        while (numberOfDead < size - 1) {\n            var count: Int = 0\n            while (count < step) {\n                soldier = nextLivingSoldier(soldier)\n                count++\n            }\n            soldier.suicide()\n            numberOfDead++\n        }\n        return nextLivingSoldier(soldier)\n    }\n\n    private fun nextLivingSoldier(soldier: Soldier): Soldier {\n        var currentSoldier = soldier.next\n        while (currentSoldier.isDead()) {\n            currentSoldier = currentSoldier.next\n        }\n        return currentSoldier\n    }\n}\n```\n\nThis code works fine and the tests are successful.\n\nHowever, while trying to code the solution, I realized that there were no data-structure implementing circular linked lists neither in Java nor in Kotlin. I had thus to implement my own circular data-structure, but without implementing common collection features.\n\nNow, my problem with the above code is that while the `Soldier` class looks fine by me, the `Circle` class doesn’t. There are too many vars in `Circle` and it feels too much like imperative programming. The lack of `for(;;)` in Kotlin forces me to use a `while` with an outside variable – twice: `count` and `numberOfDead`.\n\nI’ve been thinking that I could improve the situation by changing the data-structure. I just don’t know how... Now, Kotlin and FP gurus, do you have any proposal?\n\n","author":"Nicolas Franke","date":"2016-03-06","type":"article","categories":["Kotlin"],"features":["highlightjs"],"description":"","filename":"","lang":"EN","enclosure":null},{"title":"Kotlin Digest 2016.Q1","url":"http://blog.jetbrains.com/kotlin/2016/04/kotlin-digest-2016-q1/","body":"\n\nWelcome the Kotlin Digest of Q1 2016. It was in this quarter that Kotlin 1.0 was released, and naturally the number of articles and coverage received has substantially increased.\nWe want to thank everyone for their contributions, and highlight some of the most notable articles and blog posts.\n\n<center>![2016Q1Cover](http://i0.wp.com/blog.jetbrains.com/kotlin/files/2016/04/2016Q1Cover.png?resize=640%2C320)</center>\n\nBy the way, you can [join us on slack](http://kotlinslackin.herokuapp.com/) and subscribe to the _#feed_ channel, where we push quite a bit of interesting content as it appears.\n\n# General Articles\n\n* [Kotlin 1.0 Is Now Available and the Newest JVM Language Is a Breeze](https://dzone.com/articles/kotlin-10-is-now-available)\n* Two Q&A of Kotlin’s project lead Andrey Breslav on [DZone](https://dzone.com/articles/a-qa-with-andrey-breslav-on-kotlin) and [InfoQ](http://www.infoq.com/news/2016/02/kotlin-10-released)\n* [Kotlin: a new JVM language you should try](https://opencredo.com/kotlin/) by [Rafal Gancarz](https://twitter.com/rafalgancarz)\n* [Kotlin: The Ying and Yang of Programming Languages](https://www.linkedin.com/pulse/kotlin-ying-yang-programming-languages-eric-kolotyluk) by [Eric Kolotyluk](https://www.linkedin.com/in/eric-kolotyluk-7462253?trk=pulse-det-athr_prof-art_hdr)\n* [Kotlin – 2 Years On](https://yobriefca.se/blog/2016/02/24/kotlin-2-years-on/) by [James Hughes](https://twitter.com/kouphax)\n\n# Android\n\n* [Kotlin awesome tricks for Android](http://antonioleiva.com/kotlin-awesome-tricks-for-android/) by Antonio Leiva (author of [Kotlin for Android Developers](https://leanpub.com/kotlin-for-android-developers) book)\n* Series of posts [Kotlin & Android: A Brass Tacks Experiment](https://medium.com/@CodingDoug/kotlin-android-a-brass-tacks-experiment-part-1-3e5028491bcc#.d0dy6mji7) by [Doug Stevenson](https://www.linkedin.com/in/doug-stevenson-95509b22) (Developer Advocate in Google)\n* [Getting Started with Kotlin and Anko on Android](https://realm.io/news/getting-started-with-kotlin-and-anko/) by [Donn Felker](https://twitter.com/donnfelker) from Realm\n* [Roberto Perez](https://www.linkedin.com/in/raperez) shared his expirience in [creating an AndroidWear watchface using Kotlin](https://medium.com/@robj.perez/creating-an-androidwear-watchface-using-kotlin-e5f725813fa9)\n\n# Web Development\n\n* Two great posts by [Sébastien Deleuze](https://twitter.com/sdeleuze) from Spring: [Developing Spring Boot applications with Kotlin](https://spring.io/blog/2016/02/15/developing-spring-boot-applications-with-kotlin) and [A Geospatial Messenger with Kotlin, Spring Boot and PostgreSQL](https://spring.io/blog/2016/03/20/a-geospatial-messenger-with-kotlin-spring-boot-and-postgresql)\n* Three-part article by [Mike Gehard](https://twitter.com/mikegehard) from Pivotal: [The Journey of a Spring Boot application from Java 8 to Kotlin: The Application Class](http://engineering.pivotal.io/post/spring-boot-application-with-kotlin/)\n* [Nicolas Frankel](https://twitter.com/nicolas_frankel) wrote about his [experiments with Spring Boot, Vaadin, and Kotlin](https://dzone.com/articles//playing-with-spring-boot-vaadin-and-kotlin)\n* [Writing a RESTful backend using Kotlin and Spring Boot](https://medium.com/@dime.kotevski/writing-a-restful-backend-using-kotlin-and-spring-boot-9f162c96e428) by [Dimitar Kotevski](https://twitter.com/dimitar_)\n* [Rest API plumbing with kotlin](https://medium.com/@gz_k/rest-api-plumbing-with-kotlin-b161af052178) by [Gaëtan Zoritchak](https://twitter.com/gz_k)\n\n# Ecosystem\n\n* [TornadoFX](https://dzone.com/articles/a-new-javafx-app-framework-for-kotlin-tornadofx) — a new JavaFX app framework for Kotlin\n* [KillerTask](http://inaka.net/blog/2016/01/25/killertask-the-solution-to-asynctask-implementation/) — a solution to AsyncTask implementation\n* [PaperParcel](http://blog.bradcampbell.nz/introducing-paperparcel/) — a new annotation processor that automatically generates type-safe [Parcelable](http://developer.android.com/intl/es/reference/android/os/Parcelable.html) boilerplate code for Kotlin and Java\n* [Kotlin + RxJava = Functional Powerhouse](http://tomstechnicalblog.blogspot.ru/2016/02/kotlin-rxjava-what-rxjava-should-be.html)\n* [Kotlin : Retrofit + RxAndroid + Realm](https://medium.com/@ahmedrizwan/kotlin-retrofit-rxandroid-realm-39d7be5dc9dc)\n* [Using Dagger 1 and Kotlin](http://michaelevans.org/blog/2016/02/17/using-dagger-1-and-kotlin/)\n* [Using libGDX with Kotlin](http://obviam.net/index.php/libgdx-and-kotlin/) and [creating a simple 2D platformer](http://obviam.net/index.php/libgx-and-kotlin-2d-platformer-prototyping/)\n\n# Features overwiew\n\n* [Kotlin for Java Developers: 10 Features You Will Love About Kotlin](http://petersommerhoff.com/dev/kotlin/kotlin-for-java-devs/)\n* [10 Features I Wish Java Would Steal From the Kotlin Language](http://blog.jooq.org/2016/03/31/10-features-i-wish-java-would-steal-from-the-kotlin-language/)\n* [Kotlin — Love at first line](https://medium.com/@dime.kotevski/kotlin-love-at-first-line-7127befe240f#.kan4x5dyg)\n* [An Introduction to Kotlin](https://objectpartners.com/2016/02/23/an-introduction-to-kotlin/)\n* [Kotlin, superseding the language we love](http://www.endran.nl/blog/kotlin-super-seeding-the-language-we-love-2)\n* [Kotlin, the somewhat obscure modern Android-friendly programming language](https://medium.com/math-camp-engineering/kotlin-3e963864db9e#.4hxqlfnvn)\n\n# Technical\n\n* [A Very Peculiar, but Possibly Cunning Kotlin Language Feature](http://blog.jooq.org/2016/02/22/a-very-peculiar-but-possibly-cunning-kotlin-language-feature/)\n* [Solving the Josephus problem in Kotlin](https://blog.frankel.ch/solving-the-josephus-problem-in-kotlin) & [update](https://blog.frankel.ch/feedback-jospehus-problem)\n* [Kotlin: Easily storing a list in SharedPreferences with Custom Accessors](http://blog.dennislysenko.com/2016/01/22/kotlin-easily-storing-a-list-in-sharedpreferences-with-custom-accessors/)\n* [Using Kotlin Extensions for Rx-ifying](http://vishnurajeevan.com/2016/02/13/Using-Kotlin-Extensions-for-Rx-ifying/)\n* [Using Mockito for unit testing with Kotlin (1/x)](http://makingiants.com/blog/using-mockito-for-unit-tests-with-kotlin-1x/)\n* [Using Kotlin For Tests in Android](https://medium.com/@sergii/using-kotlin-for-tests-in-android-6d4a0c818776)\n\n# Kotlin series\n\n* [Juan Saravia](https://twitter.com/juanchosaravia) started his series of stories about learning Kotlin, while developing an Android App\n  * [Introduction: A few words about this](https://medium.com/@juanchosaravia/learn-kotlin-while-developing-an-android-app-introduction-567e21ff9664)\n  * [Part 1: Configuring Android Studio with Kotlin](https://medium.com/@juanchosaravia/learn-kotlin-while-developing-an-android-app-part-1-e0f51fc1a8b3)\n  * [Part 2: MainActivity.kt: Syntax, Null Safety and more...](https://medium.com/@juanchosaravia/learn-kotlin-while-developing-an-android-app-part-2-e53317ffcbe9)\n  * [Part 3: NewsFragment.kt: Extension Functions, Android Extensions...](https://medium.com/@juanchosaravia/keddit-part-3-extension-functions-android-extensions-and-more-faa7d232f232)\n  * [Part 4: RecyclerView — Delegate Adapters & Data Classes with Kotlin](https://medium.com/@juanchosaravia/keddit-part-4-recyclerview-delegate-adapters-data-classes-with-kotlin-9248f44327f7)\n  * [Part 5: Kotlin, RxJava & RxAndroid](https://medium.com/@juanchosaravia/keddit-part-5-kotlin-rxjava-rxandroid-105f95bfcd22)\n  * [Part 6: API — Retrofit & Kotlin](https://medium.com/@juanchosaravia/keddit-part-6-api-retrofit-kotlin-d309074af0)\n* Kotlin Month series by Jacob Zimmerman\n  * [Post 1: Assorted Features](https://programmingideaswithjake.wordpress.com/2016/02/27/kotlin-month-post-1-assorted-features/)\n  * [Post 2: Inheritance and Defaults](https://programmingideaswithjake.wordpress.com/2016/03/05/kotlin-month-post-2-inheritance-and-defaults/)\n  * [Post 3: Safety](https://programmingideaswithjake.wordpress.com/2016/03/13/kotlin-month-post-3-safety/)\n  * [Post 4: Properties](https://programmingideaswithjake.wordpress.com/2016/03/19/kotlin-month-post-4-properties/)\n* by [Ciro Rizzo](https://github.com/cirorizzo):\n  * [My Kotlin Adventure](http://www.cirorizzo.net/2016/01/23/kotlin-at-glance/)\n  * [Kotlin Coding](http://www.cirorizzo.net/2016/02/03/kotlin-code/)\n  * Building a Kotlin project ([part 1](http://www.cirorizzo.net/2016/03/04/building-a-kotlin-project/) and [part 2](http://www.cirorizzo.net/2016/03/04/building-a-kotlin-project-2/))\n\n\n","author":"Roman Belov","date":"2016-04-06","type":"article","categories":["Kotlin","Digest"],"features":["highlightjs"],"description":"","filename":"","lang":"EN","enclosure":null},{"title":"Taking Kotlin for a ride","url":"https://www.linkedin.com/pulse/taking-kotlin-ride-hadi-tok?published=t","body":"\nI have read about Kotlin and tried it on their online editor ([http://try.kotlinlang.org/](http://try.kotlinlang.org/)) previously. But I was wondering about the work required to make Kotlin work on an existing project. So I took kotlin for a ride over the weekend on a new branch and converted one of the fragments to Kotlin and make it work with the rest of the project, in language aspect and project structure aspect.  So I will not talk about the features of Kotlin but mostly how to make it work on an existing Android project.\n\nThe first thing needed is to install Kotlin plugin on Android Studio. It could be  installed as a JetBrains plugin in plugins section on Android Studio Preferences. It has three main features:\n\n* Editor support\n* Kotlin setup on project\n* Converting Java code to Kotlin\n\nThe editor support is pretty good. I don’t really felt anything lacking when writing code with Kotlin compared to Java. It is pretty important while learning a new language. You would need all the help from the IDE.\n\nYou can configure Kotlin in your project by Tools>Kotlin>Configure Kotlin in Project. The only problem I had was the apply plugin: 'kotlin-android'  line on the app build.gradle file which is placed above `apply plugin: 'com.android.application'` so I had to moved under. Other than it was fine.\n\nAs I mentioned I converted one of the fragments that uses different features of Java and android to Kotlin. On the syntax side  I only had a problem with `Iterator.remove()` apparently which doesn’t have an equivalent on Kotlin. Instead I used `Iterable<T>.filter`. I think it has more straight forward usage than iterator for loop. This was the only compilation problem I had.\n\nOne thing I had worries about was the annotation processing. It is used on Butterknife and dagger. I was using apt plugin ([https://bitbucket.org/hvisser/android-apt](http://bitbucket.org/hvisser/android-apt)) for this purpose. But it didn’t work with kotlin. I haven’t received and compilation or build exceptions but I received an exception on runtime regarding to `lateinit` (`UninitializedPropertyAccessException`)  on a variable supposed to be binded with Butterknife. Kotlin examples page on github([https://github.com/JetBrains/kotlin-examples](http://github.com/JetBrains/kotlin-examples)) came to help at this point. I modified my annotations and changed the apt plugin to Kotlin apt plugin ([http://blog.jetbrains.com/kotlin/2015/05/kapt-annotation-processing-for-kotlin/](http://blog.jetbrains.com/kotlin/2015/05/kapt-annotation-processing-for-kotlin/)) after then everything worked as expected.\n\nOther thing that is useful to know is the json deserialization. With a simple module addition to the Jackson library this is also pretty straight forward. You can find the instructions on the github page(https://github.com/FasterXML/jackson-module-kotlin)\n\nAs conclusion I haven’t decided to move to Kotlin yet. I am impressed the easy integration and  interoperability with Java. I am planning to use on one or two fragments that will be developed from scratch and try to have more experience on it. But So far my experience has been good.\n\n","author":"Hadi Tok","date":"2016-10-16","type":"article","categories":["Kotlin"],"features":["highlightjs"],"description":"","filename":"","lang":"EN","enclosure":null},{"title":"App State as a tree","url":"https://medium.com/lewisrhine/app-state-as-a-tree-a8eb6b26dd1b#.f9j7p0x89","body":"\nWe tend to think of app state as just the current values at a given time. But what if we thought about state at a higher level? Wouldn’t it be useful to have more information, not just of the values of our properties, but the state of an application as a whole.\n\nImage your whole app broken into trees. Let’s say for example, a restaurant review app, why a restaurant review app? I don’t know! I’m just trying to think of anything that’s not a To Do app, okay. Let’s draw out what the state tree of this kind of app would be.\n\nI am using a site named [Sketchboard.io](https://sketchboard.io/). I highly recommend them.\n\nFirst, what are the components of the app we are going to need?\n\nList of nearby restaurants: A list of all restaurants near the user.\n\nList of reviewed restaurants: All the restaurants the user has already reviewed, if any.\n\nCompose a review: Where the user will go to write or edit a review.\n\nHere it is sketched out:\n\n![](https://d262ilb51hltx0.cloudfront.net/max/800/1*k5oltMaFoEOkhR80Cm2Q9Q.png)\n\nNow that we have our core components we can start to build out the trees for each one.\n\nFor this example we are only going to worry about the ‘Restaurants Nearby’ component. We know that to get the data we are going to need to get the user’s GPS location. Then, we need to send a request to some kind of rest API, like Yelp or Foursquare, using that location. So it’s pretty clear the first state this tree would have would be a **Loading State**.\n\nOnce we receive our response from the API we can move down the tree to a **Done State** and come to our first branch. At this point there are going to be three possible outcomes.\n\n**Ready State** we have our list of restaurants.  \n**Empty State** there were no nearby restaurants found.  \n**Error State** we get some kind of error, either from the GPS or from the server.\n\n![](https://d262ilb51hltx0.cloudfront.net/max/800/1*uua9-C2PEPeT_9XJqxWwYQ.png)\n\nThere are a few things to notice here. We moved the ‘List of Restaurants’ down to our **Ready State**. So now, the only way for the app to get access to that list is once we’ve made it down to that branch. Also notice that in our **Done State** we have a function called **reloadData**. Now every state down the tree has the ability move back up to the loading state.\n\nLooking at this, it’s easy to see how helpful this approach can be. When we are getting data from the tree in our UI layer we know exactly what state the app is in. We know that if the tree is in a **Loading State** all we can do is tell the user and wait. Once we are updated with the new state of the tree we know “Ok, is the list ready for us? Cool get the list and display it.” If it’s empty or there was an error, we don’t even have access to the list.\n\nIt also gives an easy to glance at map of your app. Need to add a feature? You can start by looking at where in your app branches need to be changed or created, and how it will affect the rest of the app.\n\n“Ok. So yeah, drawing stuff is all well and good. But how can we do it in code?” Turns out Kotlin has a feature perfect for this.\n\nSealed classes are best described as enums on steroids. For this context you can think of them as a group of type safe abstract classes. This is what the above tree would look like as a sealed class\n\n```kotlin\nsealed class RestaurantNearby() {\n   sealed class Loading() : RestaurantNearby() {\n        //Code for getting Location, and API call\n        sealed class Done() : Loading() {\n          fun reloadData() {}\n          class Ready(val restaurants: List<Restaurant>) : Done()\n          class Empty() : Done()\n          class Error(val message: String, val throwable: Throwable?) : Done()\n        }\n    }\n}\n```\n\nThis coupled with a Kotlins ‘when’ interacting with this sealed class is super simple.\n\n```kotlin\nwhen (restaurantNearby) {\n  is RestaurantNearby.Loading -> // Tell user the data is loading\n  \n  is RestaurantNearby.Loading.Done -> {\n    restaurantNearby.reloadData() // Attach this function to some user feedback.\n  \n    when (restaurantNearby) {\n      is RestaurantNearby.Loading.Done.Ready -> restaurantNearby.restaurants // Do something with this list.\n      \n      is RestaurantNearby.Loading.Done.Empty -> // Tell the user there was no data found.\n      \n      is RestaurantNearby.Loading.Done.Error -> {\n        restaurantNearby.message // Show this message to the user.\n        restaurantNearby.throwable // Catch this and act on it as needed.\n      }\n    }\n  }\n}\n```\n    \nNow there is a big part of this idea that is missing. How do you pass these classes around? How should you set it? Should it be immutable? The idea of building your state’s into trees is part of a library I am working on called [Akorn](https://github.com/LewisRhine/Akorn). It is a Flux style architecture, open source library, that uses RxJava to reactivity pass your state trees. Akron is still a little baby and I would love for people check it out.\n\n","author":"Lewis Rhine","date":"2016-11-21","type":"article","categories":["Kotlin"],"features":["highlightjs"],"description":"","filename":"","lang":"EN","enclosure":null},{"title":"Релиз Kotlin 1.0, языка программирования для JVM и Android.","url":"http://www.opennet.ru/opennews/art.shtml?num=43882","body":"\nКомпания Jetbrains, развивающая интегрированную среду разработки IntelliJ IDEA, [представила](http://blog.jetbrains.com/kotlin/2016/02/kotlin-1-0-released-pragmatic-language-for-jvm-and-android/) первый значительный релиз объектно-ориентированного языка программирования [Kotlin 1.0](https://kotlinlang.org/), позволяющего создавать приложения, скомпилированные для последующего выполнения внутри стандартной виртуальной машины Java (JVM) или Android. Дополнительно поддерживается преобразование программ в JavaScript-представление для запуска внутри браузера, но данная функциональность пока отнесена к экспериментальным возможностям.\n\nВыпуск 1.0 позиционируется как первый выпуск, готовый для промышленного применения. Все дальнейшие обновления будут выпускаться с учётом сохранения обратной совместимости. Исходные тексты [открыты](http://github.com/jetbrains/kotlin) под лицензией Apache 2.0. Плагины с поддержкой Kotlin подготовлены для интегрированных сред разработки IntelliJ IDEA, Eclipse и Android Studio. Из систем сборки поддерживаются Maven, Gradle и Ant.\n\nЯзык развивается в санкт-петербургском центре разработки компании JetBrains c целью создания максимально совместимого с Java языка программирования, одновременно лишённого ограничений и недостатков Java, от которых Java не может избавиться из-за необходимости обеспечения обратной совместимости. При этом проекты на Kotlin полностью совместимы с компонентами на языке Java - из программ Kotlin можно вызывать Java-классы и наоборот, из Java вызывать компоненты, написанные на Kotlin. Кроме возможности использования штатных Java-бибилиотек для Kotlin подготовлена большая библиотека классов, оптимизированная для генерации байткода минимального размера.\n\nИз отличительных черт языка Kotlin можно выделить ориентацию на обеспечение более высокой безопасности за счет реализации статических проверок для выявления таких проблем как разыменование NULL-указателей. Среди других особенностей, имеющих отношение к безопасности, отмечается отсутствие raw-типов, полное сохранение информации о типах в процессе выполнения и реализация массивов в виде [инварианта](http://confluence.jetbrains.net/display/Kotlin/Basic+types#Basictypes-Arrays). Из расширенных языковых возможностей отмечается поддержка [функций высшего порядка](http://ru.wikipedia.org/wiki/%D0%A4%D1%83%D0%BD%D0%BA%D1%86%D0%B8%D1%8F_%D0%B2%D1%8B%D1%81%D1%88%D0%B5%D0%B3%D0%BE_%D0%BF%D0%BE%D1%80%D1%8F%D0%B4%D0%BA%D0%B0), [вывода типов](http://ru.wikipedia.org/wiki/%D0%92%D1%8B%D0%B2%D0%BE%D0%B4_%D1%82%D0%B8%D0%BF%D0%BE%D0%B2) значений на основании выражения, использование уточняющих \"[примесей](http://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%B8%D0%BC%D0%B5%D1%81%D1%8C_%28%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5%29)\" (mixin) и [делегирования](http://ru.wikipedia.org/wiki/%D0%94%D0%B5%D0%BB%D0%B5%D0%B3%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5_%28%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5%29).\n\n","author":"Open Source","date":"2016-02-16","type":"article","categories":["Kotlin","JVM"],"features":["highlightjs"],"description":"","filename":"","lang":"RU","enclosure":null},{"title":"Kanvas: generating a simple IDE from your ANTLR grammar","url":"https://tomassetti.me/kanvas-generating-simple-ide-antlr-grammar/","body":"\n![](https://i0.wp.com/tomassetti.me/wp-content/uploads/2017/01/Kanvas-1.png?resize=1024%2C768)\n\n## What is an editor?\n\nAn editor is, for me, the main tool I use for work. As a Language Engineer I create new languages, I use existing ones and I need different tools to work with them. I would like to be able to hack all of them together, in a customized IDE I can grow for me. This is why I am working on Kanvas, the hackable editor. Which is [on GitHub](https://github.com/ftomassetti/kanvas), of course.\n\nIn many cases I need a simple text editor for my DSLs and I tend to build them using ANTLR. I will need other stuff, like tabular or graphical projections, simulators and more but I need to start somewhere, right? Also, I think right now there is not an easy way to get a standalone editor for a DSL, with **minimal dependencies and a simple structure**. There is not a light option on the menu. Time to add one.\n\n## Getting an editor from your grammar quickly\n\nOnce you define the grammar of your language there is a lot of information you can extract from it. I think you should be able to get as much value as possible from it for free, with the possibility to customize it further, if needed. This is similar to the idea behind Xtext (minus the 400 pages you need to read to understand EMF).\n\nHow quickly can you get an editor for your ANTLR grammar? You create a new project for your editor, add Kanvas as a dependency and register which languages do you intend to support:\n\n```kotlin\nfun main(args: Array<String>) {\n    languageSupportRegistry.register(\"sm\", smLangSupport)\n    val kanvas = Kanvas()\n    SwingUtilities.invokeLater {\n        kanvas.createAndShowKanvasGUI()\n        kanvas.addTab(\"My SM\", languageSupport = smLangSupport)\n    }\n}\n```\n\nand add these lines to support your language:\n\n```kotlin\nobject smLangSupport : BaseLanguageSupport() {\n    override val antlrLexerFactory: AntlrLexerFactory\n        get() = object : AntlrLexerFactory {\n            override fun create(code: String): Lexer = SMLexer(org.antlr.v4.runtime.ANTLRInputStream(code))\n        }\n    override val parserData: ParserData?\n        get() = ParserData(SMParser.ruleNames, SMParser.VOCABULARY, SMParser._ATN)\n}\n```\n\nThis quickly. Less then 10 lines of code. We just need to specify the Lexer and Parser classes (_SMLexer_ and _SMParser_ in this example).\n\nIf you are wondering what language is that, that is Kotlin: a concise static language for the JVM, easily interoperable with Java.\n\n## Let’s improve it a little bit: syntax highlighting\n\nSo I have a simple language, I get an editor basically for free and I start using it. As first thing I want to define the style for the different kind of tokens. We are doing something simple, just setting the colors:\n\n```kotlin\nobject smLangSyntaxScheme : SyntaxScheme(true) {\n    override fun getStyle(index: Int): Style {\n        val style = Style()\n        val color = when (index) {\n            // Types\n            SMLexer.STRING, SMLexer.INT, SMLexer.DECIMAL -> Color(42, 53, 114)\n\n            // Literals\n            SMLexer.STRINGLIT -> Color(21, 175, 36)\n            SMLexer.INTLIT, SMLexer.DECLIT -> Color.BLUE\n\n            // Comments\n            SMLexer.COMMENT -> Color(170, 181, 171)\n\n            // Operators\n            SMLexer.ASTERISK, SMLexer.DIVISION, SMLexer.PLUS, SMLexer.MINUS -> Color.WHITE\n\n            // Keywords\n            SMLexer.VAR -> Color.GREEN\n            SMLexer.INPUT -> Color(200, 250, 200)\n            SMLexer.SM -> Color(200, 250, 200)\n            SMLexer.EVENT -> Color(200, 250, 200)\n            SMLexer.AS -> Color(50, 12, 96)\n\n            // Identifiers\n            SMLexer.ID -> Color.MAGENTA\n\n            // Separators\n            SMLexer.ARROW -> Color(50, 12, 96)\n            SMLexer.COLON -> Color(50, 12, 96)\n            SMLexer.ASSIGN -> Color(50, 12, 96)\n            SMLexer.LPAREN, SMLexer.RPAREN -> Color.WHITE\n\n            // Rest\n            SMLexer.UNMATCHED -> Color.RED\n            else -> null\n        }\n        if (color != null) {\n            style.foreground = color\n        }\n        return style\n    }\n}\n```\n\nWe are not setting certain tokens to be bold or in italic because we want to keep things simple. By the way, if you are interested in how syntax highlighting works in Kanvas, I described it in [this post](https://tomassetti.me/how-to-create-an-editor-with-syntax-highlighting-dsl/).\n\n## And then comes autocompletion\n\nNow, we get some limited autocompletion for free. We basically get autocompletion depending on the structure of the language, so our algorithm can tell us which keywords can be inserted in the current position or that in a certain position an identifier can be accepted. What the algorithm cannot not determine for free is which identifiers should suggest. Let’s implement a very simple logic: when we can insert an identifier we look at the preceeding tokens and use them to determine which suggestion to make. For example, when defining an input we could suggest “anInput” while when defining a variable we could suggest “aVar”:\n\n```kotlin\n    override val propositionProvider: PropositionProvider\n        get() = object : PropositionProvider {\n            override fun fromTokenType(completionProvider: CompletionProvider,\n                                       preecedingTokens: List<Token>, tokenType: Int): List<Completion> {\n                val res = LinkedList<Completion>()\n                var proposition : String? = this@smLangSupport.parserData!!.vocabulary.getLiteralName(tokenType)\n                if (proposition != null) {\n                    if (proposition.startsWith(\"'\") && proposition.endsWith(\"'\")) {\n                        proposition = proposition.substring(1, proposition.length - 1)\n                    }\n                    res.add(BasicCompletion(completionProvider, proposition))\n                } else {\n                    when (tokenType) {\n                        SMParser.ID -> {\n                            val determiningToken = preecedingTokens.findLast { setOf(SMLexer.SM, SMLexer.VAR, SMLexer.EVENT, SMLexer.INPUT).contains(it.type) }\n                            val text = when (determiningToken?.type) {\n                                SMLexer.SM -> \"aStateMachine\"\n                                SMLexer.EVENT -> \"anEvent\"\n                                SMLexer.INPUT -> \"aInput\"\n                                SMLexer.VAR -> \"aVar\"\n                                else -> \"someID\"\n                            }\n                            res.add(BasicCompletion(completionProvider, text))\n                        }\n                    }\n                }\n                return res\n            }\n        }\n```\n\nHere is the code. Is this enough? I do not know, but what I know is that this is a system small enough to be understandable and simple enough to be easily extended and customized. So I plan to use it for this small language, and improve the autocompletion as needed, specifically for this language. Organically and iteratively grow tool support is the name of the game.\n\n## Design goals: something similar to Sublime Text but open-source\n\nWe all love Sublime Text. I would like to have something inspired to it, but open-source. Why open-source? So that I can customize it as much as I want.\n\nThis is how it looks like for now:\n\n![](https://i1.wp.com/tomassetti.me/wp-content/uploads/2017/01/Kanvas_550.png?resize=500%2C500)\n\nYes, it is not yet as beautiful as Sublime Text. But this means I have space for improvement.\n\n## To Language Workbench or to not Language Workbench?\n\nI work routinely with Language Workbenches such as Jetbrains MPS and Xtext. They are great because they permit to obtain very good tool support very quickly. In many situations they are your best option. However, as every engineering choice, there are different aspects to consider. Jetbrains MPS and Xtext are very large and complex pieces of software, the kind of stuff that weight hundreds of MBs. To learn the internals of these platforms require a lot of work and a large effort. You can have a huge benefit by simply using those platforms. However they are not the best solution in all situations because in some situations you need to integrate your language with existing systems and thus you have to bend those Language Workbenches in ways they are not designed to. Maybe you want to embed your editor or tools in your existing platform, maybe you want to have a simple editor to use on a tablet, maybe you want tools to use from the command line. Maybe you want to hack a system together to fit your particular needs in some peculiar way. In those cases using a Language Workbench is not the right choice. You need something simple, something hackable. This is the approach I am experimenting it. To do that I am working on a few open-source projects and [writing a book](https://leanpub.com/create_languages).\n\n## Conclusions\n\nWill this fly? I do not know. I am having fun spending the few time I find on this project. And I feel it can be a good approach to get simple standalone editors for DSLs built with ANTLR. I would also like to use it as my sort of Kotlin-powered vim, a vim for the new millenium. With super-projectional-powers. Let’s see how this grows.\n\nAnd yes, I know that Atom describes itself as the hackable editor. But it is not hackable enough from my point of view.\n\n","author":"Federico Tomassetti","date":"2017-01-03","type":"article","categories":["Kotlin"],"features":["highlightjs"],"description":"","filename":"","lang":"EN","enclosure":null},{"title":"Kotlin DSL: Anko","url":"https://docs.google.com/presentation/d/12mkyGQZO22kf0_6kp2K6xyFdpg0nBLqGtNcVR-cV4M8/pub","body":"\n\n[Kotlin DSL: Anko](https://docs.google.com/presentation/d/12mkyGQZO22kf0_6kp2K6xyFdpg0nBLqGtNcVR-cV4M8/pub)\n\n","author":"@maciekjanusz","date":"2016-04-06","type":"slides","categories":["Kotlin","Android"],"features":["highlightjs"],"description":"","filename":"","lang":"EN","enclosure":null},{"title":"The Kobalt diaries: testing","url":"http://beust.com/weblog/2016/02/20/the-kobalt-diaries-testing/","body":"\nKobalt automatically detects how to run your tests based on the test dependencies that you declared:\n\n```kotlin\ndependenciesTest {\n    compile(\"org.testng:testng:6.9.9\")\n}\n```\n\nBy default, Kobalt supports TestNG, JUnit and Spek. You can also configure how your tests run with the test{} directive:\n\n```Kotlin\ntest {\n    args(\"-excludegroups\", \"broken\", \"src/test/resources/testng.xml\")\n}\n```\n\nThe full list of configuration parameters can be found in the [TestConfig](https://github.com/cbeust/kobalt/blob/master/modules/kobalt-plugin-api/src/main/kotlin/com/beust/kobalt/TestDirective.kt#L6) class.\n\nAdditionally, you can define multiple test configurations, each with a different name. Each configuration will create an additional task named \"test\" followed by the name of that configuration. For example:\n\n```Kotlin\ntest {\n    args(\"-excludegroups\", \"broken\", \"src/test/resources/testng.xml\")\n}\n\ntest {\n    name = \"All\"\n    args(\"src/test/resources/testng.xml\")\n}\n```\n\nThe first configuration has no name, so it will be launched with the task \"test\", while the second one can be run with the task \"testAll\".\n\nThe full series of articles on Kobalt can be found [here](http://beust.com/weblog/category/kobalt/).\n\n","author":"Cédric Beust","date":"2016-02-20","type":"article","categories":["Kotlin","Kobalt"],"features":["highlightjs"],"description":"","filename":"","lang":"EN","enclosure":null},{"title":"Kotlin for Data Science","url":"http://tomstechnicalblog.blogspot.com.by/2016/10/kotlin-for-data-science.html","body":"\n## Can Kotlin be an Effective Alternative for Python and Scala?\n\nAs I started diving formally into data science, I cannot help but notice there is a large gap between data science and software engineering. It is good to come up with prototypes, ideas, and models out of data analysis. However, executing those ideas is another animal. You can outsource the execution to a software engineering team, and that can go well or badly depending on a number of factors. In my experience, it is often helpful to do the execution yourself or at least offer assistance by modeling towards production.\n\nAlthough Python can be used to build production software, I find its lack of static typing causes difficulty in scaling. It does not easily plug in with large corporate infrastructures built on the Java platform either. Scala, although an undeniably powerful JVM language, is rather esoteric and inaccessible for those who do not have a software engineering background. But [Kotlin](http://kotlinlang.org/), a new JVM language by [JetBrains](https://www.jetbrains.com/) (the creator of [Intellij IDEA](https://www.jetbrains.com/idea/), [PyCharm](https://www.jetbrains.com/pycharm/), and dozens of other developer tools), has an active community, rapid growth and adoption, and might serve as a more accessible alternative to Scala.\n\n[Apache Spark](http://spark.apache.org/) is definitely a step in the right direction to close the gap between data science and software engineering, or more specifically, turning an idea into immediate execution. You can use [SparkR](https://spark.apache.org/docs/latest/sparkr.html) and [PySpark](http://spark.apache.org/docs/0.9.0/python-programming-guide.html) to interface R and Python with Spark. But if you want to use a production-grade JVM language, the only mainstream options seem to be Scala and Java. But Kotlin works out-of-the-box with Spark as well, since it is 100% interoperable with Java libraries.\n\n## A Comparison Between Python and Kotlin\n\nLet's take a look at a somehwat simple data analysis case study. We will leave Scala out and only compare Kotlin with Python. What I want to highlight is how Kotlin has the tactical conciseness of Python, and maybe even brings a little more to the table as a language for data analysis. Granted, there are not a lot of mainstream JVM data science libraries other than Apache Spark. But they do exist and perhaps there is room for growth. After all, Python caught up with R in a short time, and I am certainly not saying to drop your entire data analysis stack for Kotlin either. But the language may be worth keeping your eye on (and even exploring!).\n\nThis comparison was inspired by the social media example from the first chapter of [Data Science from Scratch](http://shop.oreilly.com/product/0636920033400.do) (Grus, _O'Reilly_). Let's start with declaring two sets of data, `users` and `friendships`. Using simply dicts, lists, and tuples without any classes, this is how it could be done in Python.\n\n**Python**\n\n```python\nusers = [ \n    { \"id\" : 0, \"name\" : \"Hero\" }, \n    { \"id\" : 1, \"name\" : \"Dunn\" }, \n    { \"id\" : 2, \"name\" : \"Sue\" }, \n    { \"id\" : 3, \"name\" : \"Chi\" }, \n    { \"id\" : 4, \"name\" : \"Thor\" }, \n    { \"id\" : 5, \"name\" : \"Clive\" }, \n    { \"id\" : 6, \"name\" : \"Hicks\" }, \n    { \"id\" : 7, \"name\" : \"Devin\" }, \n    { \"id\" : 8, \"name\" : \"Kate\" }, \n    { \"id\" : 9, \"name\" : \"Klein\" }, \n]\n \nfriendships = [ \n    (0,1), \n    (0,2), \n    (1,2), \n    (1,3), \n    (2,3), \n    (3,4), \n    (4,5), \n    (5,6), \n    (5,7), \n    (6,8), \n    (7,8), \n    (8,9)\n]\n```\n\nThe `users` is a `List` of `dict` items, and the `friendships` are a `List` of `Tuple` items. A feature of dynamic typing is you can be fast-and-loose creating data structures that maintain a raw data-like nature. There is no enforcement to uses classes or explicit types.\n\nThe equivalent to doing this in Kotlin would look like this:\n\n**Kotlin**\n\n```kotlin\nval users = listOf(\n    mapOf(\"id\" to 0, \"name\" to \"Hero\"),\n    mapOf(\"id\" to 1, \"name\" to \"Dunn\"),\n    mapOf(\"id\" to 2, \"name\" to \"Sue\"),\n    mapOf(\"id\" to 3, \"name\" to \"Chi\"),\n    mapOf(\"id\" to 4, \"name\" to \"Thor\"),\n    mapOf(\"id\" to 5, \"name\" to \"Clive\"),\n    mapOf(\"id\" to 6, \"name\" to \"Hicks\"),\n    mapOf(\"id\" to 7, \"name\" to \"Devin\"),\n    mapOf(\"id\" to 8, \"name\" to \"Kate\"),\n    mapOf(\"id\" to 9, \"name\" to \"Klein\")\n    )\n \n val friendships = listOf(\n        listOf(0,1), listOf(0,2), listOf(1,2), listOf(1,3), listOf(2,3), listOf(3,4),\n        listOf(4,5), listOf(5,6), listOf(5,7), listOf(6,8), listOf(7,8), listOf(8,9)\n )\n```\n\nFor the `friendships`, we can actually create `Pair<Int,Int>` items. Kotlin does not really encourage Tuples (or any collection with differing types) and we will see what it offers instead later with the [`data class`](https://kotlinlang.org/docs/reference/data-classes.html). But let's use [Pairs](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-pair/) in this example instead using the `to` operator.\n\n```kotlin\nval friendships = listOf(\n        0 to 1, 0 to 2, 1 to 2, 1 to 3, 2 to 3, 3 to 4,\n        4 to 5, 5 to 6, 5 to 7, 6 to 8, 7 to 8, 8 to 9\n)\n```\n\nThis may look effective at first glance, and Kotlin is statically typed. It is inferring the type for `users` and `friendships` as `List<Map<String,Any>>` and `List<List<Int>` respectively. Notice how `friendships` is a `List` containing `Map<String,Any>` items, meaning each item has a `String` for a key and an `Any` for the value. The reason for the `Any` is some values are `String` and others are `Int` (due to the \"id\" and \"name\"), and because the type is not consistent it cast them back down to `Any`. If we want to use Hero's \"id\", we need to cast it back up to an `Int` for it to be treated like an `Int` rather than a raw `Any`.\n\n```kotlin\nval herosId = users[0][\"id\"] as Int\n```\n\nOf course, if an \"id\" value is slipped in as a `String` accidentally this would throw an error. You can check if it is an `Int`, but at this point we are just fighting the statically-typed nature of Kotlin (just like Java and Scala). In Kotlin, we are much better off creating a `class` and doing things the statically-typed way. While this may make dynamic-typing advocates moan, check this out. Kotlin has a concise, readable way of declaring a class quickly and easily, even exceeding Python's standards\n\n**Python**\n\n```python\nclass User(Any):\n    def __init__(self, id, name):\n        self.id = id\n        self.name = name\n \n    def __str__(self):\n        return \"{0}-{1}\".format(self.id, self.name)\n \nusers = [ \n    User(0,\"Hero\"), \n    User(1,\"Dunn\"), \n    User(2,\"Sue\"), \n    User(3,\"Chi\"), \n    User(4,\"Thor\"), \n    User(5,\"Clive\"), \n    User(6,\"Hicks\"), \n    User(7,\"Devin\"), \n    User(8,\"Kate\"), \n    User(9,\"Klein\"), \n]\n```\n\n**Kotlin**\n\n```kotlin\ndata class User(val id: Int, val name: String)\n \nval users = listOf(\n      User(0, \"Hero\"),\n      User(1, \"Dunn\"),\n      User(2, \"Sue\"),\n      User(3, \"Chi\"),\n      User(4, \"Thor\"),\n      User(5, \"Clive\"),\n      User(6, \"Hicks\"),\n      User(7, \"Devin\"),\n      User(8, \"Kate\"),\n      User(9, \"Klein\")\n    )\n```\n\nNot too shabby, right? Technically, we did _less_ typing (as in keyboard typing) than Python (76 characters less to be exact, excluding spaces). And we achieved static typing in the process!\n\nKotlin is certainly a progressive language compared to Java, and it even has practical features like [data classes](https://kotlinlang.org/docs/reference/data-classes.html). We made our `User` a `data class`, which will automatically implement functionality typically used for classes holding plain data. It will implement `toString()` and `hashcode()`/`equals()` using the properties, as well as a nifty \"copy-and-modify\" builder by using a `copy()` function.\n\n**Kotlin**\n\n```kotlin\ndata class User(val id: Int, val name: String)\n \nval user = User(10,\"Tom\")\nval changedUser = user.copy(name = \"Thomas\")\n \nprintln(\"Old user: $user\")\nprintln(\"New user: $changedUser\")\n```\n\n**OUTPUT:**\n\n```\nOld user: User(id=11, name=Tom)\nNew user: User(id=11, name=Thomas)\n```\n\n> NOTE: In Kotlin, `val` precedes the declaration of an immutable variable. `var` precedes a mutable one.\n\nData classes are a valuable tool especially for working with data. And yes, Kotlin supports named arguments for constructors and functions as shown in the `copy()` function above.\n\nLet's return back to our example. Say we wanted to find the mutal friends between two Users. Traditionally in Python, you would create a series of helper functions to assist in this task.\n\n**Python**\n\n```python\nclass User(object):\n    def __init__(self, id, name):\n        self.id = id\n        self.name = name\n \n    def __str__(self):\n        return \"{0}-{1}\".format(self.id, self.name)\n \nusers = [ \n    User(0,\"Hero\"), \n    User(1,\"Dunn\"), \n    User(2,\"Sue\"), \n    User(3,\"Chi\"), \n    User(4,\"Thor\"), \n    User(5,\"Clive\"), \n    User(6,\"Hicks\"), \n    User(7,\"Devin\"), \n    User(8,\"Kate\"), \n    User(9,\"Klein\"), \n]\n \nfriendships = [ \n    (0,1), \n    (0,2), \n    (1,2), \n    (1,3), \n    (2,3), \n    (3,4), \n    (4,5), \n    (5,6), \n    (5,7), \n    (6,8), \n    (7,8), \n    (8,9)\n]\n \ndef user_for_id(user_id):\n    for user in users:\n        if user.id == user_id:\n            return user\n \n \n \ndef friends_of(user):\n    for friendship in friendships:\n        if friendship[0] == user.id or friendship[1] == user.id:\n            for other_user_id in friendship:\n                if other_user_id != user.id:\n                    yield user_for_id(other_user_id)\n \ndef mutual_friends_of(user, otherUser):\n    for friend in friends_of(user):\n        for other_friend in friends_of(otherUser):\n            if (friend.id == other_friend.id):\n                yield friend\n \n \n# print mutual friends between Hero and Chi \n \nfor friend in mutual_friends_of(users[0],users[3]):\n    print(friend)\n```\n\n**OUTPUT:**\n\n```\n1-Dunn\n2-Sue\n```\n\nBut we can do something similar in Kotlin.\n\n**Kotlin**\n\n```kotlin\nfun main(args: Array<String>)  {\n \n    data class User(val id: Int, val name: String)\n \n    val users = listOf(\n        User(0,\"Hero\"),\n        User(1, \"Dunn\"),\n        User(2, \"Sue\"),\n        User(3, \"Chi\"),\n        User(4, \"Thor\"),\n        User(5, \"Clive\"),\n        User(6, \"Hicks\"),\n        User(7, \"Devin\"),\n        User(8, \"Kate\"),\n        User(9, \"Klein\")\n        )\n \n    \n    val friendships = listOf(\n            0 to 1, 0 to 2, 1 to 2, 1 to 3, 2 to 3, 3 to 4,\n            4 to 5, 5 to 6, 5 to 7, 6 to 8, 7 to 8, 8 to 9\n    )\n \n    fun userForId(id: Int): User {\n        for (user in users)\n            if (user.id == id)\n                return user\n        throw Exception(\"User not found!\")\n    }\n \n    fun friendsOf(user: User): List<User> {\n        val list = mutableListOf<User>()\n        for (friendship in friendships) {\n            if (friendship.first == user.id)\n                list += userForId(friendship.second)\n            if (friendship.second == user.id)\n                list += userForId(friendship.first)\n        }\n        return list\n    }\n \n    fun mutualFriendsOf(user: User, otherUser: User): List<User> {\n        val list = mutableListOf<User>()\n        for (friend in friendsOf(user))\n            for (otherFriend in friendsOf(otherUser))\n                if (friend.id == otherFriend.id)\n                    list += friend\n \n        return list\n    }\n \n    for (friend in mutualFriendsOf(users[0],users[3]))\n        println(friend)\n}\n```\n\n**OUTPUT:**\n\n```kotlin\nUser(id=1, name=Dunn)\nUser(id=2, name=Sue)\n```\n\nAlthough Kotlin seems to have lost in this example by being wordier and resorting to Lists, hold on. Kotlin has no direct concept of [generators](https://wiki.python.org/moin/Generators) and `yield` keywords. However, we can accomplish something that fulfills the same purpose (and is arguably stylistically better) through `Sequence`.\n\n```kotlin\nfun main(args: Array<String>)  {\n \n    data class User(val id: Int, val name: String)\n \n    val users = listOf(\n        User(0,\"Hero\"),\n        User(1, \"Dunn\"),\n        User(2, \"Sue\"),\n        User(3, \"Chi\"),\n        User(4, \"Thor\"),\n        User(5, \"Clive\"),\n        User(6, \"Hicks\"),\n        User(7, \"Devin\"),\n        User(8, \"Kate\"),\n        User(9, \"Klein\")\n        )\n \n    \n    val friendships = listOf(\n            0 to 1, 0 to 2, 1 to 2, 1 to 3, 2 to 3, 3 to 4,\n            4 to 5, 5 to 6, 5 to 7, 6 to 8, 7 to 8, 8 to 9\n    )\n \n    fun userForId(id: Int) = users.asSequence().filter { it.id == id }.first()\n \n    fun friendsOf(user: User) = friendships.asSequence()\n            .filter { it.first == user.id || it.second == user.id }\n            .flatMap { sequenceOf(it.first,it.second) }\n            .filter { it != user.id }\n            .map { userForId(it) }\n \n    fun mutualFriendsOf(user: User, otherUser: User) = friendsOf(user).flatMap { friend ->\n        friendsOf(otherUser).filter { otherFriend -> otherFriend.id == friend.id }\n    }\n \n    mutualFriendsOf(users[0],users[3]).forEach { println(it) }\n}\n```\n\n**OUTPUT:**\n\n```\nUser(id=1, name=Dunn)\nUser(id=2, name=Sue)\n```\n\nWe can use the `Sequence` to compose a series of operators as a chain, like `filter()`, `map()`, `flatMap()`, and many others. This style of functional programming has been getting a lot of traction over the past few years, primarily because it easily breaks up logic into simple pieces and increases maintainability. 99.99% of the time, I am never using `for` loops but rather using a Kotlin `Sequence`, a Java 8 `Stream`, or an RxKotlin/RxJava `Observable`. This chain-operator syntax is becoming less alien in Python as well (look at [PySpark](http://www.mccarroll.net/blog/pyspark/) and [RxPy](https://github.com/ReactiveX/RxPY)). What is great about this style of programming is you can read what is happening left-to-right, top-to-bottom rather than jumping through several loops and helper functions.\n\n## Conclusions\n\nIn the coming months, I am going to blog about my experiences using Kotlin for data science, and I will continue to share what I learn. I may throw in an article occasionally covering [ReactiveX](http://reactivex.io/) for data science as well (for both Kotlin and Python). I acknowledge that the Java JVM platform, which Kotlin runs on, does not handle numbers as efficiently as Python or R (maybe [Project Valhalla will change that?](http://openjdk.java.net/projects/valhalla/)). But successful models inevitably need to turn into execution, and the Java platform increasingly seems to be the place that happens.\n\nKotlin merely provides a pragmatic abstraction layer that provides a tactical and concise syntax that seems excellent for data analysis. Not to mention, Kotlin has spurred many powerful open-source libraries even before a year after its release. One library, [TornadoFX](https://github.com/edvin/tornadofx), allows rapid turnaround of complex business user interfaces using Kotlin (As a disclaimer, I have helped with TornadoFX as well as [RxKotlinFX](https://github.com/thomasnield/RxKotlinFX)). The Kotlin community is incredibly active, growing, and engaged on the [Slack channel](http://kotlinslackin.herokuapp.com/). It [continues to be adopted on Android](https://www.raywenderlich.com/132381/kotlin-for-android-an-introduction), and JetBrains is using Kotlin to build all their tools (including PyCharm and Intellij IDEA). It is also [replacing Groovy as the official language for Gradle](https://blog.gradle.org/kotlin-meets-gradle). Because of these facts, I do not see Kotlin's momentum slowing down anytime soon.\n\nI believe Kotlin could make a great first JVM language, more so than Java or Scala. There is a new [O'Reilly video series](http://shop.oreilly.com/product/0636920052982.do) that covers Kotlin from scatch, and its instructor Hadi Hariri (one of the JetBrains folks behind Kotlin) believes Pythonistas should be able to follow along. He said anybody familiar with classes, functions, properties, etc should be able to learn Kotlin in a day with this video series. Unfortunately, the existing [Kotlin documentation](https://kotlinlang.org/docs/reference/) and [books](https://www.manning.com/books/kotlin-in-action) assume prior Java knowledge, and hopefully more resources other than the video pop up in the future.\n\nThere is a lot of exciting features I have not covered about Kotlin in this article. Features like [nullable types](https://kotlinlang.org/docs/reference/null-safety.html), [extension properties and functions](https://kotlinlang.org/docs/reference/extensions.html), and [boilerplate-free delegates](https://kotlinlang.org/docs/reference/delegation.html) make the language pleasant to use and highly productive. So check out Kotlin if you are using Python or Scala for data science. I will continue blogging about my experiences, and showcase it being used in deeper data science topics as well as Spark.\n\n","author":"Thomas Nield","date":"2016-10-28","type":"article","categories":["Kotlin"],"features":["highlightjs"],"description":"","filename":"","lang":"EN","enclosure":null},{"title":"Android development with Kotlin","url":"http://inaka.net/blog/2016/01/15/android-development-with-kotlin/","body":"\n\n## What is Kotlin?\n\n[Kotlin](https://kotlinlang.org/) is a statically typed programming language for the Java Virtual Machine, Android and web browsers. Inside Android apps we can use Kotlin language to replace Java code, but also we can use both together having Java classes and Kotlin classes in the same project.\n## Getting started\n\nUsing Android Studio\n\n### 1. Install the Kotlin plugin\n\nGo to \"Android Studio\" menu, \"Preferences\", \"Plugins\", search 'Kotlin' and install the plugin. Then you will have to restart Android Studio.\n\n### 2. Start a new Android project\n\nLet's create a new Android project: go to \"Start a new Android Studio project\" or \"File\" menu, and click \"New project\".\n\n### 3. Configure gradle\n\nYou can configure Kotlin in the project by clicking \"Help\" on the menu, then \"Find Action\" (or press ⇧⌘A) and finally enter \"Configure Kotlin in Project\". Then you should choose the Kotlin version that you want. After that, the app/build.gradle file should be updated. Also, instead of using \"Find Action\", you can edit the app/build.gradle file manually. Here is an example:\n\n\n```groovy\napply plugin: 'com.android.application'\napply plugin: 'kotlin-android'\n\nandroid {\n    compileSdkVersion 23\n    buildToolsVersion \"23.0.2\"\n\n    defaultConfig {\n        applicationId \"examples.kotlin.inaka.com\"\n        minSdkVersion 17\n        targetSdkVersion 23\n        versionCode 1\n        versionName \"1.0\"\n    }\n    buildTypes {\n        release {\n            minifyEnabled false\n            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'\n        }\n    }\n    sourceSets {\n        main.java.srcDirs += 'src/main/kotlin'\n    }\n}\n\nbuildscript {\n    ext.kotlin_version = '1.0.0-beta-4583'\n    repositories {\n        mavenCentral()\n    }\n    dependencies {\n        classpath \"org.jetbrains.kotlin:kotlin-gradle-plugin:$kotlin_version\"\n        classpath \"org.jetbrains.kotlin:kotlin-android-extensions:$kotlin_version\"\n    }\n}\n\nrepositories {\n    mavenCentral()\n}\n\ndependencies {\n    compile fileTree(dir: 'libs', include: ['*.jar'])\n    compile 'com.android.support:appcompat-v7:23.1.1'\n    compile \"org.jetbrains.kotlin:kotlin-stdlib:$kotlin_version\"\n}\n```\n\n### 4. Convert .java to Kotlin (.kt) files\n\nOpen a Java file and choose \"Help\" on the menu, then \"Find Action\" (or press ⇧⌘A) and enter the action \"Convert Java File to Kotlin File\". Alternatively you can call this option via \"Code\" menu, \"Convert Java File to Kotlin File\".\n\n## Some characteristics\n\nUsing Kotlin to develop Android apps introduce many differences and 'advantages' compared to Java development. Here I will mention some of them:\n\n### Variables and type inference\n\n```kotlin\nvar age = 5 // you don't need to declare as an Int\n```\n\nBut if you want to declare the type:\n\n```kotlin\nvar age: Int = 5\n```\n\nJava's 'final' = Kotlin's 'val':\n\n```kotlin\nval name = \"Fernando\" // 'val' can't be reassigned\n```\n\n### Pattern matching\n\n```kotlin\nfun valueDependingOnType(type: Int) {\n    var value = 0\n    when (type) {\n        1 -> toast(value.toString())\n        2 -> {\n            value = 100\n            toast(value.toString())\n        }\n        else -> toast(type.toString())\n    }\n}\n```\n\n### Safe call - null verification\n\nVerifying null object with Java:\n\n```kotlin\nint len;\nif(list != null){\n  len = list.size();\n}\n```\n\nSame as above but using Kotlin language:\n\n```kotlin\nvar len = list?.size\n```\n\nSafe cast example:\n\n```kotlin\nval x: String? = y as? String\n\n```\n\n### Properties\n\nAvoid usage of getters and setters:\n\n```kotlin\nvar user = User()\nuser.name = \"Fernando\" // set user's name\ntoast(user.name)       // get user's name\n```\n\n### Companion object\n\nA Kotlin class can have a companion object. This is like the static variable for Java classes. For example:\n\n```kotlin\nclass MainActivity : AppCompatActivity() {\n\n  companion object {\n      val PICK_CONTACT = 100\n  }\n\n  ...\n}\n```\n\nThen you can call MainActivity.PICK_CONTACT and it will receive the value 100.\n\n### String templates\n\n```kotlin\nfun printFirst(array: Array<String>) {\n  if (array.size == 0) return\n  print(\"First value: ${array[0]}\")\n}\n```\n\n### Ranges\n\n```kotlin\nif (x in 1..y)\nprint(\"x is  >= 1 and <= y\")\n```\n\n### Lambda expressions\n\n```kotlin\nfun foo(numbers: ArrayList<Int>) {\n   val doubled = numbers.map { elem -> elem * 2 }\n   ...\n}\n```\n\nor\n\n```kotlin\nfun foo(numbers: ArrayList<Int>) {\n   val doubled = numbers.map { it * 2 }\n   ...\n}\n```\n\n### Kotlin extensions - finding views\n\nYou don't need to call the findViewById() method. For example, if you want to change programatically the text of a TextView with id \"textView1\" from activity_main.xml you can do:\n\n```kotlin\nimport kotlinx.android.synthetic.main.activity_main.*\n```\n\nAnd then into onCreate method:\n\n```kotlin\ntextView1.text = \"example text\"\n```\n\n## Resources\n\n[Kotlin language official documentation](https://kotlinlang.org/docs/reference/)\n\n### Some open source example projects\n\n* [kotlillon](https://github.com/inaka/kotlillon) Compilation of simple Kotlin examples, all together in one Android app\n* [restful_android_kotlin](https://github.com/ramabit/restful-android-kotlin) Restful Android app example, using Kotlin with Realm, Retrofit, Picasso, Robospice and more\n\n### Some interesting Kotlin libraries for Android development\n\n* [Anko](https://github.com/Kotlin/anko)\n* [RxKotlin](https://github.com/ReactiveX/RxKotlin)\n* [kotterknife](https://github.com/JakeWharton/kotterknife)\n* [kotlin-nosql](https://github.com/cheptsov/kotlin-nosql)\n\n","author":"Fernando Ramirez","date":"2016-01-15","type":"article","categories":["Kotlin","Android"],"features":["highlightjs"],"description":"","filename":"","lang":"EN","enclosure":null},{"title":"Our first book about Kotlin is out","url":"https://blog.jetbrains.com/kotlin/2017/02/our-first-book-about-kotlin-is-out/","body":"\nWe’re happy to announce that [Kotlin in Action][] – a book about Kotlin written by the members of the Kotlin team – is now out, as both a eBook and a printed book. The book is written for experienced Java developers and covers all aspects of the language, without focusing on any specific problem domain. We received a lot of positive feedback about the book during Manning’s Early Access Preview program, so we hope that you’ll enjoy it too!\n\n![Kotlin in Action book][]\n\n\nTwo chapters from the book, covering Kotlin’s type system and its support for domain-specific languages, are available as a [free preview][] on the publisher’s Web site. And in our online mini-IDE for Kotlin, you can try out all examples from the book, starting from the [very first one][], also for free.\n\nTo accompany the release of the book, Manning is offering a special discount, valid today only: you can get half off the book if you enter the code *dotd021017au* during checkout.\n\nHappy reading, and have a nice Kotlin!\n\n\n[Kotlin in Action]: https://www.manning.com/books/kotlin-in-action\n[Kotlin in Action book]: https://d3nmt5vlzunoa1.cloudfront.net/kotlin/files/2017/02/20170209_112611.jpeg\n[free preview]: https://www.manning.com/books/kotlin-in-action#downloads\n[very first one]: http://try.kotlinlang.org/#/Kotlin%20in%20Action/chapter%201/1.1/1.1_ATasteOfKotlin.kt\n","author":"Dmitry Jemerov","date":"2017-02-10","type":"article","categories":["Kotlin"],"features":["highlightjs"],"description":"","filename":"","lang":"EN","enclosure":null},{"title":"Scala vs Kotlin: Operator overloading","url":"https://blog.frankel.ch/scala-vs-kotlin/2/","body":"\nLast week, I started my comparison of Scala and Kotlin with the [Pimp my library](/scala-vs-kotlin/1/) pattern. In the second part of this serie, I’d like to address operator overloading.\n\n## Overview\n\nBefore to dive into the nitty-gritty details, let’s try first to tell what it’s all about.\n\nIn every language where there are functions (or methods), a limited set of characters is allowed to define the name of said functions. Some languages are more lenient toward allowed characters: naming a function `\\O/` might be perfectly valid.\n\nSome others are much more strict about it. It’s interesting to note that Java eschewed the ability to use symbols in function names besides `$` - probably in response to previous abuses in older languages. It definitely stands on the less lenient part of the spectrum and the Java compiler won’t compile the previous `\\O/` function.\n\nThe name operator overloading is thus slightly misleading, even if widespread. IMHO, it’s semantically more correct to talk about operator characters in function names.\n\n## Scala\n\nScala stands on the far side of leniency spectrum, and allows characters such as `+` and `£` to be used to name functions, alone or in combinations. Note I couldn’t find any official documentation regarding accepted characters (but some helpful discussion is available [here](https://stackoverflow.com/questions/7656937/valid-identifier-characters-in-scala)).\n\nThis enables libraries to offer operator-like functions to be part of their API. One example is the `foldLeft` function belonging to the `TraversableOnce` type, which is also made available as the `/:` function.\n\nThis allows great flexibility, especially in defining <abbr title=\"Domain Specific Language\">DSL</abbr>s. For example, mathematics: functions can be named `π`, `∑` or `√`. On the flip side, this flexibility might be subject to abuse, as `\\O/`, `^_^` or even `|-O` are perfectly valid function names. Anyone for an emoticon-based API?\n\n```scala\ndef ∑(i: Int*) = i.sum\n\nval s = ∑(1, 2, 3, 5) // = 11\n```\n\n## Kotlin\n\nKotlin stands on the middle of the leniency scale, as it’s possible to define only a [limited set of operators](https://kotlinlang.org/docs/reference/operator-overloading.html).\n\nEach such operator has a corresponding standard function signature. To define a specific operator on a type, the associated function should be implemented and prepended with the `operator` keyword. For example, the `+` operator is associated with the `plus()` method. The following shows how to define this operator for an arbitrary new type and how to use it:\n\n```kotlin\nclass Complex(val i: Int, val j: Int) {\n    operator fun plus(c: Complex) = Complex(this.i + c.i, this.j + c.j)\n}\n\nval c = Complex(1, 0) + Complex(0, 1) // = Complex(1, 1)\n\n```\n\n## Conclusion\n\nScala’s flexibility allows for an almost unlimited set of operator-looking functions. This makes it suited to design DSL with a near one-to-one mapping between domains names and function names. But it also relies on implicitness: every operator has to be known to every member of the team, present **and** future.\n\nKotlin takes a much more secure path, as it allows to define only a limited set of operators. However, those operators are so ubiquitous that even beginning software developer know them and their meaning (and even more so experienced ones).\n\n","author":"Nicolas Fränkel","date":"2016-07-24","type":"article","categories":["Kotlin","Scala"],"features":["highlightjs"],"description":"","filename":"","lang":"EN","enclosure":null},{"title":"Functional Programming in Kotlin with funKTionale (Video)","url":"https://www.youtube.com/watch?v=klakgWp1KWg","body":"\n\n[Slides](https://speakerdeck.com/marioariasc/functional-programming-in-kotlin-with-funktionale-2)\n\n<iframe width=\"960\" height=\"480\" src=\"https://www.youtube.com/embed/klakgWp1KWg\" frameborder=\"0\" allowfullscreen></iframe>\n\n","author":"Mario Arias","date":"2016-12-16","type":"video","categories":["Kotlin"],"features":["highlightjs"],"description":"","filename":"","lang":"EN","enclosure":null},{"title":"DevZen Podcast: Kotlin и Vulkan 1.0 — Episode 0080.","url":"http://devzen.ru/episode-0080/","body":"\nТемы выпуска: Сравнение разных конфигурации сети в Kubernetes, Kotlin наконец вышел в версии 1.0, Vulkan тоже вышел в 1.0, критическая уязвимость в glibc, ZFS в Ubuntu 16.04, снова Rust, и про Монады. И, конечно, ответы на вопросы слушателей.\n\nШоу нотес:\n\n* Вакансия C++ & Scala Software Engineer\n* Comparison of Networking Solutions for Kubernetes — Comparison of Networking Solutions for Kubernetes 2 documentation\n* [Kotlin 1.0 Released: Pragmatic Language for JVM and Android | Kotlin Blog](http://blog.jetbrains.com/kotlin/2016/02/kotlin-1-0-released-pragmatic-language-for-jvm-and-android/)\n* Go 1.6 is released — The Go Blog\n* Does FreeBSD support OpenGL 3.3?\n* Unable to build Assimp on FreeBSD 10.2 · Issue #795 · assimp/assimp · GitHub\n* Vulkan — Industry Forged\n* Vulkan in 30 minutes\n* OpenNews: Опубликован графический стандарт Vulkan 1.0\n* Khronos Products\n* Vulkan 1.0 Released: What You Need To Know About This Cross-Platform, High-Performance Graphics API — Phoronix\n* PVS-Studio покопался в ядре FreeBSD\n* Критическая уязвимость библиотеки glibc позволяет осуществлять удаленное выполнение кода / Блог компании Positive Technologies / Хабрахабр\n* FreeBSD and CVE-2015-7547\n* OpenNews: В Ubuntu 16.04 будет добавлена поддержка ZFS и Vulkan\n* From the Canyon Edge: ZFS is *the* FS for Containers in Ubuntu 16.04!\n* There is No Now — ACM Queue\n* select * from depesz; » Blog Archive » Waiting for 9.6 – Remove GROUP BY columns that are functionally dependent on other columns.\n* Hint Bits — PostgreSQL wiki\n* Speeding up things with hint bits — Cybertec — The PostgreSQL Database Company\n* Introduction to Windows shellcode development – Part 3 – Security Café\n* The latest high-end Ubuntu phone will be available globally | ZDNet\n* CharybdeFS: a new fault-injecting filesystem for software testing\n* Red Book, 5th ed. Ch. 6: Weak Isolation and Distribution\n* PostgreSQL: Documentation: 9.5: Transaction Isolation\n* [Libevent-users] Comparison of libevent and libuv\n* Kazuho’s Weblog: The reasons I stopped using libuv for H2O\n* Using non-blocking and asynchronous I/O (CK10 problem) in Linux and Windows (with epool, iocp, libevent/libev/libuv/boost.asio and librt/libaio) | Rui’s Blog\n* Запах монад по утрам — Прогулки по воде\n* Темы и вопросы слушателей для 0080 « DevZen Podcast\n\n","author":"DevZen Podcast","date":"2016-02-20","type":"article","categories":["Podcast","Kotlin"],"features":["highlightjs"],"description":"","filename":"","lang":"RU","enclosure":{"url":"http://devzen.ru/download/2016/devzen-0080-2016-02-19-3280e712a2cc1485.mp3","size":55240704}},{"title":"Kotlin: A Low-Ceremony, High-Integration Language","url":"http://www.oracle.com/technetwork/issue-archive/2015/15-sep/index.html","body":"\nWork with a statically typed, low-ceremony language that provides first-class functions, nullability protections, and complete integration with existing Java libraries.\n\nIt has been more than five years since Project Kotlin, an open source language targeting the JVM, was announced by JetBrains. Since then, much progress has been made, some language designs have changed, a new platform — namely JavaScript — is now supported, and even the project name has changed. It’s now simply known as Kotlin. But if there’s one thing that still remains, it is the initial goals and intent for why Kotlin was developed.\n\nAt JetBrains, we have been developing IDEs for many programming languages, and yet despite this, much of our code continues to be written in Java. In 2009, we were looking for an alternative to Java, something that could reduce the size of our codebase by being more concise and, at the same time, offer features that we felt could provide important benefits. We needed a language that was also syntactically similar enough to Java that ramp-uptime would not be substantial. The main contender at the time was Scala, but the compiler performance wasn’t that great and providing tooling for Scala was (and continues to be) quite challenging. Tooling and performance were important aspects in our decision, so we opted not to go with Scala. Thus was born Project Kotlin.\n\nShortly afterward, news about the JVM language Ceylon was announced; and at one point we considered joining efforts. However, at the time, Ceylon’s focus on interoperability was somewhat of a low priority. Given that we have a large codebase in Java, being able to use and extend it was of considerable importance to us. Thus, we decided to continue down our own path with Kotlin.\n\n## Removing the Pain\n\nFive years later and close to reaching the 1.0 milestone, Kotlin remains true to its initial goals of being concise, safe, interoperable, “toolable”, and performant. Many, if not all, of these goals are for a single purpose: removing some of the pain and the errors we encounter when writing code.\n\nThe IntelliJ platform is an extremely large codebase on which all our IDEs, including IntelliJ IDEA, are built. The open source Community Edition alone, which is hosted on [GitHub](https://github.com/JetBrains/intellij-community/), has millions of lines of code. While there is a lot of functionality, much of the code is often boilerplate code that is necessary because, well, because it’s Java. One of Kotlin’s goals has been to reduce the amount of somewhat pointless code yet maintain readability and functionality. For instance, a typical Java bean with property getters, setters, toString, and equality in Kotlin can be reduced to the following:\n\n```kotlin\ndata class Customer(\n    var name: String,\n    var email: String\n)\n```\n\nThings such as smart-casting remove the need for verbosity by delegating the work to the compiler. For example, when checking an immutable value for a specific type, it’s no longer necessary to cast to that type when operating on it:\n\n```kotlin\nfun convert(obj: Shape) {\n    if (obj is Circle) {\n        val radius = obj.radius()\n        // ...\n    }\n}\n```\n\nKotlin also has support for named objects, which, in essence, means a singleton would simply be written as follows:\n\n```kotlin\nval MySingleton = object {\n    val numberOfDays = 10\n}\n```\n\nAnother pain point Kotlin addresses is the need to use functional constructs — such as lambda expressions and higher-order functions — and to treat functions as first-class citizens. While Java 8 addresses some of these concerns, our goal was and continues to be to provide this functionality when using Java 6, 7, or 8 — thus, even allowing support for these features on the Android platform. This is one reason that Kotlin has enjoyed considerable popularity in the Android development community.\n\nFunctions can be top-level in Kotlin, much like they are in JavaScript, meaning there’s no need to attach a function to an object. As such, we could simply declare a function in a file like this:\n\n```kotlin\nfun toSentenceCase(input: String) {\n    // ...\n}\n```\n\nMuch like C#, Kotlin also allows extension functions, meaning a type (either of Java or Kotlin) can be extended with new functionality simply by suffixing the type. Taking the previous example, if I want the String type to have `toSentenceCase()`, I can simply write the following:\n\n```kotlin\nfun String.toSentenceCase() {\n    // 'this' would hold an\n    // instance of the object\n}\n```\n\nTo work efficiently with functions as primitives, there needs to be support for higher-order functions — that is, functions that take functions as parameters or return functions. With Kotlin, this is possible, for example:\n\n```kotlin\nfun operate(x: Int, y: Int, operation: (Int, Int) -> Int) {\n    // ...\n}\n```\n\nThis code declares a function that takes three parameters: two integers and a third parameter that is a function that, in turn, takes two integers and returns an integer. We can then invoke functions as follows:\n\n```kotlin\nfun sum(x: Int, y: Int) {\n    // ...\n}\n\noperate(2, 3, ::sum)\n```\n\nThis code shows a function, `sum`, being defined and passed as a parameter to operate. It shows that Kotlin supports referencing functions by name. Of course, a lambda expression can be passed in as well:\n\n```kotlin\noperate(2, 3, { x, y -> x +y })\n```\n\nThese capabilities deliver an elegant way of doing function pipelining:\n\n```kotlin\nval numbers = 1..100\n\nnumbers\n    .filter { it % 2 == 0 }\n    .map { it + 5 }\n    .forEach {\n        println(it)\n    }\n```\n\nOne more issue we attack with Kotlin is null pointer exceptions. In Kotlin, by default, things cannot be null, meaning that potentially the only way we’d get a null reference exception would be if we explicitly force it.\n\n```kotlin\nvar city = \"London\"\n```\n\nIn the code above, city could never be assigned a null value. If we want it to be null, we need to go out of our way to be explicit:\n\n```kotlin\nvar city : String? = null\n```\n\nwhere `?` indicates that a type can be nullable. When interoperating with Java, we provide certain mechanisms to warn of possible null references, as well as providing some operators to make the code more concise, such as the safe call operator:\n\n```kotlin\nvar file = File(\"...\")\nfile?.length()\n```\n\nBecause of the `?.` , this code would invoke `length()` on `file` only if `file` were not `null`. The standard library, a small runtime that ships with Kotlin, also provides additional functions in this area, such as the `let` function, which when combined with the safe call operator allows for succinct code, such as the following:\n\n```kotlin\nobj?.let {\n... // execute code here\n}\n```\n\nThis results in the code block executing if the object is not null.\n\nOne last thing worth mentioning about Kotlin is its ability to easily enable the creation of DSLs — without the overhead that necessarily comes with maintaining them or the language knowledge required to implement them. Top-level functions, higher-order functions, extension functions, and a few conventions, such as not having to use brackets when the last parameter to a function is another function — these features allow for creating rich DSLs that are strongly typed. The quintessential example is that of type-safe Groovy-style builders. The following function generates the expected HTML output:\n\n```kotlin\nhtml {\n    head {\n        title { +\"XML encoding with Kotlin\" }\n    }\n    body {\n        h1 { +\"XML encoding with Kotlin\" }\n        p { +\"this is an alternative markup to XML\" }\n    }\n}\n```\n\n## Growth and the Road Ahead\n\nThe previous code snippets are just a few examples of what Kotlin provides. It wouldn’t be possible to cover all the little details and conveniences Kotlin offers in a single article.\n\nOver the past year, and despite not having released version 1.0, we’ve noticed a substantial growth and interest in Kotlin. There has been an increase in downloads and visits to the Kotlin site, as well as an increase in technical questions in both our forums and public venues such as StackOverflow.\n\nWhile a lot of this interest is due to the Android community and our contributions in terms of additional tooling and frameworks for this space, there’s also interest in other more generic areas such as web development, both client-side (given Kotlin’s ability to compile to JavaScript) and server-side.\n\nWe’re close to reaching the first major release, and we’ve made significant steps toward that. Over the past few milestone releases, we’ve been removing and adjusting some things in the language to make sure that once we release, we’ll be fairly certain that what we ship is there to stay. As any language designer or developer knows, whatever goes in a language stays as baggage pretty much forever.\n\nAs a company that provides tooling for developers, we’ve tried to make language release transitions as smooth as possible. To this end, a new release usually comes with a compiler warning about a potential upcoming change or deprecation. The IDE also provides a quick fix to easily migrate code to newer syntax. We believe that this way, we create a smooth experience for developers that are already using Kotlin in production.\n\nBeyond these quick fixes, we’re also focusing on improving other aspects of tooling. For Kotlin to be successful, the entry barrier should be low in all aspects. That is why we not only provide tooling for IntelliJ IDEA, in both Ultimate and the open source Community Edition, but also for build tools such as Gradle, Ant, and Maven, as well as a simple command-line compiler. We’ve also released a preliminary version of Kotlin for Eclipse, and we’re hoping that much like there are contributions to Kotlin in other areas, the community will contribute to Eclipse support as well.\n\n## Conclusion\n\nIn conclusion, we developed Kotlin for our own use primarily and are heavily invested in it. For us, it’s a tool that we’re using to drive our own business, which is developer tools. We already have several internal and public-facing web applications written in Kotlin. Some of our newer tools are being written in Kotlin and our existing tools, such as IntelliJ IDEA and YouTrack, are adopting Kotlin. `</article>`\n\n> This article is the inaugural installment of a new series on JVM languages that will appear in Java Magazine. We will examine the full range of languages, from large commercial efforts to projects driven by determined groups of hackers. In the next issue, we’ll cover Jython. —Ed.\n\n## LEARN MORE\n* [Kotlin home](http://kotlinlang.org/)\n* [Kotlin on StackOverflow](https://stackoverflow.com/questions/tagged/kotlin)\n* [Kotlin on Reddit](https://www.reddit.com/r/Kotlin/)\n","author":"HADI HARIRI","date":"2015-09-30","type":"article","categories":["Kotlin"],"features":["highlightjs"],"description":"","filename":"","lang":"EN","enclosure":null},{"title":"Exploring Delegation in Kotlin","url":"http://codemonkeyism.com/exploring-delegation-in-kotlin/","body":"\nI’m a huge fan of interfaces in Java and also of composition over inheritance. Inheritance is some magic wiring with tight coupling that creates lots of friction when evolving a code base. I’ve written about interfaces before several times, for example [here](http://codemonkeyism.com/how-to-improve-programming-with-interfaces/) or [here](http://codemonkeyism.com/generation-java-programming-style/). Looking at Kotlin I wanted to see what I can do with interfaces and composition.\n\nTake this example:\n\n```kotlin\ninterface HasName {\n  fun getName():String\n}\n\nclass Person(): HasName {\n   override fun getName():String = \"Stephan\"\n}\n\nfun main(args: Array<String>) {\n  val p = Person()\n  // Prints 'Stephan'\n  println(p.getName())\n}\n\n```\n\nWhy would one introduce a `HasName` interface in this case? It reduces dependencies and coupling. This makes reasoning about code easier and speeds up compilation, especially incremental compilation.\n\nHow would we use the `HasName` interface? A function that checks for a good name could look like this:\n\n```kotlin\nfun goodName(p:Person):Boolean {\n  return p.getName() == \"Stephan\"\n}\n```\n\nNow the function depends on the whole of person, not just the name part. The function can not operate on a lot of things, just persons. What about other things with `Name`, like Dogs? Rewritting the code to\n\n```kotlin\nfun goodName(n:HasName):Boolean {\n   return n.getName() == \"Stephan\"\n}\n```\n\nmakes the function more reusable.\n\nInside our `Person class` we have the code for the `HasName` functionality. It woud be nicer to be able to reuse the functionality from somewhere else.\n\nIn Kotlin we can delegate Interfaces to objects:\n\n```kotlin\ninterface HasName {\n  fun getName():String\n}\n\nclass NameMixin(val n:String): HasName {\n  override fun getName() = n\n}\n\nclass Person(n:NameMixin): HasName by n {\n}\n\nfun main(args: Array<String>) {\n    val p = Person(NameMixin(\"Stephan\"))\n    // Prints 'Stephan'\n    println(p.getName())\n}\n\n```\n\nThis looks a little unnatural to me, as the user of the `Person class` needs to know about the `NameMixin`. See if we can do better\n\n```kotlin\nclass Person(n:String): HasName by NameMixin(n) {\n}\n\nfun main(args: Array<String>) {\n  val p = Person(\"Stephan\")\n  // Prints 'Stephan'\n  println(p.getName())\n}\n\n```\n\nlooks cleaner as the consumer of `Person` does not know about `NameMixin`.\n\nKotlin can also use data classes (Thanks to Christian Helmbold for pointing this out).\n\n```kotlin\ninterface HasName {\n    val name: String\n}\n\ndata class NameMixin(override val name: String) : HasName\n\nclass Person(named : HasName) : HasName by named\n```\n\nIf we want to have more control, we can use a Factory inside `Person`.\n\n```kotlin\nclass Person(n:String): HasName by Person.name(n) {\n  companion object Name {\n    fun name(n:String) = NameMixin(n)\n  }\n}\n\n```\n\nThe name of the `companion object`, in this case `Name`, is optional but helps to structure the factory methods.\n\nThe mixin can be accessed with `this`:\n\n```kotlin\nclass Person(n:String): HasName by Person.name(n) {\n  ...\n  fun isStephan():Boolean {\n    // Access name property\n    return this.getName() == \"Stephan\"\n  }\n}\n```\n\nUsing a `companion object` with a factory method is better, because it gives us more control in the creation of the Mixin. But the control is not optimal. I wish we had something like\n\n```kotlin\n// Not working Kotlin code!\nclass Person(n:String): HasName {\n    val name delegates from HasName\n}\n```\n\nwhere I have access to name and more control over it. It would also be nice to have a way to access other Mixins from a Mixin. But overall, some nice functionality in Kotlin.\n\n","author":"@codemonkeyism","date":"2016-04-04","type":"article","categories":["Kotlin"],"features":["highlightjs"],"description":"","filename":"","lang":"EN","enclosure":null},{"title":"Zero boilerplate delegation in Kotlin","url":"https://medium.com/@piotr.slesarew/zero-boilerplate-delegation-in-kotlin-e383fdef28eb#.k4sdth6d4","body":"\n![](https://cdn-images-1.medium.com/max/880/1*40AToH3O5szPdLfWU3kLVA.jpeg)\n\n> Delegation is an implementation mechanism in which an object forwards or delegates a request to another object. — _(_[_GoF_](https://www.amazon.com/Design-Patterns-Elements-Reusable-Object-Oriented-ebook/dp/B000SEIBB8)_)_\n\nIt is said that [inheritance](https://en.wikipedia.org/wiki/Inheritance_%28object-oriented_programming%29) is useful only in case of having [Donald Trump](https://en.wikipedia.org/wiki/Donald_Trump) as a father. Abstract classes have a lot of gotchas in term of designing scalable and reusable architecture. How many times did you create the superclass in your codebase that could not be replaced and blocked you from doing new fancy features? Thanks to [Henry Lieberman](https://g.co/kgs/EzZ2yF) our programming toolbox include an amazing delegation_,_ so it can be used against wrong abstractions. Remember! The wrong abstraction is worst than no abstraction.\n\nWords are cheap, let’s code a little bit.\n\n```kotlin\nclass CopyPrinter implements Copy, Print {\n\n    private Copy copier;\n    private Print printer;\n\n    public CopyPrinter(Copy copier, Print printer) {\n        this.copier = copier;\n        this.printer = printer;\n    }\n\n    @Override\n    public Page copy(Page page) {\n        return copier.copy(page);\n    }\n\n    @Override\n    public void print(Page page) {\n        printer.print(page);\n    }\n}\n\ninterface Copy {\n    Page copy(Page page);\n}\n\ninterface Print {\n    void print(Page page);\n}\n\nclass Page {}\n```\n\nThe sample above is pretty straightforward, but still begging for some code generation because of having boilerplate in it. It would be so nice to have delegation as a built-in language feature. In old Java world things like that does not exist, so is there any way to solve that problem differently? It is possible to use annotation processing to create a library for code generation or implement reflection to invoke methods dynamically. That sounds pretty scary, right? As a fan of [Kotlin](https://kotlinlang.org), I will show you how to delegate like a pro.\n\n### [Kotlin](https://kotlinlang.org)\n\nAs I have already mentioned, there is a huge need of having delegationpattern implemented in language. Guess what! [Kotlin](https://kotlinlang.org) has it❤.\n\n```kotlin\nclass CopyPrinter(copier: Copy, printer: Print) : Copy by copier, Print by printer\n\ninterface Copy {\n    fun copy(page: Page): Page\n}\n\ninterface Print {\n    fun print(page: Page)\n}\n\nclass Page\n```\n\nJust amazing. When I saw it for the first time it literally blew my mind. [Kotlin](https://kotlinlang.org) makes it so clear and concise that I do not have to explain what the code does.\n\nAnd if that is not enough, [Kotlin](https://kotlinlang.org) have the whole concept of [Delegated Properties](https://kotlinlang.org/docs/reference/delegated-properties.html). If you are not familiar with it, you have to read it and start using it as soon as possible.\n\n> Any piece of code that you’re forced to duplicate or that can be automatically generated by an IDE is a missing language abstraction feature. — ([**Mario Fusco**](https://twitter.com/mariofusco/status/790171082242359296))\n\n#### Notes:\n\n[GoF](https://www.amazon.com/Design-Patterns-Elements-Reusable-Object-Oriented-ebook/dp/B000SEIBB8), [Delegated Properties](https://kotlinlang.org/docs/reference/delegated-properties.html), [Kotlin](https://kotlinlang.org), [Henry Lieberman](https://g.co/kgs/EzZ2yF)\n\n","author":"Piotr Ślesarew","date":"2016-10-28","type":"article","categories":["Kotlin"],"features":["highlightjs"],"description":"","filename":"","lang":"EN","enclosure":null},{"title":"Kotlin null safety and its performance considerations -- part 1","url":"http://allegro.tech/2016/06/kotlin-null-safety-part1.html","body":"\n[Kotlin](http://kotlinlang.org) may seem like a new kid on the block – itʼs been officially released only in [February](http://blog.jetbrains.com/kotlin/2016/02/kotlin-1-0-released-pragmatic-language-for-jvm-and-android/). Its history however dates [a few years back](http://www.infoworld.com/article/2622405/java/jetbrains-readies-jvm-based-language.html) and itʼs mature and stable enough to be used for developing solid reliable applications. Therefore at [Allegro](http://allegro.pl) we decided to give it a chance – we built our new shiny server-side system using Kotlin as its primary language and we do not regret it.\n\nOne of the first features a Kotlin developer learns is the languageʼs approach to handling `null` values. It is quite interesting – especially at times like these when the most popular way of handling this problem is to use some kind of [Option monad](https://en.wikipedia.org/wiki/Option_type). As weʼll soon see Kotlin actually does not introduce any new special wrapper type – it uses regular Java types albeit with slight variance.\n\n## Null-safe world\n\nIn Kotlin when you declare a variable, a field or a function parameter, by default they cannot be `null`. For example letʼs suppose we have a class `Greeter` which has a function `hello` that by default prints a greeting message on the standard output:\n\n```kotlin\nclass Greeter {\n  fun hello(who: String): Unit {\n    println (\"Hello $who\")\n  }\n}\n```\n\nWe declared `who` to be of type `String` which is interpreted by the compiler to mean that `who` cannot be `null`. If we want to declare a _nullable_ parameter we have to add a question mark at the end of the type name:\n\n```kotlin\nclass Greeter {\n  fun hello(who: String?): Unit {\n    println (\"Hello $who\")\n  }\n}\n```\n\nThis simple solution turns out to be very convenient and strong at the same time. It divides the world of our code into two areas: one where `null`s are allowed and one where they arenʼt. As weʼll see in a moment Kotlin provides quite a range of helpful features which makes the transition between those areas entirely safe. Yet we have to be aware of a few surprising issues.\n\nTo fully explore how Kotlin handles `null`s underneath weʼll take a closer look at the code generated by Kotlin compiler. Weʼll do it on two levels: first weʼll inspect the output bytecode – although for brevity weʼll actually see equivalent Java code. Then, in the second part of this article – for some interesting cases weʼll have a glance at the machine code generated by [JVM JIT compiler](http://openjdk.java.net/groups/hotspot/docs/HotSpotGlossary.html#JITCompilers).\n\n### Smart casts\n\nSince Kotlin compiler knows the type of every variable, field, function parameter, etc. it can check if an incorrect assignment takes place and throw an error in such case. In the code below we try to assign a _nullable_ reference to a _non-null_ property:\n\n```kotlin\nclass User {\n  private var username: String = \"\"\n\n  fun setName(newName: String?) {\n    username = newName // the compiler will indicate an error here\n  }\n}\n```\n\nWhat if we wanted to check if the reference is not `null` and only then assign it to a property? The following code provides an answer:\n\n```kotlin\nclass User {\n  private var username: String = \"\"\n\n  fun setName(newName: String?) {\n    if (newName == null)\n      throw NullPointerException(\"Name cannot be null!\")\n\n    username = newName // here the compiler knows that newName cannot be null and therefore\n  }                    // its type is String and not String?\n}\n```\n\nThis construct – where the compiler can infer that the reference cannot be `null` – is called smart casting as it seems to cast the reference from `String?` to `String`.\n\nThere is one thing we have to bear in mind when using smart casts. We can only do it with references that cannot be changed between the checkpoint and the actual assignment. In the code above the reference was taken from the function parameter which cannot change in the course of function execution. If we were to take the reference from some read/write property the compiler would not allow it:\n\n```kotlin\nclass UserRequest {\n  var username: String? = null\n}\n\nclass User {\n  private var username: String = \"\"\n\n  fun setNameFrom(request: UserRequest) {\n    if (request.username == null)\n      throw NullPointerException(\"Name cannot be null!\")\n\n    username = request.username // here the compiler cannot be sure that request.username\n  }                             // is not null - it could change in some other thread\n}                               // right after the condition check\n```\n\n### The !! operator\n\nThe code shown in the above example looks quite common. When we expect a reference to be not `null` and this assumption proves wrong we may want to throw `NullPointerException`. Kotlin has a special syntax for such cases:\n\n```kotlin\nclass User {\n  private var username: String = \"\"\n\n  fun setName(newName: String?) {\n    username = newName!! // the type of newName!! is String and the compiler generates a runtime check to be sure of that...\n  }\n}\n```\n\nThe equivalent Java code as taken from the bytecode generated by the Kotlin compiler is as follows:\n\n```kotlin\nimport org.jetbrains.annotations.Nullable;\n\nimport static kotlin.jvm.internal.Intrinsics.throwNpe;\n\npublic final class User {\n  private String username = \"\";\n\n  public void setName(@Nullable newName: String) {\n    if (newName == null) {\n      throwNpe();\n    }\n\n    username = newName;\n  }\n}\n```\n\nWe can see a couple of interesting things here:\n\n1.  The `newName` parameter of the `setName` method gets an annotation indicating its _nullability_. This annotation is used internally by Kotlin compiler and [IntelliJ IDEA](https://www.jetbrains.com/idea/), although one can think of using it also in tools like [FindBugs](http://findbugs.sourceforge.net/) or [Checker Framework](http://types.cs.washington.edu/checker-framework/current/checker-framework-manual.html#nullness-checker).\n2.  The code in `setName` has a striking resemblance (surprise!) to the code we wrote in our smart cast example. The only difference is the usage of the `throwNpe` method. Weʼll delve into the details in part 2 – for now we can make a simplification and state that it throws `KotlinNullPointerException` (which extends `NullPointerException`).\n\n### Parameter validation\n\nSo far in our examples we didnʼt have methods which were not private and at the same time had non-`null` parameters. In order to gain some insight into what happens in such situations letʼs modify our code:\n\n```kotlin\nclass User {\n  var username: String = \"\"\n\n  fun setName(newName: String) {\n    username = newName\n  }\n}\n```\n\nOne obvious method that weʼd like to have a look at is the `setName` method. But the equivalent Java code contains a surprise:\n\n```java\nimport org.jetbrains.annotations.NotNull;\nimport org.jetbrains.annotations.Nullable;\n\nimport static kotlin.jvm.internal.Intrinsics.checkParameterIsNotNull;\n\npublic class User {\n  @NotNull\n  private String username = \"\";\n\n  @NotNull\n  public String getUsername() {\n    return username;\n  }\n\n  public void setUsername(@NotNull String value) {\n    checkParameterIsNotNull(value, \"<set-?>\");\n\n    username = value;\n  }\n\n  public void setName(@NotNull String newName) {\n    checkParameterIsNotNull(value, \"newName\");\n\n    username = value;\n  }\n}\n```\n\nWe can see that we now have two additional methods (`getUsername` and `setUsername`) and the `username` field earned a `@NotNull` annotation. Weʼre witnesses to how Kotlin compiler manages properties in classes:\n\n1.  If it is `private` then a property is simply a field of the class with no special annotations – this is because this property is not visible anywhere outside the class and therefore Kotlin compiler can optimize access to it and it can be sure that the field will always be non-`null`.\n2.  If it is not `private` then a property is actually a field with a pair of setter and getter methods – this is because the property is visible to the outside world and Kotlin compiler must check upon every access that it is non-`null` and at the same time provide this information to this outside world.\n\nWe can also observe that to check whether a value of a parameter is not `null` the `checkParameterIsNotNull` method is used. Again weʼll investigate this method in part 2. For now it is enough to say that upon receiving a `null` value an `IllegalArgumentException` will be thrown.\n\n### Elvis operator\n\nWhen we have a `null` value there are situations when instead of throwing an exception weʼd rather do something else. We can compare this to a `default` block in Java `switch` statement. A simple `if` statement with an `else` should suffice here, but Kotlin has a special syntax for it – the famous [Elvis operator](https://en.wikipedia.org/wiki/Elvis_operator).\n\nLetʼs suppose that for a `null` value weʼd like to set `username` to `\"N/A\"`:\n\n```kotlin\nclass User {\n  private var username: String = \"\"\n\n  fun setName(newName: String?) {\n    username = newName ?: \"N/A\"\n  }\n}\n```\n\nThe equivalent Java code is:\n\n\n```java\nimport org.jetbrains.annotations.Nullable;\n\npublic class User {\n  private String username = \"\";\n\n  public void setName(@Nullable String newName) {\n    username = (newName != null) ? newName : \"N/A\";\n  }\n}\n```\n\n\nThe Kotlin syntax is more concise and itʼs also worth mentioning that the expression after the Elvis operator is lazily evaluated and it can also throw an exception. So itʼs completely legal to have this kind of code:\n\n```kotlin\nclass User {\n  private var username: String = \"\"\n\n  fun setName(newName: String?) {\n    username = newName ?: throw RuntimeException(\"Are you nuts?\")\n  }\n}\n```\n\nThe equivalent Java code is:\n\n\n```java\nimport org.jetbrains.annotations.Nullable;\n\npublic class User {\n  private String username = \"\";\n\n  public void setName(@Nullable String newName) {\n    if (newName != null)\n      username = newName;\n    else\n      throw new RuntimeException(\"Are you nuts?\");\n  }\n}\n```\n\n### Safe calls and let/run/apply functions\n\nThere are circumstances when we have a possibly `null` object and we want to invoke a method on it but only if it is actually non-`null` (because otherwise we would get `NullPointerException`). We can do it with simple `if`, but Kotlin provides a fancy `?.` operator to make the code more compact. So this code:\n\n```kotlin\ndata class SimpleUser(var name: String)\n\nobject Users {\n  private val userMap = mapOf(1 to SimpleUser(\"John\"))\n\n  @JvmStatic\n  fun getUser(userId: Int): SimpleUser? = userMap[userId]\n}\n\nfun getUserName(userId: Int): String? =\n        getUser (userId)?.name\n```\n\nhas the following equivalent Java code for `getUserName`:\n\n\n```java\n@Nullable\npublic String getUserName(int userId) {\n  SimpleUser simpleUser = getUser(userId);\n  return simpleUser != null ? simpleUser.getName() : null;\n}\n```\n\nKotlin code is indeed a lot shorter and more expressive. To further aid developers Kotlin provides three convenient [higher-order functions](https://kotlinlang.org/docs/reference/lambdas.html#higher-order-functions): `let`, `run` and `apply`. Although they are not directly related to `null`-safety issues we often use them with potentially `null` objects. Below you can find some code examples – they should give you an intuition about when and how to use them.\n\n#### let\n\nLetʼs look at the following code with [`let`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/let.html) (pardon the pun):\n\n```kotlin\nfun findUserNameWithLet(userId: Int): String? =\n    getUser (userId)?.let { it.name }\n```\n\n`let` is essentially an [extension function](https://kotlinlang.org/docs/reference/extensions.html#extension-functions) (i.e. a method of a class which you can define outside of the class definition) that can be invoked on any type. It takes a [lambda expression](https://kotlinlang.org/docs/reference/lambdas.html#lambda-expressions-and-anonymous-functions) as its parameter and calls the expression with `this` as an argument. If a _lambda expression_ has only one parameter then we may skip declaring it and simply access the parameter via the name... `it`. Therefore in the example above `this` inside the lambda (`this` is of type `SimpleUser` – the type returned by the `getUser` method) is accessible as `it`. The value of the _lambda expression_ is returned as the result of the `let` function.\n\nThe equivalent Java code for `findUserNameWithLet` is as follows:\n\n```java\n@Nullable\npublic String findUserNameWithLet(int userId) {\n  String result;\n\n  SimpleUser simpleUser = getUser(userId);\n  if (simpleUser != null) {\n    SimpleUser it = simpleUser;\n\n    result = it.getName(); // { it.name }\n  } else {\n    result = null;\n  }\n\n  return result;\n}\n```\n\n`let` is usually used if we want to perform some operations on a non-`null` object and return the result of these operations while simply returning `null` for `null` objects.\n\n#### run\n\nThe [`run`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/run.html) function is a slight variation of `let`. It takes a parameterless _lambda expression_ as its parameter and the object on which you invoke `run` can be accessed via `this` inside the _lambda expression_. Just like in `let` the result of the _lambda expression_ is returned as the result of the `run` function.\n\nLetʼs see an example:\n\n```kotlin\nfun findUserNameWithRun(userId: Int): String? =\n    getUser (userId)?.run { name }\n```\n\nand the equivalent Java code:\n\n```kotlin\n@Nullable\npublic String findUserNameWithRun(int userId) {\n  String result;\n\n  SimpleUser simpleUser = getUser(userId);\n  if (simpleUser != null) {\n    SimpleUser $receiver = simpleUser;\n\n    result = $receiver.getName(); // { name }\n  } else {\n    result = null;\n  }\n\n  return result;\n}\n```\n\nAs we can see there is little difference with `let` – Kotlin code is similar although with `run` it is even more concise.\n\n#### apply\n\nThe last of the three convenient functions weʼre going to talk about is [`apply`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/apply.html). The following code illustrates its usage:\n\n```kotlin\nfun findUserNameWithApply(userId: Int): SimpleUser? =\n      getUser (userId)?.apply { name = \"Jane\" }\n}\n```\n\n`apply` is similar to `run` – it is an _extension function_ which takes a parameterless _lambda expression_ as its parameter and the object on which you invoke `apply` can be accessed via `this` inside the _lambda expression_. However, the return value of `apply` is the object on which you invoke it (and not the _lambda expression_ result).\n\nThe equivalent Java code for `findUserNameWithApply` is as follows:\n\n```java\n@Nullable\npublic SimpleUser findUserNameWithApply(int userId) {\n  SimpleUser result;\n\n  SimpleUser simpleUser = getUser(userId);\n  if (simpleUser != null) {\n    SimpleUser $receiver = simpleUser;\n\n    $receiver.setName(\"Jane\"); // { name = \"Jane\" }\n\n    result = simpleUser;\n  } else {\n    result = null;\n  }\n\n  return result;\n}\n```\n\nThe most common reason to use `apply` is the initialisation of an object. If there is something we have to do before returning an object (and simply return `null` if it is `null`) then `apply` is the way to go.\n\n### Platform types\n\nSo far we have not talked about the interoperability with Java. While from Java code point of view with regard to `null`-safety nothing unusual happens if we call Kotlin code, there is a difference when we want to call Java code from Kotlin. This is especially important for the case of the result returned from Java method where Kotlin compiler has to take some precautions. After all it does not know if the value returned can be `null` or not.\n\nTo resolve this problem Kotlin introduces the concept of [platform types](https://kotlinlang.org/docs/reference/java-interop.html#null-safety-and-platform-types). In essence _platform type_ is used every time Kotlin compiler encounters an invocation of Java method which was not generated by Kotlin compiler. At the same time a developer cannot explicitly declare anything to be of _platform type_ – it exists solely when Kotlin compiler infers it from the code.\n\nLetʼs look at some code samples which present most of things you have to know about _platform types_:\n\n```kotlin\nfun writeOutNullable(s: String?) = println(s)\n\nfun nullableCase() {\n  val value = System.getProperty(\"key\") // value has a platform type String!\n  writeOutNullable(value)               // The ! after a type indicates it's a platform type\n}\n```\n\nThe equivalent Java code is:\n\n```java\npublic void nullableCase() {\n  String value = System.getProperty(\"key\");\n  writeOutNullable(value);\n}\n```\n\nWe can see nothing special here – the _platform type_ is taken as is when it is converted to a _nullable_ type.\n\nLetʼs see what happens when the target type is non-`null`:\n\n```kotlin\nfun writeOut(s: String) {\n  println(s)\n}\n\nfun nonNullCase() {\n  val value = System.getProperty(\"key\") // value has a platform type String!\n\n  writeOut(value)\n}\n```\n\nThe equivalent Java code is:\n\n```java\nimport static kotlin.jvm.internal.Intrinsics.checkExpressionValueIsNotNull;\n\npublic void nonNullCase() {\n  String value = System.getProperty(\"key\");\n\n  checkExpressionValueIsNotNull(value, \"value\");\n  writeOut(value);\n}\n```\n\nNow we have a validation in the generated code. `writeOut` expects a non-`null` type, but the `value` type is _platform type_ and in theory it could be `null`. Therefore the compiler produces a runtime check with the help of `checkExpressionValueIsNotNull` method which weʼll explore in part 2.\n\nNext example shows the code where only Java methods are used.\n\n```kotlin\nfun pureJavaCase() {\n  val value = System.getProperty(\"key\") // value has a platform type String!\n\n  System.setProperty(\"other_key\", value)\n}\n```\n\nThe equivalent Java code is:\n\n```java\npublic void pureJavaCase() {\n  String value = System.getProperty(\"key\");\n\n  System.setProperty(\"other_key\", value);\n}\n```\n\nJust like when we had the _nullable_ types no runtime check is generated. After all at no place in the code do we pass the value to the code which explicitly expects non-`null` values.\n\nOne might ask what happens after the value is checked not to be `null` – does the compiler treat it as a non-`null` value?\n\n```kotlin\nfun doubleCheckCase() {\n  val value = System.getProperty(\"key\") // value has a platform type String!\n\n  writeOut(value)\n  writeOut(value)\n}\n```\n\nThe equivalent Java code is:\n\n```java\npublic void doubleCheckCase() {\n  String value = System.getProperty(\"key\");\n\n  checkExpressionValueIsNotNull(value, \"value\");\n  writeOut(value);\n  checkExpressionValueIsNotNull(value, \"value\");\n  writeOut(value);\n}\n```\n\nIt appears it doesnʼt – the runtime checks are generated each time the conversion to non-`null` type takes place.\n\nThe following example shows assigning the value with _platform type_ to some variable without explicitly stating this variable type:\n\n```kotlin\nfun assignCase() {\n  val value = System.getProperty(\"key\") // value has a platform type String!\n  val newValue = value // newValue has a platform type String!\n\n  writeOut(newValue)\n}\n```\n\nThe equivalent Java code is:\n\n```java\npublic void assignCase() {\n  String value = System.getProperty(\"key\");\n  String newValue = value;\n\n  checkExpressionValueIsNotNull(newValue, \"newValue\");\n  writeOut(newValue);\n}\n```\n\nNo surprise here – the type of the variable `newValue` is also a _platform type_ and runtime checks are generated.\n\nWhat if we explicitly state the variableʼs type?\n\n```kotlin\nfun explicitCase() {\n  val value = System.getProperty(\"key\") // value has a platform type String!\n\n  val nullableValue: String? = value\n  writeOutNullable(nullableValue)\n\n  val nonNullValue: String = value\n  writeOut(nonNullValue)\n  writeOut(nonNullValue)\n}\n```\n\nThe equivalent Java code is:\n\n```java\npublic void explicitCase() {\n  String value = System.getProperty(\"key\");\n\n  String nullableValue = value;\n  writeOutNullable(nullableValue);\n\n  checkExpressionValueIsNotNull(value)\n  String nonNullValue = value;\n  writeOut(nonNullValue);\n  writeOut(nonNullValue);\n}\n```\n\nAs we can see the rule is simple – every time we go from the _plaform type_ to non-`null` type a runtime check is generated. Once weʼre in the `null`-safe world no additional validation is needed.\n\nIn the examples above weʼve seen that the `checkExpressionValueIsNotNull` method takes a variable name as the second parameter. This is done so that when a `null` value is passed youʼll see an error message with the name of the variable in it. But as the name of the method implies the second parameter does not have to be a variable name. In fact itʼs always an expression name, but in the cases presented above we had simple one-variable expressions. If we had a more complicated expression...:\n\n```kotlin\nfun funnyCase() {\n  writeOut(System.getProperty(\"key\"))\n}\n```\n\nThe equivalent Java code is:\n\n```java\npublic void funnyCase() {\n  String tmp = System.getProperty(\"key\");\n  checkExpressionValueIsNotNull(tmp, \"System.getProperty(\\\"key\\\")\");\n  writeOut(tmp);\n}\n```\n\nIf we now call `funnyCase` (and there is no `\"key\"` system property set) then weʼll see the following stack trace:\n\n```\nException in thread \"main\" java.lang.IllegalStateException: System.getProperty(\"key\") must not be null\n    at pl.kk.test.kotlin.PlatformTypesKt.funnyCase(PlatformTypes.kt:54)\n    at pl.kk.test.kotlin.FunnyCaseCall.main(PlatformTypes.kt:60)\n```\n\n### Summary\n\nWeʼve taken a tour of different Kotlin language constructs where you could observe the code generated by the compiler. During regular development you rarely have to think about how things work under the hood. Nonetheless it is useful to know a thing or two about it. And if youʼre interested in the performance issues surrounding some of those constructs check out the second part of this article which will be soon published.\n\n","author":"Konrad Kamiński","date":"2016-06-20","type":"article","categories":["Kotlin"],"features":["highlightjs"],"description":"","filename":"","lang":"EN","enclosure":null},{"title":"Developing Spring Boot applications with Kotlin.","url":"https://spring.io/blog/2016/02/15/developing-spring-boot-applications-with-kotlin","body":"\nJust in time for [Kotlin 1.0 release](http://blog.jetbrains.com/kotlin/2016/02/kotlin-1-0-released-pragmatic-language-for-jvm-and-android/), we are adding support for Kotlin language to [https://start.spring.io](https://start.spring.io/#!language=kotlin) in order to make it easier to start new Spring Boot projects with this language.\n\nThis blog post is also an opportunity for me to explain why I find this language interesting, to show you a sample project in detail and to give you some tips.\n\n## What is Kotlin?\n\n[Kotlin](https://kotlinlang.org/) is a language created by [JetBrains](https://www.jetbrains.com/). It runs on top of the JVM (but not only), it is an object oriented language that includes many ideas from functional programming. I won’t go too much in details about all Kotlin features ([PDF](https://kotlinlang.org/docs/kotlin-docs.pdf), [HTML](https://kotlinlang.org/docs/reference/)), but I would like to highlight the ones I find the most interesting:\n\n* Kotlin is a statically typed language, but thanks to its [clever type inference](https://kotlinlang.org/docs/reference/basic-types.html), it allows you to write code as short and expressive as dynamic language with performances close to pure Java projects\n* [Properties support](https://kotlinlang.org/docs/reference/properties.html#declaring-properties)\n* Relatively lightweight standard library compared to other languages\n* Easy to learn: a Java developer can quickly understand most of the language (this [quick comparison to Java](https://kotlinlang.org/docs/reference/comparison-to-java.html) is worth to read)\n* [Java interop](https://kotlinlang.org/docs/reference/java-interop.html) is a first class concern and great\n* Perfect for Android development\n* Built-in immutability and [null safety](https://kotlinlang.org/docs/reference/null-safety.html) support\n* Code is easy to read, efficient to write\n* Allows to [extend existing libraries](https://kotlinlang.org/docs/reference/extensions.html) without having to inherit from the class or use any type of design pattern such as Decorator\n* No semicolon required ;-)\n\nYou will find a lot of useful links to improve your Kotlin knowledge in this [Kotlin digest 2015](http://blog.jetbrains.com/kotlin/2016/01/kotlin-digest-2015/) blog post. Also have a look to these simple [Kotlin exercices](http://try.kotlinlang.org/koans) to have a quick overview of the language.\n\n## A sample Spring Boot + Kotlin project\n\nKotlin has been designed to play well with the Java ecosystem, and it seems to me that it shares the same pragmatic, innovative and opinionated mindset as Spring Boot, so they play well together. You can have a look at this simple [Spring Boot + Spring Data JPA Kotlin project](https://github.com/sdeleuze/spring-boot-kotlin-demo) to see more concretely what it looks like.\n\nKotlin allows to write (and read) your domain model easily thanks to [data classes](https://kotlinlang.org/docs/reference/data-classes.html). The compiler automatically derives the following members from all properties declared in the primary constructor:\n- `equals()` / `hashCode()` pair\n- `toString()` of the form “Customer(firstName=Foo, lastName=Bar, id=42)”\n- `componentN()` functions corresponding to the properties in their order or declaration\n- `copy()` function\n\nYou can see that Kotlin allows you to specify parameter default values, and types are declared after the name of the variable/parameter:\n\n```kotlin\n@Entity\ndata class Customer(\n\tvar firstName: String = \"\",\n\tvar lastName: String = \"\",\n\t@Id @GeneratedValue(strategy = GenerationType.AUTO)\n\tvar id: Long = 0\n)\n```\n\nThe Spring MVC REST controller you can see below is using constructor level injection, and default visibility in Kotlin is `public` so no need to specify it. When a function returns a single expression, the curly braces can be omitted and the body is specified after a `=` symbol. It is even better since the return type can be inferred by the compiler.\n\n```kotlin\n@RestController\nclass CustomerController @Autowired constructor(val repository:CustomerRepository) {\n\n\t@RequestMapping(\"/\")\n\tfun findAll() = repository.findAll()\n\n\n\t@RequestMapping(\"/{name}\")\n\tfun findByLastName(@PathVariable name:String)\n\t\t= repository.findByLastName(name)\n}\n```\n\nThe Spring Data repository is self explanatory:\n\n```kotlin\ninterface CustomerRepository : CrudRepository<Customer, Long> {\n\tfun findByLastName(name: String): List<Customer>\n}\n```\n\nSince Kotlin supports top-level functions, you can declare your application as simple as:\n\n```kotlin\n@SpringBootApplication\nopen class Application {\n\n\t@Bean\n\topen fun init(repository: CustomerRepository) = CommandLineRunner {\n\t\trepository.save(Customer(\"Jack\", \"Bauer\"))\n\t\trepository.save(Customer(\"Chloe\", \"O'Brian\"))\n\t\trepository.save(Customer(\"Kim\", \"Bauer\"))\n\t\trepository.save(Customer(\"David\", \"Palmer\"))\n\t\trepository.save(Customer(\"Michelle\", \"Dessler\"))\n\t}\n}\n\nfun main(args: Array<String>) {\n\tSpringApplication.run(Application::class.java, *args)\n}\n```\n\nYou need to mark `@Configuration` classes, some others like most `@Component` ones and `@Bean` methods as `open` because they cannot be `final` in Spring due to proxy usage (classes and methods in Kotlin are `final` by default without the `open` modifier).\n\n## Additional tips\n\nEven if Spring Boot and Kotlin work pretty well together, these additional tips are worth to know.\n\n\n### Property injection\n\nWe have seen previously how to do constructor injection, since that’s the [recommended approach](http://olivergierke.de/2013/11/why-field-injection-is-evil/) (especially with Kotlin). If you have to perform property injection, you will have to use [late-initialized properties](https://kotlinlang.org/docs/reference/properties.html#late-initialized-properties) because normally, raw properties declared as having a non-null type must be initialized in the constructor.\n\n```kotlin\n@RestController\nclass CustomerController {\n\n\t@Autowired\n\tlateinit var repository:CustomerRepository\n\n\t// ...\n}\n```\n\n### Property placeholders\n\n`$` is used for [String interpolation](https://kotlinlang.org/docs/reference/basic-types.html#string-templates) in Kotlin, so you should escape it when using property placeholders: `@Value(\"\\${some.property}\")`. As an alternative you can also use `@ConfigurationProperties` instead, see [this Stack Overflow](http://stackoverflow.com/a/33883230/1092077) answer for more details.\n\n### Array annotation attribute\n\nUnlike Java, Kotlin does not allow to specify array annotation attribute as a single value, so be aware that you will have to write `@RequestMapping(method = arrayOf(RequestMethod.GET))` or `@EnableAutoConfiguration(exclude = arrayOf(Foo::class))`.\n\nIt will be possible to use a shorter syntax with upcoming Spring Framework 4.3 composed annotations like `@GetMapping`, see [SPR-13992](https://jira.spring.io/browse/SPR-13992) for more details.\n\n### Jackson Kotlin Module\n\nIf you are using Jackson you are likely to want to add `com.fasterxml.jackson.module:jackson-module-kotlin` dependency in order to allow it to deal with data classes with no default constructor or with Kotlin collections.\n\nIn addition to the dependency, you need to register it in Jackson `ObjectMapper`:\n\n```kotlin\n@SpringBootApplication\nopen class Application {\n\n\t@Bean\n\topen fun objectMapperBuilder(): Jackson2ObjectMapperBuilder\n\t    = Jackson2ObjectMapperBuilder().modulesToInstall(KotlinModule())\n\n\t// ...\n}\n```\n\n### Experiment with the Java to Kotlin converter\n\nLast tip, the Java to Kotlin converter available in IntelliJ IDEA (Menu Code -> Convert Java file to Kotlin file) is quite useful when you can’t figure out how to write something in Kotlin. So do not hesitate to write something in Java and use it to find the Kotlin counterpart. This [comparison to Java documentation](https://kotlinlang.org/docs/reference/comparison-to-java.html) can also provide some help.\n\n## Feedbacks\n\nWe are interested by your feedbacks about developing Spring applications with Kotlin. This blog post is just an introduction, there is much more to say especially about using Spring Boot with more Kotlin idiomatic code like with [Exposed](https://github.com/JetBrains/Exposed) SQL library, so stay tuned ...\n\n","author":"Sébastien Deleuze","date":"2016-02-15","type":"article","categories":["Kotlin","Spring"],"features":["highlightjs"],"description":"","filename":"","lang":"EN","enclosure":null},{"title":"When Kotlin met Gradle","url":"https://jaxenter.com/when-kotlin-met-gradle-126726.html","body":"\n_Love story alert_\n\n![Kotlin](https://jaxenter.com/wp-content/uploads/2016/06/Screen-Shot-2016-06-06-at-2.56.13-PM.png)\n\nSource: [http://gradle.org/](http://gradle.org/)\n\nThe idea of having a Kotlin-based approach to writing Gradle build scripts and plugins was enticing enough to convince the JetBrains team and the Gradle team to concoct a way to get the best of both worlds. And this is how Gradle Script Kotlin was born.\n\nKotlin seems tireless these days! First, Gradle announced what they call _[Gradle Script Kotlin](http://gradle.org/blog/kotlin-meets-gradle/)_; then JetBrains announced [a new release of their plugin](https://blog.jetbrains.com/kotlin/2016/06/kotlin-eclipse-plugin-0-7-is-here/) for Eclipse IDE. But first things first!\n\n## Gradle + Kotlin = New project\n\nGradle’s Chris Beams [announced](http://gradle.org/blog/kotlin-meets-gradle/) in mid-May that after years of closely watching Kotlin, the team sat down with some people from the JetBrains team in late 2015 and tried to answer the following questions: what might it look like to have a Kotlin-based approach to writing Gradle build scripts and plugins? How might it help teams—especially big ones—work faster and write better structured, more maintainable builds?\n\nKotlin could give Gradle users proper IDE support from auto-completion to refactoring and everything in-between since this statically-typed language offers deep support in both IDEA and Eclipse. Plus, the fact that it is rich with features such as first-class functions and extension methods means that it could retain and improve on the best parts of writing Gradle build scripts. The result is called Gradle Script Kotlin, a Kotlin-based build language for Gradle.\n\n[The first milestone](https://github.com/gradle/gradle-script-kotlin/releases/tag/v1.0.0-M1) towards version 1.0 was launched less than a month ago and its repository was open-sourced at [https://github.com/gradle/gradle-script-kotlin](https://github.com/gradle/gradle-script-kotlin). Take a look at the outcome:\n\n[![Screen Shot 2016-06-06 at 3.28.27 PM](https://jaxenter.com/wp-content/uploads/2016/06/Screen-Shot-2016-06-06-at-3.28.27-PM.png)](http://gradle.org/blog/kotlin-meets-gradle/)\n\nSource: [http://gradle.org/blog/kotlin-meets-gradle/](http://gradle.org/blog/kotlin-meets-gradle/)\n\n\nAs you begin to explore what’s possible in the IDE, you will will be able to ‘play with’ things such as refactoring, quick documentation, auto-completion and content assist, navigation to source and more.\n\n## Kotlin Eclipse plugin 0.7\n\nRoughly two weeks after _Gradle Script Kotlin_ was announced, Kotlin returned to the spotlight thanks to a new release. In addition to the support for Kotlin 1.0.2 compiler, Eclipse plugin 0.7 brings highly important features and improvements such as a rebuilt code formatting feature and the _Organize Imports_ feature which cleans unused imports, adds missing imports for classes used in the file and resorts them.\n\nThe team also added some quick-fixes about missing or illegal modifiers. As a result, it is now possible to add an open modifier to a declaration which is overridden or subclassed and it is easy to deal with the “class must be declared abstract” compiler error. Plus, invalid modifier removing is now available for the quick-fix popup.\n\n","author":"Gabriela Motroc","date":"2016-06-06","type":"article","categories":["Kotlin","Gradle"],"features":["highlightjs"],"description":"","filename":"","lang":"EN","enclosure":null},{"title":"Kotlin EE: Boost your Productivity","url":"https://www.youtube.com/watch?v=fpjDY6XRBJM","body":"\n# v1\n\nKotlin is a language for the JVM, invented by JetBrains a few years ago. But what the hell is Kotlin EE? If you never heard of Kotlin EE, don’t panic, it does not exist. But you can use it right away and boost your productivity!\n\nI invented the term Kotlin EE as a synonym for using the Kotlin language together with the Java EE API to create services of any size (microservices, nanoservices etc.) with just a few lines of code and the ability to focus on the business logic.\n\nKotlin and Java EE are a perfect couple for writing micro- or nanoservices. Kotlin is a very pragmatic language, builds on many concepts and techniques from Java, designed for developer productivity. Kotlin works great with all existing Java libraries and frameworks and runs with the same level of performance as Java.\n\nThe Java EE API allows us to code against a proven and stable API. Provided libraries like JAX-RS for writing RESTful APIs and Jackson for JSON (de)serializing decrease the need for additional third-party libraries which results in a short build time and a small artifact size. Benefit from a very fast build and test feedback and stay focused on your code.\n\nIn this talk, I try to prove my statements from above. Live on stage I write a service in Kotlin with a RESTful JSON API with only a few lines of code and run the service using a local Docker cloud where you can see how these can be scaled up and down to manage fluctuating loads. Coding, building, testing, deploying, scaling: fast and efficient!\n\n<iframe width=\"960\" height=\"480\" src=\"https://www.youtube.com/watch?v=fpjDY6XRBJM\" frameborder=\"0\" allowfullscreen></iframe>\n\n","author":"Marcus Fihlon @ Voxxed Days Bucharest","date":"2018-03-23","type":"video","categories":["Cloud","Docker","Jakarta EE","Java EE","Kotlin"],"features":["highlightjs"],"description":"","filename":"","lang":"EN","enclosure":null},{"title":"The Journey of a Spring Boot application from Java 8 to Kotlin, part 2: Configuration Classes","url":"http://engineering.pivotal.io/post/spring-boot-configuration-in-kotlin/","body":"\nIn the [first post](/post/spring-boot-application-with-kotlin/) of this series, we looked at the conversion of a Spring Boot application class from Java 8 to Kotlin. The nice thing about these migrations is that they can be done incrementally since Kotlin plays very nicely with legacy Java. In fact, it was one of the design considerations for the language.\n\nIn this second post, we will look at the conversion of a configuration class into Kotlin.\n\nHere is an example of a Spring Boot configuration class as written in Java 8:\n\n```kotlin\npackage com.example.billing;\n\nimport com.example.billing.reocurringPayments.Service;\nimport com.example.payments.RecurlyGateway;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\n\n@Configuration\nclass Configuration {\n    @Bean\n    public com.example.payments.Gateway paymentGateway() {\n        return new RecurlyGateway();\n    }\n\n    @Bean\n    public Service serviceThatMayFail() {\n        return new Service();\n    }\n}\n```\n\nHere is that same configuration class written in Kotlin:\n\n```kotlin\npackage com.example.billing\n\nimport com.example.billing.reocurringPayments.Service\nimport com.example.payments.RecurlyGateway\nimport org.springframework.context.annotation.Bean\nimport org.springframework.context.annotation.Configuration\n\n@Configuration\nopen class Configuration {\n    @Bean\n    open fun paymentGateway() = RecurlyGateway()\n\n    @Bean\n    open fun serviceThatMayFail() = Service()\n}\n```\n\nThere aren't a bunch of huge differences but here are some of the smaller differences that stand out to me:\n\n* The Configuration class must be declared open. This is because Spring Boot subclasses your configuration class but Kotlin makes them final by default. See [here](https://kotlinlang.org/docs/reference/classes.html#inheritance) for details.\n* The @Bean functions must be declared open for the same reason as above.\n* There are no return types on the functions because Kotlin will infer the types. This type inference is one of\nmy favorite features of Kotlin.\n* Kotlin has implicit returns (and no braces) for [single-expression functions](https://kotlinlang.org/docs/reference/functions.html#single-expression-functions). When you only have one expression in a function body, Kotlin will automatically assume that you want to return that value so there is no need for an explicit `return` or braces. For bodies with multiple expressions, the `return` is still mandatory because the compiler may not be able to guess what the return type is for the function.\n* No `new` keyword when initializing an object. This coupled with the type inference, implicit returns and single statement/no braces makes for a nice compact configuration class.\n\nSpring configuration classes are a mixed bag for me in Kotlin. The actual code difference is only 4 lines of code (18 vs 14) but the visual noise is significantly reduced in Kotlin. Having to declare both the class and all of the methods as open seems a bit clunky for me but I'm willing to overlook it due to the type inference, lack of return for single expression functions and the other improvements that these classes gain from Kotlin.\n\nThanks for reading. In our next installment, we will take a look at Spring controllers in Kotlin.\n\n","author":"Mike Gehard","date":"2016-02-23","type":"article","categories":["Spring Boot","Kotlin"],"features":["highlightjs"],"description":"","filename":"","lang":"EN","enclosure":null},{"title":"The Kobalt diaries: Automatic Android SDK management","url":"http://beust.com/weblog/2016/04/09/the-kobalt-diaries-automatic-android-sdk-management/","body":"\n![](http://beust.com/pics/sdk-manager.png)\n**The dreaded SDK Manager**\n\nAndroid has always had a weird dependency mechanism. On the JVM (and therefore, Android), we have this great Maven repository system which is leveraged by several tools (Gradle and Kobalt on Android) and which allows us to add dependencies with simple additions to our build files. This is extremely powerful and it has undoubtedly been instrumental in increasing the JVM’s popularity. This system works for pretty much any type of applications and dependencies.\n\nExcept for Android libraries.\n\nThe Android support libraries (and I’m using “support” loosely here to include all such libraries and not just the one that Google calls “support”) are not available on any of the Maven repositories. They are not even available on Google’s own repository. Instead, you need to use a special tool to download them, and once you do that, they land on your local drive as a local Maven repository, which you then need to declare to Gradle so you can finally add the dependencies you need.\n\nI suspect the reason why these libraries are not available in a straight Maven repo is that you need to accept licenses before you can use them, but regardless, this separate download management makes building Android applications more painful, especially for build servers (Travis, Jenkins) which need to be configured specifically for these builds.\n\nThe graphical tool used to download this repository, called “SDK Manager”, is also a command tool called `\"android\"` that can be invoked without the GUI, and inspired by [Jake Wharton’s sdk-manager-plugin](https://github.com/JakeWharton/sdk-manager-plugin), I set out to implement automatic SDK management for [Kobalt](http://beust.com/kobalt).\n\nOnce I became more comfortable with the esoteric command line syntax used by the `\"android\"` tool, adding it to the Kobalt Android plug-in was trivial, and as a result, Kobalt is now able to completely install a full Android SDK from scratch.\n\nIn other words, all you need in your project is a simple Android configuration in your `Build.kt` file:\n\n```kotlin\nandroid {\n    compileSdkVersion = \"23\"\n    buildToolsVersion = \"23.0.1\"\n    // ...\n}\n\ndependencies {\n    compile(\"com.android.support:appcompat-v7:aar:23.0.1\")\n}\n```\n\nThe Kobalt Android plug-in will then automatically download everything you need to create an `apk` from this simple build file:\n\n* If `$ANDROID_HOME` is specified, use it and make sure a valid SDK is there. If that environment variable is not specified, install the SDK in a default location (`~/.android-sdk`).\n* If no Build Tools are installed, install them.\n* Then go through all the Google and Android dependencies for that project and install them as needed.\n* And a few other things...\n\nA typical run on a clean machine with nothing installed will look like this:\n\n```bash\n$ ./kobaltw assemble\n...\nAndroid SDK not found at /home/travis/.android/android-sdk-linux, downloading it\nCouldn't find /home/travis/.android/android-sdk-linux/build-tools/23.0.1, downloading it\nCouldn't find /home/travis/.android/android-sdk-linux/platform-tools, downloading it\nCouldn't find /home/travis/.android/android-sdk-linux/platforms/android-23, downloading it\nCouldn't find Maven repository for extra-android-m2repository, downloading it\nCouldn't find Maven repository for extra-google-m2repository, downloading it\n...\n          ===========================\n          | Building androidFlavors |\n          ===========================\n------ androidFlavors:clean\n------ androidFlavors:generateR\n------ androidFlavors:compile\n  Java compiling 4 files\n------ androidFlavors:proguard\n------ androidFlavors:generateDex\n------ androidFlavors:signApk\nCreated androidFlavors/kobaltBuild/outputs/apk/androidFlavors.apk\n```\n\nObviously, these downloads will not happen again unless you modify the dependencies in your build file.\n\nI’m hopeful that Google will eventually make these support libraries available on a real remote Maven repository so we don’t have to jump through these hoops any more, but until then, Kobalt has you covered.\n\nThis feature is available in the latest [`kobalt-android` plug-in](https://github.com/cbeust/kobalt-android) as follows:\n\n```kotlin\nval p = plugins(\"com.beust:kobalt-android:0.81\")\n```\n\n","author":"Cédric Beust","date":"2016-04-09","type":"article","categories":["Kotlin","Kobalt"],"features":["highlightjs"],"description":"","filename":"","lang":"EN","enclosure":null},{"title":"My Kotlin Adventure","url":"http://cirorizzo.net/2016/01/23/kotlin-at-glance/","body":"\n###### _Part 1_\n\nMy first thought when I heard about Kotlin for the first time was \"_Just another language to write the same thing using new keywords!_\"\n\nLuckily, I’m hugely curious and this thought wasn’t enough to stop me looking into it further. I started reading about it and the more I read, the more I became intrigued...\n\nNow let me say:\n\n> Kotlin is not just another language, it uses another **paradigm** to help developers to solve everyday challenges\n\n#### Android Developers\n\nI’ve been working with Android since 2010, initially just because I was curious to explore the potential of the promising platform from the big *G, but later for several commissioned projects. For each project, I used the standard language that was available: **Java** (just in some spare cases using C with NDK). From it’s release, the Android SDK promised to give a boost to Java using a custom library for Mobile developing and so far it’s been good.\n\nSince the beginning The Android SDK really has been oriented to solve the Mobile challenges (UI responsiveness, Network availability, Sensors API), release after release, improving every time. The first JVM Dalvik did a very good job and the ART even more...  \nBut I was still getting still stuck with Java (_enhanced 1.6_) and all its Ceremonies in the code.\n\n#### Android Studio\n\nMy first projects were on Eclipse IDE and to be honest I found it very useful and reliable with a plenty of documentation and a vivid community, but Google had other plans. They called it **Android Studio**.  \nThe first version of it was really unreliable, plenty of bugs and not easy to use, so I decided to wait a few versions before using it for my projects.  \nFortunately it didn't take so much time to release a very good, stable and absolutely reliable version of a proper **Android Studio** with all the quality of **JetBrains** products.  \nBut still Java was the language...\n\n#### New kids in town\n\nMeanwhile the Developer community starting to use new paradigms offered by different kinds of programming languages like the brand new _Swift2_ by **Apple** (and soon Open Source and available for **Linux** too), _Scala_, _Haskell/Miranda_, _F#_, etc. The functional programming paradigm rocked the Developers community like a tsunami, waking them up from the deep sleep of spending too many years working with imperative and procedural languages.\n\nBut the Android community still were stuck on Java, and even if the new Java 8 promised to refresh the language, the Android framework couldn't move on it due to the backward compatibility with the oldest version of libraries used by the framework.  \nIn the meantime **JetBrains** was working on it’s own language, **Kotlin**.\n\n![Kotlin Logo](http://cirorizzo.net/content/images/2016/02/xKotlin-logo.png.pagespeed.ic.3prhfChkMF.png)\n\n\n#### Kotlin\n\nSince from the early Beta versions, Kotlin has astonished the Android Community (and even more like Back End and Front End developers, etc). It is definitely a _Concise_, _Neat_ language with 100% Java interoperability, studied by people who deeply know the issues and routines of development issues and how to afford them as best as they can.  \nIn other words I started to experiment with it several months ago and have since decided to use it in my existing and further projects.\n\n#### Having a look to some code\n\nThis is just an example of how concise coding with Kotlin can be:\n\n```kotlin\nfun thisIsTheMethod(message: String) {\n    buttonMessage.setOnClickListener {\n        Toast.makeText(context, \"Here the message: $message\",\n                Toast.LENGTH_LONG).show()\n    }\n}\n```\n\n\nThe above method is a clear example of how easy it can be to simplify typical Android code using Java. It usually looks like:\n\n```java\npublic void thisIsTheMethod(final String message) {\n    buttonMessage.setOnClickListener(new OnClickListener() {\n        @Override\n        public void onClick(View v) {\n            Toast.makeText(getBaseContext(),\n                    String.format(\"Here the message: %s\", message),\n                    Toast.LENGTH_LONG).show();\n        }\n    });\n}\n```\n\n\nMost of the boilerplate code used to write in Android can be reduced with Kotlin, still having a clean and understandable code.\n\nAt a glance, the method or function _thisIsTheMethod_ in Kotlin is implicitly _public_ a if hasn't any return (_void_ in Java, in Kotlin will see next what is) doesn't need any further keywords\n\n```kotlin\nfun thisIsTheMethod(message: String) {...}\n```\n\nAlso the signature has param declaration quite different from Java. The type follow the param name but it hides something more: **Null Safety** type system.\n\nI like to report from the official documentation the following:\n\n> Kotlin’s type system is aimed to eliminate NullPointerException’s from our code\n\nJust this should be something Android developers will love.\n\nAnd last but not least the _setOnClickListener_ for the view (_buttonMessage_) that can be reduced in a SAM (Single Abstract Method) through the Lambda Expression. Yes, finally!\n\n```kotlin\nbuttonMessage.setOnClickListener() {...}\n```\n\nWell, that’s it for now. I'm gonna go further in future posts to share more about the language and the benefits Kotlin has brought to my Android coding\n\nIt really is easy to switch to Kotlin from Java. Maybe now is the time for you to give it a closer look?  \n[Jump to part two](http://www.cirorizzo.net/2016/02/03/kotlin-code/)\n\n","author":"Ciro Rizzo","date":"2016-01-23","type":"article","categories":["Android","Kotlin"],"features":["highlightjs"],"description":"","filename":"","lang":"EN","enclosure":null},{"title":"Kotlin + Android First Impressions","url":"https://www.javacodegeeks.com/2016/04/kotlin-android-first-impressions.html","body":"\nI am a huge Android fanboy, and have been one ever since the Nexus One came out. The Android OS has evolved so much and into so many variations. Almost a year ago, one of the Android developers I follow on Twitter was pushing for Kotlin to be the main language for Android. What was more interesting was it was retweeted by an Android Developer from Google. Fast forward to around this time, and the guys behinds IntelliJ announce 1.0 of Kotlin.\n\nI decided to see what the big hype was about on Kotlin. Consider this blog as a first impression rather than a review.\n\n## Going from Java to Kotlin\n\n[Kotlin](https://github.com/Kotlin) (for the most part) is similar to Groovy and Scala, as it runs on a JVM. It can also be compiled to JavaScript.\n\nI took the time to learn the syntax by first going to its official website. It’s advertised that Kotlin should be easy to pick up if you already code in Java, and it is interoperable with existing Java frameworks. I’ve been a Java developer most of my life, so I figured it wouldn’t be too hard to learn Kotlin.\n\nThe [official website](https://kotlinlang.org/) had a nice tutorial section for it. Here are a couple of cool things about the syntax I liked:\n\n*   Types are defined after the variable name.\n    In Java, you would declare variables with the type first then the variable name like `private int x;` while the Kotlin equivalent is `var x: Int`.\n    The type can also be inferred `var x = 1 //is Int initialized to 1`.\n*   Variables can be declared as nullable with `?`.\n    For example: `y?.length`. If y is null, then return null. Otherwise return `y.length`.\n*   Smart Casts! If a variable is of certain type, it is already cast to that type.\n    For example: `if (a is String) print(a.length)`\n\nThere are a lot more that I liked, but to keep this blog short, I suggest you check out [the official website](https://kotlinlang.org/).\n\n## Kotlin in Android Studio\n\nIt has been a while since I played around with the Android API. The last time I messed around with an Android app was around the time Android was known as “Jelly Bean.”\n\nSo, that said, I had to familiarize myself with the newer APIs such as [RecyclerView](http://developer.android.com/reference/android/support/v7/widget/RecyclerView.html) and new UI elements from the Design Support Library. Luckily, since Android Studio is from the same guys who did Kotlin, it was easy to integrate Kotlin into the SDK.\n\nFirst, I created a new project in Android Studio which created a default main activity. Then with the Android Studio Kotlin plugin, I am able to invoke an action to convert from Java to Kotlin. This will convert the Java code thats autogenerated in MainActivity.java to Kotlin in MainActivity.kt. It will also add the Kotlin dependency to your build.gradle.\n\n## Put away that Butterknife\n\nA nice Kotlin feature worth mentioning is that within an Activity or Fragment, you don’t have to call on findViewById to get a View widget. Simply refer to it by id.\n\nSo, instead of `TextView myTextView = (TextView) findViewById(R.id.myTextView)`, you can simply refer to the TextView widget by `myTextView`. Kotlin will get the reference to that view.\n\n## So, overall?\n\nRather than making, say, a Hello World app or an app with a generic List view, I decided to try out creating an app that plays sounds using MediaPlayer API to challenge myself.\n\n![Kotlin](https://www.javacodegeeks.com/wp-content/uploads/2016/04/Kotlin.png)\n\nDuring my experience with it as I coded the activities, inflating layouts, and RecyclerView adapters, I think I spent more time going back to the Android API documentation than I did with Kotlin. At first I had to refer back to the Kotlin docs to look up stuff until I got use to the syntax.\n\nWhat I liked most about Kotlin was there were less lines of code. When comparing things I would do in Java that would take a couple of lines, I could accomplish the same in Kotlin with just one line. Less lines of code is pleasant to my tiring eyes. Plus, less boilerplate which is helpful, especially in Android.\n\n## Anko\n\nYou could also use [Anko](https://github.com/Kotlin/anko) which is a UI library written in Kotlin. Instead of XML, Anko does the UI in DSL. I heard much praise for this tool. But as I started playing around with Kotlin, I wanted to be more familiar with Android’s default XML layout UI.\n\nMaybe one day I’ll write another blog on Anko or something :).\n\n## The future...\n\nSo what are the chances that Kotlin will indeed be the official, main go-to when coding in Android?\n\nThere have been rumors that Google is seeking to stray away from Java for Android development, there have been reports that [Google is looking into adopting Apple’s Swift language](http://thenextweb.com/dd/2016/04/07/google-facebook-uber-swift/). However, that same report also stated that Google isn’t considering Kotlin because of its long build times.\n\nWith all that said, if you’re an existing Java developer looking into something new or looking into developing Android apps, I would suggest to look into Kotlin and give it a try.\n\n","author":"Keyhole Software","date":"2016-04-20","type":"article","categories":["Kotlin","Android"],"features":["highlightjs"],"description":"","filename":"","lang":"EN","enclosure":null},{"title":"Kotlin без магии","url":"http://javanese.online/%D1%81%D1%82%D0%B0%D1%82%D1%8C%D0%B8/Kotlin_%D0%B1%D0%B5%D0%B7_%D0%BC%D0%B0%D0%B3%D0%B8%D0%B8/","body":"\nОбычно, когда открываешь для себя новый язык программирования, некоторые его конструкции выглядят, как магия. Например, for-each loop в Java:\n\n```kotlin\nfor (String s : strings) {\n    /* ... */\n}\n```\n\nКакого типа должна быть ```strings```? Во что разворачивается эта конструкция?\n\n(для массива (допустим, ```T[]```) получается подобие ```for (int i = 0; i < array.length; i++) { T t = array[i]; /* ... */ }```, а для ```Iterable<T>``` — нечто вроде ```for (Iterator<T> itr = iterable.iterator; itr.hasNext(); ) { T t = itr.next(); /* ... */ }```)\n\nИли, скажем, как работает try-with-resources ( ```try (InputStream is = new FileInputStream(file)) { /* ... */ }```)? Какой ```finally``` вызовется раньше — сгенерированный компилятором и закрывающий ресурсы или наш собственный? Что нужно сделать чтобы собственный класс работал с try-with-resources? <small>(ну да, реализовать ```AutoCloseable```)</small>\n\nПример ещё проще и повседневнее.\n\n```java\nString first = getStringSomewhere();\nString second = \"first: \" + first;\nString third = \"first: \" + first + \"; hashCode: \" + first.hashCode();\n```\n\nКак переопределён оператор сложения? Где будет создаваться ```StringBuilder```, а где — нет?\n\nЕщё пример. Код на Groovy.\n\n```groovy\ndef personDetails = [firstName:'John', lastName:'Doe', age:25]\n```\n\nКакой класс у personDetails? ```HashMap```, ```TreeMap```, ```LinkedHashMap```, ```Collections$UnmodifiableMap```?\n\n## Что там про Kotlin?\n\nВ Kotlin нет магических и тайных языковых конструкций.\n\n```Array<T>.forEach и Collection<T>.forEach``` — это extension functions, которые определены как ```for (element in this) action(element)```. При Ctrl-клике (Cmd-клике) на ```in``` можно увидеть, что этот оператор работает с функциями ```iterator```, ```next``` и ```hasNext```. Последние, в свою очередь, определены как ```operator fun```, что и позволяет использовать их с языковыми конструкциями. То есть автор класса, написав ```operator fun```, явно разрешает использовать эту функцию как конструкцию языка.\n\nВ выражении ```someFile.bufferedReader.use { /* тот же try-with-resources */ }```, например, ```use``` — инлайновая (встраиваемая) extension-функция для ```Closeable```. Можно посмотреть в её код и понять, когда там вызывается ```finally```.\n\nВ коде ```val s = \"a\" + \"b\"``` можно Ctrl-кликнуть плюс и увидеть ```operator fun plus``` в классе ```kotlin.String```.\n\nВ конструкции ```val personDetails = mapOf(\"firstName\" to \"John\", \"lastName\" to \"Doe\", \"age\" to 25)``` можно заглянуть в реализацию ```mapOf``` (также есть ```mutableMapOf```, ```hashMapOf```, ```linkedMapOf```) и в реализацию ```to``` (```infix fun <a, b=\"\">A.to(that: B): Pair <a, b=\"\">= Pair(this, that)</a,></a,>```).\n\nЛично для меня при всём синтаксическом разнообразии и гибкости Kotlin код на нём остаётся очень понятным. Можно создавать свои функции, которые благодаря модификаторам ```operator```, ```inline``` и ```infix``` выглядят как языковые конструкции, но всегда можно посмотреть в их реализацию, и нигде не будет чего-то вроде ```*тут магия компилятора*```.\n\n","author":"Mike Gorunov","date":"2016-12-28","type":"article","categories":["Kotlin"],"features":["highlightjs"],"description":"","filename":"","lang":"RU","enclosure":null},{"title":"Exercises in Kotlin: Part 3 - Functions","url":"http://blog.dhananjaynene.com/2016/04/exercises-in-kotlin-part-3-functions/","body":"\nWe looked at a bit of syntax and variable declarations in the last post [Exercises in Kotlin: Part 2 - High level syntax and Variables](http://blog.dhananjaynene.com/2016/04/exercises-in-kotlin-part-2-high-level-syntax-and-variables/). We explore functions in this post. Here's how a typical function in Kotlin would look like.\n\n```kotlin\nfun add(first: Int, second: Int): Int {\n    // will not compile\n    // first = first + 2. Because first is a val and cannot be reassigned\n    return first + second\n}\n```\n\nAs noted earlier, the arguments are declared with the names followed by the types. Also even though `val` is not specified, each argument is automatically a `val` and can not be reassigned within the function. Also the return type is specified after the argument list followed by a colon.\n\nIn this case, since the body of the function is an expression it can also alternatively be specified as\n\n```kotlin\nfun addExpr(first: Int, second: Int) = first + second\n```\n\nNote in particular that the curly brackets are replaced by `=`. And because the compiler can infer the return type, it is no longer required to provide it (though it would work just as well if you did provide one)\n\n### Functions can have default arguments\n\n```kotlin\nfun powerOf(value: Double, power: Double = 2.0) = Math.pow(value, power)\n```\n\nThe second argument `power` is no longer required to be specified, (when not specified its value will default to 2.0. Thus allowing both the following statements\n\n```kotlin\npowerOf(3.0)         // This will return 9.0\npowerOf(3.0, 4.0)    // This will return 81.0\n```\n\nThis makes it convenient to require fewer overloaded functions. The order of the arguments needs to be retained, and all the arguments after the ones specified will need to have default values. While this makes a lot of defaulting easy, it still is a little problematic for selectively overriding defaults for only few of the arguments. This is helped by the next feature.\n\n### Arguments can also be named\n\n```kotlin\nfun contrived(first: String = \"First\",\n              second: String = \"Second\",\n              third: String = \"Third\",\n              fourth: String = \"Fourth\",\n              fifth: String = \"Fifth\") =\n        first + \" \" + second + \" \" + third + \" \" + fourth + \" \" + fifth\n\n// ....\n\nfun someOtherFunction() {\n    contrived(second=\"2nd\", fourth=\"4th\")\n    // the above returns \"First 2nd Third 4th Fifth\"\n}\n```\n\nAs shown in the example above using a combination of default and named arguments we can choose to have smaller function invocations by specifying only the non defaults. Thus only the arguments whose default values need to be overridden, making the code both terse and more readable\n\n### Functions can have variable arguments\n\n```kotlin\nfun showStrings(suffix: String, vararg items: String) {\n    for(item in items) {\n        print(item + \" \")\n    }\n    print(suffix)\n    println()\n}\n\nfun somewhereElse() {\n    showStrings(\"!\", \"Hello\", \"World\") // prints \"Hello World !\"\n}\n```\n\nFunction can have variable number of arguments so long as all of them are of the same type. The type of the declared argument then becomes an array of that type. Thus in the above example, `items` is an array of String or `Array<String>`.\n\nThe above function also introduces you to a for statement when used with an array. The syntax is very simple and natural, `for itemVar in arrayVar { ... }`\n\n(_I imagine there can be only one `vararg` type argument and that has to be declared at the end but never attempted to do anything differently_)\n\n### Functions can have nested functions\n\n```kotlin\nfun showStrings2(suffix: String, vararg items: String): String {\n    val sb = StringBuffer()\n    fun appendToBuffer(item: String) {\n        sb.append(item)\n        sb.append(\" \")\n    }\n    for(item in items) { appendToBuffer(item) }\n    appendToBuffer(suffix)\n    return sb.toString()\n}\n\n....\n\nfun somewhereElse() {\n    showStrings2(\"!\", \"Hello\", \"World\") // returns \"Hello World !\"\n}\n```\n\nAs shown above, `appendToBuffer` is a nested function (called local function) It can access variables in the parent functions namespace (in the above situation - `sb`.).\n\n### Aside: if - else can also be an expression\n\nIn java, `if`-`else` is a statement. And has a complementary ternary operator `? :` which is an expression. Kotlin merges both by allowing use of `if` - `else` as an expression, and such if/else expressions can be used as a part of the function expression body (or a part of regular block bodies as well). eg.\n\n```kotlin\nfun isBlankString(arg: String) = if (arg.trim() == \"\") true else false\n```\n\nFor an if/else to be an expression, both if and else branches have to be specified and followed by an expression each\n\n### Functions can be tail recursive.\n\nYes! They can be.\n\n```kotlin\nfun factorial(n: Int): Int {\n    tailrec fun factorial(accumulator: Int, n: Int): Int = if (n == 1) accumulator else factorial(accumulator * n, n - 1)\n    return factorial(1, n)\n}\n```\n\nIf a function is written in a form that lends itself to [tail recursion](https://en.wikipedia.org/wiki/Tail_call) the compiler generates optimised code that uses a loop based version which no longer risks a stack overflow.\n\n### Extension functions.\n\nThis is a very interesting and very useful feature to Kotlin. It is the ability to seemingly externally add a method to a class. Thus the function `isBlankString` introduced above could be rewritten as\n\n```kotlin\nfun String.isBlankString() = this.trim() == \"\"\n\nfun somewhereElse() {\n    \" \".isBlankString() // returns true\n}\n```\n\nNote that in an extension function, you can use `this` to refer to the receiver of the function (in this case the String object on whom the `isBlankString` function is called). Also that the receiver class is resolved statically and not dynamically. So if you had an extension function defined for a `Base` class and a `Derived` class that inherits from `Base`, and called it on a variable declared of type `Base` but actually referencing an instance of type `Derived` the `Base` version of the extension function will be called.\n\n### Infix functions\n\nClass member functions or extension functions with a single argument, can in turn be declared as infix which allows from syntactic sugar in terms of how that function is invoked. Thus the function\n\n```kotlin\ninfix fun Int.toThePowerOf(n: Int) = Math.pow(this.toDouble(), n.toDouble()).toInt()\n```\n\ncould be invoked using either of the two ways, the latter becoming feasible only because of the keyword `infix` being used in the function declaration above.\n\n```kotlin\n5.toThePowerOf(3)\n5 toThePowerOf 3\n```\n\n### Higher order functions\n\nHigher order functions are functions which take functions as parameters or as a return type. For that let us first understand how a function can be alternatively represented as a variable using a function type.\n\n```kotlin\nfun double(n: Int) = n * 2\n```\n\nWhat if we wish to represent the function above as a variable. We need to understand the type of the function. In this case it happens to be of the type which takes a single `Int` and returns an `Int`. Knowing that we can now declare it as a variable\n\n```kotlin\nval doubleAsArg = { n : Int -> n * 2}\n```\n\nThe way to invoke the function above would be similar to the way double is invoked\n\n```kotlin\ndoubleAsArg(5) // would return 10\n```\n\nBut the more interesting capability that is now possible is that you can write a function which takes another function as an argument, and in turn pass doubleAsArg as an argument to the newly written function. eg.\n\n```kotlin\nfun twice(function: (Int) -> Int, arg: Int) = function(function(arg))\n\nfun somewhereElse() {\n    twice(doubleAsArg,5) // will return 20\n}\n```\n\n`doubleAsArg` could have been also declared using an alternative syntax as follows. For all practical purposes they are identical. However the declaration below makes the function type very explicit (it was inferred in the declaration above)\n\n```kotlin\nval doubleAsArgRedux: (Int) -> Int = { n -> n * 2}\n```\n\n#### Aside: Function Types\n\nJust like `String`, `Int` etc, since functions are also things that can be passed around, they also have types. As is shown above, doubleAsArg above has the type `(Int) -> Int`. In general a function taking n arguments each of type Type1..TypeN, and returning a type TypeReturn will have the type `(Type1, Type2,..TypeN) -> TypeReturn`\n\n### Lambdas\n\nA lambda function is a function that is not declared upfront but is passed in immediately to another function. In the situation below the function that is passed as the first argument to the function twice is a lambda. A lambda expression is always surrounded by curly braces, its parameters (if any) are declared before -> while the body goes after -> (if required).\n\n```kotlin\nfun somewhereElse() {\n    twice({n: Int -> n * 10}, 5) // returns 500\n}\n```\n\nNote that for a lambda function the declaration of the parameter types is optional, and there is no way to declare the return type of the function (it has to be inferred). And it is always wrapped with curly braces. Thus the general syntax for a lambda function with n arguments is\n\n```kotlin\n{ p1: Type1, p2: Type2 .. pn: TypeN -> /* do something */ }\n```\n\nNote that the lambda function body is an expression and does not allow a return statement. It could consist of multiple statements and/or branches so long as they end with an expression. So the following is a valid lambda.\n\n```kotlin\n{ n: Int -> val twoN = 2 * n; if (twoN < 100) twoN * 2 else twoN * 3}\n```\n\n### Single parameter lambdas\n\nIf a lambda has a single argument and its type can be inferred, then the argument declaration along with its type and the subsequent `->` can be omitted. In such a case that parameter will have the default name `it`.\n\n```kotlin\nval quadruple: (Int) -> Int = { it * 4}\n```\n\n### Anonymous functions\n\nAn anonymous function is a function with no name. For obvious reasons you cannot declare it by itself. But you could say use it as the right hand side of an assignment to a variable or pass it as an argument to another function eg.\n\n```kotlin\nval triple = fun(n: Int): Int = n * 3\n\nfun somewhereElse() {\n    twice(triple, 5)\n    twice(fun(n: Int): Int { return n * 3}, 5)\n}\n```\n\nThis is particularly useful when the return type cannot be contextually inferred\n\n### Closures\n\nNote that local functions, lambda functions and anonymous functions can access variables declared in their outer scope, ie. their closure. They can also modify such variables (assuming they are vars).\n\n### Receivers\n\nLambdas and anonymous functions can be used as extension functions as well. Their function type then is `ReceiverType.(p1: Type1 .. pn: TypeN) -> ReturnType`\n\n### Alternative invocation syntax\n\nIf a function has one or more arguments, but exactly one argument which is of a function type, then it can be invoked with an alternative syntax where the function is not specified within the parenthesis, but is instead specified after them wrapped in curly braces.\n\n```kotlin\nfun doubleAndThen(n: Int, then: (Int) -> Int): Int = then(n * 2)\n\nfun somewhereElse() {\n    doubleAndThen(5) { it * 5 } // returns 50\n}\n```\n\n### Inline functions\n\nYou can specifically request that a function be inlined using the `inline` keyword. eg. you could've alternatively declared the `doubleAndThen` function above as\n\n```kotlin\ninline fun doubleAndThen(n: Int, then: (Int) -> Int): Int = then(n * 2)\n```\n\nIn this case the compiler will emit the function (and the lambda passed to it) inlined at the call site where doubleAndThen is called. This causes your compiled code to grow in size but could pay off in performance.\n\nIf you do not want a particular lambda passed to the function as inlined, then you could mark it as noinline. eg.\n\n```kotlin\ninline fun doubleAndThen(n: Int, noinline then: (Int) -> Int): Int = then(n * 2)\n```\n\nIf a function is inlined, then the lambdas passed to it are allowed to have a `return`\n\nThe next post in the series is [Exercises in Kotlin: Part 4 - Control flows and return](http://blog.dhananjaynene.com/2016/04/exercises-in-kotlin-part-4-control-flows-and-return/)\n\n","author":"Dhananjay Nene","date":"2016-04-20","type":"article","categories":["Kotlin"],"features":["highlightjs"],"description":"","filename":"","lang":"EN","enclosure":null},{"title":"Writing Kotlin Idiomatic Code","url":"http://code.hootsuite.com/writing-kotlin-idiomatic-code/","body":"\n# Writing Kotlin Idiomatic Code\n\n[Kotlin](http://kotlinlang.org/), a new JVM language created by Jetbrains, is quickly becoming the go-to programming  language used for Android development at Hootsuite. Its many features and Java interoperability make writing code much faster, cleaner, and less verbose. However, without being aware of language idioms it can be easy to fall back to old Java patterns. In order to maximize the utility of this new language, it is important to familiarize yourself with writing idiomatic Kotlin code. Kotlin’s features, such as the nullable types, lambdas, and delegates, differentiate the language from Java and are useful for writing effective code.\n\n[![Kotlin](http://code.hootsuite.com/wp-content/uploads/2016/08/Kotlin-500x111.png)](https://kotlinlang.org/)\n\n**Null Checks and Safe Casts**\n\nNull references, called a [“billion-dollar mistake”](https://www.infoq.com/presentations/Null-References-The-Billion-Dollar-Mistake-Tony-Hoare) by their creator, are a major problem in Java. Null checks are possible in Java, but they are cumbersome, verbose, and easy to miss. In Kotlin, nullability is part of the type system and the language forces null checks for nullable types. The Java way of performing a null check in Kotlin would look like this:\n\n```kotlin\nval school : School = null\n\nif (school != null && school.students != null){\n\tdoSomething(school.students.get(“billy”))\t\n}\n```\n\nFortunately, Kotlin provides a number of easy ways of dealing with this cleanly. The safe call operator “?” provides a simple way of dealing with nullability. When combined with the let{} method, it allows for chained operations like this:\n\n```kotlin\nschool?.students?.let { doSomething(it.get(“billy”)) }\n```\n\nIn the above line of code, the null safety operator used on x and y prevents the code in the let block from being executed if either value is null. When the code in the let block runs it represents the non-null value of y. let blocks can also be useful when needing to access a nullable mutable variable several times since it makes a copy of the variable when it is executed. let blocks can also be used with the safe cast operator in order to replace type checks in if blocks like this:\n\n```kotlin\nif (x is String){\n   println(x)\n}\n// can be replaced with\n(x as? String)?.let { println(x) }\n```\n\nFinally, the safe elvis operator that allows you to return an alternative value or throw an error in the case of null:\n\n```kotlin\nval parent = node.getParent() ?: return null\nval name = node.getName() ?: throw IllegalArgumentException(\"...\")\n```\n\n**Lambdas, Closures, and Higher Order Operators**\n\nSome other key features that Kotlin has over Java 7 are lambdas and closures, which allow your code to be more concise and functional. In Kotlin, functions are treated as first class citizens, which means means you can easily pass function parameters without needing to create an interface. For example, the Java way of setting an OnClickListener would look like this:\n\n```kotlin\nsome_view.setOnClickListener(object : View.OnClickListener {\n   override fun onClick(view: View) {\n       println(\"clicked!\")\n   }\n})\n```\n\nUsing lambdas, this can be shorted like this:\n\n```kotlin\nval listener: (View) -> Unit = { println(“clicked!”) }\nsome_view.setOnClickListener (listener)\n\n// Or you can use closures \n\nsome_view.setOnClickListener {doSomething()}\n```\n\nUsing higher order operators and closures, you can remove many loops that you would otherwise need in Java. For example, if one wished to sentence from a list of words with spaces in between one could do the following:\n\n```kotlin\nlistOf(\"This\", \"is\",\"a\", \"sentence\").reduce { accumulator, s -> accumulator +\" \" + s }\n```\n\nIn the above example listOf is used to create an immutable list of words. Then, the reduce operator is used to concat all of the words by accumulating them and appending a space to the end of each word to produce the string “This is a sentence”.\n\nKotlin also allows for higher order operators to be chained. In this more advanced example, this code finds the first perfect square that contains the numbers 123:\n\n```kotlin\n(1..100000).map { it * it }.find { it.toString().contains(Regex(\".*123.*\")) }\n```\n\nIn this example we use the range operator to get a list of numbers, then we map that list to their squares. Afterwards, we use the find operator to find the first number that matches the regular expression. There many more higher order operators that you can read about [here](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/index.html#functions).\n\n**Delegates**\n\nIn Java, if you wish to expose an encapsulated property for a class, you need to write a getter and setter. For example, if you are in a custom view and wish to expose the value of a checkbox, you would need to expose property through a getter and setter. In Kotlin, properties automatically generate getters and setters, so this step is unnecessary. You can delegate out the property of the enclosed checkbox object like this:\n\n```kotlin\nvar isChecked: Boolean by object {\n   operator fun getValue(thisRef: Any?, property: KProperty<*>): Boolean {\n       return checkbox.checked\n   }\n\n   operator fun setValue(thisRef: Any?, property: KProperty<*>, value: Boolean) {\n       checkbox.checked = value\n   }\n}\n```\n\nThis uses two interesting features of Kotlin: object expressions and property delegates. An anonymous object is created which this property is delegated out to, meaning you can still access it using property access syntax and getters and setters are generated.\n\nAnother problem that delegates can solve is composition. It is often convenient when building a model that depends on views to allow each view to build it’s own component. If you wish to abstract away direct access to the views in this situation, property delegates provide a clean solution. Here’s an example of a class with an EditText view inside it:\n\n```kotlin\nclass EditTextDelegate {\n   // represents some editable text view\n   var editText: EditText = EditText();\n\n operator  fun getValue(thisRef: Any?, property: KProperty<*>): String? {\n       return editText.text\n   }\n\n operator  fun setValue(thisRef: Any?, property: KProperty<*>, value: String?) {\n       editText.text = value\n   }\n}\n```\n\nYou can then use your view class as a delegate like this:\n\n```kotlin\nclass ComposedObject(textDelegate: EditTextDelegate){\n  var text: String? by textDelegate\n}\n```\n\nThis allows you to ask each of the views that compose this model for their properties without needing to deal with getters and setters. Additionally, you can now access all of these abstracted view properties as if they are normal properties.\n\n**Functions and Functional Programming**\n\nMany of these new Kotlin features mean that functional programming is now an option when solving problems. One of the most important features that Kotlin provides for functional programming is immutability in both default lists and and objects, with it’s val type. In Effective Java Second Edition Joshua Bloch states “Classes should be immutable unless there’s a very good reason to make them mutable.” Many of these same arguments for immutability apply to Kotlin including thread safety, easy shareability, and simplicity. In Kotlin one can define an immutable class like this:\n\n```kotlin\nclass Person(val name: String, val city: String)\n```\n\nWhen functional programming, recursion is key to solving problems without changing state. Recursive functions, however, can be expensive if they aren’t tail recursive because of the stack space required. Kotlin solves this problems with the tailrec operator which optimizes a tail recursive function (a function where the the the last call is recursive) to reuse the stack. For example:\n\n```kotlin\ntailrec fun fib(count: Long, seq: List<Int> = listOf(1,1)): List<Int> =\nif (seq.size >= count) seq else fib(count, seq + (seq.last() + seq[seq.lastIndex - 1]))\n```\n\nHere we see that the last call in this function is a recursive call, which means that it is able to be optimized. Additionally, in the above function we can see that using operator overloading we are able to use the + operator on the list. This allows for more terse syntax because it returns a new list, not a boolean like List.add() and allows for immutable lists to be used.\n\nMany of the the other parts of the this post such as lambdas and nullable types can be used to enhance functional programming. For more information on functional programming in Kotlin read Mike Hearn’s excellent [blog post](https://medium.com/@octskyward/kotlin-fp-3bf63a17d64a#.geo4mq2nx) goes into more detail.\n\n**Conclusion**\n\nKotlin is language fast growing language, and there are still new practices being developed. Hopefully this blog post provides a clear set of examples of using Kotlin’s feature set more effectively.\n\nThank you to the Android team and Kimli for helping me write and edit this blog post.\n\n","author":"Denis Trailin","date":"2016-08-31","type":"article","categories":["Kotlin"],"features":["highlightjs"],"description":"","filename":"","lang":"EN","enclosure":null},{"title":"Introducing Kotlin support in Spring Framework 5.0","url":"https://spring.io/blog/2017/01/04/introducing-kotlin-support-in-spring-framework-5-0","body":"\nFollowing the [Kotlin support on start.spring.io](https://spring.io/blog/2016/02/15/developing-spring-boot-applications-with-kotlin) we introduced a few months ago, we have continued to work to ensure that Spring and [Kotlin](https://kotlin.link/) play well together. One of the key strengths of Kotlin is that it provides a very good [interoperability](https://kotlinlang.org/docs/reference/java-interop.html) with libraries written in Java. But there are ways to go even further and allow writing fully idiomatic Kotlin code when developing your next Spring application. In addition to Spring Framework support for Java 8 that Kotlin applications can leverage like functional web or bean registration APIs, there are additional Kotlin dedicated features that should allow you to reach a new level of productivity.\n\nThat’s why we are introducing a dedicated Kotlin support in [Spring Framework 5.0 M4](https://spring.io/blog/2016/12/30/spring-framework-5-0-m4-released), and I would like to summarize in this blog post the features that are designed to make your developer experience seamless when using these technologies together. You can use [this link](https://jira.spring.io/issues/?filter=15463) to find Kotlin related issues in Spring Framework bug tracker.\n\nA key building block of our Kotlin support is [Kotlin extensions](https://kotlinlang.org/docs/reference/extensions.html). They allow to extend existing APIs in a non-intrusive way, providing a better alternative to utility classes or Kotlin specific class hierarchies to add Kotlin dedicated features to Spring. Some libraries like [KotlinPrimavera](https://github.com/MarioAriasC/KotlinPrimavera/wiki) from [Mario Arias](https://github.com/MarioAriasC) have already showed various kind of Kotlin helpers we can bring to Spring API in order to allow writing more idiomatic code. With Spring Framework 5, we integrate the most useful and popular extensions in Spring Framework dependencies, and we are adding new ones! Be aware that Kotlin extensions are statically resolved, you have to import them (like static imports in Java).\n\n## Functional bean registration with Kotlin\n\nSpring Framework 5.0 introduces a new way to register beans using lambda as an alternative to XML or JavaConfig with `@Configuration` and `@Bean`. In a nutshell, it makes it possible to register beans with a `Supplier` lambda that acts as a `FactoryBean`.\n\nIn Java you will for example write:\n\n```kotlin\nGenericApplicationContext context = new GenericApplicationContext();\ncontext.registerBean(Foo.class);\ncontext.registerBean(Bar.class, () -> new \n    Bar(context.getBean(Foo.class))\n);\n```\n\nWhile in Kotlin, reified type parameters allow us to simply write:\n\n```kotlin\nval context = GenericApplicationContext {\n    registerBean<Foo>()\n    registerBean { Bar(it.getBean<Foo>()) }\n}\n```\n\nYou can see a concrete example of Spring application using both functional [web](https://github.com/mix-it/mixit/blob/master/src/main/kotlin/mixit/controller/UserController.kt) and [bean registration](https://github.com/mix-it/mixit/blob/master/src/main/kotlin/mixit/Context.kt) API at [https://github.com/mix-it/mixit/](https://github.com/mix-it/mixit/).\n\n`ApplicationContext` related Kotlin extensions available are [BeanFactoryExtensions](https://github.com/spring-projects/spring-framework/blob/master/spring-beans/src/main/kotlin/org/springframework/beans/factory/BeanFactoryExtensions.kt), [ListableBeanFactoryExtensions](https://github.com/spring-projects/spring-framework/blob/master/spring-beans/src/main/kotlin/org/springframework/beans/factory/ListableBeanFactoryExtensions.kt), [GenericApplicationContextExtensions](https://github.com/spring-projects/spring-framework/blob/master/spring-context/src/main/kotlin/org/springframework/context/support/GenericApplicationContextExtensions.kt) and [AnnotationConfigApplicationContextExtensions](https://github.com/spring-projects/spring-framework/blob/master/spring-context/src/main/kotlin/org/springframework/context/annotation/AnnotationConfigApplicationContextExtensions.kt).\n\n## Spring Web functional API, the Kotlin way\n\nSpring Framework 5.0 comes with a `RouterFunctionDsl` that allows you to leverage the [Spring Functional Web API](https://spring.io/blog/2016/09/22/new-in-spring-5-functional-web-framework) recently announced with clean and idiomatic Kotin code:\n\n```kotlin\nfun route(request: ServerRequest) = route(request) {\n    accept(TEXT_HTML).apply {\n            (GET(\"/user/\") or GET(\"/users/\")) { findAllView() }\n            GET(\"/user/{login}\") { findViewById() }\n    }\n    accept(APPLICATION_JSON).apply {\n            (GET(\"/api/user/\") or GET(\"/api/users/\")) { findAll() }\n            POST(\"/api/user/\") { create() }\n            POST(\"/api/user/{login}\") { findOne() }\n    }\n }\n```\n\nThanks to Yevhenii Melnyk for its early prototype and help!\n\n## Leveraging Kotlin nullable information\n\nOriginally based on a community contribution from [Raman Gupta](https://github.com/rocketraman), Spring now takes advantage of [Kotlin null-safety support](https://kotlinlang.org/docs/reference/null-safety.html) to determine if an HTTP parameter is required without having to define explicitly the `required` attribute. That means `@RequestParam name: String?` with be treated as not required and `@RequestParam name: String` as required. This is also supported on Spring Messaging `@Header` annotation.\n\nIn a similar fashion, Spring bean injection with `@Autowired` or `@Inject` uses this information to know if a bean is required or not. `@Autowired lateinit var foo: Foo` implies that a bean of type `Foo` must be registered in the application context while `@Autowired lateinit var foo: Foo?` won’t raise an error if such bean does not exist.\n\n## Extensions for RestTemplate and Functional Web API\n\nFor example, [Kotlin reified type parameters](https://kotlinlang.org/docs/reference/inline-functions.html#reified-type-parameters) provide a workaround for JVM [generics type erasure](https://docs.oracle.com/javase/tutorial/java/generics/erasure.html), so we have introduced some extensions to take advantage of this feature to provide a better API when possible.\n\nThat allows to provide convenient API for `RestTemplate` (thanks to [Jon Schneider](https://github.com/jkschneider) from Netflix for contributing this). For example, to retrieve a list of `Foo` objects in Java you have to write:\n\n```java\nList<Foo> result = restTemplate.exchange(url, HttpMethod.GET, null, new ParameterizedTypeReference<List<Foo>>() { }).getBody();\n```\n\nOr that way if you use an intermediate array:\n\n```java\nList<Foo> result = Arrays.asList(restTemplate.getForObject(url, Foo[].class));\n```\n\nWhile in Kotlin with Spring Framework 5 extensions you will be able to write:\n\n```kotlin\nval result: List<Foo> = restTemplate.getForObject(url)\n```\n\nWeb API Kotlin extensions available in Spring Framework 5.0 are [RestOperationsExtensions](https://github.com/spring-projects/spring-framework/blob/master/spring-web/src/main/kotlin/org/springframework/web/client/RestOperationsExtensions.kt), [ServerRequestExtensions](https://github.com/spring-projects/spring-framework/blob/master/spring-web-reactive/src/main/kotlin/org/springframework/web/reactive/function/server/ServerRequestExtensions.kt), [BodyInsertersExtensions](https://github.com/spring-projects/spring-framework/blob/master/spring-web-reactive/src/main/kotlin/org/springframework/web/reactive/function/BodyInsertersExtensions.kt), [BodyExtractorsExtensions](https://github.com/spring-projects/spring-framework/blob/master/spring-web-reactive/src/main/kotlin/org/springframework/web/reactive/function/BodyExtractorsExtensions.kt), [ClientResponseExtensions](https://github.com/spring-projects/spring-framework/blob/master/spring-web-reactive/src/main/kotlin/org/springframework/web/reactive/function/client/ClientResponseExtensions.kt), [ModelExtensions](https://github.com/spring-projects/spring-framework/blob/master/spring-context/src/main/kotlin/org/springframework/ui/ModelExtensions.kt) and [ModelMapExtensions](https://github.com/spring-projects/spring-framework/blob/master/spring-context/src/main/kotlin/org/springframework/ui/ModelMapExtensions.kt).\n\nThese extensions also provide member functions supporting natively Kotlin `KClass`, allowing you to specify `Foo::class` parameter instead of `Foo::class.java`.\n\n## Reactor Kotlin extensions\n\n[Reactor](https://projectreactor.io/) is the reactive foundation Spring Framework 5.0 is built upon, and there are good chances you are going to use its [Mono](https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html), [Flux](https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html) and [StepVerifier](https://projectreactor.io/docs/test/release/api/reactor/test/StepVerifier.html) APIs when developing a reactive web application.\n\nSo today we are also introducing Kotlin support in Reactor, via the new [reactor-kotlin](https://github.com/reactor/reactor-kotlin) project! It provides extensions to be able to create `Mono` instances from any class instance by writing `foo.toMono()` which many will prefer to `Mono.just(foo)`. It also supports for example creating a `Flux` from a Java 8 `Stream` instance with `stream.toFlux()`. `Iterable`, `CompletableFuture` and `Throwable` extensions as well as `KClass` based variants of Reactor API are also provided.\n\nThis is still the early days of this project, so feel free to [contribute](https://github.com/reactor/reactor-kotlin/pulls) your own extensions if you find missing bits.\n\n## No need to declare your bean class as open anymore\n\nUntil now, one of the few pain points you faced when building a Spring Boot application with Kotlin was the need to add an `open` keyword on each class and their member functions of Spring beans proxified with CGLIB like `@Configuration` classes. The root cause of this requirement comes from the fact that in Kotlin, [classes are final by default](https://discuss.kotlinlang.org/t/classes-final-by-default/166).\n\nFortunately, Kotlin 1.0.6 now provides a `kotlin-spring` plugin that open classes and their member functions by default for classes annotated or meta-annotated with one of the following annotation:\n\n* `@Component`\n* `@Async`\n* `@Transactional`\n* `@Cacheable`\n\nMeta-annotations support means that classes annotated with`@Configuration`, `@Controller`, `@RestController`, `@Service` or `@Repository` are automatically opened since these annotations are meta-annotated with `@Component`.\n\nWe have updated [start.spring.io](http://start.spring.io/#!language=kotlin) to enabled it by default. You can have a look to [this Kotlin 1.0.6 blog post](https://blog.jetbrains.com/kotlin/2016/12/kotlin-1-0-6-is-here/) for more details, including the new `kotlin-jpa` and `kotlin-noarg` plugins really useful with Spring Data entities.\n\n## Kotlin based Gradle build configuration\n\nBack in May, Gradle [announced](https://blog.gradle.org/kotlin-meets-gradle) that they are going to support writing build and config files in Kotlin in addition to Groovy. This makes it possible to have full auto-completion and validation in your IDE, because such files are regular statically-typed Kotlin Script files. This is likely to become the natural choice for Kotlin based project, but this is also valuable for Java projects too.\n\nSince May, the [gradle-script-kotlin](https://github.com/gradle/gradle-script-kotlin) project has continued to evolve, and is now usable with 2 warnings to keep in mind:\n\n* You need Kotlin 1.1-EAP IDEA plugin to get autocompletion (but wait Kotlin `1.1-M05` if you are using `kotlin-spring` plugin since `1.1-M04` does not work reliably with this plugin yet)\n* The documentation is not complete, but the Gradle team is really helpful on the #gradle channel of the Kotlin Slack.\n\nBoth [spring-boot-kotlin-demo](https://github.com/sdeleuze/spring-boot-kotlin-demo) and [mixit](https://github.com/mix-it/mixit/) projects use such Kotlin based Gradle builds, so feel free to have a look. We are [discussing](https://github.com/spring-io/initializr/issues/334) adding such support on start.spring.io.\n\n## Kotlin Script based templates\n\nAs of version 4.3, Spring Framework provides a [ScriptTemplateView](http://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/web/servlet/view/script/ScriptTemplateView.html) to render templates using script engines that supports [JSR-223](https://www.jcp.org/en/jsr/detail?id=223). Kotlin 1.1-M04 provides such support and allows to render Kotlin based templates, see [this commit](https://github.com/spring-projects/spring-framework/commit/badde3a479a53e1dd0777dd1bd5b55cb1021cf9e) for details.\n\nThis enables some interesting use cases like writing type-safe templates using [kotlinx.html](https://github.com/Kotlin/kotlinx.html) DSL or simply Kotlin multiline `String` with interpolation, as demonstrated in this [kotlin-script-templating](https://github.com/sdeleuze/kotlin-script-templating) project. This could allow you to write this kind of templates with full autocompletion and refactoring support in your IDE:\n\n```kotlin\nimport io.spring.demo.User\nimport io.spring.demo.joinToLine\n\n\"\"\"\n${include(\"header\", bindings)}\n<h1>Title : $title</h1>\n<ul>\n    ${(users as List<User>).joinToLine{ \"<li>User ${it.firstname} ${it.lastname}</li>\" }}\n</ul>\n${include(\"footer\")}\n\"\"\"\n```\n\nThis feature is still work in progress, but I am collaborating with the Kotlin team to tentatively make it production ready with nested template and i18n support on both MVC and Reactive sides for Spring Framework 5.0 GA.\n\n## Conclusion\n\nThe more I write Spring Boot applications with Kotlin, the more I feel these 2 technologies share the same mindset and allow you to write applications more efficiently with expressive, short and readable code, and Spring Framework 5 Kotlin support is a significant step towards combining these technologies in a natural, simple and powerful way.\n\nKotlin can be used to write [annotation-based Spring Boot applications](https://github.com/sdeleuze/spring-boot-kotlin-demo), but will also be a good fit with the new kind of [functional and reactive applications](https://github.com/mix-it/mixit/) that Spring Framework 5.0 will enable.\n\nKotlin team did a great job by fixing almost all the pain points we reported, so big thanks to them. The upcoming Kotlin 1.1 release is expected to also fix [KT-11235](https://youtrack.jetbrains.com/issue/KT-11235) in order to allow specifying array annotation attribute single value without `arrayOf()`. The main remaining issue you will face is maybe [KT-14984](https://youtrack.jetbrains.com/issue/KT-14984) that will require specifying explicitly lambda type where just specifying `{ }` should be enough.\n\nFeel free to test Spring Framework 5.0 Kotlin support by going to [start.spring.io](https://start.spring.io/#!language=kotlin) and generating a Spring Boot `2.0.0 (SNAPSHOT)` project and send us your feedback here or in the `#spring` channel of [Kotlin Slack](http://slack.kotlinlang.org/). You can also [contribute](https://github.com/spring-projects/spring-framework/pulls) the Kotlin extensions you need ;-)\n\n","author":"Sébastien Deleuze","date":"2017-01-04","type":"article","categories":["Kotlin","Spring"],"features":["highlightjs"],"description":"","filename":"","lang":"EN","enclosure":null},{"title":"Non-trivial constructors in Kotlin","url":"http://alexshabanov.com/2014/12/01/non-trivial-constructors-in-kotlin/","body":"\nKotlin really simplifies things such as defining constructors and writing immutable objects for your application. For example, flexible Kotlin constructor definitions eliminate the need of [builder classes](http://en.wikipedia.org/wiki/Builder_pattern \"Builder Pattern - Wikipedia\") (you simply don’t need them in 99% of all the possible use cases, if you use Kotlin), thus reducing overhead of having immutable objects in your application, while retaining full flexibility and expressiveness.\n\nHowever, if you want to define non-trivial constructor (especially for [data classes](http://kotlinlang.org/docs/reference/data-classes.html \"Kotlin Data Classes\")) it might not be as trivial as just writing a function.\n\nFor example, when I started playing with Kotlin, I decided to start with something as simple as defining a class that would represent a [rational number](http://en.wikipedia.org/wiki/Rational_number \"Rational Number - Wikipedia\").\n\nMy first brute force (or naive, if you like) attempt to define that class was as follows:\n\n```kotlin\ndata class Ratio (val numerator : Int, val denominator : Int)\n```\n\nThe problems with this class are obvious: you can create ratios like Ratio(1, 2) and Ratio(2, 4) and they won’t be equal to each other. And I wanted exact opposite – whenever the user of this class constructs a ratio it divides a numerator and denominator to their greatest common divisor – to have coprime numerator and denominator in the corresponding fields of the newly constructed instance of Ratio class. Also I wanted to retain nice-to-have features of the [data class](http://kotlinlang.org/docs/reference/data-classes.html \"Kotlin Data Classes\") – I didn’t want to define copy, hashCode and equals myself.\n\nSo, at this point you’re welcome to play before reading my solution.\n\n* * *\n\nOK, now if you came up with your approach or just would like to see the possible solution – here is the [link to the full class definition](https://github.com/avshabanov/math/blob/master/approx/src/main/kotlin/ratio.kt \"Ratio class definition in Kotlin\") for those who interested.\n\nIn short: you can define custom class constructor (and yet retain call semantics) is to define `invoke` function in ‘class object’ section of your class that has special semantics: you can define static functions as well as factory function `invoke`. It may look as follows (simplified):\n\n```kotlin\nclass Ratio private (val numerator : Int, val denominator : Int) {\n  class object {\n    val ZERO = Ratio(0, 1) // static member!\n    val ONE = Ratio(1, 1) // static member!\n    fun invoke(numerator : Int = 1, denominator : Int = 1) : Ratio {\n      if (denominator == 0) throw IllegalArgumentException(\"denominator can't be zero\")\n      if (numerator == 0) return ZERO\n      if (numerator == denominator) return ONE\n\n      val d = gcd(numerator, denominator)\n      return Ratio(numerator / d, denominator / d)\n    } // <-- end of static function invoke\n\n    fun gcd(a : Int, b : Int) : Int { /*omitted*/ } // static function!\n  }\n\n}\n```\n\nThe beauty of Kotlin here is that you'll still be able to use 'constructor' semantics whenever you need to create an instance of `Ratio`, i.e. you can write as follows as if you had ordinary constructor:\n\n```kotlin\nval r1 = Ratio(3, 7) // invoke will be called here\nval r2 = Ratio(numerator = 1, denominator = 4) // invoke will be called here\n```\n\nThis is it, I hope you find it useful.\n\n","author":"Alex Shabanov","date":"2014-12-01","type":"article","categories":["Kotlin"],"features":["highlightjs"],"description":"","filename":"","lang":"EN","enclosure":null},{"title":"Our Experiment Building a Multiselection Solution for Android in Kotlin","url":"https://yalantis.com/blog/how-we-created-a-multiselection-solution-for-android/","body":"\n“Multiselection can be quite tricky on mobile,” says our designer, Vitaly Rubtsov. Multiselection solutions found in most applications – Telegram, Apple Music, Spotify and others – are usually not that flexible and can be quite uncomfortable to use.\n\nWhen creating your own playlists in Apple Music, for example, it can be confusing to understand which songs have already been added without switching between several screens or endlessly scrolling through a list of selected songs.\n\nAnd the situation may get even worse if we decide to apply filters. In this case, the list of compositions may change once we’ve applied a filter, but the compositions you’ve already selected may not be displayed at all. Vitaly decided to solve this problem with his own concept for multiselection (originally published to [Dribbble](https://dribbble.com/shots/2904577-Multi-Selection-Experiment)).\n\nThe idea is just brilliant: the screen is divided into two parts, so you can always “see and manage what you’ve selected without having to leave the current view,” as Vitaly explains. Filters are only applied to the main list from which you select, but are not applied to your list of selected items.\n\nThat's when I knew that Vitaly’s multiselection concept must be brought to life by any means; so I started my work on the component almost immediately. And now let’s see how the Android Multiselection Animation was born.\n\n![](https://lh6.googleusercontent.com/yIkYWeVg0xYmKOWMEMlUn1hRk2B2DBjeD14bqTRS5cbsRYyLKpvkJ6bPg-vUbQjyCaVHsCahYEXQfM_2RCj-d1x0dcqfPZ34XKX3cMF0k2Vfr5ktrQrmpTqYHwA12LXm8ESxsmSj)\n\n## Implementing the component\n\nThe animation’s logic seems straightforward, yet it has a few catches.\n\nThe component has a `ViewPager` with two `RecyclerViews`. We can make a `ViewPager` page narrower than the screen by overriding the `getPageWidth` method in the `ViewPager` adapter and returning a floating number between 0 and 1.\n\nA `ViewPager` has two pages, each with the `RecyclerView`. Unselected items are on the left list. Selected items are on the right one. For instance, if you click an unselected item, a few things will happen:\n\n1. The clicked item is deleted from the unselected items list and added to the container that holds both lists.\n\n2. Item position in the selected items list is determined. (The unselected list always has its items sorted alphabetically. The selected list has its items in the order they were selected)\n\n3. A hidden item is added to the selected items list.\n\n4. The translation animation is run for the clicked item.\n\n5. The clicked item is deleted and the hidden item in the selected list is shown.\n\nThe most tricky part of this sequence is removing a view from the layout manager; otherwise, the layout manager will try to recycle it, which will cause an error since we are deleting the view from `RecyclerView`:\n\n    sourceRecycler.layoutManager.removeViewAt(position)\n\n## Technology stack\n\nI chose the Kotlin programming language as the tool for this job. The main benefits of Kotlin are its concise syntax and virtually no `NullPointerException` crashes compared to Java. (And, as a result, Kotlin makes for happier developers.) Here are a few useful Kotlin features that made my life easier while I was implementing this library:\n\n### Extension functions\n\nWith extension functions, you can ‘extend’ pre-defined classes with useful methods – even classes you don’t own!\n\nTake the Android View class, for example. Often you need to remove a view from its old parent and attach it to a new one:\n\n```kotlin\n​fun View.removeFromParent() {\n   val parent = this.parent\n   if (parent is ViewGroup) {\n       parent.removeView(this)\n   }\n}\n```\n\nAfter defining the above method, you can now call it from anywhere in your project like this:\n\nOr, you can even write a method that removes the view from its current parent and attaches the view to a new one:\n\n```kotlin\nview.attachTo(newParent)\n```\n\nOne more advantage is that you can add the (strangely absent) `setScaleXY `method. I’ve hardly ever seen `setScaleX` used without `setScaleY`, or vice versa. So why not have a single method that sets both scales? Let’s do it:\n\n```kotlin\nfun View.setScaleXY(scale: Float) {\n   scaleX = scale\n   scaleY = scale\n}\n```\n\nYou can find more examples of how we used extension functions in the Extensions.kt file in the library’s source code.\n\n### Null safety\n\nKotlin’s null safety feature is a game changer. The ‘?.’ operator works just like ‘.’ but if the object it’s called upon is null, ‘?.’ won’t throw a `NullPointerException`, but will return null instead:\n\n```kotlin\nvar targetView: View? = targetRecycler.findViewHolderForAdapterPosition(prev)?.itemView\n```\n\nThe code above, for instance, won’t crash even if `findViewHolderForAdapterPosition` returns null.\n\n### Collections\n\nKotlin comes with `stdlib`, which includes a lot of neat collection functions like map and filter. These methods are widespread, and basically exhibit the same behavior across programming languages, including Java 8 (streams). Unfortunately, streams are still not available out of the box for Android development.\n\nFor our multiselection library, we needed to animate transparency of every view child except the child with a specific id. The following Kotlin code does the job well:\n\n```kotlin\nif (view is ViewGroup) {\n   (0..view.childCount - 1)\n           .map { view.getChildAt(it) }\n           .filter { it.id != R.id.yal_ms_avatar }\n           .forEach { it.alpha = value }\n}\n```\n\nAccomplishing the same in Java would take perhaps twice as many lines of code as we used here.\n\n* ### Better syntax\n\nIn general, Kotlin’s syntax is more concise and readable than Java’s.\n\nOne example is the when expression. Unlike switch (Java’s analogue), Kotlin’s when expression returns a value, so you have to assign it to a variable or return it from a function. That feature in and of itself allows for shorter and more readable code:\n\n```kotlin\nprivate fun getView(position: Int, pager: ViewPager): View = when (position) {\n   0 -> pageLeft\n   1 -> pageRight\n   else -> throw IllegalStateException()\n}\n```\n\n## How to use MultiSelect\n\nHere are 5 simple steps to follow if you want to use our multiselect component in your project.\n\n1. First, add this to your root build.gradle:\n\n```gradle\nallprojects {\n        repositories {\n            ...\n            maven { url \"https://jitpack.io\" }\n        }\n}\n```\n\nAnd then add this to your module `build.gradle`:\n\n```gradle\ndependencies {\n    compile 'com.github.yalantis:multi-selection:v0.1'\n}\n```\n\n2. Then create a `ViewHolder`:\n\n```javas\nclass ViewHolder extends RecyclerView.ViewHolder {\n   TextView name;\n   TextView comment;\n   ImageView avatar;\n\n   public ViewHolder(View view) {\n       super(view);\n       name = (TextView) view.findViewById(R.id.name);\n       comment = (TextView) view.findViewById(R.id.comment);\n       avatar = (ImageView) view.findViewById(R.id.yal_ms_avatar);\n   }\n\n   public static void bind(ViewHolder viewHolder, Contact contact) {\n       viewHolder.name.setText(contact.getName());\n       viewHolder.avatar.setImageURI(contact.getPhotoUri());\n       viewHolder.comment.setText(String.valueOf(contact.getTimesContacted()));\n   }\n}\n```\n\nTake note of the static bind method. It’s useful to have it in here because that way you can use the same viewholder in both adapters.\n\n3. Next, create two adapters for unselected and selected items. The first one should extend `BaseLeftAdapter`; the second, `BaseRightAdapter`:\n\n```java\n​public class LeftAdapter extends BaseLeftAdapter<Contact, ViewHolder>{\n\n   private final Callback callback;\n\n   public LeftAdapter(Callback callback) {\n       super(Contact.class);\n       this.callback = callback;\n   }\n\n   @Override\n   public ViewHolder onCreateViewHolder(ViewGroup parent, int viewType) {\n       View view =  LayoutInflater.from(parent.getContext()).inflate(R.layout.item_view, parent, false);\n       return new ViewHolder(view);\n   }\n\n   @Override\n   public void onBindViewHolder(@NonNull final ViewHolder holder, int position) {\n       super.onBindViewHolder(holder, position);\n\n       ViewHolder.bind(holder, getItemAt(position));\n\n       holder.itemView.setOnClickListener(view -> {\n           // ...\n           callback.onClick(holder.getAdapterPosition());\n           // ...\n       });\n\n   }\n\n}\n```\n\nNotice that you should call super constructor with the model class you use in the adapters.\n\nThe adapter for selected items is very similar:\n\n```java\npublic class RightAdapter extends BaseRightAdapter<Contact, ViewHolder> {\n\n   private final Callback callback;\n\n   public RightAdapter(Callback callback) {\n       this.callback = callback;\n   }\n\n   @Override\n   public ViewHolder onCreateViewHolder(ViewGroup parent, int viewType) {\n       View view = LayoutInflater.from(parent.getContext()).inflate(R.layout.item_view, parent, false);\n       return new ViewHolder(view);\n   }\n\n   @Override\n   public void onBindViewHolder(@NotNull final ViewHolder holder, int position) {\n       super.onBindViewHolder(holder, position);\n\n       ViewHolder.bind(holder, getItemAt(position));\n\n       holder.itemView.setOnClickListener(view -> {\n           // ...\n           callback.onClick(holder.getAdapterPosition());\n           // ...\n       });\n   }\n}\n```\n\nAdapters need to extend different base classes because unselected items are sorted, but selected items stay in the order they were previously selected.\n\n4. Finally, call the builder:\n\n```java\nMultiSelectBuilder<Contact> builder = new MultiSelectBuilder<>(Contac\n       .withContext(this)\n       .mountOn((ViewGroup) findViewById(R.id.mount_point))\n       .withSidebarWidth(46 + 8 * 2); // ImageView width with paddings\n```\n\nYou’ll then need to:\n\n* Pass the context.\n* Pass the view (usually `FrameLayout`) that you want the component to be mounted on.\n* Specify the sidebar width in dp (shown in the image below).\n\n![how-we-build-a-multiselection-component-for-android-application](http://images.yalantis.com/w770/uploads/ckeditor/pictures/2105/content_Artboard.jpg)\n\n5. Last but not least, set the adapters:\n\n```java\nLeftAdapter leftAdapter = new LeftAdapter(position -> mMultiSelect.select(position));\nRightAdapter rightAdapter = new RightAdapter(position -> mMultiSelect.deselect(position));\n\nleftAdapter.addAll(contacts);\n\nbuilder.withLeftAdapter(leftAdapter)\n       .withRightAdapter(rightAdapter);\n```\n\nNow all you need to do is call `builder.build()`, which returns the `MultiSelect<T>` instance.\n\nYou can find this MultiSelect library and many more in our GitHub repository, and can check out our designs on Dribbble:\n\n* [GitHub](https://github.com/Yalantis/Multi-Selection)\n\n* [Dribbble](https://dribbble.com/shots/2904577-Multi-Selection-Experiment)\n\nYou can also get a cool demo with our component on [Google Play Store](https://play.google.com/store/apps/details?id=com.yalantis.multiselect.demo).\n\n","author":"Artem Kholodnyi","date":"2016-11-03","type":"article","categories":["Kotlin","Android"],"features":["highlightjs"],"description":"","filename":"","lang":"EN","enclosure":null},{"title":"The Next Language You Thought You Didn’t Need","url":"http://www.dellingertechnologies.com/2016/08/17/kotlin-the-next-language-you-thought-you-didnt-need/","body":"\nAt a recent conference, I happened upon some information about the programming language, Kotlin. I had heard of it, but never looked into anything about it. After taking a casual look at it, I’m strongly considering giving it a shot on a “real” project. Read on to find out why. My background is primarly Java programming, followed closely by Ruby. I’ve had experience with numerous other languages over the years, but usually only on a small number of projects, or on projects old enough that I don’t consider myself current. Java is my favorite overall. Ruby has lots of great benefits in certain types of projects, so it’s a handy tool to have around as well. So what about Kotlin?\n\nKotlin was developed by JetBrains, the makers of IntelliJ IDEA and other IDE variants as well as other developer tools. Kotlin is a statically typed language that runs on the Java Virtual Machine. It is not syntax compatible with Java, but both Java and Kotlin source files can seamlessly interoperate within the same code base. That is a pretty huge benefit if you’d like to try it out in an existing Java project and can not afford to spin up an entirely new rewrite. The language was first announced in 2011 and was open sourced in 2012. The version 1.0 release became available earlier this year. The language supports object oriented and procedural programming. And, like Scala, it tackles many of the shortcomings and inconveniences from Java. For example, Kotlin makes a distinction between nullable and non-nullable types, so you must explicitly indicate that variables can be null.  It allows you to write concise, clear code and reduce lots of boilerplate which is often a big complaint with Java.\n\nSo why not just use Scala? In my case, a language needs to really sell me on the benefits and low cost of adoption for it to be worth my time to consider incorporating it into my toolset. Scala just never seemed convenient enough in my cursory glances at it. But Kotlin seems to have knocked down those barriers to entry. It has fantastic tool support in IntelliJ. You can even have the IDE automatically convert Java code to Kotlin if you want. Since Kotlin source code is perfectly happy to live alongside Java code, it is trivial to transition at your own pace or give it a trial run without too much overhead. You can call any existing Java code directly and easily from Kotlin code and vice versa. Kotlin is even quickly gaining ground as a go to platform for Android development.\n\nAt this point, I’ve only looked at a few tutorial examples to start getting my feet wet, so I can’t speak to the long term transition and adoption. However, it was ridiculously easy to get started and that is a serious win in my book. I enjoyed it enough to actually take a look at using it on some upcoming personal projects. I’m interested to see how it plays alongside some of my goto Java frameworks like Spring Boot, etc., although it will almost certainly be pretty seamless. JetBrains has committed to long term support of the language so it’s not going away anytime soon.\n\nI’m not one to jump over to the latest and greatest languages that show up on the radar. They usually turn out to be more effort than they are worth for me. However, Kotlin has definitely piqued my interest and I will be taking a closer look at how I can incorporate it my projects. Great benefits to efficiency, low barriers to entry, and low risk. With features like that, if you are a Java developer, it might be a language you are interested in as well. If you’ve tried it already, let me know about your experiences with it.\n\n","author":"Jay Dellinger","date":"2016-08-17","type":"article","categories":["Kotlin"],"features":["highlightjs"],"description":"","filename":"","lang":"EN","enclosure":null},{"title":"Kotlin/Native Tech Preview: Kotlin without a VM","url":"https://blog.jetbrains.com/kotlin/2017/04/kotlinnative-tech-preview-kotlin-without-a-vm/","body":"\nWe are happy to announce the first Technology Preview of **Kotlin/Native** that compiles Kotlin directly to machine code. The Kotlin/Native compiler produces standalone executables that can run without any virtual machine.\n\nIt is not a fully functional release yet, but you can already play with the technology and take a look at its source code [here][]. The compiler is available under the Apache 2 OSS license.\n\n![KotlinNative][]\n\n\n## Mission ##\n\nKotlin/Native is another step toward making Kotlin usable throughout a modern application. Eventually, it will be possible to use Kotlin to write every component, from the server back-end to the web or mobile clients. Sharing the skill set is one big motivation for this scenario. Another is sharing actual code.\n\nOur vision for inter-platform code reuse is the following: one can write entire modules in Kotlin in a platform-independent way and compile them for any supported platform (currently these are Kotlin/JVM, Kotlin/JS and the upcoming Kotlin/Native). We call these *common modules*. Parts of a common module may require a platform-specific implementation, which can be developed individually for each platform. Common modules provide a common API for all clients, but other (platform-specific) modules can extend this API to provide some exclusive capabilities on their platform.\n\nNote that we do not intend to make arbitrary Kotlin/JVM programs runnable on Kotlin/Native or Kotlin/JS. It would be equivalent to implementing another JVM, which is both a lot of work and a lot of limitations for the runtime. We are going another way: providing a common language for all platforms while enabling creation of common libraries through seamless interoperability with platform code.\n\n## Technology ##\n\nKotlin/Native uses the LLVM compiler infrastructure to generate machine code. In this preview, we support the following [target platforms][]:\n\n *  Mac OS X 10.10 and later (x86-64)\n *  x86-64 Ubuntu Linux (14.04, 16.04 and later), other Linux flavours may work as well\n *  Apple iOS (arm64), cross-compiled on MacOS X host\n *  Raspberry Pi, cross-compiled on Linux host\n\nMore platforms can be added relatively easily, as long as the LLVM support is available for them. We will probably support a few more platforms out-of-the-box in the future.\n\nAs usual, interoperability is among our top priorities, and Kotlin/Native can efficiently call C functions and pass/get data to/from them. You can generate Kotlin bindings from a C header files at build time and get fast type-safe access to any API native to the target platform. See detailed instructions [here][here 1].\n\n### Memory management ###\n\nKotlin/Native is designed to potentially enable different memory management solutions for different target platforms. For example, in the future it may make sense to have a tracing GC for server/desktop platforms, while ARC makes a lot more sense on iOS. Some platforms may only need manual memory management, and get an even smaller Kotlin/Native runtime in return.\n\nThis Technology Preview features automatic reference counting with a cycle collector on top, but what the final memory management solution(s) will look like is unknown at this point.\n\n### Current limitations ###\n\nAs mentioned above, Kotlin/Native is far from complete, so this Technology Preview has a number of limitations that will be eliminated at later stages:\n\n *  No performance optimization has been done yet, so benchmarking Kotlin/Native makes no sense at this point.\n *  The Standard Library and reflection support are far from complete, more APIs will be added later.\n *  Read more in the [Release Notes][].\n\n## Future plans ##\n\nWe are currently working on the core technology for Kotlin/Native which is the same for all target platforms (compiler, core runtime and library). As a matter of possible future work, we are considering the following possible use cases:\n\n *  iOS applications (reusing code with Android)\n *  Embedded systems/IoT (e.g., Arduino and beyond)\n *  Data analysis and Scientific Computing\n *  Server-side and Microservices (low-footprint executables, utilizing the power of coroutines)\n *  Game Development\n\n## How to try ##\n\nWe’ve prepared two archives with compiler, samples and documentation: [for Mac and iOS][] and [for Linux and Raspberry Pi][].\n\nCheck out the [Github project][] and [Release Notes][] for instructions.\n\n**Your feedback is very welcome** in the \\#kotlin-native channel on our [public Slack][] (Get your invite [here][here 2].\n\n[here]: https://github.com/JetBrains/kotlin-native/\n[KotlinNative]: https://d3nmt5vlzunoa1.cloudfront.net/kotlin/files/2017/04/KotlinNative.png\n[target platforms]: https://github.com/JetBrains/kotlin-native/blob/v0.1.0/RELEASE_NOTES.md#supported-platforms\n[here 1]: https://github.com/JetBrains/kotlin-native/blob/v0.1.0/INTEROP.md\n[Release Notes]: https://github.com/JetBrains/kotlin-native/blob/v0.1.0/RELEASE_NOTES.md\n[for Mac and iOS]: http://download.jetbrains.com/kotlin/native/kotlin-native-macos-0.1.tar.gz\n[for Linux and Raspberry Pi]: http://download.jetbrains.com/kotlin/native/kotlin-native-linux-0.1.tar.gz\n[Github project]: https://github.com/JetBrains/kotlin-native\n[public Slack]: https://kotlinlang.slack.com/\n[here 2]: http://slack.kotl.in/\n","author":"Andrey Breslav","date":"2017-04-04","type":"article","categories":["Kotlin"],"features":["highlightjs"],"description":"","filename":"","lang":"EN","enclosure":null},{"title":"Kotlin 1.1 Event Report","url":"https://blog.jetbrains.com/kotlin/2017/04/kotlin-1-1-event-report/","body":"\nThe Kotlin 1.1 release was warmly met by the community. To demonstrate the new features in Kotlin 1.1, JetBrains offered an online event. All those interested were able to watch a live stream of Andrey Breslav’s demo presentation and get their questions answered during a Q&A session.\n\nThis motivated many local communities to meet up: more than 30 user groups hosted events in 21 countries.\n\nYou can find the full list of the events at [the Kotlin community web page][]. Over 3000 people joined the broadcast on the day of the event.\n\nThe recording of the demo presentation and the Q&A is available on YouTube:\n\n<iframe width=\"960\" height=\"480\" src=\"https://www.youtube.com/embed/zpyJHSR-5ts\" frameborder=\"0\" allowfullscreen></iframe>\n\n## Kotlin 1.1 Event Feedback ##\n\nIf you watched the live stream, we want to know what you think! Please share your feedback by [completing this form][]. It should only take about 7-10 minutes. Your input is very important in helping us improve all future Kotlin events.\n\n## Kotlin Future Features Survey ##\n\n![future\\_features\\_collage\\_2][future_features_collage_2]\nWe also offered all communities to make an impact on Kotlin future. Event organizers received survey kits and event participants could have a say on the most expected features in an off-line mode. The survey gained much attention, and we’ve now placed it online to listen to the wider community. Now you can [have your say on the Kotlin future][] online!\n\nPlease note it’s more likely that you won’t see those features in v1.2, but we will take your opinion into account when prioritizing our work.\n\n[the Kotlin community web page]: http://kotlinlang.org/community/talks.html?time=kotlin\n[completing this form]: https://docs.google.com/forms/d/e/1FAIpQLSdgKsJzwc1ToAusi-xpEiiE1O4t3HA5xjlbZXDU5Mg0i3qvNg/viewform\n[future_features_collage_2]: https://d3nmt5vlzunoa1.cloudfront.net/kotlin/files/2017/04/collage_2.png\n[have your say on the Kotlin future]: https://docs.google.com/forms/d/e/1FAIpQLSdnCgBonEV5pwN8L903BzdYb9Baf0dpwsJ5YrKnxLveiLFkEQ/viewform\n","author":"Alina Dolgikh","date":"2017-04-06","type":"article","categories":["Kotlin"],"features":["highlightjs"],"description":"","filename":"","lang":"EN","enclosure":null},{"title":"Quick dive in Kotlin extensions","url":"https://medium.com/@piotr.slesarew/quick-dive-in-kotlin-extensions-317eda4d0c0d#.vulwu13rs","body":"\n> Sometimes a large number of independent extensions are possible and would produce an explosion of subclasses to support every combination. _— (GoF)_\n\nAs a kid, I was a fan of diving as it gave me freedom and measureless joy. Over the years my passion changed and I have started diving in deep waters of the ocean of programming. Knowing how things work brings a lot of satisfaction so let’s try to understand amazing extensions in Kotlin.\n\nIt is said that problems with architecture design are strictly connected with lack of knowledge about how language mechanisms work and what they are for. Sadly but truly nowadays countless amount of engineers have gaps in fundamentals and that is why we need to evangelize them over and over again.\n\n#### What are extensions for?\n\nKotlin introduces extension functions and extension properties to solve some common scenarios. Imagine that there is a need to add or extend existing functionality to a class. What are the options?\n\n* Extend an entire class\n* Use util function\n* Decorate\n\nExtending a class is always a risky option, util function will become a big static pain for testing and even using sophisticated Decorator Pattern(if applicable) generates tons of boilerplate. Kotlin extensions give the fourth and the best option you can get.\n\n#### Extend non-extendable\n\nExtension mechanism provides an ability to add functionality even to final classes. Let’s have a look at this code.\n\n```kotlin\nimport org.junit.Assert.assertEquals\nimport org.junit.Test\n\nfun String.removeWhitespaces() = replace(\" \", \"\")\n\nclass StringKtTest {\n    @Test fun removesWhitespacesFromString() {\n        val tested = \"Piotr Slesarew\"\n\n        val actual = tested.removeWhitespaces()\n\n        val expected = \"PiotrSlesarew\"\n        assertEquals(expected, actual)\n    }\n}\n```\n\nFrom the newbie perspective, it looks pretty odd. Adding functionality to String class? How is that even possible? Extensions do not actually modify classes they extend.\n\n```kotlin\npublic final class StringKtTestKt {\n  @NotNull\n  public static final String removeWhitespaces(@NotNull String $receiver) {}\n}\n```\n\nThe sample above shows that compiler generates a class and the static function with a receiver as a parameter. The receiver has a type of extended class. Now it is obvious why the code is so awful when extension functions are used in Java. In the end, they are only static functions.\n\n```kotlin\nString foo = \"Piotr Slesarew\";\nStringKtTestKt.removeWhitespaces(foo);\n```\n\n#### Inlining matters\n\nInline functions are extremely beneficial in case of a having function that takes functions as parameters. That sounds like an inception but do not be frightened. It is just a functional programming and it is closely related to extension functions.\n\nLately, I was dealing a lot with collections and for most of the time, I had to search through them in reverse order. My pre-refactored code looked like this.\n\n```kotlin\nval collection = listOf(\"Piotr\", \"Slesarew\")\n\ncollection.reversed()\n          .forEach(::println)\n```\n\nAs soon as I typed ._reversed().forEach()_ twentytimes I realized that it is a really good idea to squash it into ._reversedForEach(). R_efactored code used extension function which I added to _Iterable_ type.\n\n```kotlin\nval collection = listOf(\"Piotr\", \"Slesarew\")\n\ncollection.reversedForEach(::println)\n\nfun <T> Iterable<T>.reversedForEach(action: (T) -> Unit): Unit {\n    for (element in this.reversed()) action(element)\n}\n```\n\nEverything was great except a performance. I accidentally forgot to _inline_ my function so my code was creating redundant objects. This is a common mistake in designing extension functions.\n\n![](https://cdn-images-1.medium.com/max/800/1*5Wsah0hFTzI4-a0MYBgOoA.png)\n_**Left:** no inlining | **Right:** with inlining_\n\nThe picture shows Java code generated from Kotlin. It is clear that _inlining_ has a great impact on bytecode. For the closer look, I suggest to read carefully _inline functions_ section in Kotlin reference and play with some samples.\n\nSumming up extension functions have a great potential to cure a lot of headaches but it needs to be remembered that with a great power comes a great responsibility so use them consciously.\n\n_If this was interesting to you, please do hit the heart button ❤ or_ [_let me know on Twitter_](https://twitter.com/SliskiCode)_._\n\n","author":"Piotr Ślesarew","date":"2016-11-05","type":"article","categories":["Kotlin"],"features":["highlightjs"],"description":"","filename":"","lang":"EN","enclosure":null},{"title":"Coding Functional Android Apps in Kotlin: Getting Started","url":"https://code.tutsplus.com/tutorials/start-developing-android-apps-with-kotlin-part-1--cms-27827","body":"","author":"Jessica Thornsby","date":"2016-12-19","type":"article","categories":["Kotlin","Android"],"features":["highlightjs"],"description":"","filename":"","lang":"EN","enclosure":null},{"title":"Decision Trees with Kotlin","url":"http://cloudmark.github.io/Decision-Trees/","body":"\n\nIt has been quite a while since my last post; things have been pretty busy in preparation for the launch of our new product [VoodooDreams](https://www.voodoodreams.com). Now that we have shipped our baby, I am super eager to try out [Kotlin](https://www.kotlin.com) - a new programming language from JetBrains targeting the JVM.  One interesting aspect about Kotlin (similar to Scala and other JVM-based languages) is that it treats functions as first class citizens (_IMO Functional Interfaces just patch the gap_).  In order to try out this language we will create a Decision Tree Learning algorithm which is one of the most used and practical methods for learning inductive inference.  \n\n# Learning as a Task\nIn order to ground our discussion, we will consider the example of learning the concept \"Play Tennis\". _Note that this example has been adapted from the book - [Machine Learning by Tom Mitchell](https://www.amazon.de/Machine-Learning-McGraw-Hill-Computer-Science/dp/0070428077/ref=sr_1_1?ie=UTF8&qid=1471686003&sr=8-1&keywords=machine+Learning+Tom+Mitchell)_.  The table below represents a list of positive and negative examples which we will use to induce a general function. This will be our training DataSet \\\\(D\\\\).  \n\n\n| Outlook  | Temperature | Humidity    | Wind        | Play Tennis |\n| ---------| ----------- | ----------- | ----------- | ----------- |\n| Sunny    | Hot         | High        | Weak        | False       |       \n| Sunny    | Hot         | High        | Strong      | False       |\n| Overcast | Hot         | High        | Weak        | True        |\n| Rain     | Mild        | High        | Weak        | True        |\n| Rain     | Cool        | Normal      | Weak        | True        |\n| Rain     | Cool        | Normal      | Strong      | False       |\n| Overcast | Cool        | Normal      | Strong      | True        |\n| Sunny    | Mild        | High        | Weak        | False       |\n| Sunny    | Cool        | Normal      | Weak        | True        |\n| Rain     | Mild        | Normal      | Weak        | True        |\n| Sunny    | Mild        | Normal      | Strong      | True        |\n| Overcast | Mild        | High        | Strong      | True        |\n| Overcast | Hot         | Normal      | Weak        | True        |\n| Rain     | Mild        | High        | Strong      | False       |\n\nThe task here is to learn the _Play Tennis_ concept from the attributes: Outlook, Temperature, Humidity and Wind.  Each row in the table represents a hypothesis. We will represent this in Kotlin using the `DataPoint` class and use the [Delegated Properties](http://kotlinlang.org/docs/reference/delegated-properties.html) **map** feature.  \n\n```kotlin\ndata class DataPoint(val map: Map<String, Any?>, val result: Boolean? = null){\n    val outlook:String by map\n    val temperature: String by map\n    val humidity: String by map\n    val wind: String by map\n}\n```\n\nThe **Delegated Property map** feature (`by map`) allows us to store properties in a map whilst still allowing accessing them as properties.  In the ID3 algorithm we will be using the map to train the algorithm whilst an end user can use the properties directly. Our training DataSet \\\\(D\\\\) can be represented as follows: \n\n```kotlin\nval D = listOf(\n   DataPoint(mapOf(\"outlook\" to \"Sunny\", \"temperature\" to \"Hot\", \"humidity\" to \"High\", \"wind\" to  \"Weak\"), false),\n   DataPoint(mapOf(\"outlook\" to \"Sunny\", \"temperature\" to \"Hot\", \"humidity\" to \"High\", \"wind\" to \"Strong\"), false),\n   DataPoint(mapOf(\"outlook\" to \"Overcast\", \"temperature\" to \"Hot\", \"humidity\" to \"High\", \"wind\" to \"Weak\"), true),\n   DataPoint(mapOf(\"outlook\" to \"Rain\", \"temperature\" to \"Mild\", \"humidity\" to \"High\", \"wind\" to \"Weak\"), true),\n   DataPoint(mapOf(\"outlook\" to \"Rain\", \"temperature\" to \"Cool\", \"humidity\" to \"Normal\", \"wind\" to \"Weak\"), true),\n   DataPoint(mapOf(\"outlook\" to \"Rain\", \"temperature\" to \"Cool\", \"humidity\" to \"Normal\", \"wind\" to \"Strong\"), false),\n   DataPoint(mapOf(\"outlook\" to \"Overcast\", \"temperature\" to \"Cool\", \"humidity\" to \"Normal\", \"wind\" to \"Strong\"), true),\n   DataPoint(mapOf(\"outlook\" to \"Sunny\", \"temperature\" to \"Mild\", \"humidity\" to \"High\", \"wind\" to \"Weak\"), false),\n   DataPoint(mapOf(\"outlook\" to \"Sunny\", \"temperature\" to \"Cool\", \"humidity\" to \"Normal\", \"wind\" to \"Weak\"), true),\n   DataPoint(mapOf(\"outlook\" to \"Rain\", \"temperature\" to \"Mild\", \"humidity\" to \"Normal\", \"wind\" to \"Weak\"), true),\n   DataPoint(mapOf(\"outlook\" to \"Sunny\", \"temperature\" to \"Mild\", \"humidity\" to \"Normal\", \"wind\" to \"Strong\"), true),\n   DataPoint(mapOf(\"outlook\" to \"Overcast\", \"temperature\" to \"Mild\", \"humidity\" to \"High\", \"wind\" to \"Strong\"), true),\n   DataPoint(mapOf(\"outlook\" to \"Overcast\", \"temperature\" to \"Hot\", \"humidity\" to \"Normal\", \"wind\" to \"Weak\"), true),\n   DataPoint(mapOf(\"outlook\" to \"Rain\", \"temperature\" to \"Mild\", \"humidity\" to \"High\", \"wind\" to \"Strong\"), false)\n)\n```\n\n# Decision Trees Representation \nHaving represented our DataSet we will now focus on how to represent the Decision Tree built by using the ID3 algorithm.  This algorithm is but one in the family of Decision Tree Learning Algorithms; a family of algorithms which are great at approximating discrete-valued target functions.  The output of the ID3 algorithm is a decision tree which can be represented visually as follows: \n \n![](https://cloudmark.github.io/images/kotlin/ID3.png)\n\nIn order to classify (predict) a new instance, we will start off at the root of the tree, test the attribute specified and then move down the tree branch corresponding to the value of the attribute.  This process is repeated until a leaf node is reached. \n\nLet us follow with the example:\n\n> **Outlook** = Sunny, **Temperature** = Hot, **Humidity** = High, **Wind** = Strong \n\nWe will start off at the root of the tree which contains the attribute **Outlook** and move to the left subtree (since the value is _Sunny_).  The remaining attributes which could be tested are: \n\n> **Temperature** = Hot, **Humidity** = High, **Wind** = Strong \n\nThe root of the left subtree requires us to check the **Humidity** attribute.  Since the value of the attribute is _High_ we will move to the left subtree to find the leaf node containing the result **No**. Hence we can infer that this is not a good day to play tennis (but a great time to read this article! :bowtie:). \n\nIn order to represent the following Tree in Kotlin we will make use of the [Sealed Classes](https://kotlinlang.org/docs/reference/classes.html).  From their documentation: \n\n> Sealed classes are used for representing restricted class hierarchies, when a value can have one of the types from a limited set, but cannot have any other type. They are, in a sense, an extension of enum classes: the set of values for an enum type is also restricted, but each enum constant exists only as a single instance, whereas a subclass of a sealed class can have multiple instances which can contain state.\n\n```kotlin\nsealed class Tree {\n    class Node(val key: String, val children: Map<String, Tree>?) : Tree()\n    class Leaf(val result: Boolean) : Tree()\n}\n```\n\nThe tree above would be represented as follows: \n\n```kotlin\n Tree.Node(\"Outlook\", mapOf(\n         Pair(\"Sunny\", Tree.Node(\"Humidity\", mapOf(\n                 Pair(\"High\", Tree.Leaf(false)),\n                 Pair(\"Normal\", Tree.Leaf(true))\n         ))),\n         Pair(\"Overcast\", Tree.Leaf(true)),\n         Pair(\"Rain\", Tree.Node(\"Wind\", mapOf(\n                 Pair(\"Strong\", Tree.Leaf(false)),\n                 Pair(\"Weak\", Tree.Leaf(true))\n\n         )))\n ))\n```\n\nNote that we could have also represented this as a disjunction of conjunctions.  If you are interested you can try it out - depth traversal algorithm comes to mind).  \n\n$$\n\\begin{eqnarray} \n(Outlook = Sunny \\wedge Humidity = Normal) \\vee \\nonumber \\newline\n(Outlook = Overcast) \\vee \\nonumber \\newline \n(Outlook = Rain \\wedge Wind = Weak)\n\\end{eqnarray} \n$$\n\n# Classifying New Exemplars.  \n\nThe advantage of using a sealed class is that it will make the implementation of the `classify` function more succinct.  When paired with the [When Expression](https://kotlinlang.org/docs/reference/control-flow.html#when-expression) feature, sealed classes give us rudimentary pattern matching capabilities .  _It would be great to see proper pattern matching support in the coming Kotlin releases._  The implementation of the `classify` function is as follows: \n\n```kotlin\nclass ID3() {\n    companion object {\n        fun classify(dataPoint: DataPoint, tree: Tree): Boolean = when (tree) {\n            is Tree.Leaf -> tree.result\n            is Tree.Node -> {\n                val value = dataPoint.map[tree.key]\n                val subtree = tree.children?.get(value)!!\n                classify(dataPoint, subtree)\n            }\n        }\n    }\n}\n```\n\nNote that we are using the [Companion Object](https://kotlinlang.org/docs/reference/object-declarations.html) feature of Kotlin.  If you have never seen Companion objects before you can think of them as `public static` methods on the ID3 class. Another feature which we are using is the [Smart Cast](https://kotlinlang.org/docs/reference/typecasts.html) feature.  This feature will automatically type cast a variable after using the `is` checks.  In this case after the `is Tree.Leaf` expression evaluates to true, tree will automatically be cast to `Tree.Leaf`.  \n\n\n# Building the Tree\nNow that we have represented our decision tree and learnt how to classify new exemplars, let us take on the task of building a tree from the example data.  The most important question to ask when building a decision tree is \"Which Attribute Is the Best Classifier?\". What we would like to determine is which attribute is the best attribute to classify items at a certain level in the tree, or better, which item gives us the best _information gain_.  \n\n## Entropy\nIn order to determine information gain we start off by looking at entropy which measures the (im)purity of an arbitrary collection of examples.  Given a collection of elements \\\\(S\\\\) containing only positive and negative items, entropy is measured by: \n\n\\\\[\nEntropy(S) = -p\\_{\\oplus} log\\_{2} p\\_{\\oplus} - p\\_{\\ominus} log\\_{2}p\\_{\\ominus}\n\\\\]\n\nAn intuitive way in which we can think about entropy is a number (\\\\([0,1]\\\\)) which represents the minimum number of bits of information needed to encode the classification of an arbitrary member of \\\\(S\\\\).  If the collection \\\\(S\\\\) does not have any positive or negative examples the entropy will be 0.  If I pick an item at random from the collection \\\\(S\\\\) and all items are from the same class then the item I picked must be from that class hence we need 0 bits to encode this information. If the distribution of samples is equal, then the entropy is 1.  This means that we need at minimum 1 bit to represent a randomly picked item from \\\\(S\\\\).  We could encode a positive sample as 1 and a negative sample as 0.  As an example, if we have 9 positive examples and 5 negative examples the entropy would be: \n\n$$\nEntropy([9+, 5-]) = -\\frac{9}{14}log\\_{2}\\Big(\\frac{9}{14}\\Big) -\\frac{5}{14}log\\_{2}\\Big(\\frac{5}{14}\\Big) = 0.940\n$$\n\nWe can extend this formula of Entropy to multiple attributes (rather than just _true_ and _false_) as follows: \n\n$$\nEntropy(S) = \\sum\\_{i=1}^{c} -p\\_{i}log\\_{2}p\\_{i}\n$$\n\nwhere \\\\(p\\_{i}\\\\) is the proportion of \\\\(S\\\\) belonging to class \\\\(i\\\\).  \n\nIn Kotlin we can express `entropy` as follows: \n\n```kotlin\nfun entropy(positive: Double, negative: Double, total: Double = positive + negative):Double {\n  fun log2(valueA: Double, valueB: Double) = if (valueA == 0.0) 1.0 else Math.log(valueA / (valueA + valueB)) / Math.log(2.0)\n  return -(positive / total * log2(positive, negative) + negative / total * log2(negative, positive))\n}\n```\n    \n\n# Information Gain  \nNow that we have defined Entropy as an (im)purity measure, we can answer the question \"Which Attribute Is The Best Classifier?\".  This measure is called _Information Gain_ - you can think of this value as the expected reduction in entropy or the expected number of bits saved if we had to encode the classification using the particular attribute.  The Information Gain of an attribute \\\\(A\\\\) is defined as: \n\n$$\nGain(S, A) = Entropy(S) - \\sum\\_{v \\in Values(A)} \\frac{|S\\_{v}|}{|S|}Entropy(S\\_{v})\n$$\n\n\nTo understand what we need to do, lets work out the _Information Gain_ of attribute \\\\(Wind\\\\) for the dataset \\\\(S\\\\) i.e. \\\\(Gain(S, Wind)\\\\).  _Note that there are 14 examples in our dataset;  9 positive, 5 negative \\\\([9+ 5-]\\\\).  There are 2 values for the attribute Wind: Weak and Strong.  Weak has 6 positive examples and 2 negative examples \\\\([6+, 2-]\\\\).  Strong has 3 positive examples and 3 negative examples \\\\([3+, 3-]\\\\)_.  \n\n$$\\begin{eqnarray} \nGain(S, A) &=&  Entropy(S) - \\sum\\_{v \\in \\\\{Weak, Strong\\\\} } \\frac{|S\\_{v}|}{|S|}Entropy(S\\_{v}) \\nonumber \\newline\n&=& Entropy(S) - \\frac{8}{14}Entropy(S\\_{Weak}) - \\frac{6}{14}Entropy(S\\_{Strong}) \\nonumber \\newline\n&=& 0.940 - \\frac{8}{14}0.811 - \\frac{6}{14}1.0 \\nonumber \\newline\n&=& 0.048\n\\end{eqnarray}$$\n\nIn Kotlin the Gain can be implemented as follows: \n\n```kotlin\nfun gain(dataPoints: List<DataPoint>, extractor: (DataPoint) -> Pair<String, Boolean>): Double {\n    val (positive, negative) = dataPoints.map { extractor(it) }.partition { it.second }\n    val attributes = dataPoints.map { extractor(it) }\n        .groupBy { it.first }\n        .map {\n            val (positiveSv, negativeSv) = it.value.partition { it.second }\n            Triple(it.key, positiveSv.size.toDouble(), negativeSv.size.toDouble())\n        }\n    return (entropy(positive.size.toDouble(), negative.size.toDouble())\n            + attributes.map({ -entropy(it.second, it.third, dataPoints.size.toDouble()) }).sum())\n\n}\n```\n\nWe can compute the Gain of the attribute Wind as follows: \n\n```kotlin\ngain(dataPoints, { Pair(it.wind, it.result!!) })\n```\n\nThe `extractor` function defined as \n\n```kotlin\nextractor: (DataPoint) -> Pair<String, Boolean>\n```\n \nis a function which will be called on the dataset \\\\(S\\\\) to extract the information required - the value of the wind property and the classification result.  The `!!` is an indication to Kotlin that we are 100% sure that this property will not be null.  \n\n# ID3 Tree\nNow that we have all the pieces of our puzzle ready, we will write the `build` function which will create the ID3 Tree. To understand what is going on, I will use a literate programming approach.  Below you will find the listing of the build `function`. \n\n```kotlin\n fun build(dataPoints: List<DataPoint>): Tree {\n    val (positive, negative) = dataPoints.partition { it.result!! }\n    if (positive.size == 0) return Tree.Leaf(false)\n    if (negative.size == 0) return Tree.Leaf(true)\n    val attributes = dataPoints.map { it.map.keys }.flatMap { it }.distinct()\n    if (attributes.size == 1) {\n        return if (dataPoints.count { it.result!! } > dataPoints.count { !it.result!! }) Tree.Leaf(true) else Tree.Leaf(false)\n    } else {\n        val (attribute) = attributes.map { attr ->\n            Pair(attr,\n                gain(dataPoints, { Pair(it.map[attr].toString(), it.result!!) })\n            )\n        }.sortedByDescending { it.second }.first()\n    \n        val remaining = dataPoints.groupBy { it.map[attribute] }\n        val filteredRemaining = remaining.entries.map {\n            entry ->\n            Pair(entry.key, entry.value.map { dataPoint ->\n                DataPoint(dataPoint.map.filterKeys { it != attribute }, dataPoint.result)\n            })\n        }\n    \n        val children = filteredRemaining.map { Pair(it.first.toString(), build(it.second)) }.toMap();\n        return Tree.Node(attribute, children)\n    }\n}\n```\n\nSome explanations are due.  \n\n\nStarting off, we determine whether the DataSet is made up of all positive or all negative sample points (Entropy 0): \n\n``` kotlin\nval (positive, negative) = dataPoints.partition { it.result!! }\nif (positive.size == 0) return Tree.Leaf(false)\nif (negative.size == 0) return Tree.Leaf(true)\n```\nIt such a case we return a `Tree.Leaf` with the corresponding result.  \n \nNext we will check how many attributes there are in the DataSet: \n\n```kotlin\nval attributes = dataPoints.map { it.map.keys }.flatMap { it }.distinct()\n```\n       \nIf there is only one attribute, then the most common value of the target attribute is returned.  \n\n```kotlin\nif (attributes.size == 1) {\n    return if (dataPoints.count { it.result!! } > dataPoints.count { !it.result!! }) \n        Tree.Leaf(true) else Tree.Leaf(false)\n}\n```\n\nOtherwise, we will first determine \"Which attribute is the best?\" by working the Information Gain of each attribute and retrieve the one with the highest Information Gain: \n\n```kotlin\nval (attribute) = attributes.map { attr ->\n    Pair(attr,\n        gain(dataPoints, { Pair(it.map[attr].toString(), it.result!!) })\n    )\n}.sortedByDescending { it.second }.first()\n```\n\nFor all the values of the chosen attribute: \n\n```kotlin\nval remaining = dataPoints.groupBy { it.map[attribute] }\n```\n\nwe will add a new subtree below the parent node and select the DataSet subset such that the attribute \\\\(A\\\\) in the parent subset matches the value \\\\(v\\_{i}\\\\).  \n\n\n```kotlin\nval filteredRemaining = remaining.entries.map {\n    entry ->\n    Pair(entry.key, entry.value.map { dataPoint ->\n        DataPoint(dataPoint.map.filterKeys { it != attribute }, dataPoint.result)\n    })\n}\n```\n\nIn this case the attribute which has the highest Information Gain is the Outlook attribute.  Since Outlook has three values we will create three subtrees: one for Sunny, one for Overcast and one for Rain.  The Sunny Subtree should filter out all data points whose Overcast attribute value is not Sunny.  In this case this subtree will have 5 data points; 2 positive examples and 3 negative examples \\\\([2+,3-]\\\\): \n\n\n| Outlook  | Temperature | Humidity    | Wind        | Play Tennis |\n| ---------| ----------- | ----------- | ----------- | ----------- |\n| Sunny    | Hot         | High        | Weak        | False       |       \n| Sunny    | Hot         | High        | Strong      | False       |\n| Sunny    | Mild        | High        | Weak        | False       |\n| Sunny    | Cool        | Normal      | Weak        | True        |\n| Sunny    | Mild        | Normal      | Strong      | True        |\n\nFinally we will call the build function recursively on this DataSet subset.  \n\n```kotlin\nval children = filteredRemaining.map { Pair(it.first.toString(), build(it.second)) }.toMap();\nreturn Tree.Node(attribute, children)\n```\n\nNote that `it.first` will contain the attribute value (e.g. Sunny) whilst the it.second contains the DataSet subset.  \n\n\n# Conclusion\nIn this post we have looked at some of Kotlin's key features and we have used these to build an ID3 decision tree.  If you are further interested in learning about Kotlin I'd suggest you have a look at the [reference guide](https://kotlinlang.org/docs/reference/).  If you are interested in learn more about Decision Tree Learning consider buying the book linked above.  It is an absolute classic! Stay safe and keep hacking!\n\n\n","author":"Mark Galea","date":"2016-08-20","type":"article","categories":["Kotlin"],"features":["mathjax","highlightjs"],"description":"","filename":"","lang":"EN","enclosure":null},{"title":"Data Binding in Anko","url":"https://medium.com/lewisrhine/data-binding-in-anko-77cd11408cf9#.ym6ibevib","body":"\n\nEver since Google announced their data binding library there has been a debate in the community whether it is “the best thing since fragments” or “the worst thing since fragments”. (I knew you would see that coming, but I did it anyways)\n\nWhen I first heard about it I was excited. I had been playing with AngularJS a lot at the time and I spent about an hour playing with the two-way data binding. Typing text in an input box and watching text in other places change as you type yelling, “Wheeeee, I love JavaScript!” Then I read more about how Google was implementing data binding and was horrified. Logic... In.... Your... X... M... L... Dun Dun Dun!\n\nIf you couldn’t tell from all those dramatic dots, I am on the “it’s bad” side of the binding argument. You can do some really cool things with it. But I just can’t get past having logic in your XML. In fact thinking about it more, why do anything in XML? It’s ugly, dumb, and I hate it.\n\nAnko is a Kotlin library from Jetbrains that provides a lot of extension functions that make Android development much easier. One part of it leverages Kotlin’s ability to create a custom DSL to allow you to build out your views programmatically in a clean simple way. No XML needed. I have wanted to play with this feature of Anko for a while, besides the little bit I did when Kotlin was still in beta that is. So I thought it would be fun to try to build a simple data binding system we can use inside Anko.\n\nFirst things first, I need a simple app with an Anko Component. I just used the example from Anko’s GitHub with some small name changes.\n\n```kotlin\nclass MainActivityUI : AnkoComponent<MainActivity> {\n    override fun createView(ui: AnkoContext<MainActivity>) = with(ui) {\n        verticalLayout {\n            val name = editText()\n            button(\"Say Hello\") {\n                onClick { ctx.toast(\"Hello, ${name.text}!\") }\n            }\n        }\n    }\n}\n```\n\nAnd the Activity looks like this.\n\n```kotlin\nclass MainActivity : AppCompatActivity() {\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        MainActivityUI().setContentView(this)\n    }\n}\n```\n\nI’m going to start simple by just trying to bind a string to a TextView. My first thought is to have a wrapper class that holds a property and has a hash map of bind functions that it invokes whenever the property is changed. This is what I came up with.\n\n```kotlin\nclass Binder<T>(initValue: T) {\n    private val bound: MutableMap<Int, (item: T) -> Unit> = HashMap()\n    var item: T by Delegates.observable(initValue) { prop, old, new -> if (old  != new) bound.values.forEach { it(new) } }\n    fun bind(id: Int, binding: (item: T) -> Unit) {\n        bound.put(id, binding)\n        binding(item)\n    }\n\n    fun unBind(id: Int) = bound.remove(id)\n}\n```\n\nTo simplify binding the data to views I wrote two extension functions that set the id based on the views. This means any view that has any bindings will need an id.\n\n```kotlin\nfun <T> View.bind(binder: Binder<T>, binding: (item: T) -> Unit) = binder.bind(this.id, binding)\n\nfun <T> View.unBind(binder: Binder<T>) = binder.unBind(this.id)\n```\n\nI can come back to these guys at a later data and make them inline to increase performance but for now, I’m not going to worry about it.\n\nI new up a Binder in the Activity passing it an initial string value.\n\n```kotlin\nprivate val bindText = Binder(\"Oh, Hi Mark.\")\n```\n\nThen I add it as a property in the MainActivityUI constructor, add a TextView and bind a function that sets the text of that TextView. Like I said before, the TextView is going to need an id. There is probably a better way of doing it but I just set it to an Int of one.\n\n```kotlin\nclass MainActivityUI(private val bindText: Binder<String>) : AnkoComponent<MainActivity> {\n    override fun createView(ui: AnkoContext<MainActivity>) = with(ui) {\n        verticalLayout {\n            textView {\n                Id = 1\n                bind(bindText) { text = it }\n            }\n            val name = editText()\n            button(\"Say Hello\") {\n                onClick { ctx.toast(“ Hello, ${ name.text }!”) }\n            }\n        }\n    }\n}\n```\n\nNow whenever that item inside the Binder class is changed it will call that function and reset the TextView text. Also notice back inside the Binder class because we are using an observable delegate. It can check to see if the new string has the same value as the old one and only change it if is different. This saves the UI from needlessly setting the TextView if there was really no change in the value.\n\nNow I want to be able to test that the data binding is working. In my Activity, I created a function to change the Binders text and map it to the button to simulate a change made from outside the UI.\n\nIn the Activity.\n\n```kotlin\nfun changeData(text: String) {\n    bindText.item = text\n}\n```\n\nAnd in the Component.\n\n```kotlin\nbutton(\"Say Hello\") {\n    onClick { (ctx as MainActivity).changeData(\"Hello Doggy\") }\n}\n```\n\nSo now any time that string is changed it will automatically update the UI. Yay data binding! Now I want to make sure it can be unbound. First I added a new Binder to hold the state of whether or not to bind the data. Since we now have two Binders, I want to try to play with how a model would work. I want to use a pure data class because the are super nice things like models and I love them deeply.\n\n```kotlin\ndata class Model(val bindText: Binder<String>, val bindOn: Binder<Boolean>)\n```\n\nI updated the Activity and Anko Component to use the model instead of just the string. Then I added a second button that binds to the new Boolean Binder.\n\n```kotlin\nbutton {\n    id = 2\n    bind(model.bindOn) { bindOn ->\n        when (bindOn) {\n            true -> text = \"Binding On\"\n            false -> text = \"Binding Off\"\n        }\n        onClick { model.bindOn.item = (bindOn == false) }\n    }\n}\n```\n\nNow I added logic telling the TextView to bind and unbind based on bindOn\n\n```kotlin\nbind(model.bindOn) {\n    when (it) {\n        true -> bind(model.bindText) { text = it }\n        false -> unBind(model.bindText)\n    }\n}\n```\n\nOk, so I can now bind data to the view and unbind it when need be, even based on the binding of another piece of data like a Boolean. I can use pure data classes to do this without the need to use any annotations and generated classes. I’m pretty happy with it.\n\nNow for some extra fun, I decided to add some two-way data binding. I added a textChangedListener to the editText and change the binders string onTextChanged.\n\n```kotlin\nval editText = editText().apply {\n    textChangedListener {\n        onTextChanged {\n            charSequence, p1, p2, p3 ->\n            bindText.item = “$charSequence”\n        }\n    }\n}\n```\n\nAnd now I can type text in an EditText and watch text in textView change as I type... “Wheeeee, I love Kotlin!”\n\nThis was mostly a proof of concept. I’m sure there are better ways of doing this. I might come back to it and play around some more. If so I’ll be sure to make another.\n\nThe source code is up on my GitHub.\n\nThank you.\n\n","author":"Lewis Rhine","date":"2016-12-01","type":"article","categories":["Kotlin","Anko"],"features":["highlightjs"],"description":"","filename":"","lang":"EN","enclosure":null},{"title":"The power of templating in a DSL","url":"http://jonnyzzz.com/blog/2016/09/16/power-of-dsl/","body":"\n\nWelcome a powerful templating engine that \nis available for every DSL in a general \npurpose language.\n\n\nIntroduction\n============\n\nLet's consider a general purpose language (e.g. Scala, Java, Kotlin)\nand a library (or a DSL API library) which helps to define \nobjects for some domain. \n\nWe use the library in a program to yield a domain objects.\nThis means we are allowed to mix the libraly calls with other \ngeneral language calls features. This forms a templates. \n \nYou may recall a `.php` or `.jsp` condition or loop tags as an example.\n\nFor the DSL case the general purpose \nlanguage turns into a powerfull templage engine. Unlike string \ntemplage engines, this approach allows a semantic aware templating as\nall calls goes to the DSL API library. \n\nSemantic aware templates can be used to enrich \n[The DSL Way](http://jonnyzzz.com/blog/2016/09/02/dsl-building/) approach\ntoo. \n\nLet's consider examples.\n\nA DSL example\n=============\n\nI will be using [IntelliJ IDEA](https://www.jetbrains.com/idea/) as an IDE \nand [Kotlin](https://kotlinlang.org) as \\\\(Target Language \\\\) below. Suppose\nwe have a DSL API library for logger configuration implemented in Kotlin. An\nevaluation of `log4j` function yield a logger configuration \n(e.g. for [Log4j](http://logging.apache.org/log4j/1.2/)).\n\nSay we have the following code to setup\n[loggers](http://jonnyzzz.com/blog/2016/09/09/log4j-dsl/). \n\n```kotlin\nlog4j {\n  logger(\"category2warn\") {\n    + WARN\n  }\n}\n```\n\nThe goal is to configure a number of loggers in the exactly \nsame way. Thanks to Kotlin language features, one is allowed to use a \nloop, e.g.\n\n```kotlin\nlog4j {\n  listOf(\"A\", \"B\", \"C\").forEach {\n    logger(\"category2warn.$it\") {\n      + WARN\n    }\n  }\n}\n```\n\nThis is a straitforward example of a template engine. There \nis nothing specific to be done to have a template engine at all. A mix \nof languge features and DSL API library calls forms the template engine.\n\nThere are no loops support in the logger configuration itself, \nbut thats to DSL API we are allowed to loop over several categories \nto generate all definitions. \n\nThe following part is now a template:\n\n```kotlin\n    logger(\"category2warn.$it\") {\n      + WARN\n    }\n}\n```\n\nOne may go further and decide to extract the collection of categoring into \na function. So we turn the logger configuration code into the following\n\n```kotlin\nlog4j {\n  listAllRootPackages().forEach {\n    logger(\"category2warn.$it\") {\n      + WARN\n    }\n  }\n}\n```\n\nHere we assume the `listAllRootPackages()` to return a list of \ncategories. There is no longer necessary to have this \nfunction to return a constant list. Instead, it can be implemented\nas we like it to, e.g. it may scan an application package to collect\nall possible root categories. It may use some resources as the input.\n\nOverall, this is the way to turn a static (and declarative) logger \nconfiguration to a flexible thing. It is now psedo-declarative. Meaning\nthere is another program, that yields a declarative configuration script\nduring a build phase. On that phase all templates are getting substituted.\n\nA next step is to extract the actual category setup code (a template)\n\n```kotlin\nlog4j {\n  listAllRootPackages().forEach {\n    declareCategory(it)\n  }\n}\n```\n\nAt that point we have a shared library, where a category is declared \nin the *right* way and reused. Next we use a function aka template all other \nthe place.\n\n\nClosing\n=======\n\nThe examples above show how a general purpose language can \nbe turned into a powerfull templating engine for any DSL APIs.\n\nIt turns out that a general purpose language features turning \nit to a powerfull template engine for a given DSL. It's up to \na developer to decide which features to use. The only requirement\nis to have a properly designed DSL API, so that such transformations \nwere possible.\n\nThe example below illustrates a side-effect or a benefit of using \n[The DSL Way]({http://jonnyzzz.com/blog/2016/09/02/dsl-building/)\nto extend an IDE **without** writing any IDE specific code.\nIt shows how powerfull an \\\\(Original Launguage\\\\) can be\nform the \\\\(Target Language\\\\) perspective.\n\nYou may take a look to\n[the post](http://jonnyzzz.com/blog/2016/09/09/log4j-dsl/)\nfor more formal DSL description for a logger configurations.\n\n","author":"Eugene Petrenko","date":"2016-09-22","type":"article","categories":["Kotlin","DSL"],"features":["mathjax","highlightjs"],"description":"","filename":"","lang":"EN","enclosure":null},{"title":"FRP + Kotlin","url":"https://drive.google.com/file/d/0BxCm4NRlzb3PWjNNaG1KS0Utckk/view","body":"\n\n![Photo from meetup](http://i.imgur.com/DOlI1Of.jpg)\n\n[Slides](https://drive.google.com/file/d/0BxCm4NRlzb3PWjNNaG1KS0Utckk/view)\n\n","author":"Giorgio Natili","date":"2016-11-25","type":"slides","categories":["Kotlin","FP"],"features":["highlightjs"],"description":"","filename":"","lang":"EN","enclosure":null},{"title":"Архитектор Kotlin: «Язык программирования — рабочий инструмент. Если никогда их не менять, можно отстать от жизни»","url":"https://dev.by/lenta/main/arhitektor-kotlin-yazyk-programmirovaniya-rabochiy-instrument","body":"\nВ феврале 2016-го, после шести лет разработки, компания JetBrains выпустила в релиз версию 1.0 статически типизированного языка программирования [Kotlin](https://kotlinlang.org/). Его авторы ставили целью создать язык «более лаконичный и типобезопасный, чем Java, и более простой, чем Scala». О том, что из этого вышло, а также о моде на языки программирования, конкуренции между ними, перспективах и «серебряной пуле» в интервью dev.by рассказал руководитель разработки проекта Kotlin в JetBrains​ **Андрей Бреслав**.   \n\n\n![](https://dev.by/ckeditor_assets/pictures/20014/content_breslav.jpg)\n\n# О Kotlin и о конкуренции\n\n**— Первому релизу Kotlin предшествовали шесть лет разработки. Получилось ли у вас то, к чему стремились?**\n\n**—** В разные моменты мы стремились к разным вещам, но большая часть из того, что сейчас мы считаем правильными целями, состоялась. Мы хотели сделать удобный язык для разработчиков с широким кругом задач — получилось. Мы хотели сделать язык, который будет нравиться людям и сделает их жизнь заметно лучше — результатом мы довольны. Цели в процессе менялись: менялись приоритеты, появлялись новые внешние обстоятельства — конкуренты, новые платформы. Например, Android, о котором мы изначально не думали, стал для нас очень интересной и важной платформой, и сейчас мы получаем аудиторию в среде Android-разработчиков. Мы придумали компилироваться в JavaScript — сразу такой мысли не было, а сейчас понятно, что это тоже очень полезное направление.\n\n**— Кстати, о конкурентах. За последние 10-15 лет языков под JVM развелось много, и многие на слуху: Groovy, Gosu, Ceylon. Почему этих разработок так много? Почему не удаётся сконцентрироваться на какой-то одной, особенно в случаях, когда цели схожи?**\n\n— Языков программирования вообще появляется много, и поиск в этом поле бесконечен.\n\n> Создать новый язык — одна из немногих задач системного программирования, относительно несложная, с интересной «математикой». Написать базу данных или операционную систему куда сложнее, поэтому это делают не так часто.\n\nМногие языки возникают, чтобы заполнить новые или пустующие ниши. Например, Gosu изначально создавался для внуренних конфигурационных скриптов, то есть как язык внутри конкретного продукта компании Guidewire, и только потом отделился и стал более самостоятельным. Groovy — одна из первых успешных попыток сделать динамически типизированный язык специально для JVM, и в какой-то момент он стал новым словом в этом направлении.\n\n**— Многие ли идеи конкурентов перекочевали в Kotlin?**\n\n— Мы использовали всё полезное, что нашли у других: цели придумывать всё с нуля не было. Из названных языков по задачам мы пересекаемся с Ceylon, но общий набор требований у нас другой. Большой упор в Kotlin — на взаимодействие с существующим кодом, так называемый interop с Java, а создатели Ceylon от этой идеи отказались. Они запускаются на JVM, но при этом полностью переписывают стандартную библиотеку: вместо классов из JDK используется их собственная SDK. Это сильно меняет дело: подмешать немножечко Ceylon в существующий проект на Java — большая проблема просто потому, что язык создан не для этого, а для того, чтобы на нём с нуля разрабатывать красивые проекты. А Kotlin хорошо подходит для уже существующих проектов.\n\n**— Создание обратной совместимости с Java и стало самой сложной частью проекта?**\n\n— Да, это, пожалуй, принесло больше всего головной боли. По пути мы перебрали четыре основных схемы взаимодействия с библиотеками Java. Первая была очень консервативной: мы считали, что код на Java очень небезопасен, и в Kotlin нужно проверять всё, что можно. Оказалось, что это очень неудобно. Потом мы пытались аннотировать Java-библиотеки, чтобы внести в код на Java дополнительную типовую информацию и её использовать — это решение оказалось слишком хрупким. Закончили мы тем, что создали концепцию платформенных типов, у меня есть [целый доклад о ней](http://medianetwork.oracle.com/video/player/1785452087001) на JVM Language Summit. Модель достаточно сложна и оригинальна, но на практике она работает хорошо.\n\n**— Вернёмся к релизу. Первый фидбек уже собран? Что понравилось пользователям?**\n\n— Разным людям — разные вещи. Очень многим нравится, что программы становятся короткими и понятными, что компилятор ловит ошибки, которые другие компиляторы не поймали бы.\n\n> На Kotlin удаётся и прозрачно использовать существующие библиотеки, и писать хорошие новые — а это значит, что можно добавлять немножко кода на Kotlin в существующий проект и ничего не бояться. Есть и узкоспециализированные вещи: пользователям на Android, например, нравится, что у нас маленькая стандартная библиотека.\n\n# Как и почему возникает мода на языки\n\n**— Появились ли в последние лет 10-15 языки, которые уже стали поворотными для сферы или могут ими стать?**\n\n— Есть такое образное выражение: «Язык превратился в COBOL». Казалось бы, COBOL — старый язык, который должны давно забыть, но в реальности на нём работает ещё очень много систем, особенно в финансовой сфере. Мы наверняка пишем на Java больше новых проектов, чем на COBOL, но при этом я не брался бы утверждать, что мы пишем больше кода на Java в целом :).\n\n> Я к тому, что судьбоносными становятся те языки, которые в какой-то момент были популярны — на них пишут много больших систем, которые потом нужно поддерживать, и от них никуда не денешься.\n\nВ своё время C в этом смысле совершил революцию, Java тоже стала судьбоносным языком. Из более новых языков не смогу назвать ни одного —  наверное, прошло недостаточно много времени, чтобы они могли набрать такую популярность. Но в любом случае, очень успешные языки были. На JVM это Scala и Groovy, на которых крупные компании написали уже немало кода. Вне JVM в своё время имел огромный успех Ruby, на нём писали крупные web-проекты; потом случился кризис роста, люди стали отказываться от Ruby, но этот язык так или иначе серьёзно повлиял на восприятие динамических языков программирования.\n\nОчень большое влияние на направление мысли оказывают функциональные языки. С одной стороны, это языки семейства Lisp-Scheme и всё, что рядом с ним. На JVM есть Clojure, который воплощает те же идеи. С другой стороны — Haskell и другие языки семейства ML. Думаю, что хорошо закрепится Swift, поскольку Apple переводит на него разработчиков для своих платформ, а платформа — вещь такая, что с ней не поспоришь. Раз велено писать на Swift под устройства Apple, значит, все будут писать на Swift — а язык очень хороший, поэтому никакого сопротивления я не ожидаю.\n\n**— Как вы считаете, стоит ли гнаться за модой на языки?**\n\n— Есть люди, которые получают удовольствие от того, что пробуют новые языки и технологии — им, безусловно, стоит пробовать. А есть те, у которых нет на это времени — им есть смысл подождать, пока более резвые коллеги разберутся, какой из конкурирующих языков лучше, и уже постфактум выбирать язык для себя.\n\n> В принципе, язык программирования — это только рабочий инструмент. Менять его слишком часто не нужно — не будет полноты овладения инструментом. Но если не менять инструменты совсем, можно отстать от жизни.\n\nЗдесь нужен баланс. Важно правильно выбирать инструмент по задаче. Когда мы меняем сферу деятельности или переходим к работе в другой области, или просто устали от проблем с тем, что используем сейчас, то есть смысл рассмотреть новые инструменты, понять, не сделают ли они нашу работу принципиально лучше.\n\n**— Тот же Ruby, да и Swift тоже, частенько называют «хипстерскими языками». Почему они стали такими модными?**\n\n— Элемент моды возникает там, где пишутся короткие маленькие проекты. Люди начинают новый проект каждые три месяца и могут себе позволить очередной из них написать на Ruby или на новомодной технологии на базе JavaScript. Естественно, этот эффект хайпа недолговечен, как и любая мода. В мире клиентской разработки это видно особенно ярко: фреймворки и системы программирования на JavaScript сменяют одна другую со страшной скоростью. Мы даже испытываем некоторые сложности из-за этого при разработке Kotlin, потому что при компиляции в JavaScript нам нужно поддерживать какие-то популярные технологии, а их каждый день появляется очень много, и за всем очень сложно уследить. Для Swift всё сказанное тоже частично релевантно, но у этого языка принципиально другая судьба: это стандартное решение, которое поставляется вместе с платформой, и его выбирают не из-за моды.\n\n**— Есть ли, по-вашему, критерии, по которым язык может «выстрелить»?**\n\n— Возвращаясь к сказанному, самый надёжный способ «выстрелить» — быть языком, привязанным к платформе. В своё время C широко распространился, потому что он был языком для платформы Unix, которая была популярной и очень удобной. Java тоже в распространялась как платформа, и язык был её частью. То же касается C#: пускай это и не единственный, но основной язык для платформы .NET. Опять же, есть JavaScript, который популярен не потому, что он хороший или плохой, а потому, что это язык для браузера, браузер нужен всем.\n\nДать надежный рецепт «Как сделать язык, который станет популярным», я не могу, но есть и другие понятные причины, по которым языки становятся популярными.\n\nЕсть языки, которые распространяются по идеологическим моделям — например, Haskell или в какой-то степени Python. Но идеология — это скорее способ сформировать комьюнити, а не удержать его. Тот же Python — это просто хороший язык для многих задач. А вот кто победит из нескольких конкурирующих языков, которые не являются частью платформы и не являются идеологической революцией — как Kotlin, например, — решает рынок.\n\n> Попадание во время и потребности пользователей, правильная маркетинговая работа, своевременный отзыв от ярких представителей сообщества — это все очень важно, но на популярность влияет ещё целая куча разных вещей, которые трудно предсказывать.\n\n![](https://dev.by/ckeditor_assets/pictures/20015/content_breslav2.jpg)\n\n# Прилетит ли «серебряная пуля»?\n\n**— В каком направлении сейчас меняются языки программирования?**\n\n— Есть выраженная тенденция включения в мейнстримовые языки возможностей, изначально придуманных в мире функционального программирования. Наибольшую популярность получили функции высших порядков и лямбда-выражения.\n\nЕщё одна популярная вещь, которая пришла из функционального мира — неизменяемые данные. Здесь есть вполне понятная причина: многоядерные процессоры, которые не так давно произвели революцию на рынке аппаратных средств, а вместе с собой принесли много так называемого «конкурентного программирования», когда программа выполняется в нескольких параллельных нитях. Разделяемые между разными потоками изменяемые данные ведут себя плохо, ошибки отслеживать очень сложно, а чтобы этих ошибок не делать, нужно очень многое держать в голове. В функциональных языках программирования мутирующие операции изначально не в чести, и сейчас эта идея неизменяемых данных становится всё популярнее, поскольку пользоваться ими гораздо проще и надёжнее.\n\n**— Чего, на ваш взгляд, современным языкам не хватает? Что в них «ещё не пришло» из того, что уже, казалось бы, должно?**\n\n— Про языки мне сложно ответить: если бы знал, чего не хватает, уже добавил бы! Мне кажется, что основные болезненные места на сегодня связаны, как я отмечал выше, с многопоточностью. А там главная сложность в том, что никто не знает хорошей модели для многопоточного программирования. Сама эта идея — независимые нитки исполнения, имеющие общую память — несколько противоестественная, и порождает тяжкие ухищрения на аппаратном уровне. Процессор, синхронизируя кеши между ядрами, фактически реализует message passing, но мы притворяемся, что этого нет, и на самом деле у нас разделяемая память. Но чтобы как-то совладать с многопоточным программированием, мы стараемся поменьше пользоваться разделяемой памятью, и программно реализуем поверх неё — снова message passing!\n\nТак получилось исторически: новые процессоры эмулируют поведение старых для совместимости, поэтому сменить парадигму радикально очень сложно. И это отражается на программировании, конечно. Если бы железо могло быть гибче, программирование тоже было бы другим, я думаю. Но мы все в этом смысле связаны во многом всё той же совместимостью. Можно сделать всё очень здорово — и процессор и языки, но только программ и библиотек под это все никаких не будет, и пользователи останутся на традиционных платформах...\n\n**— У программистов есть давняя мечта о «серебряной пуле» — одном языке, который удовлетворил бы большинство или даже всех. Возможно ли его появление?**\n\n— Думаю, в обозримое время ни один язык не победит. Есть искусственные ситуации, в которых можно писать только на одном языке: например, в случае с клиентским вебом. Основным языком браузера был и остаётся JavaScript, и не очень понятно, может ли это измениться. А в остальных случаях, когда есть свобода выбора, я не вижу никаких предпосылок к появлению универсальной идеи, которая бы всех примирила. Слишком уж много противоречивых требований.\n\n# Надо ли уметь программировать каждому школьнику\n\n**— Программирование становится всё более популярным. Сложится ли так, что через какое-то время программировать должен будет уметь каждый?**\n\n— Не думаю, что такое должно произойти. У людей есть автоматически не приобретаемые навыки, которые нужны всем. Например, писать на родном языке или считать. А вот зачем всем на свете нужно будет программировать, я себе представить не могу. Непрограммисты иногда пишут программы, но, как правило, этим всё же занимаются профессионалы. Например, инженеры, которые работают с численными моделями и используют специализированные языки программирования для математического моделирования. Или люди, которые пользуются сложными офисными программами — внутри того же Microsoft Office есть язык программирования Visual Basic for Applications, на котором часто пишут достаточно сложные вещи.\n\nЕсли человек по роду деятельности никак не связан с таким набором задач, то зачем ему программировать? Многие считают, что раз компьютеры — передний край прогресса, значит, все должны разбираться в компьютерах. Когда квантовая физика казалась передним краем прогресса, многие думали, что все будут очень «квантово» жить, но на самом деле никто не будет жить более «квантово», чем живёт сейчас, по-моему.\n\n**— Тем не менее, пока число программистов растёт, и количество запросов на программы тоже растёт.**\n\n— И в ближайшее время этот рост никуда не денется хотя бы из-за того, что правительство Китая изменяет экономический курс. Насколько я понимаю, количество программистов в Китае должно резко увеличиться в ближайшие годы, и для мирового рынка программистов это будет весьма заметный рост. Означает ли это, что в других странах количество рабочих мест для программистов замедлит рост или начнёт падать — хороший вопрос.\n\n**— Стоит ли тогда, на ваш взгляд, преподавать программирование в школе?**\n\n— Я сам восемь лет преподавал программирование в физико-математической школе, и мне кажется, что это столь же разумно, как и преподавание математики или физики. Другой вопрос — содержание курса. Как правильно преподавать программирование в школе без специализации или с гуманитарным уклоном, я не знаю, но всё равно считаю, что это может быть полезным. Программирование развивает алгоритмические и аналитические навыки мышления, очень полезные по жизни, даже если человек никогда больше не будет писать программы.\n\n","author":"yankoits","date":"2016-06-09","type":"article","categories":["Kotlin"],"features":["highlightjs"],"description":"","filename":"","lang":"RU","enclosure":null},{"title":"Радио-Т 484","url":"https://radio-t.com/p/2016/02/20/podcast-484/","body":"\n* [Kotlin дорос до версии 1.0](http://thenextweb.com/dd/2016/02/15/kotlin-the-pragmatic-language-for-android-and-jvm-has-reached-its-1-0-release/) - 00:02:45.\n* [В чем его прагматизм](https://dzone.com/articles/kotlin-10-is-now-available) - 00:12:57.\n* Версия 3 iTerm2 - 00:42:04.\n* Странная история борьбы Apple - 00:52:37.\n* GitHub добавил поддержку шаблонов - 01:10:35.\n* Go 1.6 - 01:15:12.\n* Страшный баг угрожает нашим серверам - 01:21:21.\n* Архитектура Stack Overflow на 2016 - 01:26:33.\n* Custom Machine Types - конфигурации по вкусу - 01:31:15.\n* Темы наших слушателей\n\n","author":"Umputun, Bobuk, Gray, Ksenks","date":"2016-02-20","type":"article","categories":["Podcast","Kotlin"],"features":["highlightjs"],"description":"","filename":"","lang":"RU","enclosure":{"url":"http://cdn.radio-t.com/rt_podcast484.mp3","size":72259834}},{"title":"Беглый взгляд на Async-Await в Android","url":"https://habrahabr.ru/post/314574/","body":"\n\n","author":"Макс Ровкин","date":"2016-11-08","type":"article","categories":["Kotlin","Android"],"features":["highlightjs"],"description":"","filename":"","lang":"RU","enclosure":null},{"title":"How I built my first Kotlin-VertX-Hibernate stack","url":"https://hashnode.com/post/how-i-built-my-first-kotlin-vertx-hibernate-stack-cixhsnv1b002au6539uu6iw7r","body":"\nI've been using Kotlin for close to 6 months now, and have been experimenting with quite a number of frameworks trying to find the combination that will allow me the most flexibility as well as great performance.\n\nSince I've used [Spring Boot](http://start.spring.io/) previously, and ran into a few troubles after trying to do things which the framework didn't support, I steered clear of it. `Spring5`, which supports asynchronous operations, only reached Milestone 1 when I was in the market for a new framework. So, I parked it until it was stable enough for production use.\n\n`DropWizard` looked like a decent option as well, considering its use of `Jersey`, `Jetty`, `Jackson`, and `Metrics`.\n\n`JDBI` + `Liquibase` made for decent choices, to take care of the DB layer, but I needed `Hibernate` for the having to switch between `MySQL`, `SQLServer`, and `PostgreSQL`. Since a lot of my existing logging infrastructure depends on `Log4j`, having to hack around to see how I can replace `Logback`, did not seem like a good use of my time.\n\nI've been sharing articles about `VertX` from time to time, including spectacular benchmarks, but haven't used it myself until now. So, I wanted to see how easy it would be to write a complete system in `Kotlin` + `VertX`, and how complex it would be, compared to the other alternatives I've listed above.\n\nMaybe you can be the judge of the ease of the aforementioned setup. Let's start with a basic maven `pom.xml` in the root directory ...\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<project xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns=\"http://maven.apache.org/POM/4.0.0\"\n         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n    <modelVersion>4.0.0</modelVersion>\n    <groupId>com.hashnode</groupId>\n    <artifactId>demo</artifactId>\n    <packaging>jar</packaging>\n    <version>1.0.0</version>\n    <name>Kotlin Vertx Hibernate Demo</name>    \n    <properties>\n\n    </properties>\n    <dependencies>\n\n    </dependencies>\n    <build>\n\n    </build>       \n</project>\n```\n\nFor Kotlin support, we need the Kotlin Standard lib:\n\n```xml\n<dependency>\n    <groupId>org.jetbrains.kotlin</groupId>\n    <artifactId>kotlin-stdlib</artifactId>\n    <version>${kotlin.version}</version>\n</dependency>\n```\n\n... and the Kotlin Maven plugin:\n\n```xml\n<build>\n    <plugins>\n        <plugin>\n            <artifactId>kotlin-maven-plugin</artifactId>\n            <groupId>org.jetbrains.kotlin</groupId>\n            <version>${kotlin.version}</version>\n            <configuration>\n                <jvmTarget>1.6</jvmTarget>\n            </configuration>\n            <executions>\n                <execution>\n                    <id>compile</id>\n                    <phase>process-sources</phase>\n                    <goals>\n                        <goal>compile</goal>\n                    </goals>\n                </execution>\n                <execution>\n                    <id>test-compile</id>\n                    <phase>process-test-sources</phase>\n                    <goals>\n                        <goal>test-compile</goal>\n                    </goals>\n                </execution>\n            </executions>\n        </plugin>    \n    </plugins>\n</build>\n```\n\nWe would be be using 1.0.5-2 for this demo:\n\n```xml\n<properties>\n    <kotlin.version>1.0.5-2</kotlin.version>\n</properties>\n```\n\nFor VertX, we need VertX Core, and if we need to open websockets, or enable REST endpoints, we need VertX Web.\n\n```xml\n<dependency>\n    <groupId>io.vertx</groupId>\n    <artifactId>vertx-core</artifactId>\n    <version>${vertx.version}</version>\n</dependency>\n<dependency>\n    <groupId>io.vertx</groupId>\n    <artifactId>vertx-web</artifactId>\n    <version>${vertx.version}</version>\n</dependency>\n```\n\nWe would be using 3.3.3 for this demo (note that a Kotlin specific version of VertX will be released in early 2017, for now we're using VertX Java inside Kotlin)\n\n```xml\n<properties>\n    <vertx.version>3.3.3</vertx.version>\n</properties>\n```\n\nAnd that's most of the XML boilerplate - you can always switch to `gradle` if you prefer to get away from the `maven` boilerplate.\n\nNow in your `src/main/java` directory (you can also use `src/main/kotlin` if you prefer, but that would require us to configure the Maven Kotlin plugin, to look for source files in that directory), create a `HashnodeDemo.kt` file and add the following code to the file:\n\n```kotlin\nimport io.vertx.core.AbstractVerticle\nimport io.vertx.core.Vertx\nimport io.vertx.core.logging.LoggerFactory\nimport io.vertx.ext.web.Router\nimport java.io.IOException\n\nobject HashnodeDemo : AbstractVerticle() {\n\n    // initiate logging system\n    private val log = LoggerFactory.getLogger(HashnodeDemo.javaClass)\n\n    @JvmStatic\n    @Throws(IOException::class)\n    fun main(args: Array<String>) {\n\n        // setup verx\n        val vertx = Vertx.vertx()\n        val router = Router.router(vertx)\n\n        router.get(\"/\").handler { it.response().end(\" Hello World :-) \") }\n\n        // start vertx\n        vertx.createHttpServer().requestHandler { router.accept(it) }.listen(9090)\n\n    }\n}\n```\n\nNow if you run this class from your IDE (I'm using IntelliJ, so for me it's `right-click` and `Run HashnodeDemo`), and open your browser at `localhost:9090`, you should see `Hello World :-)` in your browser.\n\nSo, with a single `pom.xml` file, and a single Kotlin `object` we've got a web server that can respond to `GET` requests. Nothing fancy yet, but as you would see further on, VertX mostly gets out of your way allowing you almost full control of the response going back.\n\nHandling WebSockets can also be done with extra minimal code, but I'll cover that in more detail in a future post:\n\n```kotlin\nvertx.createHttpServer().websocketHandler { ws ->\n    log.info(\"WebSocket Connected\")\n    ws.handler {\n        // print content of request to logs\n        log.info(it.toString())\n        // write data back to browser\n        ws.writeFinalTextFrame(\"Hello World\")\n    }\n}.requestHandler { router.accept(it) }.listen(port)\n```\n\nCORS support can also be added with an extra couple of lines (this route should be added before any `GET`, `POST`, etc... routes). To allow cross-domain cookies, use `allowCredentials`\n\n```kotlin\n// handle CORS\nrouter.route().handler(\n    CorsHandler.create(origin)\n        .allowCredentials(true)\n        .allowedMethod(HttpMethod.GET)\n        .allowedMethod(HttpMethod.POST)\n        .allowedMethod(HttpMethod.OPTIONS)\n        .allowedHeader(\"X-PINGARUNER\")\n        .allowedHeader(\"Content-Type\"))\n```\n\nVertX, just like NodeJS, uses an event-loop, and at no point should the event-loop be blocked. If you do block it, expect lots of warnings in your logs, and a poor performance. Fortunately, VertX gives you a mechanism out of the box that will allow you to handle blocking requests with ease.\n\nTo demonstrate, let's add some ASCII art that will displayed when the application starts. In `src/main/resources`, create `ascii.txt` and add some ASCII art to it:\n\n```\n          _    _           _                     _        _____                       \n         | |  | |         | |                   | |      |  __ \\                      \n         | |__| | __ _ ___| |__  _ __   ___   __| | ___  | |  | | ___ _ __ ___   ___  \n         |  __  |/ _` / __| '_ \\| '_ \\ / _ \\ / _` |/ _ \\ | |  | |/ _ \\ '_ ` _ \\ / _ \\\n         | |  | | (_| \\__ \\ | | | | | | (_) | (_| |  __/ | |__| |  __/ | | | | | (_) |\n         |_|  |_|\\__,_|___/_| |_|_| |_|\\___/ \\__,_|\\___| |_____/ \\___|_| |_| |_|\\___/\n\n              Starting Hashnode Demo 1.0.0 ...\n\nJust before `//start vertx`, add the following block of code:\n\n            // show ascii art\n            vertx.executeBlocking<String>({\n                it.complete(InputStreamReader(javaClass.getResourceAsStream(\"/ascii.txt\")).readText())\n            }, {\n                log.info(it?.result())\n            })\n```\n\nDuring startup, the blocking call to the file-system would run in a worker pool while the rest of VertX continues to run asynchronously — best of both worlds; handling an asynchronous request, while still being able to make use of blocking calls in the background...\n\nNow before you follow this tutorial and add `Hibernate` to your project, consider the vast array of options available. `Hibernate`, in my opinion, is the most feature-complete ORM out there, but that also makes it the heaviest ORM available. Other options include:\n\n*   [JDBI](http://jdbi.org/) looks decent if you just want to write normal SQL queries, by hand, and need help in binding params and results\n*   [VertX JDBC](http://vertx.io/docs/vertx-jdbc-client/java/) is very bare-bone, and will probably require lots of work on your side, depending on what you are looking for\n*   [ReQuery](https://github.com/requery/requery) comes bundled with RxJava out of the box, and feels almost like `Hibernate`, but it's much more lightweight\n*   [Falkon](https://github.com/jayrave/falkon) is another option if you like the DSL style\n*   [JOOQ](http://www.jooq.org/) also comes highly recommended.\n*   Kotlin [Kwery](https://github.com/andrewoma/kwery), I've had a look at it, but haven't used it yet.\n\nTo get started with `Hibernate`, let's add some more dependencies in our `pom.xml`:\n\n```xml\n<!-- Hibernate -->\n<dependency>\n    <groupId>org.hibernate</groupId>\n    <artifactId>hibernate-core</artifactId>\n    <version>${hibernate.version}</version>\n</dependency>\n<dependency>\n    <groupId>org.hibernate</groupId>\n    <artifactId>hibernate-entitymanager</artifactId>\n    <version>${hibernate.version}</version>\n    <exclusions>\n        <exclusion>\n            <groupId>cglib</groupId>\n            <artifactId>cglib</artifactId>\n        </exclusion>\n        <exclusion>\n            <groupId>dom4j</groupId>\n            <artifactId>dom4j</artifactId>\n        </exclusion>\n    </exclusions>\n</dependency>\n<dependency>\n    <groupId>org.hibernate</groupId>\n    <artifactId>hibernate-validator</artifactId>\n    <version>${hibernate.version}</version>\n</dependency>\n```\n\nLet's use MySQL for this demo:\n\n```xml\n<dependency>\n    <groupId>mysql</groupId>\n    <artifactId>mysql-connector-java</artifactId>\n    <version>${mysql.version}</version>\n</dependency>\n```\n\nAnd while we're at it, let's add a connection pool as well, to reduce latency:\n\n```xml\n<dependency>\n    <groupId>org.hibernate</groupId>\n    <artifactId>hibernate-c3p0</artifactId>\n    <version>${hibernate.version}</version>\n</dependency>\n```\n\nWe would be using the latest versions of the MySQL driver, and Hibernate:\n\n```xml\n<properties>        \n    <mysql.version>6.0.5</mysql.version>\n    <hibernate.version>5.2.4.Final</hibernate.version>\n</properties>\n```\n\nWe would also need to setup the `persistence.xml` file at `src/main/resources/META-INF/persistence.xml`\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\"?>\n<persistence xmlns=\"http://xmlns.jcp.org/xml/ns/persistence\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" version=\"2.1\" xsi:schemaLocation=\"http://xmlns.jcp.org/xml/ns/persistence http://xmlns.jcp.org/xml/ns/persistence/persistence_2_1.xsd\">\n    <persistence-unit name=\"default\">\n        <description>Persistence XML</description>\n        <provider>org.hibernate.jpa.HibernatePersistenceProvider</provider>\n        <exclude-unlisted-classes>false</exclude-unlisted-classes>\n        <properties>\n\n            <!-- Hibernate Config -->\n            <property name=\"hibernate.dialect\" value=\"org.hibernate.dialect.MySQL5InnoDBDialect\" />\n            <property name=\"hibernate.generate_statistics\" value=\"false\" />\n            <property name=\"hibernate.hbm2ddl.auto\" value=\"update\"/>\n            <property name=\"hibernate.ejb.naming_strategy\" value=\"org.hibernate.cfg.ImprovedNamingStrategy\"/>\n            <property name=\"hibernate.connection.charSet\" value=\"UTF-8\"/>\n            <property name=\"hibernate.show_sql\" value=\"true\" />\n            <property name=\"hibernate.format_sql\" value=\"false\"/>\n            <property name=\"hibernate.use_sql_comments\" value=\"false\"/>\n\n            <!-- JDBC Config -->\n            <property name=\"javax.persistence.jdbc.driver\" value=\"com.mysql.jdbc.Driver\" />\n            <property name=\"javax.persistence.jdbc.url\" value=\"jdbc:mysql://localhost:3306/hashnodedb?useSSL=false\" />\n            <property name=\"javax.persistence.jdbc.user\" value=\"username\" />\n            <property name=\"javax.persistence.jdbc.password\" value=\"password\" />\n\n            <!-- Connection Pool -->\n            <property name=\"hibernate.connection.provider_class\"\n                      value=\"org.hibernate.connection.C3P0ConnectionProvider\" />\n            <property name=\"hibernate.c3p0.max_size\" value=\"5\" />\n            <property name=\"hibernate.c3p0.min_size\" value=\"1\" />\n            <property name=\"hibernate.c3p0.acquire_increment\" value=\"1\" />\n            <property name=\"hibernate.c3p0.idle_test_period\" value=\"300\" />\n            <property name=\"hibernate.c3p0.max_statements\" value=\"0\" />\n            <property name=\"hibernate.c3p0.timeout\" value=\"100\" />\n\n        </properties>\n    </persistence-unit>\n</persistence>\n```\n\nThe `hibernate.dialect` sets the flavour of SQL you are running. We would be using `MySQL` with `InnoDB` for this demo. `hibernate.hbm2ddl.auto` can be set to `validate`, to validate the database against the current database model; `update` will update your database based on your model; whereas `create-drop` will recreate your database effectively every time your restart.\n\nSet `hibernate.hbm2ddl.auto` to `validate` when going to production, otherwise you might just drop / corrupt your production database.\n\nThe `JDBC Config` is simply where you configure the location of your database, username, and password.\n\nThe `Connection Pool` section allows us to setup a connection pool, in this example we set it to use only 5 connections at maximum. If your application is the only application connecting to the database, you can set that close to the maximum number of connections your database can handle. Just remember that those connections will be kept open as long as the application is running.\n\nLet's create a few `Hibernate` models — first, let's create a base model so that we don't have to re-declare all the basic fields in all the models we create. Create a new directory `src/main/java/com/hashnode/demo/model`\n\nNow, let's create the base model in `StandardEntity.kt`:\n\n```kotlin\npackage com.hashnode.demo.model\n\nimport java.util.*\nimport javax.persistence.*\n\n@MappedSuperclass\nopen class StandardEntity {\n\n    @Id\n    @GeneratedValue(strategy = javax.persistence.GenerationType.AUTO)\n    @Column(name = \"id\")\n    var id: Int? = null\n\n    @Version\n    @Column(name = \"version\")\n    private var version: Int = 0\n\n    @Temporal(TemporalType.TIMESTAMP)\n    var created: Date = Date()\n\n    @Temporal(TemporalType.TIMESTAMP)\n    var modified: Date = Date()\n\n    @PreUpdate\n    protected fun onUpdate() {\n        this.modified = Date()\n    }\n\n}\n```\n\nNotice the `@MappedSuperclass`. If you want to extend a base model in `Hibernate`, that base model should be annotated with `@MappedSuperclass`, otherwise extending the base model won't work.\n\nLet's create another entity in `Company.kt`\n\n```kotlin\npackage com.hashnode.demo.model\n\nimport com.hashnode.demo.model.StandardEntity\nimport javax.persistence.Column\nimport javax.persistence.Entity\nimport javax.persistence.EntityManager\nimport javax.persistence.Table\n\n@Entity\n@Table(name = \"Companies\")    \nclass Company(\n\n    @Column(unique = true)\n    var name: String = \"\"\n\n) : StandardEntity() {\n\n    fun getCompanyByName(em: EntityManager, name: String): Company {\n        val query = em.createQuery(\"SELECT o FROM Company AS o WHERE o.name=:name\", Company::class.java)\n        query.setParameter(\"name\", name)\n        return query.singleResult\n    }\n\n}\n```\n\nNext we bootstrap `Hibernate` in our main class, `HashnodeDemo.kt`. First let's add a `lateinit` variable, just after we initiate logging:\n\n```kotlin\nobject HashnodeDemo : AbstractVerticle() {\n\n    // initiate logging system\n    private val log = LoggerFactory.getLogger(HashnodeDemo.javaClass)\n    lateinit var emf: EntityManagerFactory\n```\n\n`lateinit` indicates that we don't want the variable to be `null`, but we don't want to initialise it immediately either.\n\nJust before we display the ASCII art, we instantiate `emf`.\n\n```kotlin\n// setup hibernate\nemf = Persistence.createEntityManagerFactory(\"default\", hibernate)\n```\n\nThis setup would give you a very quick startup time, but `Hibernate` will only startup after the first query has been fired, meaning your first user will get a very slow response. To fix that, we make a dummy query which would force `Hibernate` to start in the background.\n\n```kotlin\nvertx.executeBlocking<Any>({\n    it.complete(emf.createEntityManager().createNativeQuery(\"SELECT 'Hibernate Ready!'\").singleResult)\n}, {\n    log.info(it?.result())\n})\n```\n\nSince we're using the entity manager, all queries would require an entity manager, whether you do a query inside, or outside of a transaction. Let's create a few helper functions to make that easier.\n\nCreate another package where you can place your utils, and add a `Transaction.kt` file to it. Add the following code to your `Transaction.kt` file:\n\n```kotlin\npackage com.hashnode.demo.util\n\nimport io.vertx.core.logging.LoggerFactory\nimport javax.persistence.EntityManager\n\nval log = LoggerFactory.getLogger(AtomApi.javaClass)\n\n/**\n * Inline wrapper function used for doing transactions\n */\ninline fun transaction(f: (em: EntityManager) -> Unit) {\n    val em = AtomApi.emf.createEntityManager()\n    try {\n        em.transaction.begin()\n        f(em)\n        em.transaction.commit()\n    } catch (e: Exception){\n        log.error(e.message, e)\n        em.transaction.rollback()\n    } finally {\n        em.close()\n    }\n}\n\n/**\n * Inline wrapper function to give access to the entity manager in codeblock\n */\ninline fun notransaction(f: (em: EntityManager) -> Unit){\n    val em = AtomApi.emf.createEntityManager()\n    try {\n        f(em)\n    } catch (e: Exception){\n        log.error(e.message, e)\n    } finally {\n        em.close()\n    }\n}\n```\n\nNow whenever you need to run a bunch of queries that should be transactional, use a transaction block:\n\n```kotlin\ntransaction { em ->\n    val query = em.createQuery(\"SELECT o FROM Company AS o WHERE o.id=:id\", Company::class.java)\n    query.setParameter(\"id\", company.id)\n    val company = query.singleResult\n\n    company.name = \"new company name\"\n    em.merge(company);\n}\n```\n\nAnd for non-transactional queries, simply use the `notransaction` block in the same way.\n\n```kotlin\nnotransaction { em ->\n    val query = em.createQuery(\"SELECT o FROM Company AS o WHERE o.id=:id\", Company::class.java)\n    query.setParameter(\"id\", company.id)\n    val company = query.singleResult\n    println(company.name)          \n}\n```\n\nAny new entities, which you want to create (or update), should always be in a `transaction` block. This can be done in a one-liner (remember, if you don't specify the lambda-variable in Kotlin, it defaults to `it`)\n\n```kotlin\ntransaction { it.persist(Company(name = \"another company\")) }\n```\n\nRemember that `JDBC` is blocking, so any `Hibernate` queries should be run using `vertx.executeBlocking`. This is typically how you would structure it, either pass in the `ServerWebSocket`; or the `Route`, if you're using the REST (`GET`, `POST`, etc...) methods. Execute the query inside the `executeBlocking` section, and write the result back in the second lambda.\n\n```kotlin\nfun listCompanies(vertx: Vertx, ws: ServerWebSocket, session: Session, data: String) {\nvertx.executeBlocking<List<Company>>({\n    notransaction { em ->\n        val query = em.createQuery(\"SELECT o FROM Company\", Company::class.java)                \n        it.complete(query.resultList)\n    }\n    }, {\n        if (it.succeeded()) {\n            ws.writeFinalTextFrame(Event(\"listCompanies\", it.result()).toString())\n        }\n    })\n}\n```\n\nHow you structure your files, is completely up to you. You could even use extension methods to cut down on the boilerplate, but you do have the option to structure things according to how they suit you the best.\n\nAs I've shown, `Kotlin` to `VertX`, works like a well-fitting glove to a hand. Adding an ORM-layer is straight-forward as well. I've also demonstrated the addition of `Hibernate`, which in my case was the right choice for the stack that I work on. If you don't need to jump between databases, and prefer something more lightweight, be sure to check out the other options I have mentioned above.\n\nIf you have any questions, feel free to post them here, and I'll respond when time allows.\n\n","author":"Jan Vladimir Mostert","date":"2017-01-03","type":"article","categories":["Kotlin"],"features":["highlightjs"],"description":"","filename":"","lang":"EN","enclosure":null},{"title":"Kotlin & Android: A Brass Tacks Experiment, Part 2.","url":"https://medium.com/@CodingDoug/kotlin-android-a-brass-tacks-experiment-part-2-c67661cfdf5f#.x698dgmuz","body":"\n![](https://d262ilb51hltx0.cloudfront.net/max/800/1*UN-S8ELMC2kpHf4tJKfbLQ.png)\n_Disclaimer: I am a Google employee, but the views expressed in this article are not those of my employer._\n\n### Kotlin & Android: A Brass Tacks Experiment, Part 2\n\nThis is part 2 of a series exploring what the Kotlin® language can uniquely offer Android developers. [Last time](https://medium.com/@CodingDoug/kotlin-android-a-brass-tacks-experiment-part-1-3e5028491bcc) there was some detail on how to get Kotlin support added to an Android project. Now we’ll actually dive into code and see how some Kotlin language features can be used to do nifty things in an Android project.\n\nWhen I first encountered Kotlin and pored over the list of language features, one thing in particular stood out to me. Kotlin has a feature called [type-safe builders](https://kotlinlang.org/docs/reference/type-safe-builders.html) that lets you express object creation in a style that looks declarative. It allows a syntax that looks a lot like Gradle build files. But where Gradle and Groovy are dynamically typed, Kotlin is statically typed, so the compiler will let you know if you’re assigning values to properties that don’t make sense.\n\nThe typical examples of type-safe builders show how it’s possible to build nested data structures, like XML documents. When I think Android and XML, layouts and views quickly come to mind. If Kotlin is good at building up stuff like XML programmatically, perhaps it would do well with view hierarchies. So, that’s where I started. I figured I would try to create a sort of shorthand for building view hierarchies programmatically, which is code-intensive if you’re doing it in the Java® language.\n\nImportant note: I will be referring to _lambdas_ frequently going forward. Before continuing, be sure you understand what that means in the context of computer programming, even if not specifically for Kotlin. In short, it’s a way of expressing an anonymous function that you would pass inline to another function or assign to a variable.\n\nThe core feature of Kotlin that makes type-safe builders possible is called [_lambda with receiver_](https://kotlinlang.org/docs/reference/lambdas.html#function-literals-with-receiver). Let’s get straight into an example that’s actually useful. Kotlin allows you to define functions outside of classes, and that’s all I’m doing here. Also note that the names of variables come before their types, which is the opposite of the Java language.\n\n```kotlin\nimport android.content.Context\nimport java.lang.reflect.Constructor\n\ninline fun <reified TV : View>\n        v(context: Context, init: TV.() -> Unit) : TV {\n    val constr = TV::class.java.getConstructor(Context::class.java)\n    val view = constr.newInstance(context)\n    view.init()\n    return view\n}\n```\n\nThe above function is named v for brevity as I’ll use it a lot here and in future posts, and you can call it like this:\n\n```kotlin\nimport android.view.ViewGroup.LayoutParams\nimport android.view.ViewGroup.LayoutParams.WRAP_CONTENT\nimport android.widget.TextView\n\nval view = v<TextView>(context) {\n    layoutParams = LayoutParams(WRAP_CONTENT, WRAP_CONTENT)\n    text = \"Hello\"\n}\n```\n\nThat’s equivalent to inflating an XML layout that looks like this:\n\n```xml\n<TextView\n    android:layout_width=\"wrap_content\"\n    android:layout_height=\"wrap_content\"\n    android:text=\"Hello\" />\n```\n\nNeat! Now, if this is your first time seeing Kotlin, there’s a lot to translate into English! Here’s a few bits of Kotlin syntax to unpack:\n\n> <reified TV : View>\n\nThe word [reify](http://dictionary.reference.com/browse/reify) means “to make an abstract thing concrete”. As a Kotlin keyword on a [function’s generic type](https://kotlinlang.org/docs/reference/generics.html#generic-functions), this means that you have compile-time access to the JVM Class object specified for the generic type in the body of the function. So this bit of code says that the function v makes use of a “reified” generic type named TV (think “Type of View”) which must be View or a subclass of View. The function must also be declared inline for this to work. The caller then gives TV a specific type in angle brackets when calling the function.\n\n> init: TV.() -> Unit\n\nv takes two parameters, a Context and a lambda named init. init is special because it’s a lambda with receiver type function reference. A lambda with receiver is a block of code that requires an object of a certain type. This required object is referenced by the keyword “this” in the body of the lambda. The type of the receiver object here is the reified generic type TV.\n\nIn our specific case, function v is declaring, “I’m going to create an object of type TV, and I need you to tell me how to initialize it”. So this new TV type object becomes the receiver of the provided lambda, and the lambda is invoked by v with view.init() so it can perform some actions with the view. The “-> Unit” in the syntax is just saying that the lambda returns type Unit, which is like the type void in Java code. In other words, it returns nothing.\n\nTo summarize this lambda with receiver:\n\n*   v declares a parameter called init which is a lambda with receiver for type TV.\n*   v creates and initializes a TV type object and invokes the lambda on it to initialize it.\n*   The lambda sees the TV type object as “this” in its chunk of code.\n\n> TV::class.java\n\nTo reference the reified generic type TV’s implicitly available Class object in the function, you can use the expression TV::class.java. This kind of expression is a very special Kotlin feature for reified generic types that drastically reduces the amount of code you must write in functionally equivalent Java code.\n\nAt this point, I’m going to anticipate a couple more questions you might have about this function:\n\n> “Why does v take two arguments, but appear to be given only one inside the argument parenthesis?”\n\nThis is another unfamiliar syntax to Java programmers. In the Java language, all the arguments to a function always appear inside the call’s parentheses, which can be a lot of added lines if it includes an anonymous callback. But in Kotlin, there is a special syntax when a lambda is the last argument to a function. This syntax allows the lambda to appear in curly braces _immediately following_ the parentheses of the function call. You _could_ put the whole thing inside the parentheses, but most of the time it’s neater this way and keeps the function call parentheses on the same line, so they’re easier to track. Also, this lambda syntax is similarly available when inlining anonymous Java objects that have a single method, such as Runnable.\n\n> “Are ‘layoutParams’ and ‘text’ some sort of variables?”\n\nA syntax feature of a lambda with receiver is that the “this” keyword may be omitted when referencing methods and [properties](https://kotlinlang.org/docs/reference/properties.html) of “this” inside the lambda. But what exactly are layoutParams and text in the call example? These are provided by Kotlin as properties of the receiver type TV (a TextView in our example). Because TextView has methods for setLayoutParams() and setText(), Kotlin recognizes those as JavaBeans-style accessors and creates properties for them that can be accessed as if they were Java class members. So, text = “Hello” here is exactly equivalent to this.setText(“Hello”). Slick! Here’s a screenshot of Android Studio with the Kotlin plugin showing specifically what’s going on during autocomplete:\n\n![](https://d262ilb51hltx0.cloudfront.net/max/800/0*vDlPyDAn73AbhqQO.)\n_The IDE’s autocomplete suggests which methods are backing Kotlin properties._\n\nAs you can see, the Kotlin plugin is pointing out to us that the property called “text” (among other properties) is derived from the underlying JavaBeans-style getter and setter methods of the TextView type receiver object.\n\n> “What is this Constructor business? Can’t we just say “new TV(context)”?”\n\nSince the compiler doesn’t know exactly what a TV is yet in the method body of v, we can’t instantiate it using new + classname. However, we can use the reified class object (TV::class.java) to locate a Constructor that takes a Context as the single argument. It’s conventional for Android View types to have a constructor with this signature, and we’re depending on it. This Constructor object can be invoked to get a new instance of type TV, with the same effect as the new keyword in Java code. This is a reasonable price to pay for the flexibility of having a single function work for all types of views instead of creating a whole new function for each type of view you want to build. And we can optimize this a bit more later in a future part to this blog series.\n\nThat’s a whole lot of convenience for a few lines of code! If you’re new to Kotlin, you might want to go back and digest this a second time, because some of these concepts can be very foreign to Java programmers. It certainly took me a bit of studying to grok all this new stuff.\n\nThis is just the beginning of my experiment. There’s still many ways this function could be enhanced and made easier to use. For example, it would be great if we could build entire nested view hierarchies in a single expression. So stay tuned for [the next post in this series](https://medium.com/@CodingDoug/kotlin-android-a-brass-tacks-experiment-part-3-84e65d567a37) to see how we can use Kotlin to do that!\n\n","author":"Doug Stevenson","date":"2016-02-01","type":"article","categories":["Kotlin","Android"],"features":["highlightjs"],"description":"","filename":"","lang":"EN","enclosure":null},{"title":"Keddit — Part 7: Infinite Scroll: Higher-Order functions & Lambdas","url":"https://medium.com/@juanchosaravia/keddit-part-7-infinite-scroll-higher-order-functions-lambdas-3a11fbd5090e#.cdsuea4kc","body":"\n![](https://d262ilb51hltx0.cloudfront.net/max/2000/1*coKbXMpkG8Fc1NJtM6Jp4w.png)\n\n### Content\n\n* [Introduction: A few words about this](https://medium.com/@juanchosaravia/learn-kotlin-while-developing-an-android-app-introduction-567e21ff9664)\n* [Part 1:](https://medium.com/@juanchosaravia/learn-kotlin-while-developing-an-android-app-part-1-e0f51fc1a8b3) [Configuring Android Studio with Kotlin](https://medium.com/@juanchosaravia/learn-kotlin-while-developing-an-android-app-part-1-e0f51fc1a8b3)\n* [Part 2: MainActivity.kt: Syntax, Null Safety and more...](https://medium.com/@juanchosaravia/learn-kotlin-while-developing-an-android-app-part-2-e53317ffcbe9)\n* [Part 3: NewsFragment.kt: Extension Functions, Android Extensions...](https://medium.com/@juanchosaravia/keddit-part-3-extension-functions-android-extensions-and-more-faa7d232f232)\n* [Part 4: RecyclerView — Delegate Adapters & Data Classes with Kotlin](https://medium.com/@juanchosaravia/keddit-part-4-recyclerview-delegate-adapters-data-classes-with-kotlin-9248f44327f7)\n* [Part 5: Kotlin, RxJava & RxAndroid](https://medium.com/@juanchosaravia/keddit-part-5-kotlin-rxjava-rxandroid-105f95bfcd22)\n* [Part 6: API — Retrofit & Kotlin](https://medium.com/@juanchosaravia/keddit-part-6-api-retrofit-kotlin-d309074af0)\n* [Part 7: Infinite Scroll: Higher-Order functions & Lambdas](https://medium.com/@juanchosaravia/keddit-part-7-infinite-scroll-higher-order-functions-lambdas-3a11fbd5090e)\n* Part 8: Orientation Change (Parcelables & Data Classes)\n* Part 9: Unit & Integration Tests\n\n### Part 7: Infinite Scroll: Higher-Order functions & Lambdas\n\nThanks to all the previous stories we have a small Reddit client App that **shows the Top news from Reddit** and what we need now is to allow the user to see not only the first 10 news but the next news that also belongs to this Top Reddit news. That’s why we introduce here the Infinite Scroll.\n\nThe implementation of the infinite scroll was inspired by [this article](http://msobhy.me/2015/09/05/infinite_scrolling_recyclerview/) and the author is [Mohamed Sobhy](https://twitter.com/@mSobhy90). I made just a few changes to provide an example of Higher-Order functions and passing a lambda expression as parameter.\n\n### Higher-Order Functions\n\n> A higher-order function is a function that takes functions as parameters, or returns a function.\n\nWell, lets see how Kotlin allows you to pass functions as parameter or return it with some examples.\n\nThis function “**logExecution**” allows you to pass a function as parameter and log before and after the execution of this function.\n\n```kotlin\nfun logExecution(func: () -> Unit) {\n    Log.d(\"tag\", \"before executing func\")\n    func()\n    Log.d(\"tag\", \"after executing func\")\n}\n```\n\n#### func: ()-> Unit\n\nAs you already know, “**func**” is the name of the parameter and “**() -> Unit**” is the “type” of the parameter, in this case, we are saying that **func** will be a function that **doesn’t receive any parameter and doesn’t return any value** (remember that Unit works like void in Java).\n\nYou can call this function by passing a lambda expression that must not receive or return any value, like in this way:\n\n```kotlin\nlogExecution( { Log.d(\"tag\", \"I'm a function\") } )\n```\n\nbut also Kotlin allows you to remove the parenthesis if there is only one function parameter or if the last parameter is a function:\n\n```kotlin\nlogExecution { Log.d(\"tag\", \"I'm a function\") }\n```\n\nIf we change the **logExecution** signature to receive another parameter and we put the function parameter at the end, we can do this:\n\n```kotlin\n// added tag parameter:\nfun logExecution(tag: String, func: () -> Unit) { ... }\n\n// call in this way:\nlogExecution(\"tag\") { Log.d(\"tag\", \"I'm a function\") }\n```\n\nor:\n\n```kotlin\nlogExecution(\"tag\") {\n    Log.d(\"tag\", \"I'm a function\")\n}\n```\n\nAlso you can make the function to receive and return values:\n\n```kotlin\nfun logExecution(func: (String, String) -> Int) {\n    val thisIsAnInt = func(\"Hello\", \"World\")\n}\n```\n\nAs you can see Kotlin gives you a lot of power with Higher-Order functions. Also this allows you to remove a lot of Android ceremonies that requires you to initialize things before to execute something or never forget to close a cursor, and much more.\n\n#### Async function example\n\nLets see a practical example. We are going to create a new function that receives a function and execute it in another thread:\n\n```kotlin\nfun runAsync(func: () -> Unit) {\n    Handler().post(Runnable { func() })\n}\n```\n\nNow we can execute a function outside of the Main UI Thread easily:\n\n```kotlin\nrunAsync {\n    // i.e.: save something in the Database\n}\n```\n\n#### Is Lollipop example\n\nMaybe you want to run some specific code for Lollipop devices and instead of doing the regular if check, you can use this function:\n\n```kotlin\nfun isLollipopOrAbove(func: () -> Unit) {\n    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {\n        func()\n    }\n}\n```\n\nand use it in this way:\n\n```kotlin\nisLollipopOrAbove {\n    // run lollipop specific code safely\n}\n```\n\n### Infinite Scroll\n\nOk lets see how we can take advantages of this new concept and create our infinite scroll behaviour.\n\nThe RecyclerView allows you to set a Scroll Listener so I created this [InfiniteScrollListener](https://github.com/juanchosaravia/KedditBySteps/blob/master/app/src/main/java/com/droidcba/kedditbysteps/commons/InfiniteScrollListener.kt) and I defined the signature of this class in this way:\n\n```kotlin\nclass InfiniteScrollListener(\n        val func: () -> Unit,\n        val layoutManager: LinearLayoutManager)\n                 : RecyclerView.OnScrollListener() {...}\n```\n\nWhat we are doing here is to receive a function parameter that will be invoked every time we get to the end of the RecyclerView ([see line 36 for more details](https://github.com/juanchosaravia/KedditBySteps/blob/master/app/src/main/java/com/droidcba/kedditbysteps/commons/InfiniteScrollListener.kt#L36)). In fact, it will be called before to reach the end of the list, you can set a threshold that will make our function to be invoked a few items before and in this way you provide a better experience and not making the user to see all the time the loader that more news were requested.\n\nThe function that we are going to pass as parameter is a function that request more news and update the NewsAdapter with the new received news:\n\n```kotlin\nnews_list.addOnScrollListener(\n   InfiniteScrollListener({ requestNews() }, linearLayout)\n)\n```\n\n**requestNews()** is a function that we already have in our code, I update it to use pagination and request the next available news from Reddit.\n\nAs you may notice, I’m not passing requestNews() **but inside a lambda expression**. This is because the compiler will not take it as a function parameter but as a function that needs to be executed and use the return type of this function as the value that we are passing to the InfiniteScrollListener. As the return type of requestNews is “Unit”, it doesn’t match the InfiniteScrollListener parameter expected which is “()->Unit”, so this code will not compile except if you put this into the lambda expression that match perfectly the required parameter.\n\n#### Commit:\n\nHere you have all the code added to include Infinite Scroll behaviour:\n\n[https://github.com/juanchosaravia/KedditBySteps/commit/3bedf81ad25aecf24aacc224c6591072eccf5b73](https://github.com/juanchosaravia/KedditBySteps/commit/3bedf81ad25aecf24aacc224c6591072eccf5b73)\n\n### Conclusion\n\nWe are now able to scroll and see more news from Reddit Top list. All the details can be reviewed in the previous commit.\n\nHigher-Order functions is an incredible feature and hope it is more clear now with these examples. I invite you to post other examples if you feel inspired.\n\nSee you in the next story!\n\n**Twitter**: [https://twitter.com/juanchosaravia](https://twitter.com/juanchosaravia)\n\n","author":"Juan Ignacio Saravia","date":"2016-04-09","type":"article","categories":["Android","Kotlin","Keddit"],"features":["highlightjs"],"description":"","filename":"","lang":"EN","enclosure":null},{"title":"Kotlin vs Java: Compilation speed","url":"https://medium.com/keepsafe-engineering/kotlin-vs-java-compilation-speed-e6c174b39b5d#.kls4hgglt","body":"\n![](https://d262ilb51hltx0.cloudfront.net/max/800/1*J-1MC3QGbIuwq4tb-yr-iA.png)\n\n_[XKCD, Randall Munroe](https://xkcd.com/303/) // [CC BY-NC 2.5](https://creativecommons.org/licenses/by-nc/2.5/)_\n\n# Kotlin vs Java: Compilation speed\n\n_If you convert an app from Java to Kotlin, will it take longer to compile?_\n\n_This is part 3 in a series of articles on Kotlin._ [_Part 1 discussed_](https://medium.com/keepsafe-engineering/lessons-from-converting-an-app-to-100-kotlin-68984a05dcb6) _converting an Android app from Java to Kotlin, and_[ _part 2 contains_](https://medium.com/keepsafe-engineering/kotlin-the-good-the-bad-and-the-ugly-bf5f09b87e6f) _my thoughts on the Kotlin language._\n\nIn an earlier article, [I discussed converting an Android app from Java to 100% Kotlin](https://medium.com/keepsafe-engineering/lessons-from-converting-an-app-to-100-kotlin-68984a05dcb6). The Kotlin codebase was smaller and more maintainable than it’s Java predecessor, and so I concluded that the transition was worth it. But some people don't want to try out Kotlin because they are worried that it might not compile as quickly as Java. That’s definitely a valid concern; no one wants to spend the time to convert their codebase if it will result in long build times. So let’s take a look at the difference in compile times of the [App Lock app](https://play.google.com/store/apps/details?id=com.getkeepsafe.applock), before and after I converted it to Kotlin. I won’t be trying to compare the speed of a single line of Kotlin versus a single line of Java; instead, I’ll try to answer the question of whether converting a codebase from Java to Kotlin will affect its overall build time.\n\n### How I tested build times\n\nI wrote shell scripts to run Gradle builds repeatedly in a variety of scenarios. All tests are performed 10 times consecutively. The project is cleaned before each scenario, and for scenarios that use the [Gradle daemon](https://docs.gradle.org/current/userguide/gradle_daemon.html), the daemon is stopped once before benchmarking that scenario.\n\nAll benchmarks in this article were performed on an Intel Core i7–6700 running at 3.4 GHz, with 32GiB of DDR4 memory and a Samsung 850 Pro SSD. The source code was built with Gradle 2.14.1.\n\n### Tests\n\nI wanted to run benchmarks in several common usage scenarios: clean builds with and without the Gradle daemon, incremental builds with no file changes, and incremental builds with a changed file.\n\nBefore the transition, App Lock’s Java codebase was 5,491 methods and 12,371 lines of code. After the rewrite, those numbers dropped down to was 4,987 methods and 8,564 lines of Kotlin code. No major architectural changes occurred during the rewrite, so testing the compile times before and after the rewrite should give a pretty good idea about the difference in build times between Java and Kotlin.\n\n#### Clean builds with no Gradle daemon\n\nThis is the worst-case scenario for build times in both languages: running a clean build from a cold start. For this test, I disabled the Gradle daemon.\n\nHere’s how long each of ten builds took:\n\n![](https://d262ilb51hltx0.cloudfront.net/max/800/1*VM3VcA0f0XdjnTWDjOqgQg.png)\n\n_Ten consecutive clean builds without the Gradle daemon_\n\nThe result in this scenario is that Java build times have an average of 15.5 seconds, while Kotlin averages 18.5 seconds: an increase of 17%. Kotlin is not off to a great start, but this isn’t how most people will compile their code.\n\n> For clean builds with no Gradle daemon, Java compiles 17% faster than Kotlin.\n\nIt’s much more common to repeatedly compile the same codebase as you make changes to it. That’s the kind of scenario that the Gradle daemon was designed for, so let’s see how the numbers look when using it.\n\n#### Clean builds with the Gradle daemon running\n\nThe problem with [JIT compilers](https://en.wikipedia.org/wiki/Just-in-time_compilation), like the JVM, is that they take time to compile code that’s executed on them, and so the performance of a process increases over time as it runs. If you stop the JVM process, that performance gain is lost. When building Java code, you would typically start and stop the JVM every time you build. That forces the JVM to redo work every time you build. To combat this, Gradle comes with a daemon that will stay alive between builds in order to maintain the performance gains from the JIT compilation. You can enable the daemon by passing --_daemon_ to Gradle on the command line, or by adding _org.gradle.daemon=true_ to your _gradle.properties_ file.\n\nHere’s what the same series of clean builds as above looks like, but with the Gradle daemon running:\n\n![](https://d262ilb51hltx0.cloudfront.net/max/800/1*l9HeNTP1a2EFCNUsuMlFow.png)\n\n_Ten consecutive clean builds with the Gradle daemon running_\n\nAs you can see, the first run takes about the same amount of time as without the daemon, but subsequent runs increase in performance until the fourth run. In this scenario, it’s more useful to look at the average build time after the third run, where the daemon is warmed up. For the warm runs, the average time for doing a clean build in Java is 14.1 seconds, while Kotlin clocks in at 16.5 seconds: a 13% increase.\n\n> For clean builds with the Gradle daemon warmed up, Java compiles 13% faster than Kotlin.\n\nKotlin is catching up to Java, but is still trailing behind slightly. However, no matter what language you use, the Gradle daemon will reduce build times by over 40%. If you’re not using it already, you should be.\n\nSo Kotlin compiles a little slower than Java for full builds. But you usually compile after making changes to only a few files, and incremental builds are going to have different performance characteristics. So let’s find out if Kotlin can catch up where it matters.\n\n#### Incremental builds\n\nOne of the most important performance features of a compiler is its use of incremental compilation. A normal build will recompile all source files in a project, but an incremental build will keep track of which files have changed since the last build and only recompile those files and the files that depend on them. This can have a huge impact on compile times, especially for large projects.\n\nIncremental builds were added to Kotlin in [version 1.0.2](https://blog.jetbrains.com/kotlin/2016/05/kotlin-1-0-2-is-here/), and you can enable them by adding _kotlin.incremental=true_ to your _gradle.properties,_ or by [using a command line option](https://kotlinlang.org/docs/reference/using-gradle.html#incremental-compilation).\n\nSo how do Kotlin compile times compare to Java’s when incremental compilation is used? Here are the benchmarks with incremental compilation when no files are changed:\n\n![](https://d262ilb51hltx0.cloudfront.net/max/800/1*at-xrjHBLoSOzpGHzobUAA.png)\n\n_Ten consecutive incremental builds with no files changed_\n\nNext, we’ll test incremental compilation with a modified source file. To test this, I changed a java file and its Kotlin equivalent before each build. In this benchmark, the source file is a UI file that no other files depend on:\n\n![](https://d262ilb51hltx0.cloudfront.net/max/800/1*pFr_QiMoES45By4FrviSxA.png)\n\n_Ten consecutive incremental builds with one isolated file changed_\n\nFinally, let’s look at incremental compilation with a modified source file, where the file is imported into many other files in the project:\n\n![](https://d262ilb51hltx0.cloudfront.net/max/800/1*X0JgS3Go9vsMcwCe_95gWA.png)\n\n_Ten consecutive incremental builds with one core file changed_\n\nYou can see that the Gradle daemon still takes two or three runs to warm up, but after that the performance of both languages is very similar. With no changes, Java takes 4.6 seconds per warm build, while Kotlin averages 4.5 seconds. When we change a file that isn’t used by any other files, Java requires an average of 7.0 seconds to do a warm build, and Kotlin clocks in at 6.1. And finally, when we change a file that is imported by many other files in the project, Java requires 7.1 seconds to do an incremental build once the Gradle daemon is warmed up, while Kotlin averages 6.0 seconds.\n\n> In the most common configuration — partial builds with incremental compilation enabled — Kotlin compiles as fast or slightly faster than Java.\n\n### Conclusion\n\nWe benchmarked a few different scenarios to see if Kotlin could keep up with Java when it comes to compilation times. While Java does beat Kotlin by 10–15% for clean builds, those are relatively rare. The much more common scenario for most developers is partial builds, where incremental compilation makes large improvements. With the Gradle daemon running and incremental compilation turned on, Kotlin compiles as fast or slightly faster than Java.\n\nThat’s an impressive result, and one that I didn’t expect. I have to commend the Kotlin team for designing a language that not only has a lot of great features, but can compile so quickly.\n\nIf you were holding off on trying out Kotlin because of compile times, you don’t have to worry any more: Kotlin compiles as quickly as Java.\n\n_You can find the raw data I collected for all benchmarks_ [_here_](https://gist.github.com/ajalt/31c4a45001bea4438f313c899fa961a8)_._\n\nInterested in programming Kotlin full time? Apply as a Kotlin Engineer at [Keepsafe](https://getkeepsafe.com/careers.html).\n\n","author":"AJ Alt","date":"2016-09-09","type":"article","categories":["Kotlin"],"features":["highlightjs"],"description":"","filename":"","lang":"EN","enclosure":null},{"title":"FoldingTabBar Comes to Android. Thank You, Google!","url":"https://yalantis.com/blog/foldingtabbar-for-android/","body":"","author":"Andriy Hristyan","date":"2016-12-15","type":"article","categories":["Kotlin","Android"],"features":["highlightjs"],"description":"","filename":"","lang":"EN","enclosure":null},{"title":"Feedback on the Josephus problem","url":"https://blog.frankel.ch/feedback-jospehus-problem","body":"\nMy last week [article](https://blog.frankel.ch/solving-the-josephus-problem-in-kotlin) was about the solving the Josephus problem in Kotlin. For ease of comparison, here’s the version I wrote originally:\n\n```kotlin\nclass Soldier(val position: Int) {\n    var state = State.Living\n    lateinit var next: Soldier\n    fun suicide() {\n        state = State.Dead\n    }\n    fun isDead() = state == State.Dead\n}\n\nenum class State {\n    Living, Dead\n}\n\nclass Circle(private val size: Int, private val step: Int) {\n\n    private val first = Soldier(0)\n\n    init {\n        var person = first\n        while (person.position < size - 1) {\n            person = createNext(person)\n        }\n        val last = person\n        last.next = first\n    }\n\n    private fun createNext(soldier: Soldier): Soldier {\n        val new = Soldier(soldier.position + 1)\n        soldier.next = new\n        return new\n    }\n\n    fun findSurvivor(): Soldier {\n        var soldier: Soldier = first\n        var numberOfDead = 0\n        while (numberOfDead < size - 1) {\n            var count: Int = 0\n            while (count < step) {\n                soldier = nextLivingSoldier(soldier)\n                count++\n            }\n            soldier.suicide()\n            numberOfDead++\n        }\n        return nextLivingSoldier(soldier)\n    }\n\n    private fun nextLivingSoldier(soldier: Soldier): Soldier {\n        var currentSoldier = soldier.next\n        while (currentSoldier.isDead()) {\n            currentSoldier = currentSoldier.next\n        }\n        return currentSoldier\n    }\n}\n```\n\nThe post ended with an open question: was the code the _right_ way to do it? In particular:\n\n* Is the code idiomatic Kotlin?\n* Lack of `for` means using `while` with `var`s\n* Too many mutability (`var`) for my own liking\n\nI’ve received great feedback from the community on many different channels, including Ilya Ryzhenkov from JetBrains, Cédric Beust, Peter Somerhoff and Gaëtan Zoritchak. Thanks guys!\n\nI think the most interesting is this one, very slightly modified from the original [Gist](https://gist.github.com/gzoritchak/1e2ec8d38fc39a4485ba) by Gaëtan:\n\n```kotlin\nclass Soldier(val position: Int, var state:State = State.Living) {\n    fun suicide() {\n        state = State.Dead\n    }\n    fun isAlive() = state == State.Living\n}\n\nenum class State {\n    Living, Dead\n}\n\nclass Circle(val size: Int, val step: Int) {\n\n    val soldiers = Array( size, {Soldier(it)}).toList()\n\n    fun findSurvivor(): Soldier {\n        var soldier = soldiers.first()\n        (2..size).forEach {\n            (1..step).forEach {\n                soldier = soldier.nextLivingSoldier()\n            }\n            soldier.suicide()\n        }\n        return soldier.nextLivingSoldier()\n    }\n\n   tailrec private fun Soldier.nextLivingSoldier():Soldier =\n            if (next().isAlive())\n                next()\n            else\n                next().nextLivingSoldier()\n\n   private fun Soldier.next() = soldiers.get(\n           if (position == size - 1)\n               0\n           else\n               position + 1\n   )\n}\n```\n\nI like this code a lot because it feels more Kotlin-esque. Improvements are many.\n\n* The code is shorter without any loss of readability\n* It’s entirely functional, there’s only a single `var` involved:\n  * the 2 `while` loops with their associated `var` counter have been replaced by simple `forEach` on `Int` ranges.\n  * Chaining `Soldier` instances is not handled in the `Soldier` class itself through the `next()` method but by the containing `Circle`. Thus, a simple backing array can store them and there’s no need for custom code with mutable variables.\n* The _recursive_ `nextLivingSoldier()` function has been “annotated” with `tailrec` in order for the compiler to run its optimization magic.\n* The `Soldier` class doesn’t know about its container `Circle`‘s `size`, so functions using it have been moved inside the `Circle` class as extension functions to the `Soldier` class. This is a great usage of Kotlin’s extension functions.\n\nThis experience reinforced my belief that learning a language by just reading about it is not enough. To truly make it yours, steps should be those:\n\n1. obviously, learn the syntax of the language – and its API,\n2. code a solution or an app with this language,\n3. ask for feedback,\n4. read, analyze and understand the feedback,\n5. rinse and repeat.\n\n","author":"Nicolas Frankel","date":"2016-03-13","type":"article","categories":["Kotlin"],"features":["highlightjs"],"description":"","filename":"","lang":"EN","enclosure":null},{"title":"Developing on Android sucks a lot less with Kotlin","url":"https://wiredcraft.com/blog/android-apps-development-kotlin/","body":"\n![Kotlin](https://wiredcraft.com/images/posts/Android-app-development-Kotlin.jpg)\n\nWhile Android development has improved tremendously in the past few years, many think that it still sucks when compared to iOS. A lot of folks are working hard to make it better, maybe even enjoyable. And [Kotlin](https://kotlinlang.org/), a new programming language, seems to be headed in that direction. Having been brought onboard by Starbucks in China to work on their mobile apps, we've been experimenting with Kotlin as a viable option to improving the UX of the Android app and making it overall more maintainable.\n\n## What is Kotlin?\n\n[Kotlin](https://kotlinlang.org/) is a new language from the guys at JetBrain, the team behind Intellij, Android Studio, and some of the best IDE in the industry. Essentially, Kotlin is an evolution of the Java syntax. Its source code can be compiled to JVM bytecode and it has 100% interoperability with Java. JetBrain even recently added the ability to compile Kotlin code to JavaScript, potentially broadening its reach.\n\n## Who should use Kotlin?\n\nSo, who is Kotlin for? Newbies or experts?\n\nI would argue both.\n\nNewbies can enjoy a cleaner and more concise syntax and avoid a lot of beginner's mistakes people usually run into with Java. Experts will also most likely enjoy the cleaner syntax, and most likely find themselves more productive for it.\n\n## What makes Kotlin different?\n\nIf you hate Java, Kotlin may be your solution. In many ways, it \"fixes\" Java, especially for Android. While the next major release of Java (8) looks pretty promising and brings a lot of modern language features (e.g. lambda and functional programming), there's no official schedule yet for when it will be made available for the Android platform. Kotlin is available right now.\n\nLet's have a what it brings:\n\n### 1. Cleaner syntax\n\nHere's a \"Hello world\" in Kotlin:\n\n```kotlin\nfun main(args: Array<String>) {\n  println(\"Hello, World!\")\n}\n```\n\nCompared to Java:\n\n```java\npublic class HelloWorld {\n  public static void main(String[] args) {\n  //Prints \"Hello, World\" to the terminal window.System.out.println(\"Hello, World\");\n  }\n}\n```\n\nI think you'll agree that Kotlin is much cleaner and way more concise.\n\n### 2. Null safety\n\nHow many times did you run into a `Null Pointer Exception` while developing or testing? Kotlin takes all `null` value checks from runtime to compile time. By doing so, it ensures null safety for any code that passes compilation.\n\nFor example, the Java code below can be compiled, but will throw a `Null Pointer Exception` at runtime.\n\n```java\nString a  = null;\nSystem.out.println(a.length());\n```\n\nWith Kotlin, variables are not nullable by default. For example, this piece of Kotlin code won't compile:\n\n```kotlin\nval a:String = null\n```\n\nBut if you really want to allow some variable to have null value, you can add a question mark:\n\n```kotlin\nval a: String? = null\nprintln(a?.length())\n```\n\nIn the example above, the first `?` is used to make the variable `a` nullable, the second `?` is just to check if the value of `a` is null.\n\n### 3. Functional programming\n\nOne of the most important changes in Java 8 is lambda. While we're waiting for this to come to the Android platform, Kotlin can already add a lot of high-order functional programming features on top of Java 6.\n\nBy \"high-order,\" I mean a function that can take another function as a parameter or return a function. For example, many programming languages have the `filter` function, which can take a Collection-like data structure and a function to filter the elements in the Collection that doesn't meet certain criteria. Then return a subset of the original Collection.\n\nThis is how you might implement a `filter` function in Kotlin:\n\n```kotlin\nfun <T> filter(items: Collection<T>, f: (T) -> Boolean): List<T> {\n  val newItems = arrayListOf<T>()\n  for (item in items) if (f(item)) newItems.add(item)\n  return newItems\n}\n```\n\nThen you can use it on a Collection data structure:\n\n```kotlin\nfilter(numbers, { value ->\n  value >= 5\n})\n```\n\nPretty clean implementation right? Wait, it can be even cleaner by using the special `it` keyword that represents each item inside the collection:\n\n```kotlin\nfilter(numbers) { it >= 5 }\n```\n\n## Minimum overhead\n\nBeyond adding features, the Kotlin language is actually pretty small. For the latest version to this day (`1.0.0-beta-4584`), runtime and standard library are a few kilobytes in size. It won't add much weight to your project.\n\nThe features we mentioned previously are just a few things that Kotlin brings to the table. For more, I suggest checking out the [official reference page](https://kotlinlang.org/docs/reference/).\n\n## Using Kotlin on Android Studio\n\nThe author of Kotlin is also the author of some of the most popular IDE out there. There are official plugins for Eclipse, IntelliJ IDEA, and standalone command line compiler as well. Since we're focusing on Android, here are a few tips for Android Studio:\n\n1. Download and install Intellij IDEA/Android Studio plugin. You can install it through the IDE preference panel or download if from JetBrain site.\n\n![android-studio-Kotlin-development](https://wiredcraft.com/images/posts/Kotlin-android-app-development-2.png)\n\n2. Once you have the plugin installed, you can start using it. If you're trying to convert an existing Java project, simply click `Code → Convert Java File to Kotlin File` in the menu bar. Kotlin will convert the source Java code to Kotlin code. Alternatively, if you're starting a project from scratch, you can create a new Java project and then convert all `.java` files into `.kt` files. Not the best, but hopefully Google and JetBrain will learn to play nice with each other in the future.\n\n![android-studio-Kotlin-development](https://wiredcraft.com/images/posts/Kotlin-android-app-development-3.png)\n\nThat's it!\n\n## Conclusion\n\nKotlin probably isn't as hot in the Android community as Swift is for the iOS world, but the number of libraries is growing. Being interoperable with Java 6 and backed up by JetBrain should put you at ease with investing in it; it will be around for a long time.\n\nKotlin fixed a lot of the issues we had with developing for Android. There's still room for improvement, but I encourage all of you out there who shared the frustrations of building Android apps to give it a try on your next project.\n\nAnd finally, if you're looking for a rock-solid team of nerds and creatives in NYC, Berlin, or Shanghai to work on your next Android or iOS project, [reach out on Twitter](http://twitter.com/wiredcraft) or shoot us an email either [on our site](https://wiredcraft.typeform.com/to/GG4GQz) or at [info@wiredcraft.com](mailto:info@wiredcraft.com).\n","author":"Kuno Qing","date":"2016-03-01","type":"article","categories":["Android","Kotlin"],"features":["highlightjs"],"description":"","filename":"","lang":"EN","enclosure":null},{"title":"Building DSL Instead of an IDE Plugin","url":"http://jonnyzzz.com/blog/2016/09/02/dsl-building/","body":"\nAn alternative way of doing IDE support without any IDE plugin code for not yet supported and specific languages.\n\nProblem Statement\n=================\n\nMost of us use quite smart IDEs daily with languages we use for development. IDE helps us not only\nto highlight keywords. It is able to check types, show errors, do refactoring, complete and analyze code.\n\nOf course we spent some time working with languages that are not (or weakly) supported by an IDE. Those languages\ncould be used for configurations files, logger settings, business rules, scripts, text files and so on.\nThis is a specific domain where a language is used. It can be hard to read code on that language, it can\nbe also hard to write it too. One may easily waste time writing incorrect code.\n\nIt's the lack of decent IDE support for such languages. Let's see how we can solve it\n\nI will use \\\\(Original Language\\\\) term to refer to an unsupported language. \n\nA Trivial Solution\n==================\n\nSay we have an \\\\(Original Language\\\\) we use, and there is no decent support for it in IDE. \n\nThe very first solution is to replace the \\\\(Original Language\\\\) with some other language. \n \nSuppose the \\\\(Original Language\\\\) cannot be thrown away. And it's likely there is a code on that language. \nThere has to be a system that accepts it too.\n\nOkay. We may implement a plugin for our an IDE to support it.\n\nWriting a plugin is a complicated task. One needs to know IDE API. Moreover, you'll implement a parsing \nso that it'd be fast enough to play well in IDE. The parser should also support invalid text input too, e.g. \nincorrect code that is being entered. That can be tricky.\n\nWell, a parser may not be necessary, if, say IDE support some base language, e.g. `.properties` or `.xml` format.\nBut in that case a deep IDE APIs has to be used.\n\nFinally, a plugin will depend on IDE. Meaning it has to be updated to work with newer IDE versions. It's not in\nour control to lock an IDE version.\n\nThis can be done, but, there's an **alternative way**.\n\n\nThe DSL Way\n===========\n\nEveryone uses their IDE. And of course there is a language we use daily. For example, it could be\n[Java](http://www.oracle.com/technetwork/java/index.html),\n[Scala](http://www.scala-lang.org/),\n[Kotlin](https://kotlinlang.org),\n[Go](https://golang.org/), \n[Groovy](http://www.groovy-lang.org/).\nWe know for sure, an IDE is smart on those languages.\n\nMy idea is to an \\\\(Original Language\\\\), which is unsupported by an IDE, into a code in a supported language. \nI will use a \\\\(Target Language \\\\) term for it. Next, run the \ncode to have a code in a \\\\(Original Language\\\\) back. As shown on the diagram below:\n\n![](https://i.imgur.com/w5a5xx5.png)\n\nTo implement it we need \n- \\\\(generator\\\\), a program that reads a valid code in the \\\\(Original Language\\\\) and generates a code in the \\\\(Target Language \\\\)\n- \\\\(API Library\\\\), a peace of code that includes all definition required for a generated code to be more readable\n- \\\\(execute\\\\), a peace of code that makes compiled generated code in the \\\\(Target Language \\\\) to emit a code in the \\\\(Original Language\\\\)\n\nThe goal of those transformations is to have a readable \\\\(Generated Code \\\\). Refactorings for \\\\(Generated Code \\\\) \nin \\\\(Target Language \\\\) are projected to the \\\\(Original Language\\\\). \n\nSelecting a Target Language\n===========================\n\nMost we need from a \\\\( Target Language \\\\) is a decent IDE support.\n \nWe shall select a \\\\( Target Language \\\\) with a good readability for everyone. \nLanguages with better DSL or fluent APIs capabilities are likely to play better.\n\nStatic typing is a nice to have. It makes it harder to make a error. Moreover, \nit's likely to require no setup for an IDE to work. For some dynamic languages\nan additional [helper](https://confluence.jetbrains.com/display/GRVY/Scripting+IDE+for+DSL+awareness) may be required.\n \nThe DSL Way Benefits\n====================\n\nThe DSL Way approach projects all features from an \\\\( Target Language \\\\) into a \\\\(Original Language\\\\). \nWe can say an \\\\(Original Language\\\\) is extended with all possible high-level features of a \\\\( Target Language \\\\).\nFor example, we can use functions, loops, conditions, libraries and so on. There is no need to \nhave a support for such constructs in the \\\\(Original Language\\\\).\nOne may also tune a \\\\(generator\\\\) to say fold duplicates in the input into a loops or functions.\n \nThanks to \\\\(API Library\\\\) we have good readability. It's a creativity part here. But if implemented correctly, \nit improves readability drastically.\n\nThe parsing is easier to implement for The DSL Way approach. We only need to have it supporting valid inputs. By induction,\nwe start with a valid code and generate a valid code. It's way more complex for The IDE Plugin case. \n\nRefactorings and code analysis features for a \\\\(Target Language \\\\) are projected to a \\\\(Original Language\\\\). All \nwhat is needed is to design \\\\(API Library\\\\) and \\\\(generator\\\\) in the right way. Say you need a *find usages* \nfor some domain object. To have it, you may make a \\\\(generator\\\\) declare and use a variable for such entities. \nOnce variables are used, rename feature is implemented for free.\n\nExample\n=======\n\nLet's consider [Log4j](http://logging.apache.org/log4j/1.2/) configuration in `.properties` file as \\\\(Original Language\\\\).\n\n```properties\nlog4j.rootLogger=ERROR,stdout\nlog4j.logger.corp.mega=INFO,stdout\n# meaningful comment goes here\nlog4j.logger.corp.mega.itl.web.metrics=INFO\n\nlog4j.appender.stdout=org.apache.log4j.ConsoleAppender\nlog4j.appender.stdout.layout=org.apache.log4j.PatternLayout\nlog4j.appender.stdout.layout.ConversionPattern=%p\\t%d{ISO8601}\\t%r\\t%c\\t[%t]\\t%m%n\n```\n\nI decided to use [IntelliJ IDEA](https://www.jetbrains.com/idea/) as IDE \nand [Kotlin](https://kotlinlang.org) as \\\\(Target Language \\\\).\n \nThe configuration below can be turned into the following Kotlin code.\n\n```kotlin\nlog4j {\n  val stdout = appender<ConsoleAppender>(\"stdout\") {\n    layout<PatternLayout> {\n      conversionPattern = \"%p\\t%d{ISO8601}\\t%r\\t%c\\t[%t]\\t%m%n\"\n    }\n  }\n\n  rootLogger {\n    level = ERROR\n    appenders += stdout\n  }\n\n  logger(\"corp.mega.itl.web.metrics\") {\n    level = INFO\n  }\n\n  logger(\"corp.mega\") {\n    level = INFO\n    appenders += stdout\n  }\n}\n```\n\nThe evaluation of this Kotlin program yields the similar `.properties` file back. \n\nThe DSL code is way easier to read and to write.\n\nThanks to Kotlin static typed DSLs, IntelliJ IDEA understands the code well, warns all incorrect usages,\ncode complete all possibilities. \n\nMoreover, using such DSL is the way to implement automatic tests for your log4j configurations.\nOne may easily setup automatic tests task as a part of their continuous integration, since the code has no dependency on \nan IDE part. \n \nIt opens the way to reuse common configuration files as well as to run. \n\nConclusion\n==========\n\nIn the post we discussed The DSL Way of doing an IDE support **without** writing any IDE related code. \nThe created DSL can be used not only with IDE. It can easily be re-used in any possible applications like code sharing,\nautomatic test, continuous integration and so on.\n\nYou may follow to [this post](http://jonnyzzz.com/blog/2016/03/08/gradle-for-dsl/) for details on how to create decent package\nfor The DSL Way toolset\n\n*PS*. Do you have more examples for \\\\(Original Language\\\\)? Please share in comments below\n\n","author":"Eugene Petrenko","date":"2016-09-02","type":"article","categories":["Kotlin","DSL"],"features":["mathjax","highlightjs"],"description":"","filename":"","lang":"EN","enclosure":null},{"title":"Exercises in Kotlin: Part 1 - Getting Started","url":"http://blog.dhananjaynene.com/2016/04/exercises-in-kotlin-part-1-getting-started/","body":"\nKotlin is an exciting new language I have been working with for a couple of months now. I believe it has a lot of features going for it, and I think many will be benefited from learning a bit more about it. Hence this series of posts.\n\nThis post helps you with getting the necessary software installed on your desktop for compiling and running kotlin code\n\n## Presumed Audience :\n\nThe reader is presumed to have a reasonable working knowledge of Java. While one of the reasons Kotlin is particularly exciting is because it is such a useful language for the Android platform, the early parts of this series shall focus on the desktop based JVMs. Since those learnings are common irrespective of whether you wish to use Kotlin for desktop/server or Android programming.\n\nIt is also assumed that the reader has working java development kit installed on his desktop. Most or all of the discussion about syntax will also likely compare Kotlin with Java.\n\n## Information :\n\nSome of the useful sites for Kotlin are\n\n* [Kotlin Programming Language](https://kotlinlang.org/) : Language Home page.\n* [Kotlin Reference](https://kotlinlang.org/docs/reference/) : Reference - Kotlin Programming Language\n* [Intellij Idea](https://www.jetbrains.com/idea/) : IDE with built in kotlin support. From the same authors who bring you kotlin, ie. JetBrains\n* [Kotlin Eclipse Plugin](https://github.com/JetBrains/kotlin-eclipse) : Kotlin plugin for eclipse. _Note: I haven't used it myself_\n\n## Getting started using an IDE\n\n_Note: if you do not prefer to use an IDE and are likely to code using text editors and build and run using command line, you can skip this section entirely and go to [Command Line Usage](#cmdline)_\n\nGo to the Intellij idea page above and download the latest version. You can choose to download the community version. It has the necessary support for Kotlin. You may alternatively choose to use the Eclipse plugin described above, but I haven't used it so cannot help with getting it to work. Install the intellij idea ide and launch it. In case unsure how to do so, consult the [official guide](https://www.jetbrains.com/help/idea/2016.1/installing-and-launching.html) for downloading, installing and launching the ide.\n\nStart a new project. Click on gradle in the left hand column. You should reach the new project dialog box as follows\n\n![Intellij Idea New Project Dialog](http://blog.dhananjaynene.com/images/kotlin/kotlin-1-new-project.png)\n\nI always use the gradle build tool, so I end up making the selections as shown. Select any appropriate JVM between 1.6 and 1.8 (built in one should do). You could use the dialog as shown above. You should next see a dialog box for groupid/artifactid as required by gradle (these mean the same thing as they do for maven, so fill up some group id eg. `com.example.kotlin` and artifactid eg. `learning`). The rest of this post assumes these two values, so if you use different values, please replace them appropriately in the code as necessary.\n\n![Specify groupid and artifactid](http://blog.dhananjaynene.com/images/kotlin/kotlin-3-groupid-artifactid.png)\n\nOn the next two screens you could choose the defaults or customise as necessary\n\n![Project Configuration](http://blog.dhananjaynene.com/images/kotlin/kotlin-4-project-config.png)\n\n![Project Configuration 2](http://blog.dhananjaynene.com/images/kotlin/kotlin-5-project-configuration-2.png)\n\nSince gradle defaults to maven like directory structures, let us create the directory necessary for our work using the groupid/artifactid used earlier and maven conventions. Select the \"_learning_\" folder at the top of the left pane, and select from main or right click menu, File -> New Directory and specify the directory as follows. (If the menu options File -> New Directory do not appear, you have selected the wrong \"_learning_\", select the one at the top of the left pane, not the one in the toolbar above it).\n\n![Create source directory](http://blog.dhananjaynene.com/images/kotlin/kotlin-6-create-directory.png)\n\nSimilarly also create another directory for writing our test cases\n\n![Create test directory](http://blog.dhananjaynene.com/images/kotlin/kotlin-7-create-test-directory.png)\n\nYou should see the appropriate packages for the main and test areas appear in the left hand pane as follows\n\n![IDE View](http://blog.dhananjaynene.com/images/kotlin/kotlin-8-ide-view.png)\n\nRight click on the package name under the src/main/kotlin directory and select \"New Kotlin File/Class\". It will pop up a dialog where you can enter helloworld\n\n![New file dialog](http://blog.dhananjaynene.com/images/kotlin/kotlin-9-new-file-dialog.png)\n\nThis will create a new file \"_helloworld.kt_\" and open it into your ide\n\n![New file](http://blog.dhananjaynene.com/images/kotlin/kotlin-10-new-file.png)\n\nEnter the following code in the just opened file\n\n```kotlin\npackage com.example.kotlin.learning\n\nfun main(args: Array<String>) {\n    println(\"Hello World!\")\n}\n```\n\nRun the program using \"Run -> Run\". It will pop up a very small dialog box, select HelloWorldKt from it. (You could also use Alt-Shift-F10 instead of Run -> Run, though not sure if the same key bindings work across operating systems, though thats what it is on Linux). This is the canonical Hello World program for Kotlin. Don't worry about understanding the syntax yet. We will get to it in the very next post, this post is to get you started.\n\nOne more thing to do is to get a sample test case running. So, let us add a function to the file we just created that we shall be testing, as follows\n\n```kotlin\nfun greetings() = \"Hello World!\"\n```\n\nNext, select the package in the src/test/kotlin directory, and after a right click select \"New -> Kotlin File/Class\". This time select the name as \"_testgreet_\", which will create a new file called _testgreet.kt_. Add the following code to the file.\n\n```kotlin\npackage com.example.kotlin.learning\n\nimport org.junit.Test\nimport org.junit.Assert.assertEquals\n\nclass TestGreet() {\n    @Test\n    fun testGreetings() {\n        assertEquals(\"Greeting should be 'Hello World!'\",\n                \"Hello World!\", greetings())\n    }\n}\n```\n\nAgain select \"Run -> Run...\" or (Alt-Shift-F10 or equivalent). This will pop up a small dialog box. Select TestGreet. This will run the test case and should show an all green bar near the bottom of your IDE as shown in the image below.\n\n![Kotlin Run Test](http://blog.dhananjaynene.com/images/kotlin/kotlin-11-run-test.png)\n\nNow, we shall repeat the exercise using text editors and command line for building and running the program. Even if you _always_ use IDEs, I very much recommend that you at least do the remainder of the activities described on this post at least once. It is always helpful to have a general sense of what is happening at a command line level. However if you skip it, or it doesn't work for you for whatever reason, it won't constrain you from being able to continue with the rest of this series.\n\nIn either case, I shall not be covering the Intellij Idea IDE any further. If you are new to it or to the Eclipse plugin, learning it is beyond the scope of this series of posts, so I encourage you to play around with them, since that is likely to be useful as we go further along in this series.\n\n## Installation for command line usage\n\nThe instructions for working with Kotlin from the command line are documented on the page [Working with the Command Line Compiler](https://kotlinlang.org/docs/tutorials/command-line.html)\n\nGoto [Kotlin latest release](https://github.com/JetBrains/kotlin/releases/latest) to download the Kotlin compiler. It will likely be a file called `kotlin-compiler-<version>.zip`. The current version is 1.0.1-2 at the point in time this post was written. Unzip the file into an appropriate directory. And ensure that the executables kotlin and kotlinc (or their windows equivalent with the .bat extensions) are in your path.\n\nCreate a work directory for this exercise and change directory to it.\n\nCreate a file _helloworld.kt_ with the following content.\n\n```kotlin\npackage com.example.kotlin.learning\n\nfun main(args: Array<String>) {\n    println(\"Hello World!\")\n}\n\nfun greetings() = \"Hello World!\"\n```\n\nCompile it using the command\n\n```bash\n$ kotlinc helloworld.kt\n```\n\nNotice that it will have created a file _com/example/kotlin/learning/HelloworldKt.class_. This is the compiled _.class_ file. It is Java byte code though you wouldn't be able to run it as you might be used to just yet. In fact go ahead and try to run it as follows\n\n```bash\n$ java com.example.kotlin.learning.HelloworldKt\n```\n\nIt will fail because you do not have the necessary kotlin runtime jar in your classpath. You should've seen an error message similar to the one below\n\n```kotlin\nException in thread \"main\" java.lang.NoClassDefFoundError: kotlin/jvm/internal/Intrinsics\n        at com.example.kotlin.learning.HelloworldKt.main(helloworld.kt)\nCaused by: java.lang.ClassNotFoundException: kotlin.jvm.internal.Intrinsics\n        at java.net.URLClassLoader.findClass(URLClassLoader.java:381)\n        at java.lang.ClassLoader.loadClass(ClassLoader.java:424)\n        at sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:331)\n        at java.lang.ClassLoader.loadClass(ClassLoader.java:357)\n        ... 1 more\n```\n\nThat runtime is located in the kotlin zip you had just downloaded. Let us point the classpath to it and attempt to run the program again. (Replace `<folder_where_you_unzipped_kotlin_zip>` below with the appropriate directory where you had unzipped the file you downloaded)\n\n```bash\n$ java -cp <folder_where_you_unzipped_kotlin_zip>/kotlinc/lib/kotlin-runtime.jar:. com.example.kotlin.learning.HelloworldKt\n```\n\nYou should see \"Hello World!\" getting printed to the console. Kotlin provides an easier way to do this as well, so let us repeat the process, just a little differently.\n\nCompile the source again, but this time create a .jar file\n\n```bash\n$ kotlinc helloworld.kt -include-runtime -d helloworld.jar\n```\n\nNow run it as follows\n\n```bash\n$ java -jar helloworld.jar\n```\n\nThe program should run and \"Hello World!\" should get printed to the console.\n\nNow let us run the test case. Create a file _testgreet.kt_ as follows\n\n```kotlin\npackage com.example.kotlin.learning\n\nimport org.junit.Test\nimport org.junit.Assert.assertEquals\n\nclass TestGreet() {\n    @Test\n    fun testGreetings() {\n        assertEquals(\"Greeting should be 'Hello World!'\",\n                \"Hello World!\", greetings())\n    }\n}\n```\n\nNow for compiling and running this you will need the jar for junit (which in turn requires hamcrest). The instructions for that are provided on the [Download and Install - junit4 wiki](https://github.com/junit-team/junit4/wiki/Download-and-Install) page. For now just go ahead and download the two following jars for junit and hamcrest.\n\n* [junit jar](http://search.maven.org/remotecontent?filepath=junit/junit/4.12/junit-4.12.jar)\n* [hamcrest jar](http://search.maven.org/remotecontent?filepath=org/hamcrest/hamcrest-all/1.3/hamcrest-all-1.3.jar)\n\nYou will have downloaded _junit-4.12.jar_ and _hamcrest-all-1.3.jar_. Move both of them into your current directory after download.\n\n```bash\n$ kotlinc helloworld.kt -cp junit-4.12.jar -include-runtime -d helloworld.jar\n```\n\n```bash\n$ java -cp junit-4.12.jar:hamcrest-all-1.3.jar:helloworld.jar org.junit.runner.JUnitCore com.example.kotlin.learning.TestGreet\n```\n\nYou should see something like the follows (the time obviously could vary) that indicates success.\n\n```kotlin\nJUnit version 4.12\n.\nTime: 0.004\n\nOK (1 test)\n```\n\nYou should also be aware that Kotlin has a REPL that you can run using the command `kotlinc-jvm` as follows\n\n```kotlin\n$ kotlinc-jvm\nWelcome to Kotlin version 1.0.1-2 (JRE 1.8.0_77-b03)\nType :help for help, :quit for quit\n>>> println(\"Hello World!\")\nHello World!\n>>>\n```\n\nCongratulations you are now able to compile and run Kotlin programs. In the next post in this series, we shall attempt to understand the code that we just wrote, and explore the Kotlin language further.\n\n","author":"Dhananjay Nene","date":"2016-04-18","type":"article","categories":["Kotlin"],"features":["highlightjs"],"description":"","filename":"","lang":"EN","enclosure":null},{"title":"Kotlin 1.0: The good, the bad and the evident.","url":"https://jaxenter.com/kotlin-1-0-the-good-the-bad-and-the-evidence-124041.html","body":"\n\nKotlin 1.0 is a programming language made by JetBrains, the creator of the popular IntelliJ IDEA development environment. This programming language for the JVM and Android focuses on safety, interoperability, clarity and tooling support and combines OO and functional features.\n\nAfter a long wait, Kotlin 1.0 is finally here! According to the [official announcement](http://blog.jetbrains.com/kotlin/2016/02/kotlin-1-0-released-pragmatic-language-for-jvm-and-android/), ” Kotlin works everywhere where Java works: server-side applications, mobile applications (Android), desktop applications. It works with all major tools and services such as IntelliJ IDEA, Android Studio and Eclipse, Maven, Gradle and Ant, Spring Boot, GitHub, Slack and even Minecraft.”\n\nInteroperability and seamless support for mixed Java+ Kotlin projects has been a focal point in the making of this project. Adoption is easier, which leads to less boilerplate code and more type-safety. Plus, the new programming language has a huge standard library which makes daily tasks not only easy, but also smooth while maintaining the byte code footprint low. Kotlin has been dubbed a ‘pragmatic’ programming language because in its creation developers focused on use cases to transform it into a good tool. Utility was the idea behind Kotlin 1.0, as emphasized by Andrey Breslav, the lead language designer of Kotlin: ” the less our users have to re-learn, re-invent, re-do from scratch, the more they can re-use, the better.”\n\nBreslav explained that Kotlin 1.0 is mature enough and ready for production because the team has been using it in real-life projects on a broad scale over the past couple of years and pointed out that a handful of other companies have been using this new programming language in production “for some time now.”  The lead language designer of Kotlin revealed that the reason why it took so long for them to produce 1.0 was that they paid extra attention to validating their design decision in practice.\n\nThe team has kept Kotlin’s development very open since 2012 and has continuously talked to the community, collecting and addressing lots of feedback. Breslav announced that they are planning to establish a centralized venue for design proposals and discussions in order to make the process even more organized and visible. The team’s goals in the near future are to offer constant performance improvements for the Kotlin toolchain, JavaScript support and support generating Java 8 byte code.\n\n## The good about Kotlin\n\nMike Hearn, a former bitcoin core developer who recently made waves when he declared that the bitcoin project had “failed”, wrote in a post on [Medium](https://medium.com/@octskyward/why-kotlin-is-my-next-programming-language-c25c001e26e3#.w9lbw7fso) last July that Kotlin is the programming language he will probably use for the next five to 10 years. He opined that Kotlin is “of greatest interest to people who work with Java today, although it could appeal to all programmers who use a garbage collected runtime, including people who currently use Scala, Go, Python, Ruby and JavaScript.”\n\nAccording to Hearn, this programming language “comes from industry, not academia and solves problems faced by working programmers today.” It is open source, approachable and can be learned in a few hours by reading the language reference. “The syntax is lean and intuitive. Kotlin looks a lot like Scala, but is simpler,” he added. It allows developers to continue to use their productivity enhancing tools and adopting it is low risk because “it can be trialled in a small part of your code base by one or two enthusiastic team members without disrupting the rest of your project.”\n\n## The bad: pre-1.0\n\nAs Breslav remarked in the official announcement, the team took their time before they released Kotlin 1.0 because they paid extra attention to validating their design decision on practice. Therefore, all the problems pointed out by Hearn in his review of Kotlin should not exist anymore now that Kotlin 1.0 has been released. The former bitcoin core developer pointed out that Kotlin’s biggest problems were its immaturity (because it was a pre 1.0 language) and that sometimes the requirements of Java interop resulted in unintuitive limitations.\n\nHearn also criticized the size of the community, which was smaller at that time. However, according to Breslav, over 11.000 people were using Kotlin last month and almost 5.000 earlier this month. Plus, there is a growing list of companies using Kotlin, including Expedia and Prezi.\n\nLanguage docs and tutorials can be found on the [official website](https://kotlinlang.org/).\n\n","author":"Gabriela Motroc","date":"2016-02-16","type":"article","categories":["Kotlin","Review"],"features":["highlightjs"],"description":"","filename":"","lang":"EN","enclosure":null},{"title":"Kotlin: Practical Experience","url":"http://blog.scottlogic.com/2016/04/04/practical-kotlin.html","body":"\nKotlin 1.0.0 was officially released in February this year. Kotlin is a new language from JetBrains (of IntelliJ IDEA and ReSharper fame). It was originally announced in 2011 when a development version was made available to the public. While it can be compiled to JavaScript, the primary target is the JVM, and one of its core goals is 100% Java interoperability.\n\nI have spent some time recently experimenting with Kotlin. There are many features of the language to enjoy when comparing against Java, terseness being high in the list. However, this post primarily serves to highlight a few gotchas that caught me out in the hopes that others may save some time when dealing with similar issues. While this may seem a slightly negative approach for a blog post, my goal is to offer a more practical take instead of only mentioning all the cool things you can do.\n\nI really like Kotlin, I think it has a place in Java development regardless of whether you’re writing server-side or client-side, and regardless of your Java version. Kotlin’s internal API is based on Java 6 which allows Kotlin to be compatible with Android.\n\n## Java 8 Compatibility\n\nAs mentioned, Kotlin is internally dependent on Java 6, which places restrictions on what Java library types and language features Kotlin itself can use. This means any new types and methods added in Java 7 or 8 are not available to the Kotlin standard library, however if your target VM is Java 8 then your Kotlin code can make use of the newer Java features.\n\n### Java 8 Streams\n\nA major addition that was introduced by Java 8 was the Stream API. This API typically makes full use of Java 8’s lambdas to allow users to write code similar to .NET’s LINQ. Since Kotlin is compatible with Java 6, they offer an equivalent through their standard library so that it is available regardless of the underlying version of Java. Below is a simple comparison of the Java 8 stream API and Kotlin’s equivalent standard library:\n\n```java\nList<Integer> list = new ArrayList<>();\nfor (int i = 0; i < 50; i++) {\n    list.add(i);\n}\n\nList<Integer> filtered = list.stream()\n        .filter(x -> x % 2 == 0)\n        .collect(toList());\n```\n\n```java\nval list = (0..49).toList()\nval filtered = list\n        .filter( { x -> x % 2 == 0 } )\n```\n\nThere are a few things about Kotlin lambdas that I found confusing at first. Lambdas must always appear between curly brackets. This can make the lambda look like a standard block, but once you get used to it, it starts to make sense. There are a few special cases that can be applied to the code above to simplify it further. If the last argument to a method is a lambda, then the lambda definition can be moved outside of the method parentheses, and if the remaining method parentheses are then empty, they can be removed. Furthermore, if the lambda has a single parameter then the parameter declaration can be removed along with the arrow, and the parameter can be referred to by `it`. Applying these rules to the code above simplifies it as follows:\n\n```kotlin\nval list = (0..49).toList()\nval filtered = list\n        .filter { it % 2 == 0 }\n```\n\nA key thing to be aware of is that the code shown above is entirely implemented by the Kotlin standard libraries and is therefore independent of Java 8 streams. This is achieved through standard library extension methods.\n\n#### Lazy Streams\n\nThere are subtle differences between the Java and Kotlin code above. Java is using lazy streams - the filter lambda is only applied once the call to `collect` is made. The Kotlin example however is eager, which is why the call to filter immediately returns a list.\n\nThere are ways to make Kotlin lazy, the main option would be to first convert the list to a `Sequence` and apply the lambdas to that instead. Sequences are evaluated lazily allowing a pipeline to be defined before the underlying lambdas are executed. The Kotlin code would then be as follows:\n\n```kotlin\nval list = (0..49).toList().asSequence()\n    .filter { it % 2 == 0 }\n    .toList()\n```\n\nThis is only worth considering if the pipeline consists of more than the filter operation.\n\n#### Parallel Streams\n\nSomething I ran into was the wish to use Java 8’s parallel streams. Kotlin’s standard library does not include its own parallel stream mechanism, and it is not clear where to start when consulting Kotlin’s standard library.\n\nIn Java one would either call `List.parallelStream()` or call `parallel()` directly on a stream. The subsequent pipeline will then be applied in parallel, and the results collected at the end. The issue is that typically in Kotlin lists are referenced via the Kotlin collection interfaces, even if the runtime instances are actually plain Java classes. This means the following code would not compile because the Kotlin collection interfaces do not know about the `stream()` methods or `Stream` interface.\n\n```kotlin\nlistOf(\"One\", \"Two\", \"Three\").parallelStream()\n```\n\nConsidering these are Java 8 classes means it’s not surprising that there is currently no way for Kotlin to include a stream equivalent in their standard library - doing so would require them to reimplement a Kotlin stream equivalent for supporting Java 6 and 7, and then somehow have it use Java 8’s Stream API if running under a Java 8 VM. In fact Kotlin used to have their own `Stream` type before Java 8, but replaced it with `Sequence` shortly before finalising the 1.0.0 release.\n\nOne workaround is to implement extension methods for the `kotlin.collections.Collection` interface as follows:\n\n```kotlin\nfun <T> Collection<T>.stream(): Stream<T> {\n    @Suppress(\"PLATFORM_CLASS_MAPPED_TO_KOTLIN\", \"UNCHECKED_CAST\")\n    return (this as java.util.Collection<T>).stream()\n}\n\nfun <T> Collection<T>.parallelStream(): Stream<T> {\n    @Suppress(\"PLATFORM_CLASS_MAPPED_TO_KOTLIN\", \"UNCHECKED_CAST\")\n    return (this as java.util.Collection<T>).parallelStream()\n}\n```\n\nThis will allow the `stream()` and `parallelStream()` methods to be invoked directly on any Kotlin collection. Note the nasty suppression of warnings though. Firstly IDEA provides a generally good hint that you should probably not be using the `java.util.Collection` class directly - this is because it is normally hidden behind the Kotlin collection interfaces. The second warning is the unchecked cast which is unavoidable - the main issue is the generic type T which has been erased by Java. It is not possible to use Kotlin’s inlined reification feature in these methods either because we’re referring to the Java type that is already erased. This workaround is referenced from a [bug-report](https://youtrack.jetbrains.com/issue/KT-5175) posted for Java 8 streams on Kotlin’s bug tracker. This issue was posted when Kotlin still had its own `Stream` class. While the issue is not resolved (a subsequent release of Kotlin may see a more elegant solution), the removal of Kotlin’s `Stream` class makes the above workaround possible.\n\nAnother issue arises when collecting the results. In Java I would collect a stream to a list using `collect(Collectors.toList())`, Java is usually able to infer the types correctly, however because we’re using Kotlin which defines its own collection types, things are not as smooth. Here is a function definition that uses the `stream()` extension method defined above:\n\n```kotlin\nfun toIntList(strings:List<String>):List<Int> {\n    return strings.stream()\n        .map { it.toInt() }\n        .collect(Collectors.toList<Int>())\n}\n```\n\nThe trick is to just make the type explicit when using `Collectors.toList`. There are some alternative workarounds posted to this [Stack Overflow question](http://stackoverflow.com/questions/35721528/how-can-i-call-collectcollectors-tolist-on-a-java-8-stream-in-kotlin/35722167#35722167). The update message posted claiming the issue is fixed in Kotlin 1.0.1 is not entirely accurate - I still find I need to make the types explicit when using collectors.\n\n### SAM Types\n\nA nice feature demonstrated in the above code is the fact that Kotlin lambdas are compatible with Java’s Single Abstract Method (SAM) interfaces. This can be seen above where a Kotlin lambda is supplied directly to Java’s `Stream.map` method. The Kotlin compiler automatically generates an adapter function to convert the Kotlin lambda to the desired SAM interface type. Sometimes however this requires a bit of assistance, especially to resolve ambiguity. An example is when using Java 8’s `CompletebleFuture`:\n\n```kotlin\nfun get(url:String, ex: Executor):CompletableFuture<String> {\n    return CompletableFuture.supplyAsync( Supplier { downloadURL(url) }, ex)\n}\n```\n\nThis method takes a string and Java executor, and returns a `CompletableFuture` containing the URL’s content. It assumes there is a synchronous `downloadURL` method available. Because the `supplyAsync` Java method takes the lambda as the first parameter, followed by the executor parameter, we can’t use the Kotlin shortcut of pushing the lambda outside of the `supplyAsync` parentheses. To create the correct SAM we prefix the Kotlin lambda with the name of the SAM type we require - in this case a `java.util.function.Supplier`.\n\n### Try-with-resources\n\nThis is actually a Java 7 feature, but still applies when using Java 8. In Java we may do the following to copy from an input stream to an output stream. This example relies on Guava to save some nasty iteration, but demonstrates how in Java we can declare multiple `AutoCloseable` instances in a single try-with-resources declaration. When the try block completes, `AutoCloseable.close()` will be called on each reference.\n\n```kotlin\ntry (InputStream input = new FileInputStream(\"SourceFile\"); OutputStream output = new FileOutputStream(\"TargetFile\")) {\n    ByteStreams.copy(input, output); // using Guava\n}\n```\n\nKotlin’s approach is not to add special language constructs, but instead to provide an API: `use()` is simply an extension method on `Closeable`. The following code is the Kotlin equivalent:\n\n```kotlin\nFileInputStream(\"SourceFile\").use { input ->\n    FileOutputStream(\"TargetFile\").use { output ->\n        input.copyTo(output)\n    }\n}\n```\n\nNote that we have to nest the second `use` method call to include the second resource declaration, which also means we can’t use the implicit `it` parameter because we have to differentiate between `input` and `output`.\n\nWe also cannot use `AutoCloseable` which was only introduced in Java 7, so this restricts the usage to `Closeable` implementations only. The only workaround for the `AutoCloseable` case at the moment is to implement one’s own `use` extension method for `AutoCloseable`. JetBrains have indicated they are looking at this, though this goes back at least to 2014. I guess it wasn’t seen as something that had to be fixed by 1.0.0, especially since a proper fix introduces the need for Kotlin to be able to target newer versions of Java as well as keep working for Java 6.\n\nAnother issue is that `use` is currently not able to use `Throwable.addSuppressed(Thowable)` for the case where an Exception is being thrown but the close call in the finally block throws its own exception, because this method was also only added in Java 7 specifically for supporting the try-with-resources construct. The source for Kotlin’s `use` includes a TODO item for this and correctly swallows the exception from close so that it doesn’t mask the original exception, hopefully a better solution will be forthcoming. This issue is [discussed here](https://discuss.kotlinlang.org/t/kotlin-needs-try-with-resources/214).\n\n## Java Annotations\n\nThis is one particular case I encountered when trying to use Java’s XML binding API (JAXB), however this would affect other annotation processing libraries as well.\n\nConsider the following Kotlin class:\n\n```kotlin\n@XmlRootElement(name = \"contact\")\ndata class Contact(\n        @XmlAttribute var firstName:String? = null,\n        @XmlAttribute var lastName: String? = null\n)\n```\n\n\nI have already tried to cover the basics: by making all the fields nullable and providing null as the default argument, the resulting class will have an empty constructor, as required by JAXB. I have also annotated the root element, and the attributes. But when I try and parse an XML file, I see the following trace:\n\n```kotlin\nException in thread \"main\" com.sun.xml.internal.bind.v2.runtime.IllegalAnnotationsException: 2 counts of IllegalAnnotationExceptions\nClass has two properties of the same name \"firstName\"\n    this problem is related to the following location:\n        at public final java.lang.String blog.Contact.getFirstName()\n        at blog.Contact\n    this problem is related to the following location:\n        at private java.lang.String blog.Contact.firstName\n        at blog.Contact\nClass has two properties of the same name \"lastName\"\n    this problem is related to the following location:\n        at public final java.lang.String blog.Contact.getLastName()\n        at blog.Contact\n    this problem is related to the following location:\n        at private java.lang.String blog.Contact.lastName\n        at blog.Contact\n```\n\nIt looks like the attribute annotation is being applied to both the public getter as well as the private field, for both the `firstName` and `lastName` properties. This is primarily fallout from Kotlin’s conciseness. In the `Contact` class above, the parameters are both constructor arguments as well as property declarations. Since a Kotlin property will be compiled into a getter, setter and backing field, the annotations are applied based on a choice from the Target annotation from the underlying annotation implementation. The best workaround here was to be explicit about what the `XmlAttribute` annotation should apply to - this can be done using annotation use-site targets as follows:\n\n```kotlin\n@XmlRootElement(name = \"contact\")\ndata class Contact(\n        @get:XmlAttribute var firstName:String? = null,\n        @get:XmlAttribute var lastName: String? = null\n)\n```\n\nInserting `get:` before the annotation name will apply the annotation to the Java getter method, and this resolves the annotation/field clash. The full list of use-site targets can be found [here](https://kotlinlang.org/docs/reference/annotations.html#annotation-use-site-targets).\n\nOne more thing I found - for this simple case it is possible to fix the issue by adding `@XmlAccessorType(XmlAccessType.FIELD)` to the root element instead, however once I had more complex XML the `IllegalAnnotationsException` would just be pushed down to one of the deeper classes.\n\n## Type-Safe Builders\n\nOne of the features of Kotlin that caught my eye at the start was the concept of type-safe builders. The example included in the [official documentation](https://kotlinlang.org/docs/reference/type-safe-builders.html) shows how an HTML document can be built. Once you have the builder code in place, you can use it as follows:\n\n```kotlin\nval html = html {\n    head {\n        title { +\"Document Title\" }\n    }\n    body {\n        h1 { +\"A Nice H1 Heading\" }\n        p {\n            +\"The wordy first paragraph including a \"\n            a(href = \"http://kotlinlang.org\") { +\"link\" }\n            b { +\" as well as some bold text\" }\n        }\n    }\n}\n```\n\nI liked this because the structure of the resulting document was reflected in the structure of the code. This is made possible by a combination of features:\n\n*   Lambdas must always be defined between curly braces.\n*   If the last argument to a method is a lambda, it can be appended after the method parentheses (which in turn can be omitted when empty).\n*   _Function type with receiver_ lambda arguments.\n\nLooking at the example code again in light of these 3 features, the code is actually just a set of nested method invocations taking a lambda as a parameter. Each lambda is a function type with receiver, which is similar to an extension function. The receiver (`this`) can be optionally omitted as it can with an extension method.\n\nIt took me a bit of effort to understand initially, so I suggest reading the official documentation to get a better idea. Once I understood the underlying concepts I was ready to start writing my own set of builders to support creation of a UI. This is where I came up against an issue with the type-safe builder pattern.\n\nThe issue is as follows - each time you define a nested lambda, it collects the scope of its parent invocations - all the way to the root. In the html example above, it means that the following will compile and generate no warnings, but the result will be confusing:\n\n```kotlin\nhtml {\n    head {\n        title { +\"Document Title\" }\n    }\n    body {\n        h1 { +\"A Nice H1 Heading\" }\n        p {\n            +\"The wordy first paragraph including a \"\n            body {\n                h1 { +\"This is unexpected\" }\n            }\n            a(href = \"http://kotlinlang.org\") { +\"link\" }\n            b { +\" as well as some bold text\" }\n        }\n    }\n}\n```\n\nYou can see I’ve added an extra `body` call within the deepest `p`. From thinking of this as a type-safe builder of an html document, this should not be possible, since it should not be possible to add a body element at that level. It would be nice if compilation failed. However, if we forget about the html side of things, and just think of this as a bunch of nested closures, then it makes sense. A closure has access to the variables of the outer scope in addition to the current scope. This nested closure effectively has implicit access to all the `this` keywords up the chain. If we explicitly insert the qualified `this` keywords, it looks as follows:\n\n```kotlin\nhtml {\n    this.head {\n        this.title { +\"Document Title\" }\n    }\n    this.body {\n        this.h1 { +\"A Nice H1 Heading\" }\n        this.p {\n            +\"The wordy first paragraph including a \"\n            this@html.body {\n                this.h1 { +\"This is unexpected\" }\n            }\n            this.a(href = \"http://kotlinlang.org\") { +\"link\" }\n            this.b { +\" as well as some bold text\" }\n        }\n    }\n}\n```\n\n\nYou can see the qualified `this@html` reference - this is also implicitly available, but the point is that the second `body` invocation is actually being made against the root html instance, and not against the the paragraph instance that is implied. This leads to the following html document being generated:\n\n```html\n<html>\n  <head>\n    <title>\n      Document Title\n    </title>\n  </head>\n  <body>\n    <h1>\n      This is unexpected\n    </h1>\n  </body>\n  <body>\n    <h1>\n      A Nice H1 Heading\n    </h1>\n    <p>\n      The wordy first paragraph including a\n      <a href=\"http://kotlinlang.org\">\n        link\n      </a>\n      <b>\n         as well as some bold text\n      </b>\n    </p>\n  </body>\n</html>\n```\n\nThe reason the second `body` actually appears first is because the nested body is completed (and added to the document) before the first `body` is completed. This is confusing behaviour and is unfortunately simply the result of Kotlin’s closures behaving correctly. A workaround may be to prefix all the invocations by the unqualified `this` keyword. If you do this you will find a compiler error is then generated when you try make a call to `this.body` from inside `p`, however the resulting code looks messier, and it is still possible to forget the `this` prefix.\n\nI’ve only found the following Stack Overflow question and answer [here](http://stackoverflow.com/questions/34834739/wrong-this-being-used-in-nested-closures#34836287), where the principle engineer at JetBrains confirms the issue, and hints that a future Kotlin version may add a modifier to restrict a lambda from having access to enclosing scopes.\n\nI may wait and see where this goes before embracing type-safe builders. I like the idea - especially how it could be used to implement a DSL for creating a UI, however I think this would cause a usage issue.\n\n## Conclusion\n\nOverall I have had a very positive experience. I quickly adapted to the Kotlin syntax and enjoyed using it. The issues I’ve raised in this post should not be viewed in a negative light - for every issue I’ve raised here there are countless times I found myself impressed at how Kotlin integrates cohesively with Java. My main reason for creating this post is to collect my experiences for future reference, and hopefully to help people who run into the same issues.\n\n\n\n","author":"Allen Wallis","date":"2016-04-04","type":"article","categories":["Kotlin"],"features":["highlightjs"],"description":"","filename":"","lang":"EN","enclosure":null},{"title":"Performance comparison - building Android UI with code (Anko) vs XML Layout.","url":"https://nethergrim.github.io/performance/2016/04/16/anko.html","body":"\nHi!\n\nThis is my first blog post.\n\n## Intro\n\nHere I will be talking about difference in performance between using XML layouts and [_Anko_](https://github.com/Kotlin/anko) to build UI for _Android_ apps.\n\nAs you may know, _Anko_ is a new DSL for Android, written in [_Kotlin_](https://kotlinlang.org/). It helps a lot to develop _Android_ apps using _Kotlin_ lang. _Anko_ provides various handy features, and my favorite is building ui with code. Yeah, you can tell me that we can also build user interface using _Java_, and create all Views in code, but it is ugly and hard to maintain.\n\n## The problem\n\nBy default, UI in _Android_ is built using XML layout files. This is inconvenient because it is not typesafe, not null-safe, and it leads to overhead in **cpu** and **ram** usage. It can be insensibly for fast and powerful devices, but low-end devices may suffer from resources deficit. The more Views you have in your xml layout file, the more time it takes to:\n\n* inflate view from XML file\n* create view objects\n* find views by id with [_findViewById_](http://developer.android.com/intl/ru/reference/android/view/View.html#findViewById(int))\n\nNow imagine, that you need to perform that actions for multiple layouts, for example if you need to display list of items. In this case android will perform every step of those 3, for every list item in your UI. It will be even worse if every list item have more than 5-7 views. More views you have, more time it takes to display them.\n\nBy using _Anko_ (or creating Views programmatically, even with _Java_) we can remove 2/3 of that work:\n\n* ~~inflate view from XML file~~\n* create view objects\n* ~~find views by id with [_findViewById_](http://developer.android.com/intl/ru/reference/android/view/View.html#findViewByIdn(int))~~\n\nAlso it is easy to create UI with _Anko_, if you’re familiar with android _Layouts_.\n\n## Benchmark\n\nFor benchmark i will use two Activities, with two similar lists of users. I think it is a typical case for _Android_ apps. For every list item i will be using RelativeLayout with 4 views inside:\n\n* user avatar (using [_Fresco_](http://frescolib.org/))\n* user name\n* user title\n* last seen date\n\nAfter that i will measure [_onCreateViewHolder_](http://developer.android.com/intl/ru/reference/android/support/v7/widget/RecyclerView.Adapter.html#onCreateViewHolder) method execution time for every item.\n\n![device](https://cloud.githubusercontent.com/assets/5869863/14586400/8b257a58-049f-11e6-8e72-14f78753c53b.png)\n\n### Benchmark results\n\nWell, i tested both cases on these devices:\n\n* android emulator on MacBook pro 15 2015\n* Meizu mx-5\n* THL w8 (low end)\n* Nexus 6 Marshmallow\n* Meizu mx-4\n* Samsung Galaxy S2 Plus\n* Samsung Galaxy S3\n* Samsung Galaxy J5\n\nAll values are in milliseconds, that needed for _onCreateViewHolder_ method to execute inside the RecyclerView adapter.\n\n> Please note that frames on Android are drawing every 16 milliseconds, and if any frame will not be able to draw in that period, it will draw after 32/48/64... ms, and this is called dropped frames. So every time your frame takes >16ms to draw, it is dropped. Also note that your UI thread will have more work than just drawing frames, it need to handle all user input, and execute all of your code too. It means that less milliseconds to draw is better for us.\n\nAnd here is what i got:\n\n![2016-04-18 17 13 40](https://cloud.githubusercontent.com/assets/5869863/14607128/f77fa9b4-0588-11e6-9fcc-4884ad6d709a.png)\n\n[Macbook XML results](https://cloud.githubusercontent.com/assets/5869863/14587122/984e5338-04b5-11e6-8dd3-f953a0c2d03a.png) * [Macbook Coded results](https://cloud.githubusercontent.com/assets/5869863/14587125/b5fb4332-04b5-11e6-9b59-71c38f5bd2d0.png)\n\n[Meizu MX5 XML results](https://cloud.githubusercontent.com/assets/5869863/14587130/c8315e24-04b5-11e6-84d7-8a943e386691.png) * [Meizu MX5 Coded results](https://cloud.githubusercontent.com/assets/5869863/14587140/0143ddf4-04b6-11e6-98dd-940e89ae141e.png)\n\n[Thl W8 XML results](https://cloud.githubusercontent.com/assets/5869863/14587146/2fe107ae-04b6-11e6-8f25-5bc901d88780.png) * [Thl W8 Coded results](https://cloud.githubusercontent.com/assets/5869863/14587153/42b90c8c-04b6-11e6-8fba-6f8fec4c0b75.png)\n\n[Nexus 5 XML results](https://cloud.githubusercontent.com/assets/5869863/14587159/54031f5a-04b6-11e6-9b18-3ebd6b1e7a90.png) * [Nexus 5 Coded results](https://cloud.githubusercontent.com/assets/5869863/14587160/617e05aa-04b6-11e6-8082-ee802e5ebf4d.png)\n\n[Meizu MX4 XML results](https://cloud.githubusercontent.com/assets/5869863/14587163/75c93db8-04b6-11e6-870c-44dfcda0dc0e.png) * [Meizu MX4 Coded results](https://cloud.githubusercontent.com/assets/5869863/14587167/87feb06c-04b6-11e6-9b90-8c7549554292.png)\n\n[Galaxy S2 Plus XML results](https://cloud.githubusercontent.com/assets/5869863/14607148/10f5da3a-0589-11e6-8493-e81a92dddd38.png) * [Galaxy S2 Plus Coded results](https://cloud.githubusercontent.com/assets/5869863/14607158/1b9d5d32-0589-11e6-8185-db11a263e2ca.png)\n\n[Galaxy J5 XML results](https://cloud.githubusercontent.com/assets/5869863/14602312/e072d2be-056f-11e6-9ec0-2a23799b6911.png) * [Galaxy J5 Coded results](https://cloud.githubusercontent.com/assets/5869863/14602328/f7fb5d84-056f-11e6-86fd-1d0169a0ef45.png)\n\n[Galaxy S3 XML results](https://cloud.githubusercontent.com/assets/5869863/14602338/0bbfc29c-0570-11e6-9189-977387de5c3d.png) * [Galaxy S3 Coded results](https://cloud.githubusercontent.com/assets/5869863/14602353/1d4b2498-0570-11e6-858c-586957d4784b.png)\n\n## Conclusion\n\nAs I thought, building User Interface on Android is faster with code, than with XML layout files. And this is true for all kind of devices/sdk’s.\n\nWe can see up to **300%** performance boost here.\n\nThere is not a big (relatively) boost on high-end devices, but low-end devices can have huge boost using coded ui.\n\n_Should we use coded UI everywhere?_ - **Only if you are using Kotlin, and you have some extra time for optimizations**\n\n_Should we use it if we have large amount of Views into single list item?_ - I would say **YES**\n\n_Should we use it if our customer has low-end device, and says that app is freezing all the time?_ - Answer will be **yes** too.\n\nSource code can be found [HERE](https://github.com/nethergrim/anko_benchmark)\n\nP.S. You can try that benchmark by **yourself**, on your device. Just check the [repo](https://github.com/nethergrim/anko_benchmark)\n\n\n","author":"Andrew Drobyazko","date":"2016-04-16","type":"article","categories":["Kotlin","Anko","Android"],"features":["highlightjs"],"description":"","filename":"","lang":"EN","enclosure":null},{"title":"Costruiamo un treno in Kotlin","url":"https://www.youtube.com/watch?v=y-T6DCtNUG0","body":"\nDopo cinque anni di sviluppo JetBrains rilascia la prima versione di Kotlin, linguaggio staticamente tipizzato che pur rimanendo pienamente compatibile con Java cerca di risolverne alcuni problemi tutt'ora aperti. Presenterò un semplice programma realizzato con approccio OO/funzionale e confronteremo l'implementazione Java 8 con quella Kotlin.\n\nFrancesco Vasco: Lavoro da 16 anni in varie realtà utilizzando prevalentemente tecnologie in ambito Java e da febbraio ho iniziato ad utilizzare Kotlin sia in campo amatoriale che professionale.\n\n[JUG Milano meeting #86](http://www.jugmilano.it/meeting-86.html)\n\n<iframe width=\"960\" height=\"480\" src=\"https://www.youtube.com/embed/BUAxqiGrKOc\" frameborder=\"0\" allowfullscreen></iframe>\n","author":"Francesco Vasco","date":"2016-12-19","type":"video","categories":["Kotlin"],"features":["highlightjs"],"description":"","filename":"","lang":"IT","enclosure":null},{"title":"Kotlin: New Hope in a Java 6 Wasteland","url":"https://speakerdeck.com/pardom/kotlin-new-hope-in-a-java-6-wasteland","body":"\n\n[Slides](https://speakerdeck.com/pardom/kotlin-new-hope-in-a-java-6-wasteland)\n\n","author":"Michael Pardo","date":"2015-05-09","type":"slides","categories":["Kotlin","Android"],"features":["highlightjs"],"description":"","filename":"","lang":"EN","enclosure":null},{"title":"More Kotlin Extension Fun","url":"http://oneeyedmen.com/more-kotlin-extension-fun.html","body":"\nThis is a follow-up to my last post, [Extension Functions Can Be Utility Functions](http://oneeyedmen.com/extension-functions-can-be-utility-functions.html). Here I’ll look at more pros and cons of extension functions.\n\nThe article brought out 3 extension function use-cases.\n\n1.  Adding a little local expressiveness with private methods like `JsonNode.toAddress()`\n2.  Adding methods you wish were available on types that you don’t own - `JsonNode.getNonBlankText(name: String)`\n3.  Keeping your own classes small by defining operations as extension functions rather than actual methods - `AccessType.toUIString()`\n\nOn the Kotlin Slack Channel, Daniel Wellman asked\n\n_“How do you decide when methods should be extension functions and when they should be members (functions) on classes/objects _that you own_?”_\n\nNathan Armstrong replied\n\n_“I think it’s usually when it encapsulates operations on a type in some context tangential to the one the type was made for. For example, when writing code that intersects two domains or concerns, using extension methods can help you use your existing types more naturally alongside one another without leaking that local utility into other parts of the codebase”_\n\nHe’s right. So right that I’m going to say that again with many more words and claim the credit.\n\nMost of my Java projects have ended up with a package of domain objects - `Person`, `Address` etc. Kotlin makes these nice and simple with data classes, and when 1.1 allows inheritance these will become even more useful.\n\nOver time these classes accrete operations that make sense to our application. Things like `Person.asJson()` and `Address.isCloseMyHouse()`. These operations dilute the essence of the class for our happy convenience, but after a while we can’t see the platonic wood for expedient trees.\n\nExtension functions let us express the PersonNess in the `Person` class, and the JSONness elsewhere. In this case maybe type-classes would be better, but for now, we can move our JSON writing and useful-to-us-but-not-really-essential operations off of the class and into extension functions.\n\nA nice side-effect of this is that we can build our domain classes in a module that doesn’t have dependencies on Jackson and some SQL library and the whole of the rest of our app. Maybe we’ll finally get reuseable abstractions for those fundamental real-world things that every app has to implement from scratch because of all the special cases that define our Customer rather than yours.\n\nA word of warning though. Extension functions are not polymorphic. If I have\n\n```kotlin\nclass Person\n\nclass Customer: Person\n\nfun Person.toJson() = ...\n\nfun Customer.toJson() = ...\n```\n\nthe bindings are as follows:\n\n```kotlin\nPerson().toJson() // calls Person.toJson()\n\nCustomer().toJson() // calls Customer.toJson()\n\nval person: Person = readCustomer(42)\nperson.toJson() // calls Person.toJson() no matter what the actual type of person\n```\n\nIf you like this, [Nat Pryce](http://www.natpryce.com) and I are going to be talking about Expressive Kotlin at the [Kotlin Night London](https://info.jetbrains.com/Kotlin-Night-London.html) next Wednesday, 12 October 2016.\n\nThanks to [Springer Nature](http://www.springernature.com) for allowing me to publish examples from their code. If you’re looking for a Kotlin job in London, they are hiring - please contact me using one of the links in the sidebar.\n\n","author":"Duncan McGregor","date":"2016-10-06","type":"article","categories":["Kotlin"],"features":["highlightjs"],"description":"","filename":"","lang":"EN","enclosure":null},{"title":"Kotlin 1.1 Released with JavaScript Support, Coroutines and more","url":"https://blog.jetbrains.com/kotlin/2017/03/kotlin-1-1/","body":"\nMembers of our community have translated this blog post into several languages:\n[![](https://i1.wp.com/emojipedia-us.s3.amazonaws.com/cache/82/1a/821aaf51852412ffcf042c2f2a61309e.png?w=25&ssl=1)](https://medium.com/@walmyrcarvalho/kotlin-1-1-suporte-a-javascript-co-rotinas-e-mais-d84b65ac2f92)\n[![](https://i1.wp.com/emojipedia-us.s3.amazonaws.com/cache/51/a3/51a3fcf2d2c44c34bd3d4a90fff477f8.png?w=25&ssl=1)](http://www.weibo.com/ttarticle/p/show?id=2309404081257721035952)\n[![](https://i1.wp.com/emojipedia-us.s3.amazonaws.com/cache/31/7a/317a88ee3fdec119bfbd5f69a6bf35b1.png?w=25&ssl=1)](https://medium.com/@gz_k/kotlin-1-1-javascript-coroutines-et-plus-ce2eb3d7004)\n[![](https://i2.wp.com/emojipedia-us.s3.amazonaws.com/cache/a4/0d/a40df75ad96b0d143df710080c710f0f.png?w=25&ssl=1)](https://blog.jetbrains.com/jp/2017/03/01/739)\n[![](https://i0.wp.com/emojipedia-us.s3.amazonaws.com/cache/f8/e1/f8e14a4d5c26dedc5b0639ca763bc03a.png?w=25&ssl=1)](http://kotlin.kr/2017/03/01/kotlin-1-dot-1.html)\n[![](https://i2.wp.com/emojipedia-us.s3.amazonaws.com/cache/80/da/80da132bc3307d3d2ac0729493eb4c26.png?w=25&ssl=1)](https://habrahabr.ru/company/JetBrains/blog/323012/)\n[![](https://i2.wp.com/emojipedia-us.s3.amazonaws.com/cache/77/3e/773e66b858a69ddbade6951fdb012949.png?w=25&ssl=1)](http://kotlin.es/2017/03/1.1.0/)\n\nToday we release Kotlin 1.1. It’s a big step forward enabling the use of Kotlin in many new scenarios, and we hope that you’ll enjoy it.\n\n![Kotlin 1.1](https://d3nmt5vlzunoa1.cloudfront.net/kotlin/files/2017/03/Kotlin11blogbanner1.png)\n\nOur vision for Kotlin is to enable the use of a single expressive, performant, strongly typed language across all components of a modern application. Kotlin 1.1 makes two major steps towards this goal.\n\nFirst, the _JavaScript target_ is no longer experimental, and supports all Kotlin language features, a large part of the standard library, as well as JavaScript interoperability. This allows you to migrate the browser frontend of your applications to Kotlin, while continuing to use modern JavaScript development frameworks such as React.\n\nSecond, we’re introducing support for _coroutines_. As a lightweight alternative to threads, coroutines enable much more scalable application backends, supporting massive workloads on a single JVM instance. In addition to that, coroutines are a very expressive tool for implementing asynchronous behavior, which is important for building responsive user interfaces on all platforms.\n\nBelow we describe these two changes further. In other news: we’ve added [type aliases](http://kotlinlang.org/docs/reference/whatsnew11.html#type-aliases), [bound callable references](http://kotlinlang.org/docs/reference/whatsnew11.html#bound-callable-references), [destructuring in lambdas](http://kotlinlang.org/docs/reference/whatsnew11.html#destructuring-in-lambdas) and more. See the details in our [What’s new](http://kotlinlang.org/docs/reference/whatsnew11.html) page (check out the runnable examples!).\n\n## Coroutines\n\nCoroutines in Kotlin make non-blocking asynchronous code as straightforward as plain synchronous code.\n\nAsynchronous programming is taking over the world, and the only thing that is holding us back is that non-blocking code adds considerable complexity to our systems. Kotlin now offers means to tame this complexity by making coroutines first-class citizens in the language through the single primitive: _suspending functions_. Such a function (or lambda) represents a computation that can be suspended (without blocking any threads) and resumed later.\n\nTechnically, coroutines are light-weight means of cooperative multi-tasking (very similar to [fibers](https://en.wikipedia.org/wiki/Fiber_(computer_science))). In other words, they are just _much better threads_: almost free to start and keep around, extremely cheap to suspend (suspension is for coroutines what blocking is for threads), very easy to compose and customize.\n\nWe designed coroutines for maximum flexibility: very little is fixed in the language, and very much can be done as a library. The [kotlinx.coroutines](https://github.com/Kotlin/kotlinx.coroutines) project features libraries on top of Rx, CompletableFuture, NIO, JavaFx and Swing. Similar libraries can be written for Android and JavaScript. Even many built-in constructs available in other languages can now be expressed as Kotlin libraries. This includes generators/yield from Python, channels/select from Go and async/await from C#:\n\n```kotlin\n// runs the code in the background thread pool\nfun asyncOverlay() = async(CommonPool) {\n    // start two async operations\n    val original = asyncLoadImage(\"original\")\n    val overlay = asyncLoadImage(\"overlay\")\n    // and then apply overlay to both results\n    applyOverlay(original.await(), overlay.await())\n}\n\n// launches new coroutine in UI context\nlaunch(UI) {\n    // wait for async overlay to complete\n    val image = asyncOverlay().await()\n    // and then show it in UI\n    showImage(image)\n}\n```\n\nRead more in our [docs](http://kotlinlang.org/docs/reference/coroutines.html).\n\n**An important note**. With all the benefits that they bring, Kotlin coroutines are a fairly new design that needs extensive battle-testing before we can be sure it’s 100% right and complete. This is why we will release it under an “experimental” [opt-in flag](http://kotlinlang.org/docs/diagnostics/experimental-coroutines.html). We do not expect the language rules to change, but APIs may require some adjustments in Kotlin 1.2.\n\n## JavaScript support\n\nAs mentioned above, all language features in Kotlin 1.1, including coroutines, work on both JVM/Android and JavaScript. (Reflection for JavaScript is not available, but we’re looking into it.) This means that a web application can be written entirely in Kotlin, and we already have some experience doing that inside JetBrains. We will publish tutorials and other materials about this soon.\n\nKotlin for JavaScript has dynamic types to interoperate with “native” JavaScript code. To use well-known libraries through typed APIs, you can use the [ts2kt converter](http://github.com/kotlin/ts2kt) together with headers from [DefinitelyTyped](http://github.com/DefinitelyTyped/DefinitelyTyped).\n\nWe support both Node.js and the browser. The Kotlin Standard Library is available for use through `npm`.\n\nRead more in our [docs](http://kotlinlang.org/docs/reference/js-overview.html).\n\n## Tooling\n\nKotlin 1.1 is not a major release for Kotlin tooling: we prefer shipping tooling features that do not affect the language itself as soon as they are ready, so you’ve seen many such improvements in Kotlin 1.0.x versions. To highlight a few:\n\n* Kotlin plugins for all the major IDEs: IntelliJ IDEA, Android Studio, Eclipse and NetBeans\n* Incremental compilation in both IntelliJ IDEA and Gradle\n* Compiler plugins for Spring, JPA and Mockito (making classses open and generating no-arg constructors)\n* kapt for annotation processing\n* Lint support for Android projects\n* Numerous IDE intentions, inspections, quick fixes, refactorings and code completion improvements\n\nWe’ll keep working to make our tooling even better and deliver the updates in 1.1.x versions.\n\n## First year of Kotlin: Adoption and Community\n\nIn short, Kotlin is growing. We’ve seen over 160’000 people using it during the last year. OSS projects on Github grew from 2.4M to 10M lines of Kotlin code (about 4x). Our Slack community has grown from 1’400 to over 5’700 people (over 4x). Numerous meet-ups and user groups are organized by the community [around the world](http://kotlinlang.org/community/talks.html). We are seeing more and more Kotlin books and online courses published.\n\n![Kotlin GitHub Stats](https://d3nmt5vlzunoa1.cloudfront.net/kotlin/files/2017/03/GitHub-Stats-1.gif)\n\nKotlin is equally strong with server-side and Android developers (roughly 50/50 divide). Spring Framework 5.0 [has introduced Kotlin support](https://spring.io/blog/2017/01/04/introducing-kotlin-support-in-spring-framework-5-0), so did [vert.x 3.4](http://vertx.io/blog/vert-x-3-4-0-beta1-release/). [Gradle](https://blog.gradle.org/kotlin-meets-gradle) and [TeamCity](https://blog.jetbrains.com/teamcity/2016/11/kotlin-configuration-scripts-an-introduction/) are using Kotlin for build scripts. More projects using Kotlin can be found at [kotlin.link](http://kotlin.link/).\n\nMany well-known companies are using Kotlin: [Pinterest](https://www.youtube.com/watch?v=mDpnc45WwlI), [Coursera](https://building.coursera.org/blog/2016/03/16/becoming-bilingual-coursera/), [Netflix](https://twitter.com/robspieldenner/status/708355228832178176), [Uber](https://www.reddit.com/r/androiddev/comments/5sihp0/2017_whos_using_kotlin/ddfmkf7/), [Square](https://github.com/square/sqldelight), [Trello](https://twitter.com/danlew42/status/809065097339564032), [Basecamp](https://m.signalvnoise.com/some-of-my-favorite-kotlin-features-that-we-use-a-lot-in-basecamp-5ac9d6cea95), amongst others. [Corda](https://github.com/corda/corda), a distributed ledger developed by a consortium of well-known banks (such as Goldman Sachs, Wells Fargo, J.P. Morgan, Deutsche Bank, UBS, HSBC, BNP Paribas, Société Générale), has [over 90% Kotlin](https://www.corda.net/2017/01/10/kotlin/) in its codebase.\n\nWe are grateful to all our users, contributors and advocates in all parts of the world. Your support is very important to us!\n\n### Organize your own Kotlin 1.1 Event\n\nKotlin 1.1 is a good reason to meet up with your local user group and friends. We have prepared some materials to help you organize such an event. On March 23 we’ll stream live sessions featuring the Kotlin team members, plus there’s an organizers pack that includes some swag and a Future Features Survey. Get more info and [register your event here](https://docs.google.com/forms/d/e/1FAIpQLSf6iXcrIpaNIqeeUJI2L6pntS5yy_iI01PbrO9gTMmX0kg5Lw/viewform).\n\n## What’s next\n\nTo make Kotlin a truly full-stack language, we are going to provide tooling and language support for compiling the same code for multiple platforms. This will facilitate sharing modules between client and server. We will keep working on improving the JavaScript tooling and library support. Among other things, incremental compilation for the JavaScript platform is in the works already. Stay tuned for 1.1.x updates.\n\nJava 9 is coming soon, and we will provide support for its new features before it ships.\n\nWe expect a lot of feedback on coroutines in the upcoming months, and improving this area of the language (in terms of both performance and functionality) is among our priorities.\n\nApart from this, our next release will be mostly focused on maintenance, performance improvements, infrastructure and bugfixing.\n\nP.S. Running on multiple platforms is a strategic direction for Kotlin. With 1.1 we can run on servers, desktops, Android devices and browsers, but in the future we are going to compile Kotlin to native code and run on many more platforms (including, for example, iOS and embedded devices). A great team here at JetBrains is working on this project, and we are expecting to show something interesting fairly soon. This does not target any particular release yet, though.\n\n## Installation instructions\n\nAs always, you can **try Kotlin online** at [try.kotlinlang.org](http://try.kotlinlang.org/).\n\n**In Maven/Gradle**: Use `1.1.0` as the version number for the compiler and the standard library. See the docs [here](http://kotlinlang.org/docs/reference/using-gradle.html).\n\n**In IntelliJ IDEA**: 2017.1 has Kotlin 1.1 bundled, in earlier versions Install or update the Kotlin plugin to version 1.1.\n\n**In Android Studio**: Install or update the plugin through _Plugin Manager_.\n\n**In Eclipse**: install the plugin using [Marketplace](https://marketplace.eclipse.org/content/kotlin-plugin-eclipse).\n\n**The command-line compiler** can be downloaded from the [Github release page](https://github.com/JetBrains/kotlin/releases/tag/v1.1).\n\n**Compatibility**. In Kotlin 1.1 the language and the standard library are [backwards compatible (modulo bugs)](http://kotlinlang.org/docs/reference/compatibility.html): if something compiled and ran in 1.0, it will keep working in 1.1. To aid big teams that update gradually, we provide a compiler switch that disables new features. [Here](http://kotlinlang.org/docs/reference/compatibility.html#binary-compatibility-warnings) is a document covering possible pitfalls.\n\n_Have a nice Kotlin!_\n\nP.S. See discussions on [Reddit](https://www.reddit.com/r/programming/comments/5wvpv8/kotlin_11_released_with_javascript_support/) and [Hacker News](https://news.ycombinator.com/item?id=13763483)\n","author":"Roman Belov","date":"2017-03-01","type":"article","categories":["Kotlin"],"features":["highlightjs"],"description":"","filename":"","lang":"EN","enclosure":null},{"title":"News from KotlinTest","url":"https://discuss.kotlinlang.org/t/news-from-kotlintest/1797","body":"\nIn the last weeks [KotlinTest](https://github.com/kotlintest/kotlintest) got some new and useful features:\n\n## Testing for Exceptions\n\n```kotlin\nval exception = shouldThrow<IllegalAccessException> {\n  // code in here that you expect to throw an IllegalAccessException\n}\nexception.message should start with \"Something went wrong\"\n```\n\n## Before and after each\n\n```kotlin\noverride fun beforeEach() {\n  println(\"Test starting\")\n}\n\noverride fun afterEach() {\n  println(\"Test completed\")\n}\n```\n\n\n## Test configuration\n\nEach test case can followed by a call to the `config` function.\n\nTo execute a test two times with two threads you would write:\n\n```kotlin\nclass MyTests : ShouldSpec() {\n  init {\n\n    should(\"return the length of the string\") {\n      \"sammy\".length shouldBe 5\n      \"\".length shouldBe 0\n    }.config(invocations = 10, threads = 2)\n\n  }\n}\n```\n\nYou can tag tests to be able run them selectively:\n\n```kotlin\n...\n}.config(tags = listOf(\"database\", \"linux\"))\n```\n\nTimeouts are configured like this:\n\n```kotlin\n...\n}.config(timeout = 2, timeoutUnit = TimeUnit.SECONDS)\n```\n\nTo ignore a test, you set `ignored` to true:\n\n```kotlin\n...\n}.config(ignored = true)\n```\n\n## Future\n\nSome more features like property based (and table driven) testing are on the roadmap.\n","author":"medium","date":"2016-06-14","type":"article","categories":["Testing","Kotlin"],"features":["highlightjs"],"description":"","filename":"","lang":"EN","enclosure":null},{"title":"Kotlin Meets Gradle","url":"http://gradle.org/blog/kotlin-meets-gradle/","body":"\nMany readers will be familiar with JetBrains’ excellent [Kotlin](http://kotlinlang.com) programming language. It’s been under development since 2010, had its first public release in 2012, and went 1.0 GA earlier this year.\n\nWe’ve been watching Kotlin over the years, and have been increasingly impressed with what the language has to offer, as well as with its considerable uptake—particularly in the Android community.\n\nLate last year, Hans sat down with a few folks from the JetBrains team, and they wondered together: what might it look like to have a Kotlin-based approach to writing Gradle build scripts and plugins? How might it help teams—especially big ones—work faster and write better structured, more maintainable builds?\n\nThe possibilities were enticing.\n\nBecause Kotlin is a statically-typed language with deep support in both IDEA and Eclipse, it could give Gradle users proper IDE support from auto-completion to refactoring and everything in-between. And because Kotlin is rich with features like first-class functions and extension methods, it could retain and improve on the best parts of writing Gradle build scripts—including a clean, declarative syntax and the ability to craft DSLs with ease.\n\nSo we got serious about exploring these possibilities, and over the last several months we’ve had the pleasure of working closely with the Kotlin team to develop a new, Kotlin-based build language for Gradle.\n\nWe call it Gradle Script Kotlin, and Hans just delivered the first demo of it onstage at JetBrains’ Kotlin Night event in San Francisco. We’ve [released the first milestone](https://github.com/gradle/gradle-script-kotlin/releases/tag/v1.0.0-M1) towards version 1.0 of this work today, along with open-sourcing its repository at [https://github.com/gradle/gradle-script-kotlin](https://github.com/gradle/gradle-script-kotlin).\n\n[![KotlinGradleBanner](http://gradle.wpengine.netdna-cdn.com/wp-content/uploads/2016/05/KotlinGradleBanner.gif)](http://gradle.wpengine.netdna-cdn.com/wp-content/uploads/2016/05/KotlinGradleBanner.gif)\n\nSo what does it look like, and what can you do with it? At a glance, it doesn’t look _too_ different from the Gradle build scripts you know today:\n\n[![pasted image 0](http://gradle.wpengine.netdna-cdn.com/wp-content/uploads/2016/05/pasted-image-0.png)](http://gradle.wpengine.netdna-cdn.com/wp-content/uploads/2016/05/pasted-image-0.png)\n\nBut things get very interesting when you begin to explore what’s possible in the IDE. You’ll find that, suddenly, the things you usually expect from your IDE _just work_, including:\n\n* auto-completion and content assist\n* quick documentation\n* navigation to source\n* refactoring and more\n\nThe effect is dramatic, and we think it’ll make a big difference for Gradle users. Now, you might be wondering about a few things at this point—like whether existing Gradle plugins will work with Gradle Script Kotlin (yes, they will), and whether writing build scripts in Groovy is deprecated (no, it’s not). You can find complete answers to these and other questions in the [project FAQ](https://github.com/gradle/gradle-script-kotlin/wiki/Frequently-Asked-Questions). Do let us know if you have a question that’s not answered there.\n\nOf course, all this is just the beginning. We’re happy to announce that Kotlin scripting support will be available in Gradle 3.0, and we’ll be publishing more information about our roadmap soon. In the meantime, there’s no need to wait—you can try out Gradle Script Kotlin for yourself right now by [getting started with our samples](https://github.com/gradle/gradle-script-kotlin/tree/master/samples#readme).\n\nAnd we hope you do, because we’d love your feedback. We’d love to hear what you think, and how you’d like to see this new work evolve. You can file issues via the project’s [GitHub Issues](https://github.com/gradle/gradle-script-kotlin/issues) and please come chat with us in the #gradle channel of the public [Kotlin Slack](http://kotlinslackin.herokuapp.com/).\n\nI’d like to say a big thanks to my colleague Rodrigo B. de Oliveira for the last few months of working together on this project—it’s been a lot of fun! And a big thanks to the Kotlin team, in particular Ilya Chernikov and Ilya Ryzhenkov for being so responsive in providing us with everything we needed in the Kotlin compiler and Kotlin IDEA plugin. Onward!\n\n","author":"Chris Beams","date":"2016-05-18","type":"article","categories":["Kotlin","Gradle"],"features":["highlightjs"],"description":"","filename":"","lang":"EN","enclosure":null},{"title":"Видео со встречи JUG.ru с разработчиками Kotlin","url":"https://github.com/Heapy/awesome-kotlin/blob/master/app/rss/articles/%5BRU%5D%20%D0%92%D0%B8%D0%B4%D0%B5%D0%BE%20%D1%81%D0%BE%20%D0%B2%D1%81%D1%82%D1%80%D0%B5%D1%87%D0%B8%20JUG.ru%20%D1%81%20%D1%80%D0%B0%D0%B7%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D1%87%D0%B8%D0%BA%D0%B0%D0%BC%D0%B8%20Kotlin.md","body":"\n\n## Часть 1. Введение\nАндрей Бреслав расскажет про то, что такое Kotlin, как у него сейчас дела и т.д.\n[Андрей Бреслав — Что такое Kotlin Введение](https://www.youtube.com/watch?v=HWyd1gYMkl0)\n\n## Часть 2. К релизу и далее\nНачиная с версии 1.0, Kotlin предоставляет гарантии обратной совместимости с существующим кодом. Дмитрий Жемеров расскажет о том, что в точности они обещают на будущее, о том, как это обещание повлияло на дизайн языка, и о том, под какие направления будущего развития уже есть заготовки в версии 1.0.\n[Дмитрий Жемеров, JetBrains — Kotlin - к релизу и далее](https://www.youtube.com/watch?v=m5T0M7SnCC0)\n\n## Часть 3. Самое сложное — совместимость\n[Андрей Бреслав — Kotlin - самое сложное — совместимость](https://www.youtube.com/watch?v=LWFx4QWrTyo)\nАндрей Бреслав расскажет о том, как они боролись за прозрачную совместимость: чтобы Kotlin и Java могли дружно обитать в одном проекте. Для этого пришлось придумать немало оригинальных решений и пойти на многие компромиссы на всех уровнях: от системы типов до плагинов к билд-системам.\n\n## Часть 4. Сессия вопросов и ответов\n[Андрей Бреслав и Дмитрий Жемеров — Kotlin - сессия вопросов и ответов](https://www.youtube.com/watch?v=YOmdOTlhZa8)\nАндрей, Дмитрий и другие разработчики Kotlin с удовольствием ответят на ваши вопросы.\n\n","author":"JetBrains","date":"2016-03-04","type":"article","categories":["Kotlin","Video"],"features":["highlightjs"],"description":"","filename":"","lang":"RU","enclosure":null},{"title":"Better Android Development with Kotlin and Gradle","url":"https://www.youtube.com/watch?v=bVSeKexyzhs","body":"\n\n# v1\n\nIn this talk, Ty will walk you through setting up and using Kotlin with Gradle to streamline your workflow for Android development, both within the build tool phase and within the application itself. After a brief overview of Kotlin, we’ll dive into how it can be used with Gradle to accelerate Android Development with a consistent language.\n\n[Slides](https://speakerdeck.com/tysmith/better-android-development-with-kotlin-and-gradle-1)\n\n<iframe width=\"960\" height=\"480\" src=\"https://www.youtube.com/embed/bVSeKexyzhs\" frameborder=\"0\" allowfullscreen></iframe>\n\n# v2\n\nIn this talk, Ty will walk you through using Kotlin with Gradle and Android to streamline your workflow for app development, both within the build tool phase and within the application itself. After a brief overview of Kotlin language, he'll dive into how it can be used with Gradle to accelerate Android Development with a consistent language through the entire stack. He'll provide real world examples of using Kotlin in Gradle plugins, Gradle script, and Android apps. \n\n<iframe width=\"960\" height=\"480\" src=\"https://www.youtube.com/embed/_DaZQ374Chc\" frameborder=\"0\" allowfullscreen></iframe>\n\n# v3\n\nTy Smith, Uber\nIn this talk, Ty will walk you through setting up and using Kotlin with Gradle to streamline your workflow for Android development, both within the build tool phase and within the application itself, so that you can use a consistent language through the entire Android stack. After a brief overview of Kotlin, we’ll dive into how it can be used with Gradle to accelerate Android Development with a consistent language. I'll walk through a real world example of building a Gradle plugin in and scripts in Groovy, then I'll convert those into Kotlin. An open source repo of the sample will be provided to follow along.\n\n<iframe width=\"960\" height=\"480\" src=\"https://www.youtube.com/embed/HM7DqX9TY0k\" frameborder=\"0\" allowfullscreen></iframe>\n\n","author":"Ty Smith","date":"2016-10-03","type":"video","categories":["Kotlin","Android","Gradle"],"features":["highlightjs"],"description":"","filename":"","lang":"EN","enclosure":null},{"title":"Non-volatile vs volatile captured refs by default","url":"https://discuss.kotlinlang.org/t/non-volatile-vs-volatile-captured-refs-by-default/2122","body":"\nKotlin compiler version 1.0.x uses reference classes with `volatile` fields when local `var`s are captured by lambdas, local functions, or local classes. This results in a quite severe performance degradation on JVM backend for idiomatic Kotlin code that uses Kotlin's unique (with respect to Java) feature of capturing mutable variables. We are considering to change this implementation strategy in Kotlin 1.1 to use reference classes with non-volatile fields by default. The purpose of this thread is to gather feedback on this proposed change.\n\nThe proposed change will not affect non-concurrent code semantics, but it will make it significantly faster on JVM in many cases simply by recompilation with Kotlin 1.1. Most correct concurrent code will likewise continue to work correctly after this change and with improved performance, too. However, we can imagine some cases where existing concurrent code is working correctly with Kotlin 1.0.x as a side effect of this particular implementation strategy, but will cease to operate correctly if the proposes change is implemented in Kotlin 1.1. We cannot figure out a simple way to automatically scan Kotlin open source codebase to see how prevalent those cases in real Kotlin code are, so we need your help in finding those cases to judge the extent of this proposed change. Real-world examples of such code are highly appreciated.\n\n# Links\n\n* The corresponding performance problem is tracked as an issue [https://youtrack.jetbrains.com/issue/KT-14746](https://youtrack.jetbrains.com/issue/KT-14746) It provides some low-level implementation details of what bytecode is generated by Kotlin 1.0.x and how references are implemented.\n\n* Some micro-benchmarking results are presented at [http://www.slideshare.net/intelliyole/kotlin-bytecode-generation-and-runtime-performance](http://www.slideshare.net/intelliyole/kotlin-bytecode-generation-and-runtime-performance) (slide #27) Note, however, that it is does not really show the gravity and the extent of the problem in real-life use-cases.\n\n# FAQ\n\n## What is volatile?\n\nThe `volatile` is a JVM modifier that imbues a variable with a special semantics with respect to Java Memory Model (JMM). The semantics for volatile are specified in Chapter 17 of Java Language Specification: [https://docs.oracle.com/javase/specs/jls/se8/html/jls-17.html](https://docs.oracle.com/javase/specs/jls/se8/html/jls-17.html) **TL;DR**: reads and writes of `volatile` variables are considered to be _synchronisation_ actions for concurrent code, providing an alternative inter-thread synchronisation mechanism for writing _lock-free_ code. Volatile variables are optional for correct concurrent code, in the sense that there are many other synchronisation primitives like starting/joining threads, using locks, using futures and various other xxxConcurrent and xxxAtomic classes.\n\n## What are performance problems with volatile / why not everything is volatile?\n\nThe possible behaviours of the code that is reading/writing volatile variables are quite constrained by specification, so compiler cannot do many of the typical optimisations that modern compilers usually do. For example, compiler is not allowed to optimize away redundant reads from volatile variables and replace them with a read into register, which has cascading effect on many other code optimisations. Unfortunately, it also affects optimisation of other code around reads and write of volatile variable. Even a single volatile read/write in a piece of a typical code can make a lot of it much less optimised. This is the reason why modern languages choose to treat all variables as non-volatile by default. This enables full scope of code optimisation, unless the programmer who is writing concurrent code explicitly wants to use _lock-free synchronisation_ in their code and marks the corresponding variables as `volatile`. Kotlin follows the same strategy with respect to class variables and provides `@Volatile` annotation in `kotlin.jvm` package in order to make class variables volatile.\n\n## Why captured mutable variables are important?\n\nCaptured mutable variables might seem a niche feature of Kotlin at a first glance, since they are not present in Java. Moreover, modern collections / sequence-processing libraries strongly advocate against any kind of mutable state and provide a rich set of filter/map/etc primitives to enable writing even complex logic without any kind of mutable state. Kotlin stdlib is a good example of such a rich library. Moreover, writing your code without mutable variables makes it easy to parallelise. For example, with Java Streams parallelisation is as simple as adding `.parallel()` invocation to your pipeline, unless you are mutating any state, that is.\n\nHowever, Kotlin's powerful lambdas enable user-defined control constructs that work similarly to the ones built into the language. So, Kotlin can have fewer built-in control constructs and define things like Java's _synchronised_ and _try-with-resources_ as a library instead. This ability relies on capturing local mutable state.\n\nMoreover, when writing complex _single threaded_ (classical) data-processing algorithms one often needs to share some mutable state between several functions. In Java it typically boils down to “Doer” class anti-pattern, e.g. in order to implement a hypothetical `compute()` function, you create `Computer` class, in order to implement some `graphSearch` function you create `GraphSearcher` class, etc. It is all a boilerplate code to work around Java limitations. Kotlin's support of local functions lets us get rid of such a boiler plate and write our algorithms directly and _naturally_.\n\n## Work around for performance in Kotlin 1.0.x\n\nWhat do you do if you have exactly this kind of code where you'd like to use captured mutable state to apply some local functions or lambdas as a part of your algorithm, for example. How do you regain Java speed of this code on JVM? The solution in Kotlin 1.0.x is to write this code in Java style, e.g. ditch idiomatic Kotlin and write the Java boilerplate you typically do to work with mutable state in Java. For example, if you have the following code snippet:\n\n```kotlin\nvar myVariable = initialValue\n\n// here is the code that uses myVariable in lambdas and local functions\n```\n\nyou can use the following boilerplate code to regain runtime performance in Kotlin 1.0.x at a cost of extra class file. If you ignore the boilerplate it even looks similar to the original code. Kotlin is such a nice language that even boilerplate code in Kotlin is shorter than in Java :)\n\n```kotlin\nwith (object {\n    var myVariable = initialValue\n}) {\n    // here is the code that uses myVariable in lambdas and local functions\n}\n```\n\nHowever, you should not _actually_ write such code. If you really need that performance, then you should extract your variables into some named class. It is going to require _more_ code, but the resulting code will be easier to read and understand.\n\n","author":"Roman Elizarov","date":"2016-11-28","type":"article","categories":["Kotlin"],"features":["highlightjs"],"description":"","filename":"","lang":"EN","enclosure":null},{"title":"UI Testing: separating Assertions from Actions with Kotlin DSL","url":"https://artemzin.com/blog/ui-testing-separating-assertions-from-actions-with-kotlin-dsl/","body":"\nHello, dear reader!\n\nRecently Jake Wharton did a talk [\"Instrumentation Testing Robots\"](https://realm.io/news/kau-jake-wharton-testing-robots/) \uD83D\uDCFA.\n\nThe pattern itself is not a new concept, **but** combining it with [Kotlin DSL](https://kotlinlang.org/docs/reference/type-safe-builders.html) is pretty nice! So we decided to try it for our [Juno app](https://play.google.com/store/apps/details?id=com.gojuno.rider) which is fully written in Kotlin, including Unit, Integration and Functional tests.\n\nWhat we found is that mixing Actions and Assertions inside \"Robots\" (we call them Screens) doesn't look great, both for tests readability and \"Robot\" maintenance \uD83E\uDD16 (same is true for regular Screen abstractions).\n\n> Though I used mixed variant for years... (sigh). For some reason, only seeing screen abstraction as a Kotlin DSL finally clicked that we need to divide assertions from actions.\n\n#### Before: mixed Actions and Assertions \uD83D\uDE3F\n\n```kotlin\n// We actually use Spek but unfortunately I can't say\n// that it works great for instrumentation tests yet...\n@Test fun loginAndPasswordAreEntered() {\n  loginScreen {\n\n    login(\"artem_zin\")\n    password(\"*****\")\n\n    loginButtonActivated()\n    noLoginWarnings()\n    noPasswordWarnings()\n  }\n}\n```\n\n#### After: Assertions are separated from Actions \uD83D\uDE38\n\n```kotlin\n@Test fun loginAndPasswordAreEntered() {\n  loginScreen {\n\n    login(\"artem_zin\")\n    password(\"*****\")\n\n    assert {\n      loginButtonActivated()\n      noLoginWarnings()\n      noPasswordWarnings()\n    }\n  }\n}\n```\n\nNow that's a clear separation of actions and assertions, right? Same is true for internal structure of `LoginScreen` class:\n\n```kotlin\nfun loginScreen(func: LoginScreen.() -> Unit) = LoginScreen().apply { func() }\n\nclass LoginScreen {\n\n  fun login(login: String) = enterText(R.id.login, email)\n  fun password(password: String) = enterText(R.id.password, password)\n  fun assert(func: Assert.() -> Unit) = Assert().apply { func() }\n\n  // Previously all these assertions \n  // were on the same level in the LoginScreen class as actions.\n  class Assert {\n    fun loginButtonActivated() = ...\n    fun noLoginWarnings() = ...\n    fun noPasswordWarnings() = ...\n  }\n}\n```\n\n> Write tests and take care!\n\n","author":"Artem Zinnatullin","date":"2016-07-27","type":"article","categories":["Kotlin","Testing"],"features":["highlightjs"],"description":"","filename":"","lang":"EN","enclosure":null},{"title":"Fun with Kotlin","url":"https://vimeo.com/151846078","body":"\n\n[Fun with Kotlin](https://vimeo.com/151846078)\n\n","author":"Eder Bastos","date":"2016-01-14","type":"video","categories":["Kotlin"],"features":["highlightjs"],"description":"","filename":"","lang":"EN","enclosure":null},{"title":"Kotlin - Ready for Production","url":"https://vimeo.com/181814363","body":"\n<iframe src=\"https://player.vimeo.com/video/181814363\" width=\"960\" height=\"540\" frameborder=\"0\"></iframe>\n\n<a href=\"https://vimeo.com/181814363\">Kotlin - Ready for Production : Hadi Hariri</a> from <a href=\"https://vimeo.com/javazone\">JavaZone</a> on <a href=\"https://vimeo.com\">Vimeo</a>.\n\n[Transcript](https://realm.io/news/gotocph-hadi-hariri-kotlin-ready-for-production/)\n\n","author":"Hadi Hariri","date":"2016-09-07","type":"video","categories":["Kotlin"],"features":["highlightjs"],"description":"","filename":"","lang":"EN","enclosure":null},{"title":"Kotlin 1.1 Release Candidate is Here","url":"https://blog.jetbrains.com/kotlin/2017/02/kotlin-1-1-release-candidate-is-here/","body":"\nAs of today, Kotlin 1.1 has finally reached the release candidate stage. This means that most of our development work is done, we’re happy with the results, and we’ll soon publish them as a final Kotlin 1.1 release. We’ve done a lot of testing for this release internally, but the real world is always more varied than any test environment, so we need your help. Please try this build, and let us know about your experience!\n\n![11RC-01][]\n\n\nThe only new feature in the release candidate is the `takeUnless` function – a counterpart of [takeIf][] (added earlier in 1.1) but with an inverted condition. As for bugfixes, there’s much more, and the [changelog][] gives you a complete list. Among other things, we’ve fixed several performance problems in the IDE – both long-standing sore points and recent regressions.\n\n## Migration Notes ##\n\nAs we [noted][] earlier, all binaries produced by pre-release versions are outlawed by the compiler: you’re now **required to recompile** everything that was compiled by 1.1‑M0x and Beta’s. All the code from 1.0.x is, of course, perfectly fine without recompilation.\n\nUp until now, you could run the Kotlin compiler under any version of Java starting with Java 6, but this is about to change – starting with one of the first 1.1.x updates, the compiler will only run under Java 8 or 9. To prepare you for the migration, the compiler now emits a warning if you run it under Java 6 or 7. Note that this only affects the build environment; **the compiled code is still compatible with Java 6 by default**, and we have no plans to remove the support for that.\n\nThe `.javaClass` extension property is now deprecated. As a replacement, please use `::class.java`. The IDE offers a quickfix to update usages, both individually and across the entire project.\n\nTo reduce the size of the JavaScript standard library, we’ve deprecated a lot of helper functions in the `kotlin.dom` and `kotlin.dom.build` packages, and we’re going to remove them in a future update.\n\n## How to try it ##\n\n**In Maven/Gradle:** Add `http://dl.bintray.com/kotlin/kotlin-eap-1.1` as a repository for the build script and your projects; use `1.1.0-rc-91` as the version number for the compiler and the standard library.\n\n**In IntelliJ IDEA:** Go to *Tools → Kotlin → Configure Kotlin Plugin Updates*, then select “Early Access Preview 1.1” in the *Update channel* drop-down list, then press *Check for updates*.\n\n**In Eclipse**: install the plugin with the following update site\n`https://dl.bintray.com/jetbrains/kotlin/eclipse-plugin/0.8.0`\n\n**The command-line compiler** can be downloaded from the [Github release page][].\n\n**On [try.kotlinlang.org][]**.\n\nLet’s Kotlin!\n\n\n[11RC-01]: https://d3nmt5vlzunoa1.cloudfront.net/kotlin/files/2017/02/11RC-01.png\n[takeIf]: https://kotlinlang.org/docs/reference/whatsnew11.html#takeif-and-also\n[changelog]: https://github.com/JetBrains/kotlin/blob/1.1-rc/ChangeLog.md\n[noted]: https://blog.jetbrains.com/kotlin/2017/01/kotlin-1-1-beta-is-here/\n[Github release page]: https://github.com/JetBrains/kotlin/releases/tag/v1.1-rc\n[try.kotlinlang.org]: http://try.kotlinlang.org/\n","author":"Mikhail Glukhikh","date":"2017-02-17","type":"article","categories":["Kotlin"],"features":["highlightjs"],"description":"","filename":"","lang":"EN","enclosure":null},{"title":"Christina Lee: Kotlin in Production","url":"https://www.youtube.com/watch?v=xRDqDe4rxkM","body":"\n# v1\n\nWhile in New York for Droidcon NYC, Huyen hangs out with Christina Lee, Pinterest Android engineer and cross-country runner, to talk about bringing Kotlin into your production apps.\n\n<iframe width=\"960\" height=\"480\" src=\"https://www.youtube.com/embed/xRDqDe4rxkM\" frameborder=\"0\" allowfullscreen></iframe>\n\n# v2\n\nChristina Lee, Pinterest\nIt is hard to argue that Kotlin is not an amazing language. What is easy to argue is that there are many unknowns about its performance in the wild and at scale, which makes it hard to make an informed decision about incorporating it into your app. Fortunately for you, we went there and have lived to tell the tale. After more than a year of maintaining a pure Kotlin app at Highlight, and more recently helping Pinterest ramp up Kotlin in Android, we've learned much about the ramifications of moving away from Java. Come learn from our mistakes and successes as we cover the highs, and lows, of using Kotlin in the wild!\n\n<iframe width=\"960\" height=\"480\" src=\"https://www.youtube.com/embed/mDpnc45WwlI\" frameborder=\"0\" allowfullscreen></iframe>\n\n","author":"Android Dialogs","date":"2016-10-18","type":"video","categories":["Kotlin"],"features":["highlightjs"],"description":"","filename":"","lang":"EN","enclosure":null},{"title":"Generating Kotlin Code for Better Refactorings, Tests, and IDE Support","url":"https://docs.google.com/presentation/d/1pgzNnA4R3LU4hPnx0KTvQ0NFj23rPyq-ROr8kOiaxlM/edit#slide=id.p","body":"\n[Slides on Google Slides](https://docs.google.com/presentation/d/1pgzNnA4R3LU4hPnx0KTvQ0NFj23rPyq-ROr8kOiaxlM/edit#slide=id.p)\n\n","author":"Eugene Petrenko","date":"2016-09-20","type":"slides","categories":["Kotlin"],"features":["highlightjs"],"description":"","filename":"","lang":"EN","enclosure":null},{"title":"Kotlin - 2 Years On","url":"https://yobriefca.se/blog/2016/02/24/kotlin-2-years-on/","body":"\nI [first played](https://yobriefca.se/blog/2012/07/14/kotlin-heres-what-i-think-for-now/) with Kotlin back in 2012, I've written some Android apps with and without it and generally played around with it. Since the [release of Kotlin 1.0](http://blog.jetbrains.com/kotlin/2016/02/kotlin-1-0-released-pragmatic-language-for-jvm-and-android/) a few days ago I've decided to jump back into it and see if my original views still hold up.\n\n> Herein lies opinion of the personal kind. Proceed with an open mind.\n\nScala is my day job, not only Scala but **legacy/old** Scala. Not only that but **a lot** of legacy/old Scala. Worse still not only a lot of legacy/old Scala but a lot of **other peoples** legacy/old Scala. Thanks to the feature rich and impressively flexible nature of Scala this means there is a lot of sharp edges, unpredictability and a fresh arduous learning curve for each functional area. It can seem like a language designed by [Atë](https://en.wikipedia.org/wiki/At%C3%AB) at times.\n\nJava is no better of course, it just resides at the other end of a spectrum, with its anaemic yet rigid feature set and almost pointless type system it's no wonder you see so many over-engineered and baklava-class layered solutions. Yeah Java 8 has improved the language a fair bit but the sacrifices made for backwards compatibility has meant those changes don't often go far enough.\n\nBoth Scala and Java require a lot of work to simplify so there has to be a middle ground and I (still) think that middle ground is Kotlin.\n\nThink of Kotlin as C# for the JVM, Scala the Good Parts, Java++ or simply a decent general purpose language that won't require the blood of your first born. It's created by Jetbrains, it's about 5ish years old and just gone version 1.0. It is used extensively on Jetbrains products, being hailed as \"Swift for Android\" and works seamlessly within a mixed code base. It offers features similar to C# Extension methods, Scala implicits, Scala case classes, multiple inheritance and solid collection functionality like LINQ. It doesn't just ape Scala and C# features but introduces relatively original concepts like [delegated properties](http://kotlinlang.org/docs/reference/delegated-properties.html), [class delegation](https://kotlinlang.org/docs/reference/delegation.html#class-delegation) and [typecasting](https://kotlinlang.org/docs/reference/typecasts.html).\n\nI'd also proffer that it has an easier transition from Java to Kotlin than it is for Scala though I have no evidence for this other than my own experience of all 3 languages (including leading mixed skill teams in Scala and Java).\n\nYou could ask \"but why not one of the other many languages available on the JVM?\" and that would be fair. Many JVM languages haven't seen a great deal of traction or remain relatively niche but I think Kotlin is much better placed. It's more \"general purpose\" than a lot of the alt languages which means it will map better to current practises. It's closer to Java and/or Scala than other languages, it strikes the right balance around the type system with features like type inference and enhanced generics and it doesn't hurt that Jetbrains; a major player in the JVM world; is heavily invested in Kotlins future.\n\nIn the two years since I started playing with Kotlin it has aged well. It resisted adding a plethora of features for the sake of it and instead created a core syntax and feature set that allows developers enough wiggle room for being creative without turning them into Wizards of Arcane DSLs. This is a sweet spot for me when it comes to building and supporting a service over many years as it avoids the unnecessary pain that comes from the extreme ends of spectrum that Java and Scala tend to reside. Of course this doesn't mean it's perfect, nothing is. You're still adding another language to a project and taking on the associated baggage that comes with it like tooling differences and additional upskilling. Its not suddenly going to make your organisation move the JVM if they aren't already there. It's also not going to fix all your problems - bad architecture will remain bad architecture and bad patterns will remain bad patterns. However, with that said, **I believe Kotlin will reduce enough of the friction of general software development and maintenance on the JVM to make it worth the investment**.\n\n","author":"James Hughes","date":"2016-02-24","type":"article","categories":["Kotlin"],"features":["highlightjs"],"description":"","filename":"","lang":"EN","enclosure":null},{"title":"Future of Kotlin - How agile can language development be?","url":"https://www.slideshare.net/abreslav/future-of-kotlin-how-agile-can-language-development-be","body":"\n<iframe src=\"//www.slideshare.net/slideshow/embed_code/key/jCpYrAZ3vUM3Rf\" width=\"960\" height=\"480\" frameborder=\"0\" marginwidth=\"0\" marginheight=\"0\" scrolling=\"no\" style=\"border:1px solid #CCC; border-width:1px; margin-bottom:5px; max-width: 100%;\" allowfullscreen></iframe>\n","author":"Andrey Breslav","date":"2017-04-22","type":"slides","categories":["Kotlin"],"features":["highlightjs"],"description":"","filename":"","lang":"EN","enclosure":null},{"title":"Solutions to multiple inheritance in Kotlin","url":"https://sites.google.com/a/athaydes.com/renato-athaydes/posts/solutionstomultipleinheritanceinkotlin","body":"\nI have recently come across a little problem that recurs from time to time as I write new code.\n\nI had a base class with some really useful methods that I wanted to make another class extend, but the ditto class already extended some other, equally useful, base class.\n\nIf this were Java, I would just add a field to the class, using [composition rather than inheritance](https://en.wikipedia.org/wiki/Composition_over_inheritance) and be done with it, even if that felt a little clunky, after all that's the best you can do in Java.\n\nHowever, these days I'm using [Kotlin](https://kotlinlang.org/) more often than not. Moving on with the times, I guess!\n\nAnyway, Kotlin has a really interesting feature called [class delegation](https://kotlinlang.org/docs/reference/delegation.html), which allows you to implement composition in a much nicer way than in Java. I was already familiar with this kind of thing from using the [Groovy @Delegate](http://docs.groovy-lang.org/latest/html/gapi/groovy/lang/Delegate.html) AST in the past, so I decided to give it a go.\n\nBefore we proceed, I must note that because classes can have state and initialization logic (including side-effects), Kotlin does not allow true [multiple inheritance](https://en.wikipedia.org/wiki/Multiple_inheritance) as that could [cause havoc](https://blog.jetbrains.com/kotlin/2011/08/multiple-inheritance-part-2-possible-directions/) in slightly more complex class hierarchies (it does allow declaring properties and implementing methods in interfaces, though, as that's free of the subtle problems you could encounter with a more permissive approach)... so we will have to do something similar to Java, but with much appreciated help from the language!\n\nHere's how it works. Imagine you have two different classes you want to mix-in (ie. inherit from) to your type. As long as you have interfaces for those types, it's fairly simple:\n\n```kotlin\n interface CanFly {  \n    fun fly()  \n }  \n\n interface CanWalk {  \n    fun walk()  \n }  \n```\n\nThe concrete classes:\n\n```kotlin  \n class Flyer : CanFly {  \n    override fun fly() = println(\"Flying!\")  \n }  \n\n class Walker : CanWalk {  \n    override fun walk() = println(\"Walking...\")  \n }  \n```\n\nNow, we want a type that has both the ability to walk and fly! In other words, we want a `Pony` :)\n\n```kotlin  \n class Pony(flyer: CanFly, walker: CanWalk) :  \n        CanFly by flyer,  \n  CanWalk by walker  \n```\n\nAnd to actually make a Pony:\n\n```kotlin  \n val pony = Pony(Flyer(), Walker())  \n```\n\nIf the type we're interested in does not implement a useful interface, we can use a simple adapter that implements the interface we're interested in to achieve similar results.\n\nFor example, if `Walker` (the concrete class) did not implement `CanWalk`, we could create a `CanWalkAdapter` like this:\n\n```kotlin  \n class CanWalkAdapter(private val walkFun: () -> Unit) : CanWalk {  \n    override fun walk() = walkFun()  \n }  \n```\n\nNotice that only the (non-default) interface methods need to be manually overridden. The `Pony` class itself would remain the same, and to get our `Pony` in this situation would not be too hard:\n\n```kotlin     \n val pony = Pony(Flyer(), CanWalkAdapter { Walker().walk() })  \n```\n\nThis is just a silly example, so to show how this technique can actually be useful, let's imagine we have a class that already _\"burned\"_ its only chance at inheriting from a base class... and that we want to add caching to it!\n\nYou might already have a class that implements generic caching, and you would certainly want to re-use it. You couldn't mix-in an interface because interfaces, as we saw above, cannot have state, and without state you'll have trouble implementing a cache!\n\nSo, to solve this problem, let's try to use class delegates, as in the silly Pony example above.\n\nFirst, here's our class that will require a cache:\n\n```kotlin  \n abstract class BaseType  \n\n // the super-class is already taken class MyType : BaseType() {  \n\n    fun someFunctionThatCanBeCached(input: Int): String {  \n        // some complicated logic  \n  return input.toString()  \n    }  \n }  \n```\n\nA really simple cache interface/implementation:\n\n```kotlin  \n interface Cache<K, V> {  \n    fun get(input: K, create: (K) -> V): V  \n }  \n\n class MapCache<K, V> : Cache<K, V> {  \n\n    val map = mutableMapOf<K, V>()  \n\n    override fun get(input: K, create: (K) -> V): V =  \n            map.getOrPut(input) { create(input) }  \n }  \n```\n\nAs we saw above, even if the cache-implementation class did not implement an interface (which we need for class delegation), we could've used an adapter to solve that.\n\nAnd finally, the modified `MyType` implementation that delegates caching to some `Cache` implementation:\n\n```kotlin  \n class MyType(cache: Cache<Int, String>) :  \n        BaseType(), Cache<Int, String> by cache {  \n\n    fun someFunctionThatCanBeCached(input: Int): String {  \n        return get(input) {  \n  // some complicated logic  \n  println(\"Running complicated logic\")  \n            input.toString()  \n        }  \n  }  \n }  \n```\n\nWe can now run this code to make sure the cache is working:\n\n```kotlin  \n fun main(args: Array<String>) {  \n    val myType = MyType(MapCache())  \n\n    println(myType.someFunctionThatCanBeCached(3))  \n    println(myType.someFunctionThatCanBeCached(3))  \n\n }  \n```\n\nRunning it prints the following:\n\n```\nRunning complicated logic\n3\n3\n```\n\nAs expected, the \"complicated logic\" only ran the first time.\n\nNow `MyType` has a cache, and can also be used anywhere a cache is required because with minimal effort, it implements the `Cache` interface (which in the real world might have quite a few more methods than this, so would be cumbersome to implement the Java-way).\n\nThis is a simple, but quite useful way to re-use functionality in Kotlin. And one more small way in which using Kotlin can improve your productivity and code quality at the same time.\n\n","author":"Renato Athaydes","date":"2016-11-30","type":"article","categories":["Kotlin"],"features":["highlightjs"],"description":"","filename":"","lang":"EN","enclosure":null},{"title":"Kotlin: Easily storing a list in SharedPreferences with Custom Accessors","url":"http://blog.dennislysenko.com/2016/01/22/kotlin-easily-storing-a-list-in-sharedpreferences-with-custom-accessors/","body":"\nSharedPreferences is at its core a simple tool with a deceptively verbose interface that weighs heavily on developer productivity. Kotlin on its own will not necessarily make Java-interfacing code pretty and concise, but you can apply a few particular concepts to create an elegant, downright easy-to-use solution to a common use-case:\n\n**Storing a list of strings that will persist across app sessions.**\n\nYou can write code as if you have a regular old stored List<String> property, with the additional benefit that it is always in sync with SharedPreferences (*):\n\n```kotlin\n// Adding to a list\nif (syncingSongIds.indexOf(song.id) == -1) {\n    syncingSongIds += song.id\n}\n\n// Iterate through a list and do something with each element\nsyncingSongIds.forEach { id ->\n    stopSyncing(id)\n}\n\n// Best of all: subtracting from a list\nval intent = Intent(DONE_SYNCING)\nintent.putExtra(\"song\", song)\nsendBroadcast(intent) // send a broadcast that we're done syncing\n\nsyncingSongIds -= song.id // and remove the song id from the persisted list of syncing songs\n```\n\nIf you’re interested, read on.\n\nI’m assuming you’re doing this all inside an object or class with access to a `context` property.\n\nFirst of all, let’s set up easy access to the SharedPreferences file we’ll be reading/writing:\n\n```kotlin\nval sharedPreferences: SharedPreferences by lazy {\n    // Replace with your code for accessing shared preferences\n    // e.g. context.getSharedPreferences(SHARED_PREFERENCES_FILENAME, Context.MODE_PRIVATE)\n}\n```\n\nFor the uninitiated, the beauty of lazy properties (`by lazy`) is that they are initialized when you first access the property (i.e. when you first type `sharedPreferences`, it will call `context.getSharedPreferences(...)`) and stored from then on, so in this case, you will only ever call `context.getSharedPreferences(...)` once in the lifetime of your object.\n\n*Skip this paragraph if you already know what a property without a backing field is*. In Java, instance variables are conventionally stored properties. In Kotlin, we get the option to provide completely custom accessors for a property without having any storage for the property. That means we can have a property called `count: Float` on a class `Counter` where the property is never actually **stored** on the Counter class. It’s very useful in instances where you want to have a property that wraps data stored somewhere else (database, server) without having to copy that data into the class containing the property. So the count property on Counter might actually be stored in (i.e., “backed by”) a file on disk: every time you increment the counter, it writes directly to the file on disk, and every time you retrieve the counter’s value, it reads directly from the file on disk. *While this particular example out of context is not a great idea as it incurs tons of I/O overhead, I feel it effectively illustrates the concept of a non-stored property*.\n\nWe are going to create a property that reads directly from, and writes directly to, SharedPreferences, using Kotlin’s syntax for custom accessors:\n\n```kotlin\nvar syncingSongIds: List\n    get() {\n        val raw = sharedPreferences.getString(\"syncing_song_ids\", null) ?: return emptyList()\n        return raw.split(\",\")\n    }\n    set(value) {\n        sharedPreferences.edit().putString(\"syncing_song_idslue.joinToString(\",\")).apply()\n    }\n```\n\nThat’s actually all you need to do for really simple strings that are guaranteed not to have commas in them.\n\n**NB: This will only work for very simple strings. If you want to extend this functionality to be more powerful and accept any string or object type**, try using Google GSON or another JSON serialization library (JSONObject from the Android SDK is perfectly workable, if quirky) and replacing `raw.split(\",\")` and `value.joinToString(\",\")` with a JSON -> Object, and Object -> JSON conversion respectively.\n\n**NB: Because we call `apply()` in the setter rather than `commit`, this code is relatively safe to call on the main thread but it does NOT have immediate consistency**. That is, if you call `syncingSongIds += \"asdf\"; print(syncingSongIds)` it may not include “asdf” in the printout. **To fix this, change `apply()` to `commit()`, but beware of incurring additional overhead** as the setter now has to write to disk synchronously every time it is called. It is your decision as to whether or not to call the setter on the main thread; I think it is relatively safe when done sparingly, but I would certainly keep an eye on that particular setter and make sure it doesn’t adversely impact performance in your app noticeably.\n\n\\* I’m not making any synchronicity guarantees–maybe as a part two, but ultimately if your code is not thread-safe, you should still modify and test these code snippets to fit your synchronicity needs.\n\n","author":"Dennis Lysenko","date":"2016-02-22","type":"article","categories":["Android","Kotlin"],"features":["highlightjs"],"description":"","filename":"","lang":"EN","enclosure":null},{"title":"Classes in Kotlin: More power with less effort","url":"http://antonioleiva.com/classes-kotlin/","body":"","author":"Antonio Leiva","date":"2016-12-07","type":"article","categories":["Kotlin"],"features":["highlightjs"],"description":"","filename":"","lang":"EN","enclosure":null},{"title":"How we made Basecamp 3’s Android app 100% Kotlin","url":"https://m.signalvnoise.com/how-we-made-basecamp-3s-android-app-100-kotlin-35e4e1c0ef12","body":"\n![1_OQsP3e0v1JDMPihSMl2DSQ.png][]\nMade with ❤️ in Chicago.\n\nWe started our Kotlin journey a year ago based on two hunches: that it would 1) make a huge difference in programmer happiness and 2) wildly improve our work quality and speed.\n\nI’m happy to report that our hunches were right! As of this week, Basecamp 3’s Android app is written in 100% Kotlin. \uD83C\uDF89\n\nThat puts us in a unique position to share tips from the experience of going from all Java to all Kotlin. How do you get started? What should you look out for? What are the best ways to keep learning Kotlin?\n\nRead on!\n\n## \uD83E\uDD13 Wrap your head around the basics\n\nFirst thing’s first — take some time to get acclimated with the the language. There are free resources galore, but here are a few I’d recommend:\n\n *  [Jake Wharton’s talk about Kotlin for Android][Jake Wharton_s talk about Kotlin for Android]. This was the lightbulb moment for me. After two watches, I really started to get it.\n *  [Some of my favorite Kotlin features][]. I wrote this a few months after we started with Kotlin. I specifically wrote it to be basic and straightforward so it’d be easy for beginners (which I was at the time!)\n *  [The Kotlin docs][]. When people tell me to read the docs, I often wince. But the Kotlin docs are legit, and are an excellent way to get acclimated.\n\n## \uD83D\uDC22 Start slow but make it real\n\nWriting your first bit of Kotlin is usually the hardest part of getting started.\n\nTo alleviate the pressure, people will often suggest you start with tests or perhaps a Gradle plugin. And while that’s extremely sound advice, it doesn’t work for me. It’s too boring and obscure to get excited about.\n\nI propose something different — write real production code.\n\nThis is important because 1) it’s something you can see working in your app right away and 2) it’s more fun! That feeling of accomplishment and seeing something work shouldn’t be discounted — it builds your confidence and keeps you motivated.\n\nOf course I don’t recommend converting a giant class all at once on your first go. Instead try converting a utility or helper *method.* Take a single method from one of your util classes and rewrite it in Kotlin.\n\nDone! You now have your first bit of production ready Kotlin.\n\n## \uD83D\uDE35 Don’t try to learn the whole language at once\n\nKotlin has *a lot* of great stuff in it — so much that you might be tempted to use it all right away.\n\nAnd while that can work, I wouldn’t recommend it. Instead find a few key concepts that click in *your* brain (not what others tell you are the best parts of the language), and practice using those to their fullest.\n\nWhen I got started, three areas clicked for me: [flow control][] (`when/if/for`), [extension functions][] (add functionality to any class you want), and [null safety][] (in particular the use of `let`). Focusing on just those few concepts helped me get started without feeling overwhelmed.\n\nDon’t be afraid to start small. You need space in your brain not only to pick up new things, but to let them stick. You’re already going to be dealing with basic syntactical differences — if you try to cram all the goodness all at once, something is bound to get overwritten in your brain.\n\n## \uD83D\uDD00 Learn from the auto converter\n\nJetBrains has done a solid job with their Kotlin plugin and its ability to auto convert Java to Kotlin. It can get your class 60–70% of the way there, leaving you with some tuning and idiomatic/stylistic things to take care of.\n\nThere are two great ways to learn from this:\n\n1.  Auto convert the class, but keep the Java class handy. Put them side by side, and see how the Kotlin compares. You’ll pick up a ton by just seeing how the auto converter chose to implement the Java in Kotlin.\n2.  Auto convert the class, but don’t leave it in that state — while the 60% version will run, that last 40% is what makes the difference between OK code and great code. Attack everything for clarity and conciseness and look for ways to follow [Kotlin idioms][] that the auto converter couldn’t figure out.\n\n## \uD83E\uDD14 Question all your Java habits\n\nAs you begin writing Kotlin, the sad reality is that you’ll probably have some bad Java habits you’ll need to break.\n\nI found myself writing terrible `if/else` blocks in cases where a `when` would be so much better. I was writing null checks around objects when a simple `object?.let{}` would’ve been better. And much more.\n\nYou may also have built up some strong ¯\\\\\\_(ツ)\\_/¯ attitudes toward ugly code blocks. Because Java is so verbose, over time you may have begun to accept an occasional ugly code block as “well, that’s Java”.\n\nWriting in Kotlin will help you see through those, but you will need to let go of the idea that ugly code is OK. Sure there will be times when ugly code may be situationally necessary, but you won’t be able to blame Java’s ceremony any more.\n\nSo regularly question whether you are doing something the “Kotlin way”. When you see code that feels long or complicated, pause and take another look at it. Over time you’ll develop new, better habits that will overwrite your Java ones.\n\n## \uD83C\uDFD5️\uD83D\uDCA8 Leave the campsite cleaner than you found it (no new Java ever)\n\nA good way to keep your code heading in the right direction is to tidy up small bits of Java as you pass by. As the saying goes, leave the campsite cleaner than you found it.\n\nA lot of times when building something new, you’ll incidentally need to make a small change to an existing Java class — add an attribute, change a type, etc. These are often small classes like a model or utility class.\n\nConvert them! Don’t be lazy and leave them be. This incremental, slow approach over time will save you and your team much frustration in the long run.\n\n## ❄️ Use cool downs for Kotlin\n\nA great time to work on Kotlin conversions is when you’re cooling down off a big release.\n\nOften we’ll do our normal two week cycle, release a big feature, and then take a few days to watch for stability and customer issues.\n\nThose couple days aren’t going to be enough time to get into something big, so it’s a great time to convert some classes to Kotlin. Over time you’ll get faster at this and be able to knock out a few classes per day.\n\n## \uD83D\uDC74\uD83C\uDFFB Curb your enthusiasms\n\nWhen you start to feel comfortable with Kotlin, you might get a little…excited. That’s a good thing! That energy and enthusiasm keeps you motivated and learning.\n\nBut it’s also easy to go overboard. I certainly did.\n\nI‘d collapse whatever I could into single-expression functions to save lines, only to realize I was giving up clarity. I’d use too many `when` blocks, even in cases where a simple `if/else` would’ve been sufficient and clearer. I’d write extension functions galore, then realize I was creating more cognitive overhead than I was saving.\n\nIt’s wonderful to be enthusiastic and use all the tools that Kotlin gives you. But try to keep your cool (unlike me) and make sure you’re using language features for the right reasons.\n\n## \uD83D\uDCB8 Don’t forget about your customers\n\nWhile seeing more and more Kotlin makes your life much better, you need to keep one very important (obvious?) thing in mind: your customers don’t care.\n\nI fully support the argument that programmer happiness leads to great code and ultimately a better product. It’s crucially important.\n\nBut as with all good things, you need to find the right balance. Converting all your Java to Kotlin might be a fun goal for you, but meanwhile your customers might be struggling with a nagging bug.\n\nThe great thing is that those two things aren’t mutually exclusive. Grab those bugs and squash them with Kotlin — it’s a win-win! (If we’re being honest, Java probably caused the bug in the first place anyway).\n\n## \uD83D\uDC6F Don’t go it alone\n\nDepending on your company makeup, this might be easier said than done. But if you can, find a Kotlin buddy!\n\nThere is no question that I’m more proficient at Kotlin because of my buddy [Jay][]. We regularly share ideas, review each other’s Kotlin, and poke fun at [Jamie][], our designer.\n\nSometimes that stuff happens in informal chats, but the by far the most valuable place to learn is in pull requests. You can let your code speak for itself, and the feedback can do the same. When it comes to learning Kotlin (or any new language really), this is absolutely crucial.\n\nAlright, you made it! I know that’s quite a bit to chew on — maybe some obvious, maybe some not. But I hope it helps get you on the right path to joining us in Kotlinland!\n\n*If this article was helpful to you, please do hit the* \uD83D\uDC9A *button below. Thanks!*\n\n*We’re hard at work making the* [*Basecamp 3 Android app*][Basecamp 3 Android app] *better every day (in Kotlin, of course). Please check it out!*\n\n[1_OQsP3e0v1JDMPihSMl2DSQ.png]: https://cdn-images-1.medium.com/max/800/1*OQsP3e0v1JDMPihSMl2DSQ.png\n[Jake Wharton_s talk about Kotlin for Android]: https://www.youtube.com/watch?v=A2LukgT2mKc\n[Some of my favorite Kotlin features]: https://m.signalvnoise.com/some-of-my-favorite-kotlin-features-that-we-use-a-lot-in-basecamp-5ac9d6cea95\n[The Kotlin docs]: https://kotlinlang.org/docs/reference/basic-syntax.html\n[flow control]: https://kotlinlang.org/docs/reference/control-flow.html\n[extension functions]: https://kotlinlang.org/docs/reference/extensions.html\n[null safety]: https://kotlinlang.org/docs/reference/null-safety.html\n[Kotlin idioms]: https://kotlinlang.org/docs/reference/idioms.html\n[Jay]: https://twitter.com/jayohms\n[Jamie]: https://twitter.com/asianmack\n[Basecamp 3 Android app]: https://play.google.com/store/apps/details?id=com.basecamp.bc3\n","author":"Dan Kim","date":"2017-04-29","type":"article","categories":["Kotlin"],"features":["highlightjs"],"description":"","filename":"","lang":"EN","enclosure":null},{"title":"Testing in Kotlin","url":"http://www.51zero.com/blog/testing-in-kotlin","body":"\nFollowing on from my recent article on Kotlin for Scala developers, in this blog I’ll introduce how you can use the [KotlinTest](https://github.com/kotlintest/kotlintest) framework to write unit tests in Kotlin, which is a great way to begin exploring Kotlin.\n\nKotlinTest is based on [ScalaTest](http://www.scalatest.org/) (a superb jUnit like test framework created by Bill Venners) and offers the same choice of testing styles as well as many assertions and helpers for matching through the use of a light DSL.\n\nTo use KotlinTest first add the dependencies to your build. We’ll assume you’re using gradle (but obviously Maven is fine too).\n\n```kotlin\ncompile 'io.kotlintest:kotlintest:1.1.1'\n```\n\nThen we can create a test. Each test must extend from one of the spec classes. Each spec class offers a different way of laying out your tests. Some are very similar and similar to jTest’s @Test annotation, and some are more complicated offering BDD style descriptions.\n\n### Testing Styles\n\nLets give an example of the FlatSpec, which allows you to write tests like this:\n\n```kotlin\nclass SomeTests : FlatSpec() {\n  init {\n    \"ListStack.pop\" should \"return the last element from stack” {\n      // your test here\n    }\n    \"ListStack.pop\" should \"remove the element from the stack\" {\n      // another test\n    }\n  }\n}\n```\n\nAs you can see, you start with some text, then the keyword should, then some more text, and finally the test as a block. This gives you a readable description of what your test is doing. The split of the test description into two parts means that the IDE / build tools can nest the test output into something like:\n\nListStack.pop should\n\n*   return the last element from stack    ok\n*   remove the element from the stack    ok\n\nAll tests need to be placed inside the init {} block. For those of you coming from a Scala background, this is because Kotlin doesn’t allow the body of the class to be treated as the constructor like you can in Scala.\n\nA quick example of another style is WordSpec, in which the tests are nested. So,\n\n\"ListStack.pop\" should {\n  \"remove the last element from stack\" {\n    // test 1\n  }\n}\n\n\"ListStack.peek\" should {\n  \"should leave the stack unmodified\" {\n    // test 2\n  }\n}\n\nI think this is fairly self explanatory. The rest of the testing styles are available on the KotlinTest homepage.\n\n### Matchers\n\nLet's move onto the matchers. When writing your tests in Java, it is common to use assertions like assertEquals(a, b). This is fine, but we can do something a bit more readable with KotlinTest. As a simple example, to assert two values are equal, we can say\n\n```kotlin\n\"a\" shouldBe \"a\" or \"a\" shouldEqual \"a\"\n```\n\nWe can do clever things with strings:\n\n```kotlin\nsomeStr should start with \"foo\"\nsomeStr should end with \"bar\"\nsomeStr should have substring \"xxx\"\n```\n\nOr with collections\n\n```kotlin\nmyList should have size 4\nmySet should contain element \"a\"\n```\n\nThere are many matchers available for collections, strings, longs, ints, etc.\n\nSometimes we need to assert that an exception is thrown under certain conditions. The typical way to do this in other test frameworks is to wrap the code in a try/catch and then assert false at the bottom of the try, eg\n\n```kotlin\ntry {\n  // this code should throw an exception\n  assert(false)\n} catch (Exception e) {\n  // good\n}\n\n```\n\nWe can remove this boilerplate in KotlinTest using the `shouldThrow<T>` function. Just wrap your code with this function, replacing T with the type (or supertype) of Exception you want to catch, eg\n\n```kotlin\nshouldThrow<IllegalArgumentException> {\n  // code that should throw an exception\n}\n```\n\nOne of the more tricky things in testing, is when you have code that completes non-deterministically. Perhaps you’re sending off an async call and need to wait until a reply comes back.\n\nThe naive way to do this is to sprinkle your test code with Thread.sleeps but how long to wait? You don’t want the time-out to expire prematurely. So if your call takes 2 seconds to complete, you set your sleep to 5 seconds. Until the time your build server is running slow, and 5 seconds wasn't enough, so you set it to 15 seconds. But now you wait 15 seconds every time regardless.\n\nAnother tool is to use countdown latches, and these are often my preferred choice. Have some code trigger the latch once it's completed (i.e. in a callback) and have the main test thread block on the latch.\n\nIf that doesn't work, KotlinTest introduces the eventually function. This allows you to repeatedly probe for a test condition and once it passes the function will return. This means you can wait up to a set time, but no more. It’s very easy to use, you just supply the max time you’re prepared to wait before considering it a failure. Extend the Eventually interface in your test class, e.g.:\n\n```kotlin\nClass MyTest : FlatSpec(), Eventually {\n  Init {\n    \"This test\" should \"finish quickly\" {\n      eventually(5, TimeUnit.SECONDS) {\n        // code here\n      }\n    }\n  }\n}\n```\n\nNow if the assertions doesn't pass within 5 seconds, the test will fail. If the assertions pass quicker than 5 seconds, your test will return as soon as it can.\n\nKotlinTest borrows another feature from ScalaTest in the form of inspectors. Inspectors are helpers for assertions on elements of collections.\n\nLet's suppose you wanted to test that a collection of strings had one at most one string “root”, and the rest of the elements were not “root”, you could do this:\n\n```kotlin\nval count = strings.count { it == \"root\" }\n(count ==0 || count == 1) shouldBe true\n```\n\nWe can do this very easily using an inspector called forAtMostOne. This function will assert that there either zero or one elements pass the assertions, otherwise the test fails.\n\n```kotlin\nforAtMostOne(strings) {  it == \"root\" }\n```\n\nThere are many inspectors: forAll, forNone, forSome, forExactly(k), forAtMostOne, forAtLeastOne. The full list can be found [here](https://github.com/kotlintest/kotlintest#inspectors)\n\nAnother quick example to assert that in a collection of people, some of them are called David some live in London, and some work for 51zero. (By some we mean at least 1, but not all).\n\n```kotlin\nforSome(people) { it .firstName() shouldBe \"David\" }\nforSome(people) { it .location() shouldBe \"London\" }\nforSome(people) { it .employer() shouldBe \"51zero\" }\n```\n\nWriting that without an inspector would be at least a few lines longer.\n\nThe final thing I want to mention is setting up and tearing down tests. We can do this before and after each test, or before and after each test suite (test suite is the class file). To do this we just override whichever methods we need, e.g.\n\n```kotlin\noverride fun beforeEach() {\n  println(\"Test starting\")\n}\n\noverride fun afterEach() {\n  println(\"Test completed\")\n}\n\noverride fun beforeAll() {\n  println(\"Setting up my tests\")\n}\n\noverride fun afterAll() {\n  println(\"Cleaning up after my tests\")\n}\n```\n\nThat’s all for now. This should help get you up and running and using Kotlin in your projects. In the next article, we’ll write about how you can create custom matchers to allow your own DSL syntax for complicated matchers.\n\nPlease let [us](http://www.51zero.com/about) know your experience of testing in Kotlin in the comments below.\n\n","author":"Stephen Samuel","date":"2016-05-10","type":"article","categories":["Kotlin","Testing"],"features":["highlightjs"],"description":"","filename":"","lang":"EN","enclosure":null},{"title":"Kotlin NetBeans plugin beta is out!","url":"https://blog.jetbrains.com/kotlin/2016/09/kotlin-netbeans-plugin-beta-is-out/","body":"\nToday we are happy to present the first BETA release of the Kotlin plugin for the NetBeans IDE.\n\nThe main features are:\n\n* Building and Running Your Code\n* Maven and Ant Support\n* Java Interoperability\n* Code Highlighting\n* Diagnostics\n* Code Completion\n* Navigation\n* Debugging\n* Unit Testing\n* Auto-Import\n* Mark Occurrences\n* Quick Search\n* Code Formatting\n\n## Installation\n\nTo give it a try you will need an installation of NetBeans 8.1. The beta version of Kotlin plugin is available from the [NetBeans Plugin Portal](http://plugins.netbeans.org/plugin/68590/kotlin).\n\nInstallation process:\n\n1. Download Kotlin plugin\n2. Launch NetBeans IDE\n3. Choose **Tools** and then **Plugins** from the main menu\n4. Switch to **Downloaded** tab\n5. On the **Downloaded** tab click **Add Plugins...** button\n6. In the file chooser, navigate to the folder with downloaded plugin. Select the NBM file and click OK. The plugin will show up in the list of plugins to be installed.\n7. Click **Install** button in the Plugins dialog\n8. Complete the installation wizard by clicking **Next**, agreeing to the license terms and clicking **Install** button.\n\n## Using Kotlin in NetBeans\n\nTo start using Kotlin in NetBeans you could create a new Java project (Maven- or Ant-based) or open an existing one. You can mix Java and Kotlin freely, Java classes are accessible from Kotlin and vice versa. At the moment plugin supports Kotlin 1.0.3.\n\nHere is a quick overview of the features.\n\n### Diagnostics\n\n[![diagnostics](https://i0.wp.com/blog.jetbrains.com/kotlin/files/2016/09/diagnostics.png?zoom=1.5&resize=640%2C224&ssl=1)](https://i0.wp.com/blog.jetbrains.com/kotlin/files/2016/09/diagnostics.png?ssl=1)\n\n### Code Completion\n\n[![completion](https://i1.wp.com/blog.jetbrains.com/kotlin/files/2016/09/completion.png?zoom=1.5&resize=640%2C297&ssl=1)](https://i1.wp.com/blog.jetbrains.com/kotlin/files/2016/09/completion.png?ssl=1)\n\n### Navigation\n\nFrom Kotlin to Kotlin:\n\n[![navigationk2k](https://i0.wp.com/blog.jetbrains.com/kotlin/files/2016/09/navigationK2K.png?zoom=1.5&resize=640%2C160&ssl=1)](https://i0.wp.com/blog.jetbrains.com/kotlin/files/2016/09/navigationK2K.png?ssl=1)\n\nFrom Kotlin to Java:\n\n[![navigationk2j](https://i2.wp.com/blog.jetbrains.com/kotlin/files/2016/09/navigationK2J.png?zoom=1.5&resize=640%2C214&ssl=1)](https://i2.wp.com/blog.jetbrains.com/kotlin/files/2016/09/navigationK2J.png?ssl=1)\n\nFrom Java to Kotlin:\n\n[![navigationj2k](https://i2.wp.com/blog.jetbrains.com/kotlin/files/2016/09/navigationJ2K.png?zoom=1.5&resize=640%2C213&ssl=1)](https://i2.wp.com/blog.jetbrains.com/kotlin/files/2016/09/navigationJ2K.png?ssl=1)\n\n### Debugging\n\nYou can\n\n* Set breakpoints\n* Use Step in/out/over\n* View local variables and contents of Kotlin objects\n\n[![debugging](https://i2.wp.com/blog.jetbrains.com/kotlin/files/2016/09/debugging.png?zoom=1.5&resize=640%2C486&ssl=1)](https://i2.wp.com/blog.jetbrains.com/kotlin/files/2016/09/debugging.png?ssl=1)\n\n### Unit Testing\n\nTo write tests in Kotlin you should have JUnit in the classpath of your project.\n\n[![junit](https://i0.wp.com/blog.jetbrains.com/kotlin/files/2016/09/junit.png?zoom=1.5&resize=640%2C348&ssl=1)](https://i0.wp.com/blog.jetbrains.com/kotlin/files/2016/09/junit.png?ssl=1)\n\n### Auto-Import\n\n[![autoimport](https://i1.wp.com/blog.jetbrains.com/kotlin/files/2016/09/autoImport.png?zoom=1.5&resize=640%2C193&ssl=1)](https://i1.wp.com/blog.jetbrains.com/kotlin/files/2016/09/autoImport.png?ssl=1)\n\n### Mark Occurrences\n\n[![occurrences](https://i2.wp.com/blog.jetbrains.com/kotlin/files/2016/09/occurrences.png?zoom=1.5&resize=325%2C115&ssl=1)](https://i2.wp.com/blog.jetbrains.com/kotlin/files/2016/09/occurrences.png?ssl=1)\n\n### Quick Search\n\n[![quicksearch](https://i1.wp.com/blog.jetbrains.com/kotlin/files/2016/09/quickSearch.png?zoom=1.5&resize=640%2C118&ssl=1)](https://i1.wp.com/blog.jetbrains.com/kotlin/files/2016/09/quickSearch.png?ssl=1)\n\n### Feedback Welcome\n\nYour feedback is very important. Feel free to add issues and feature requests in the [plugin issue tracker](https://github.com/Baratynskiy/kotlin-netbeans/issues).\n\nJust like Kotlin itself, the NetBeans plugin is an open-source project, so your contributions can help it evolve faster.\n\n","author":"Dmitry Jemerov","date":"2016-09-19","type":"article","categories":["Kotlin","Netbeans"],"features":["highlightjs"],"description":"","filename":"","lang":"EN","enclosure":null},{"title":"Type safe JavaFX CSS with TornadoFX","url":"https://www.youtube.com/watch?v=rjc8_HGHy3c","body":"\n\n<iframe width=\"960\" height=\"480\" src=\"https://www.youtube.com/embed/rjc8_HGHy3c\" frameborder=\"0\" allowfullscreen></iframe>\n\n","author":"Edvin Syse","date":"2016-04-24","type":"video","categories":["Kotlin","TornadoFx"],"features":["highlightjs"],"description":"","filename":"","lang":"EN","enclosure":null},{"title":"Creating a self-contained Kotlin program using Avian","url":"https://hackernoon.com/creating-a-self-contained-kotlin-app-using-avian-ca7f2987fdd5","body":"\n[Avian](https://readytalk.github.io/avian/) is a lightweight JVM that will allow you to create self-contained apps. That means that you can ship your app without forcing your users to install any JRE. In here, we will follow simple steps that are going to allow us to create a stand-alone hello-world app using Kotlin.\n\n## Why Kotlin?\n\nKotlin is a great language with a lot of potential. I am not going to go through all the advantages of it since a lot of people before me has done it already. So we will leave it at that, great language with a lot of potential. And if you want to read why, there’s plenty of info online.\n\n## Why Avian?\n\nOne of the biggest challenges that Java has is the fact that it requires a Java Runtime Environment. That means that if I write a Java program, every single one of my users will need to download, install, and maybe configure the JRE before they can even launch my program. And in some cases, people are going to prefer not to install certain software to avoid the hassle, if they don’t have a JRE already (or if they have a non compatible version of the JRE.)\n\n## The Result\n\nWhat we are going to finish with is a 1.9MB binary for macOS or 2.2MB for Linux (with some little changes it should work with the other supported platforms, see [here](https://github.com/ReadyTalk/avian/blob/master/README.md),) that once executed will greet the user and print all the arguments that it received. Like this:\n\n```\n$ ./hello Miguel Castiblanco\nHello from Kotlin and Avian\nargs:\n-Miguel\n-Castiblanco\n```\n\n## 1. Before we start\n\n *  $JAVA\\_HOME must be pointing to the correct location\n *  Kotlin must be installed, and kotlinc (Kotlin compiler) must be in $PATH\n *  The commands below are written to work in macOS. Unless mentioned, the command should work in Linux by changing macosx to linux, and the architecture (if needed.) For example *macosx-x86\\_64* would become *linux-i386* or *linux-x86\\_64*\n *  This tutorial is based on the [README](https://github.com/ReadyTalk/avian/blob/master/README.md) of Avian. Most of my work was to make it work with Kotlin instead of Java, and to put it in groups of instructions that makes sense for people new to Avian along with explanations of what we are doing.\n\n## 2. Getting and building Avian\n\nLet’s start by getting the latest version of Avian:\n\n```\n$ git clone https://github.com/ReadyTalk/avian.git\n```\n\nThen build it with the default configuration, and test that it’s working\n\n```\n$ cd avian\n$ make\n$ build/macosx-x86_64/avian -cp build/macosx-x86_64/test Hello\n```\n\nThe last command should print “hello, world!” if everything is correct.\n\n## 3. Writing our simple Kotlin program, and packing it\n\nLet’s create a folder, put our little Kotlin script there, and pack it into a jar.\n\n```\n$ cd ../\n$ mkdir helloKotlin && cd helloKotlin\n$ cat >Hello.kt <<EOF\nfun main(args: Array<String>) {\n   println(\"Hello from Kotlin and Avian\")\n   println(\"args: \")\n   args.forEach {\n      println(\"-\\$it\")\n   }\n}\nEOF\n$ kotlinc Hello.kt -include-runtime -d boot.jar\n```\n\n## 4. Preparing Avian’s runtime to be merged with Kotlin’s\n\nNotice that we are compiling including Kotlin’s runtime, that means that if you run un*zip -l boot.jar* you will see all Kotlin’s classes in there. This is important since we want a stand-alone application.\n\nWe are going to get Avian’s runtime and extract it, and also get the files needed to create a binary with Avian.\n\n```\n$ ar x ../avian/build/macosx-x86_64/libavian.a\n$ mkdir avian-cp\n$ cp ../avian/build/macosx-x86_64/classpath.jar avian-cp/avian-cp.jar\n$ cd avian-cp/\n$ unzip avian-cp.jar && rm -rf avian-cp.jar\n```\n\n## 5. Merging Avian, Kotlin, and our app in one jar\n\nHere we create one jar that has Avian’s runtime, Kotlin’s runtime, and our little application. We’ll just merge all the content that we extracted before from *avian-cp.jar* into *boot.jar* (which already has Kotlin and our code.)\n\n```\n$ mv ../boot.jar .\n$ zip -r boot.jar META-INF avian dalvik java libcore sun\n$ mv boot.jar ../ && cd ../\n```\n\nIf you run un*zip -l boot.jar* now, you will see that all the classes are now happy together.\n\n## 6. Creating a binary\n\nNow we have a self-contained jar. Left is only to use Avian to create a binary out of the jar. First we create an object from the jar.\n\n```\n$ ../avian/build/macosx-x86_64/binaryToObject/binaryToObject boot.jar \\boot-jar.o _binary_boot_jar_start _binary_boot_jar_end macosx x86_64\n```\n\nThe following command will create the c++ main class for our binary. Please notice that *FindClass* is looking for **HelloKt**, since the classes compiled with *kotlinc* wil have a *Kt* suffix (*javac* compiles *Hello.java* into *Hello.class*, whereas *kotlinc* compiles *Hello.kt* into *HelloKt.class.*)\n\n```\n$ cat >embedded-jar-main.cpp <<EOF\n#include \"stdint.h\"\n#include \"jni.h\"\n#include \"stdlib.h\"\n\n#if (defined __MINGW32__) || (defined _MSC_VER)\n#  define EXPORT __declspec(dllexport)\n#else\n#  define EXPORT __attribute__ ((visibility(\"default\"))) \\\n  __attribute__ ((used))\n#endif\n\n#if (! defined __x86_64__) && ((defined __MINGW32__) || (defined _MSC_VER))\n#  define SYMBOL(x) binary_boot_jar_##x\n#else\n#  define SYMBOL(x) _binary_boot_jar_##x\n#endif\n\nextern \"C\" {\n\nextern const uint8_t SYMBOL(start)[];\n  extern const uint8_t SYMBOL(end)[];\n\nEXPORT const uint8_t*\n  bootJar(size_t* size)\n  {\n    *size = SYMBOL(end) - SYMBOL(start);\n    return SYMBOL(start);\n  }\n\n} // extern \"C\"\n\nextern \"C\" void __cxa_pure_virtual(void) { abort(); }\n\nint\nmain(int ac, const char** av)\n{\n  JavaVMInitArgs vmArgs;\n  vmArgs.version = JNI_VERSION_1_2;\n  vmArgs.nOptions = 1;\n  vmArgs.ignoreUnrecognized = JNI_TRUE;\n\nJavaVMOption options[vmArgs.nOptions];\n  vmArgs.options = options;\n\noptions[0].optionString = const_cast<char*>(\"-Xbootclasspath:[bootJar]\");\n\nJavaVM* vm;\n  void* env;\n  JNI_CreateJavaVM(&vm, &env, &vmArgs);\n  JNIEnv* e = static_cast<JNIEnv*>(env);\n\njclass c = e->FindClass(\"HelloKt\");\n  if (not e->ExceptionCheck()) {\n    jmethodID m = e->GetStaticMethodID(c, \"main\", \"([Ljava/lang/String;)V\");\n    if (not e->ExceptionCheck()) {\n      jclass stringClass = e->FindClass(\"java/lang/String\");\n      if (not e->ExceptionCheck()) {\n        jobjectArray a = e->NewObjectArray(ac-1, stringClass, 0);\n        if (not e->ExceptionCheck()) {\n          for (int i = 1; i < ac; ++i) {\n            e->SetObjectArrayElement(a, i-1, e->NewStringUTF(av[i]));\n          }\n\ne->CallStaticVoidMethod(c, m, a);\n        }\n      }\n    }\n  }\n\nint exitCode = 0;\n  if (e->ExceptionCheck()) {\n    exitCode = -1;\n    e->ExceptionDescribe();\n  }\n\nvm->DestroyJavaVM();\n\nreturn exitCode;\n}\nEOF\n```\n\nNow we will compile the C++ class into an object, and link all the objects (notice that in step 4 we copied a bunch of Avian’s objects into the current folder) to finally create our binary, that will be called *hello*.\n\n**For macOS:**\n\n```\n$ g++ -I$JAVA_HOME/include -I$JAVA_HOME/include/darwin \\\n     -D_JNI_IMPLEMENTATION_ -c embedded-jar-main.cpp -o main.o\n$ g++ -rdynamic *.o -ldl -lpthread -lz -o hello -framework CoreFoundation\n$ strip -S -x hello\n```\n\n**For Linux:**\n\n```\n$ g++ -I$JAVA_HOME/include -I$JAVA_HOME/include/linux \\\n     -D_JNI_IMPLEMENTATION_ -c embedded-jar-main.cpp -o main.o\n$ g++ -rdynamic *.o -ldl -lpthread -lz -o hello\n$ strip --strip-all hello\n```\n\n## 7. Run it\n\nNow we can finally run it and see how it works\n\n```\n$ ./hello Kotlin Avian\nHello from Kotlin and Avian\nargs:\n-Kotlin\n-Avian\n$ ls -lha hello\n-rwxr-xr-x 1 starcarr starcarr 2.0M Feb  8 17:03 hello\n```\n\n## Conclusions\n\n *  This process is long and of course it can potentially be transformed into a script that does all the work for us. That being said, it’s important to take the time to do it this way at least once in order to understand how Avian works so that we can troubleshoot when things go south\n *  Avian is opening the door to stand-alone Kotlin and Java apps, which will allow us to create script or utility applications that can be distributed easily for JRE-less machines\n *  The total size of the application was 1.9MB (2.2MB in Linux), which goes to show that Avian is effectively lightweight\n","author":"Miguel Castiblanco","date":"2017-02-09","type":"article","categories":["Kotlin"],"features":["highlightjs"],"description":"","filename":"","lang":"EN","enclosure":null},{"title":"Kotlin Post-1.0 Roadmap","url":"http://blog.jetbrains.com/kotlin/2016/04/kotlin-post-1-0-roadmap/","body":"\nIt’s been almost two months since Kotlin 1.0 was released, and the team is now switching from stabilisation and bug fixes to new feature work, so it’s a great time to talk about our plans for the future.\n\nWe’ve already published our [Android roadmap](http://blog.jetbrains.com/kotlin/2016/03/kotlins-android-roadmap/), but there are many other areas where we’re applying our efforts. Our current development is organised in two main branches:\n\n* **Kotlin 1.0.x** which will be a series of releases containing bug fixes, updates to tooling, IDE support and other areas which do not affect the core language. 1.0.x releases will be published on a regular basis once every several weeks.\n* **Kotlin 1.1** which will contain major new language features, along with all the improvements from the 1.0.x branch. This will be a feature-driven release, and we aren’t announcing any specific time frame for it.\n\nLet’s look at the plans for each area in more detail, starting with the big ones.\n\n## New Language Features\n\nBefore we can start talking about specific features, the **big disclaimer**: everything we’re talking about here is still in the design phase, and features may end up being changed dramatically or dropped entirely as we move forward with the design, implementation and feedback gathering process. So, no guarantees.\n\n### async/await/yield\n\nThe most important feature that we’re designing right now is support for **coroutines** (async/await/yield). By now, the async/await pattern has found its way into many different languages, including C#, Python and Dart, and we want to support this in Kotlin as well. However, that’s not the end of the story: we want to put the specific code execution semantics into the library, rather than the compiler.\n\nThe compiler will take care of transforming the function used as a coroutine into a form allowing to suspend and resume its execution. The actual execution of a coroutine (the initial invocation, as well as resuming the execution after a suspension point) will be the responsibility of the support library. Therefore, the same mechanism will allow us to support many different patterns: generators (`yield`), asynchronously executed functions (`async`/`await`), Go-like channels and goroutines, as well as potentially others which haven’t even been invented yet.\n\nNote that we’re still in the process of estimating the effort needed to implement this feature, and we don’t know whether it would be reasonable to support it in the 1.1 timeframe or it would be postponed to a later release.\n\n### Other Language Features\n\nWe’ve received quite a lot of feedback from Kotlin 1.0, and we were quite happy to see that a lot of the requests were asking for the same features. We’ve chosen the ones that come up the most often, and have prioritised them for Kotlin 1.1. Those we’re reasonably sure about are:\n\n*   **Data class hierarchy support** will remove many of the current restrictions on data class inheritance, for example, allowing you to represent an algebraic data type as a series of data classes nested in a sealed class:\n    ```kotlin\n    sealed class C {\n        data class A(val x: X, val y: Y) : C() { ... }\n    }\n    ```\n*   **Type aliases** will allow to assign a short name to a type (for example, a function type, or a generic type with a long signature):\n    `typealias MouseEventHandler = (MouseEvent) -> Unit`\n*   **Destructuring in lambdas** will allow you to easily unpack a data class instance or another object supporting the destructuring protocol when it’s passed as a parameter to a lambda:\n    `myMap.forEach { (key, value) -> println(key+value) }`\n*   **Bound method references** will allow to create a method reference that invokes a method on a specific object instance, and doesn’t require passing it as a parameter:\n    `letters.filter(\"abc\"::contains)`\n*   **Local delegated properties** will allow you to define a local variable as a delegated property:\n    `fun foo() { val x by lazy { ... } }`\n\n## Java 8/9 Support\n\nAs of version 1.0, Kotlin targets Java 6 only. This means that the generated bytecode does not make use of any features added in Java 7 or 8, and the standard library only exposes the APIs that existed in Java 6.\n\nOver the course of 1.0.x and 1.1 releases and beyond, we plan to remove these restrictions, and to give you the choice of the JVM version that you’re targeting. Java 6 is still going to be supported, but if you choose to target Java 8, we’ll make use of that. The standard library will let you use the new Java 8 APIs, such as the stream API, and the compiler will use the newer bytecode features, such as the support for default methods in interfaces. We also plan to support Project Jigsaw (the JDK 9 module system) by the time JDK 9 is released.\n\n## JavaScript Support\n\nWhen we started finalizing the 1.0 release, we decided to suspend work on JavaScript support and to focus on the JVM as the main supported platform for the release. Now that 1.0 is out, we’ve resumed work on JS, and we’re moving towards our goal of letting you write the business logic of your application only once and to run it both on the backend and in the user’s browser.\n\nOur main priorities for the short term are filling in the missing language features and better integration with the overall JavaScript infrastructure (starting with support for JS module systems). We also plan to leverage the huge set of strongly-typed API definitions for most major JS libraries, which has been accumulated by the TypeScript community. We’ll provide a tool to convert those definitions into Kotlin code, letting you use the libraries from Kotlin with a fully typed API and very little effort spent on integration.\n\n## IDE Features\n\nIn the IDE space, our current priorities are as follows:\n\n* **Framework support**: We plan to extend the unparalleled level of Java enterprise framework support offered by IntelliJ IDEA Ultimate so that it works equally well for Kotlin. This will be a gradual process happening in parallel inside IntelliJ IDEA and inside the Kotlin plugin; the first batch of Spring support features is already available in Kotlin 1.0.2 EAP.\n* **Intentions and Quickfixes:** In our view, one of the main roles of an IDE is teaching you how to use the language well and helping you get back to speed if you make a mistake, by providing code improvement suggestions and automatic quickfixes. Kotlin 1.0 already contains a nice set of tools in this area, and we’re going to expand on it in the 1.0.x and 1.1 updates. As one example, we’re building tools that can convert imperative-style loops into code written in the functional style, using functions such as map and filter.\n* **Other Improvements:** Other things on our roadmap include new refactorings such as Inline Method, a more robust and flexible formatter, support for diagrams for Kotlin code, and more.\n\n## Other Tooling Improvements\n\nThe Android roadmap post already mentioned some of the improvements that we plan to make in our tools, such as support for incremental compilation with Gradle and support for Android Lint checks. Both of these features are already available in Kotlin 1.0.2 EAP, and will receive further improvements later on.\n\n## Summary\n\nAs you can see, there are quite a lot of exciting things coming, and there’s plenty of opportunity for you to get involved. Stop by our [Slack chat](http://kotlinslackin.herokuapp.com/), try out the [EAP builds](https://discuss.kotlinlang.org/c/eap), file [issues](http://youtrack.jetbrains.com/issues/KT) – the future of Kotlin depends on you, our users, and we’re always happy to hear anything that you have to say.\n\n","author":"Dmitry Jemerov","date":"2016-04-14","type":"article","categories":["Kotlin"],"features":["highlightjs"],"description":"","filename":"","lang":"EN","enclosure":null},{"title":"Kotlin 1.1.1 is out","url":"https://blog.jetbrains.com/kotlin/2017/03/kotlin-1-1-1-is-out/","body":"\nToday we’re releasing the first bugfix update for **Kotlin 1.1**. The primary focus of this update is to address regressions causing incorrect code generation; we wanted to get those fixes out as quickly as possible. The details are available in the [changelog][].\n\nThe specific changes worth highlighting are:\n\n *  **Gradle incremental compilation** is now enabled by default. You can still turn it off as described in the [documentation][] if you need to.\n *  Kotlin plugins are now available in the **[Gradle plugin portal][]**. See the [documentation][documentation 1] for usage instructions.\n *  Using function types with receivers as parameter types of **JavaScript external declarations** is no longer allowed. Previously, lambdas passed to such parameters weren’t invoked with correct arguments, and there’s no easy workaround for this issue, so for now we’ve decided to disable the functionality.\n\nWe’ve also updated the Kotlin [Eclipse][] and [NetBeans][] plugins to include Kotlin 1.1.1, so you can enjoy the benefits of the new Kotlin version regardless of your IDE choice.\n\n## How to update ##\n\nTo update the IDEA plugin, use Tools | Kotlin | Configure Kotlin Plugin Updates and press the “Check for updates now” button. Also, don’t forget to update the compiler and standard library version in your Maven and Gradle build scripts.\nThe command-line compiler can be downloaded from the [Github release page][].\n\nAs usual, if you run into any problems with the new release, you’re welcome to ask for help on the [forums][], on Slack (get an invite [here][]), or to report issues in the [issue tracker][].\n\nLet’s Kotlin!\n\n[changelog]: https://github.com/JetBrains/kotlin/blob/1.1.1/ChangeLog.md\n[documentation]: http://kotlinlang.org/docs/reference/using-gradle.html#incremental-compilation\n[Gradle plugin portal]: https://plugins.gradle.org/\n[documentation 1]: http://kotlinlang.org/docs/reference/using-gradle.html\n[Eclipse]: https://marketplace.eclipse.org/content/kotlin-plugin-eclipse\n[NetBeans]: http://plugins.netbeans.org/plugin/68590/kotlin\n[Github release page]: https://github.com/JetBrains/kotlin/releases/tag/v1.1.1\n[forums]: https://discuss.kotlinlang.org/\n[here]: http://kotlinslackin.herokuapp.com/\n[issue tracker]: https://youtrack.jetbrains.com/issues/KT\n","author":"Dmitry Jemerov","date":"2017-03-14","type":"article","categories":["Kotlin"],"features":["highlightjs"],"description":"","filename":"","lang":"EN","enclosure":null},{"title":"Bytecode behind coroutines in Kotlin","url":"http://jonnyzzz.com/blog/2017/04/26/corotines-or-state-machine/","body":"\nA simple suspend function, and it’s bytecode.\n\nThe new thing in Kotlin 1.1 is [coroutines](http://kotlinlang.org/docs/reference/coroutines.html). As we know from the documentation, it is the `suspend` keyword that was added to the language. The rest is implemented as libraries.\n\nLet’s take a look at the bytecode side of this feature.\n\n# An Empty Suspend function\n\nI have the following code snippet:\n\n```kotlin\nsuspend fun b() {}\n```\n\nLet’s take a look to the bytecode from this method. For the experiment, I use Kotlin 1.1.1 with IntelliJ IDEA 2017.1. Results may depend on version. I use `javap -c` to generate those dumps\n\n```\npublic static final java.lang.Object b(kotlin.coroutines.experimental.Continuation<? super kotlin.Unit>);\n    Code:\n       0: aload_0\n       1: ldc           #13                 // String $continuation\n       3: invokestatic  #19                 // Method kotlin/jvm/internal/Intrinsics.checkParameterIsNotNull:(Ljava/lang/Object;Ljava/lang/String;)V\n       6: getstatic     #25                 // Field kotlin/Unit.INSTANCE:Lkotlin/Unit;\n       9: areturn\n```\n\nThe interface `Continuation` is declared in the Kotlin standard library, see [documentation](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.coroutines.experimental/). It contains `context` and methods to complete continuation: `resume` and `resumeWithException`.\n\n# A Trivial Suspend function\n\n```kotlin\nsuspend fun b2() {\n  a()\n  c()\n}\n```\n\nHere `a()` and `c()` are calls to ordinary Java methods, which were declared in Kotlin without the `suspend` keyword.\n\n```\npublic static final java.lang.Object b2(kotlin.coroutines.experimental.Continuation<? super kotlin.Unit>);\n    Code:\n       0: aload_0\n       1: ldc           #13                 // String $continuation\n       3: invokestatic  #19                 // Method kotlin/jvm/internal/Intrinsics.checkParameterIsNotNull:(Ljava/lang/Object;Ljava/lang/String;)V\n       6: invokestatic  #29                 // Method a:()V\n       9: invokestatic  #31                 // Method c:()V\n      12: getstatic     #25                 // Field kotlin/Unit.INSTANCE:Lkotlin/Unit;\n      15: areturn\n```\n\nAs we see from this code, there is nothing special done to the method. The only return value and additional parameter were added.\n\n# A suspend function with a suspend call\n\n```kotlin\nsuspend fun b3() {\n  a()\n  b3()\n  c()\n}\n```\n\nIn this example, we call `b3()` suspend function from itself. Here `a()` and `c()` are calls to ordinary Java methods, which were declared in Kotlin without `suspend` keyword. The generated code now looks way different.\n\n```\npublic static final java.lang.Object b3(kotlin.coroutines.experimental.Continuation<? super kotlin.Unit>);\n    descriptor: (Lkotlin/coroutines/experimental/Continuation;)Ljava/lang/Object;\n    Code:\n       0: aload_0\n       1: ldc           #13                 // String $continuation\n       3: invokestatic  #19                 // Method kotlin/jvm/internal/Intrinsics.checkParameterIsNotNull:(Ljava/lang/Object;Ljava/lang/String;)V\n       6: new           #34                 // class streams4/ZKt$b3$1\n       9: dup\n      10: aload_0\n      11: invokespecial #38                 // Method streams4/ZKt$b3$1.\"<init>\":(Lkotlin/coroutines/experimental/Continuation;)V\n      14: getstatic     #25                 // Field kotlin/Unit.INSTANCE:Lkotlin/Unit;\n      17: aconst_null\n      18: invokevirtual #42                 // Method streams4/ZKt$b3$1.doResume:(Ljava/lang/Object;Ljava/lang/Throwable;)Ljava/lang/Object;\n      21: areturn\n```\n\nInstead of having the method in-place, it now generates an inner class for the state-machine to implement the `suspend`.\n\nThe class `streams4/ZKt$b3$1` is generated as follows\n\n```\nfinal class streams4.ZKt$b3$1 extends kotlin.coroutines.experimental.jvm.internal.CoroutineImpl {\n  public final java.lang.Object doResume(java.lang.Object, java.lang.Throwable);\n    descriptor: (Ljava/lang/Object;Ljava/lang/Throwable;)Ljava/lang/Object;\n    Code:\n       0: invokestatic  #13                 // Method kotlin/coroutines/experimental/intrinsics/IntrinsicsKt.getCOROUTINE_SUSPENDED:()Ljava/lang/Object;\n       3: astore_3\n       4: aload_0\n       5: getfield      #17                 // Field kotlin/coroutines/experimental/jvm/internal/CoroutineImpl.label:I\n       8: tableswitch   { // 0 to 1\n                     0: 32\n                     1: 58\n               default: 74\n          }\n      32: aload_2\n      33: dup\n      34: ifnull        38\n      37: athrow\n      38: pop\n      39: invokestatic  #23                 // Method streams4/ZKt.a:()V\n      42: aload_0\n      43: aload_0\n      44: iconst_1\n      45: putfield      #17                 // Field kotlin/coroutines/experimental/jvm/internal/CoroutineImpl.label:I\n      48: invokestatic  #27                 // Method streams4/ZKt.b3:(Lkotlin/coroutines/experimental/Continuation;)Ljava/lang/Object;\n      51: dup\n      52: aload_3\n      53: if_acmpne     66\n      56: aload_3\n      57: areturn\n      58: aload_2\n      59: dup\n      60: ifnull        64\n      63: athrow\n      64: pop\n      65: aload_1\n      66: pop\n      67: invokestatic  #30                 // Method streams4/ZKt.c:()V\n      70: getstatic     #36                 // Field kotlin/Unit.INSTANCE:Lkotlin/Unit;\n      73: areturn\n      74: new           #38                 // class java/lang/IllegalStateException\n      77: dup\n      78: ldc           #40                 // String call to 'resume' before 'invoke' with coroutine\n      80: invokespecial #44                 // Method java/lang/IllegalStateException.\"<init>\":(Ljava/lang/String;)V\n      83: athrow\n\n  streams4.ZKt$b3$1(kotlin.coroutines.experimental.Continuation);\n    descriptor: (Lkotlin/coroutines/experimental/Continuation;)V\n    Code:\n       0: aload_0\n       1: iconst_0\n       2: aload_1\n       3: invokespecial #58                 // Method kotlin/coroutines/experimental/jvm/internal/CoroutineImpl.\"<init>\":(ILkotlin/coroutines/experimental/Continuation;)V\n       6: return\n}\n```\n\nThe implementation of `b3()` function is moved to a state machine anonymous object. The main method of the inner object does a switch over states of the state machine. The `b3()` function is split by every `suspend` function call. On the example below, we have only 2 states. This is up to helper functions to assert the machine is always in a correct state.\n\nOn every `suspend` function call, Kotlin creates an object to encapsulate the state of the state machine, that is created to implement the continuations on top of JVM.\n\n# Conclusion\n\nCoroutines in Kotlin are awesome, easy and powerful constructs that give us the power to fight the complexity (by the cost of an extra abstraction level). I’m looking forward to using coroutines to simplify asynchronous code in my apps.\n\nFor more information and details see [Kotlin coroutines](http://kotlinlang.org/docs/reference/coroutines.html) documentation.\n","author":"Eugene Petrenko","date":"2017-04-26","type":"article","categories":["Kotlin"],"features":["highlightjs"],"description":"","filename":"","lang":"EN","enclosure":null},{"title":"Upgrade your workflow with 0-installation kotlin scriptlets","url":"http://holgerbrandl.github.io/kotlin/2016/12/02/mini_programs_with_kotlin.html","body":"\nIn common bioinformatics/scientific workflows black magic bash hacking skills are often required and used to process data. This is because these workflows tend to live in the bash-shell, and for many data processing tasks there is no actual direct tool. To make data flow nevertheless _solution repositories_ like [biostar](https://www.biostars.org/) or [stackoverflow](http://stackoverflow.com/) tend to suggest crazy combinations of `perl`, `grep`, `awk` or `sed` mixed with various amounts of `bash`. Such solutions often lack engineering quality, depend on specific platforms and versions, and tend to very cryptic even for well-trained data monkeys. More high-level solution in _python_ or _R_ could be used as well, but hardly ever run without additional setup efforts.\n\nTo overcome this problem, I’ve evolved a small extension tool to named [`kscript`](https://github.com/holgerbrandl/kscript) over the last months. It allows to easily embed [Kotlin](https://kotlinlang.org/) scriptlets into the shell, and ships with features like compile-jar-caching and automatic dependency resolution. Just see its [github page](https://github.com/holgerbrandl/kscript) for details and examples.\n\nAlthough `kscript` has helped to create readable kotlin solutions for a range of data flow problems, it was still a bit tedious to ship around developed solutions in a concise and user-friendly manner. To overcome this problem, I’ve recently enhanced `kscript` to also allow for URLs as scriptlet sources.\n\nLet’s do an example. Imagine you’d need to filter a list of genomic sequences saved in a [fasta-formatted](https://en.wikipedia.org/wiki/FASTA_format) file by length. This is how the data may look like:\n\n```\n>HSBGPG Human gene for bone gla protein (BGP)\nGGCAGATTCCCCCTAGACCCGCCCGCACCATGGTCAGGCATGCCCCTCCTCATCGCTGGGCACAGCCCAGAGGGT\nATAAACAGTGCTGGAGGCTGGCGGGGCAGGCCAGCTGAGTCCTGAGCAGCAGCCCAGCGCAGCCACCGAGACACC\nCTCCAGGCACCCTTCTTTCCTCTTCCCCTTGCCCTTGCCCTGACCTCCCAGCCCTATGGATGTGGGGTCCCCATC\nATCCCAGCTGCTCCCAAATAAACTCCAGAAG\n>HSGLTH1 Human theta 1-globin gene\nCCACTGCACTCACCGCACCCGGCCAATTTTTGTGTTTTTAGTAGAGACTAAATACCATATAGTGAACACCTAAGA\nCGGGGGGCCTTGGATCCAGGGCGATTCAGAGGGCCCCGGTCGGAGCTGTCGGAGATTGAGCGCGCGCGGTCCCGG\nGATCTCCGACGAGGCCCTGGACCCCCGGGCGGCGAAGCTGCGGCGCGGCGCCCCCTGGAGGCCGCGGGACCCCTG\nTCAGCCCCGCGCTGCAGGCGTCGCTGGACAAGTTCCTGAGCCACGTTATCTCGGCGCTGGTTTCCGAGTACCGCT\nGAACTGTGGGTGGGTGGCCGCGGGATCCCCAGGCGACCTTCCCCGTGTTTGAGTAAAGCCTCTCCCAGGAGCAGC\nCTTCTTGCCGTGCTCTCTCGAGGTCAGGACGCGAGAGGAAGGCGC\n>ARGH1 Transcriptional regulartor\nATCCAGGGCGATTCAGAGGGCCCCGGGCCACGTTATCTCGGCGCTGGTTTCGCGCTGGTTTCGCGCTGGTTTCGC\nCTGGTTTCC\n```\n\nFor sure, there are many different [ways to solve](https://www.biostars.org/p/79202/) this problem. E.g. using a tool called `samtools faidx` with downstream filtering of its output using `awk`. Or by reformating the multi-line fasta into single-line via `perl` plus some `awk` and so on. [BioPyton](https://github.com/biopython/biopython.github.io/) or [BioPerl](http://bioperl.org/) also do the trick, are very readable, but require installation and additional setup efforts.\n\nTo allow for **0-installation scriptlets** that do their own automatic dependency resolution, `kscript` comes to rescue. Here’s a Kotlin solution for the filter problem from above, which we’ll work through step by step:\n\n```kotlin\n//DEPS de.mpicbg.scicomp:kutils:0.4\n//KOTLIN_OPTS -J-Xmx2g\n\nimport de.mpicbg.scicomp.bioinfo.openFasta\nimport java.io.File\nimport kotlin.system.exitProcess\n\nif (args.size != 2) {\n System.err.println(\"Usage: fasta_filter <fasta> <length_cutoff>\")\n exitProcess(-1)\n}\n\nval fastaFile = File(args[0])\nval lengthCutoff = args[1].toInt()\n\nopenFasta(fastaFile).\n filter { it.sequence.length >= lengthCutoff }.\n forEach { print(it.toEntryString()) }\n```\n\n* First a single dependency is added that provides a Kotlin API to parse fasta-formatted data.\n* Because some of the sequences might be large we want to run with 2gb of memory.\n* Since it is supposed to be a self-contained mini-program it ships a simplistic CLI involving just an input file and the length-cutoff.\n* The implementation is straightforward: We create an iterator over the entries in the fasta-file, which is filtered by length, and the remaining entries are printed to stdout.\n\nBecause of Kotlin’s nice and concise collections API and syntax, the solution should be readable almost even to non-developers. ;-)\n\nPreviously `kscript` allowed to run such scriptlets either from a file or inlined (See its [docs]((https://github.com/holgerbrandl/kscript)) for more examples):\n\n```kotlin\n## simply read the script from stdin\necho 'println(\"hello world\")' | kscript -\n\n## or read it from a file\necho 'println(\"hello world\")' > test.kts\nkscript test.kts\n```\n\nHowever, since recently `kscript` also can **now also read URLs** which elevates its usage to a new level: The fasta length filter scriplet from above was deposited as a [gist](https://gist.github.com/holgerbrandl/521a5e9b1eb0d5b443b82cf13f66074f) on github, and we can now simply write\n\n```bash\nkscript https://git.io/v1ZUY test.fasta 20 > filtered.fasta\n```\n\nTo further increase readability and convenience, we can `alias` the first part\n\n```bash\nalias fasta_length_filter=\"kscript https://git.io/v1ZUY\"\n\nfasta_length_filter ~/test.fasta 20 > filtered.fasta\n```\n\nWhen being invoked without arguments `fasta_length_filter` will provide just the usage info.\n\nDepending on the users’ preference the URL could point either to the master revision of the gist or to a particular revision for better reproducibility. Since the scriplet is versioned along with its dependencies (which ware fetched via `maven`), this approach does not depend on API stability for the external libraries being used – a common problem which is tedious to overcome when working with python, R or perl! In contrast `kscript` solutions provide absolute **long-term stability** (within the limits of a hardly ever changing JVM and the kotlin compiler).\n\nIn this post I’ve discussed how to write versioned, bootstrapping mini-programs using `kscript` and `Kotlin`. In my next posting I’ll talk about the support APi for `kscript` to allow for `awk`-like one-liners written in Kotlin to please they eye instead of being confusing and `aw(k)`ful.\n\n","author":"Holger Brandl","date":"2016-12-02","type":"article","categories":["Kotlin","Scripts"],"features":["highlightjs"],"description":"","filename":"","lang":"EN","enclosure":null},{"title":"Custom Views in Android with Kotlin","url":"https://antonioleiva.com/custom-views-android-kotlin/","body":"","author":"Antonio Leiva","date":"2016-12-27","type":"article","categories":["Kotlin","Android"],"features":["highlightjs"],"description":"","filename":"","lang":"EN","enclosure":null},{"title":"Android + Kotlin = <3","url":"http://blog.zuehlke.com/en/android-kotlin/","body":"\nThe Android SDK has come a long way since its early days to make developing for Android as comfortable and efficient as possible. Yet there’s one thing that still gets in our way: The Java language. While more modern languages like C# or Swift make it possible to write code that is elegant and at the same time easy to read and understand, we’re still stuck with Java 7 for Android Development. Its cumbersome syntax for executing code on a different thread asynchronously, for example, or the fact that you require separate libs for even the most basic tasks like null-safe string comparison really make it a pain for development.\n\n## A New Hope\n\nAt this year’s Berlin DroidCon, I found one session in the conference schedule very intriguing: [A talk by Svetlana Isakova from JetBrains](http://www.droidcon.de/session/kotlin-swift-android) on [the Kotlin language](http://kotlinlang.org/) – “The Swift of Android”, according to the session title. Of course I attended, and during the talk I couldn’t help but start to smile, and that smile grew bigger and bigger: Kotlin and its accompanying extensions and plugins for Android addressed so many annoying issues of Java development for Android! No more enviously looking over to Apple’s Swift for iOS development! Also I found the syntax to be very intuitive. I simply had to try it out ASAP – and what better opportunity to do so than Zühlke’s educational Camp?\n\n## An Easy Language To Get Into\n\nFor the 2015 Camp, there were already plans for exploring the development for Android Wear by writing an app that connected to a sensor via Bluetooth Low Energy. The app should get historic data from the sensor and forward it to a connected Android Wear device, including notifications for certain events.\n\nThe colleague who was going to develop the Android app together with me wasn’t aware of my decision to use Kotlin for the project until right before we started coding. But nevertheless, we both were able to pick up the new language and start writing our app very quickly. This is due to several things.\n\nFirst of all, the [reference documentation](http://kotlinlang.org/docs/reference/) is very well written and easy to get into. JetBrains also provides a plugin for IntelliJ, Android Studio and Eclipse that greatly helps development in Kotlin. The Android Studio plugin we used not only provides proper debugging, auto-completion, code navigation and full refactoring support, but it also lets developers convert existing Java code files to Kotlin with just one click.\n\nAnother thing that makes it easy to use Kotlin in your Android project is the fact that, much like Scala, it’s **100% interoperable with Java code**! Kotlin compiles to regular Java Byte Code, and you can use existing Java classes in your project from Kotlin and vice versa. If you are familiar to Android development and want to write a new Activity you can do it like this:\n\n```kotlin\nclass MyActivity : Activity() {\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super<Activity>.onCreate(savedInstanceState)\n        ...\n    }\n}\n```\n\nSimply inherit from `Activity` as before! The language is different, but you can use the framework and your own existing code, or for that matter, any existing Java library. Therefore you can gradually migrate to Kotlin if you don’t want to convert all your Java code to Kotlin right away.\n\nThe most important thing though is the incredible **ease of use** of the language. Being under development since 2010 and having gone open source in 2012, Kotlin has become very mature by now. It has adapted the great features of so many other languages. Here are some examples.\n\n## Some Nifty Kotlin Features\n\nWhen adding a property to your class, you don’t write the backing field and getters and setters separately. Instead, you do:\n\n```kotlin\npublic var context: Context? = null\n    get\n    set (value) {\n        $context = value\n        if (context != null) {\n            setupBluetooth()\n        }\n    }\n```\n\nLooks familiar? Yup, that’s **C#-style properties** right there, which are accessed without calling the getter/setter explicitly. Also **classes and their member functions are final by default** and need to be declared `open` or `abstract` in order to be overridden.\n\nLike Scala, Kotlin does away with static methods and fields, which are so easily misused in Java. Instead of using those, Kotlin facilitates the declaration of **singleton objects**. Instead of declaring a class with some “instance” method, you simply declare an object right away, which can be used directly:\n\n```kotlin\nobject MySingleton {\n    fun myFunction() { [...] }\n}\nMySingleton.myFunction()\n```\n\n**Null-safety** is also an important aspect of Kotlin. Every type is non-nullable by default, and you get a compile error when trying to assign or pass `null` to it. A type is made nullable by putting a question mark behind it. When accessing a nullable variable, Kotlin enforces a null check:\n\n```kotlin\nvar foo: String? = \"bar\" // foo is nullable now\nvar length = foo.length() // Compile error\nvar character = foo?.charAt(0) // OK; result is null if foo == null\nvar length2: Int = if (foo != null) foo.length() else 0 // Inlined null check\nvar nonNullFoo: String = foo ?: \"baz\" // Elvis operator; result is \"baz\" if foo = null\nvar letter = foo?.subSequence(0, 1) ?: return\nif (foo != null) { // Null check in the surrounding code\n    character = foo.last() // -> Smart-cast to non-null\n}\nvar bang = foo!!.capitalize() // Forced to non-null. CAUTION: If it is null, you get an NPE!\n```\n\nThe concept is similar to Swift’s Optionals or Nullable Types in C#, though the syntax is a little different here. But it’s extremely comfy to use, and it prevents the dreaded `NullPointerException`s effectively.\n\nIf you’re missing a useful method on a foreign class, simply write an **extension function**:\n\n```kotlin\nfun String?.append(other: String): String {\n    if (this == null) {\n        return other\n    }\n    return this + other\n}\nvar hi: String? = \"Hello \"\nvar all = hi.append(\"World\")\n```\n\nNotice how the method extends the _nullable_ String? This way you can gracefully handle `null` objects without using null checks as shown above.\n\n## At last – Lambdas!\n\nAnd last but not least there’s Kotlin’s **Lambda** support. Especially in the context of any asynchronous communication, this is a godsend. For example, lambdas provide an elegant way of handling the many asynchronous callbacks that are used by Android’s Bluetooth Low Energy API. The syntax for declaring and using lambdas looks like this:\n\n```kotlin\nvar filtered = intArray.filter { it > 0 }\nintArray.forEachIndexed { index, element ->\n    println(index + “:” + element)\n}\n```\n\nAnd here’s a function declaration that takes a lambda argument:\n\n```kotlin\nfun myFunction(param1: String, callback: (result: Int?, error: String?) -> Unit) {\n    [...]\n}\n```\n\nWhen passing Lambdas to functions, they are usually in-lined in the function call, but you can also assign them to variables as **first-class objects** and pass them around later. Here’s how that looks like:\n\n```kotlin\nprivate var myCallback: Function1<String, Unit> = { param1: String ->\n    println(\"Hi $param1\")\n}\n```\n\nAnd it doesn’t stop there; these features of Kotlin and many more make it possible to write code that’s elegant and easily understandable. But let’s get into some Android stuff.\n\n## Android Development With Pleasure\n\nIn addition to Kotlin’s own features, the [Anko library](https://github.com/JetBrains/anko) provides Extensions that eliminate a lot of the boilerplate code typically found in Android projects. One example is the **simplified “toast” statement**. Instead of the usual “Toast-makeText-context-content-length-show” sermon, you just do:\n\n```kotlin\ntoast(\"A toast to Android!\")\n```\n\nThe **findViewById** procedure has also been simplified:\n\n```kotlin\nval myText: TextView = find(R.id.myTextView)\n```\n\n**View hierarchies** can be quickly defined in Kotlin in the Activity code, including layout and listeners:\n\n```kotlin\nlinearLayout {\n    button(\"Login\") {\n        textSize = 26f\n        onClick {\n            doSomeStuff()\n        }\n    }.layoutParams(width = wrapContent) {\n        horizontalMargin = dip(5)\n        topMargin = dip(10)\n    }\n}\n```\n\nAnother extremely helpful feature is the simplified use of Android’s ugly and unwieldy `AsyncTask`. With Anko, **executing asynchronous code** on a worker thread and processing results on the UI thread is as simple as:\n\n```kotlin\nasync {\n    doSomeWork() // Long background task\n    uiThread {\n        result.text = \"Done\"\n    }\n}\n```\n\nTired of **SQLite handling**, with all its `Cursor` handling and countless `try...catch` blocks? Just extend Anko’s `ManagedSQLiteOpenHelper`! It contains lots of little utilities that greatly simplify your database access code. Here’s an `INSERT` using your `ManagedSQLiteOpenHelper`:\n\n```kotlin\nuse { // Now \"this\" is the SQLiteDatabase, opened for read/write\n    try {\n        insert(\"ShoppingList\", // Table name\n                \"id\" to item.id,\n                \"title\" to item.title,\n                \"checked\" to item.checked)\n    } catch (exception: SQLiteException) { // SQL exceptions can still occur, of course\n        error(\"INSERT threw exception: $exception\")\n    }\n} // At the end of the block the DB is automatically closed\n```\n\nLooks neat? Wait till you see some `SELECT` code:\n\n```kotlin\nvar result: List<ShoppingItem> = ArrayList<ShoppingItem>()\nuse {\n    try {\n        result = select(\"ShoppingList\", \"id\", \"title\", \"checked\")\n                .where(\"checked = {checkedArg}\", \"checkedArg\" to 1)\n                .orderBy(\"id\", SqlOrderDirection.ASC)\n                .exec {\n            parseList(classParser<ShoppingItem>())\n        }\n    } catch (exception: SQLiteException) {\n        error(\"SELECT threw exception: $exception\")\n    }\n}\n// Now process the result list\n```\n\nHow’s that for brevity? Just assemble your `SELECT` statement using fluent-style syntax, then automatically transform the returned `Cursor` into a `List` of your data items. The Parser is automatically generated from your data class, provided it has a constructor that matches the selected columns.\n\nAnd this is just the tip of the iceberg! Anko also provides simplified mechanisms for Intent dispatching, Service retrieval, Logging and a lot more.\n\n## Conclusion\n\nHaving tried out Kotlin in the context of Android development now, I can definitely see it becoming my new language of choice for Android development. It’s well made, mature and makes coding an absolute joy. The official Android documentation may be written for Java, but it’s easy to “translate” it to Kotlin, so any Android developer should definitely give Kotlin & Anko a try. Here’s hoping that Google will provide an Android API reference & guide in Kotlin in the near future, and that it will eventually become the de-facto standard for Android!\n\n","author":"Michael Sattler","date":"2015-07-20","type":"article","categories":["Kotlin","Android"],"features":["highlightjs"],"description":"","filename":"","lang":"EN","enclosure":null},{"title":"Kotlin 1.1-M03 is here!","url":"https://blog.jetbrains.com/kotlin/2016/11/kotlin-1-1-m03-is-here/","body":"\nWe are pleased to announce the third milestone of the upcoming Kotlin 1.1. This release brings new language features as well as improvements and fixes in the JavaScript backend, compiler and IDEA plugin. The new release also includes all tooling features introduced in Kotlin 1.0.5, and is compatible with IntelliJ IDEA 2016.3 EAP and Android Studio 2.2 and 2.3.\n\nAs with other milestone releases, we give **no backwards compatibility guarantees** for new language and library features. Anything introduced in milestone releases of 1.1 is **subject to change** before the final 1.1 release.\n\nPlease do share your feedback regarding the new features or any problems that you may run into with this release, via [YouTrack](https://youtrack.jetbrains.com/issues/KT), [forums](https://discuss.kotlinlang.org) and [Slack](http://kotlinlang.slack.com/).\n\nThe full changelog for 1.1-M03 is available [here](https://github.com/JetBrains/kotlin/blob/1.1-M03/ChangeLog.md).\n\n## Underscore for unused symbols\n\nYou can now use an underscore instead of the name of an unused parameter of a lambda:\n\n```kotlin\nfoo { _, x -> ... }\n```\n\nAnd an unused variable name in destructuring declarations can now be replaced with an underscore as well.\n\n```kotlin\nval (x, _, z) = expr\n```\n\nBoth cases are described in detail in the appropriate [KEEP](https://github.com/Kotlin/KEEP/blob/master/proposals/underscore-for-unused-parameters.md).\n\n## Underscore in numeric literals\n\nIn accordance with Java 8 specification, Kotlin supports now numeric literals with single underscore symbols between digits. For example:\n\n```kotlin\nval ONE_MILLION = 1_000_000\n```\n\nSee the [KEEP](https://github.com/Kotlin/KEEP/blob/master/proposals/underscores-in-numeric-literals.md) for more details and examples.\n\n## Generic Enum values access\n\nThe support of the [proposal](https://github.com/Kotlin/KEEP/blob/master/proposals/generic-values-and-valueof-for-enums.md) is landed to the standard library in a form of two intrinsic functions:\n\n```kotlin\ninline fun <reified T : Enum<T>> enumValues(): Array<T>\ninline fun <reified T : Enum<T>> enumValueOf(name: String): T\n```\n\nThey allow to enumerate the values of a generic enum type. E.g.\n\n```kotlin\nenum class RGB { RED, GREEN, BLUE }\n\nprint(enumValues<RGB>().joinToString { it.name }) // prints RED, GREEN, BLUE\n```\n\n## Scope control for builder-like DSLs\n\nAs described in details in the [KEEP](https://github.com/Kotlin/KEEP/blob/master/proposals/scope-control-for-implicit-receivers.md), DSL authors had problems in expressing scope restrictions for builder-like constructs. E.g., for some html-builder DSL:\n\n```kotlin\ntable {\n  tr {\n    tr {} // PROBLEM: Table.tr() is valid here\n  }\n}\n```\n\nTo solve the problem we added the `@DslMarker` annotation that allows to control visibility scope in these cases more precisely. For usage example see  [preview version of kotlinx.html library using this feature](https://github.com/Kotlin/kotlinx.html/tree/dsl-markers) (see [HtmlTagMarker](https://github.com/Kotlin/kotlinx.html/blob/dsl-markers/shared/src/main/kotlin/api.kt#L103) and [HTMLTag](https://github.com/Kotlin/kotlinx.html/blob/dsl-markers/shared/src/main/kotlin/htmltag.kt#L5) implementations and [DSL-markers.md](https://github.com/Kotlin/kotlinx.html/blob/dsl-markers/DSL-markers.md) for the preview library usage info).\n\n## Standard library unification\n\nThe standard library unification process for different platforms is moving forward. We have started unifying exception types in 1.1-M2 and now some more common types, which are supported on all platforms, are available in `kotlin.*` packages, and are imported by default. These include:\n\n* `ArrayList`, `HashSet`, `LinkedHashSet`, `HashMap`, `LinkedHashMap` in `kotlin.collections`\n* `Appendable` and `StringBuilder` in `kotlin.text`\n* `Comparator` in `kotlin.comparisons`\n\nOn JVM these are just typealiases of the good old types from `java.util` and `java.lang`\n\n## New language features support in the JavaScript backend\nn\nJavaScript backend now supports the following Kotlin language features on par with JVM backend:\n\n* Coroutines\n* Destructuring in lambda parameters\n* Unused variable name in destructuring declaration\n\n## JS code generation improvements\n\nJavaScript backend now generates more statically checkable code, which is friendlier to JS code processing tools, like minifiers, optimisers, linters, etc.\n\n## How to Try It\n\n**In Maven/Gradle:** Add [http://dl.bintray.com/kotlin/kotlin-eap-1.1](http://dl.bintray.com/kotlin/kotlin-eap-1.1) as a repository for the build script and your projects; use 1.1-M03 as the version number for the compiler and the standard library.\n\n**In IntelliJ IDEA:** Go to _Tools → Kotlin → Configure Kotlin Plugin Updates_, then select “Early Access Preview 1.1” in the _Update channel_ drop-down list, then press _Check for updates_.\n\nDrive to Kotlin!\n\n","author":"Ilya Chernikov","date":"2016-11-24","type":"article","categories":["Kotlin"],"features":["highlightjs"],"description":"","filename":"","lang":"EN","enclosure":null},{"title":"Getting Started with Kotlin and Anko on Android","url":"https://realm.io/news/getting-started-with-kotlin-and-anko/","body":"\nby [Donn Felker](https://twitter.com/donnfelker)\n\n### Getting Started With Kotlin and Anko on Android\n\nI’m just going to say it like it is ...\n\n> Android is stuck in Java 6 purgatory.\n\n![ADB Hell](http://cl.ly/2q0e3B3l202Z/1__adb.png)\n\nWhen I first started developing for Android, I was coming out of working very heavily with C# for a few years. I came over to find a lack of proper generics support (when compared to Java generics), no lambda expressions, and an awkward syntax for common things that I felt should just be in the language. 8 years later, I’m still stuck writing super-verbose Java 6. Java 8 has been out for a while now, and it would be great to use some of those features without having to resort to bytecode weaving! (That said, I am very thankful for [retrolambda](https://github.com/orfjackal/retrolambda).) Unfortunately, who knows if or when Java 8 support will ever arrive.\n\nThankfully, there seems to be a new hope for Android development: [Kotlin](https://kotlinlang.org).\n\n![Kotlin Logo](http://cl.ly/0q2n240R3I3N/kotlin-logo.png)\n\nKotlin is a new JVM-compatible language from JetBrains that you can use to write Android applications. If you haven’t been exposed to the language, I highly recommend that you watch [Michael Pardo’s talk on Kotlin](https://realm.io/news/droidcon-michael-pardo-kotlin/) from [Droidcon NYC](http://droidcon.nyc). Furthermore, the layout view for a portion of the application will be created with [Anko](https://github.com/Kotlin/anko), a DSL (Domain-Specific Language) for Android which is written in Kotlin. You can get a basic understanding of Anko [here](https://github.com/Kotlin/anko).\n\nKotlin, as a language, is a breath of fresh air compared to Java 6. Once you get used to the syntax, you will notice that it is much more succinct than its Java 6 counterpart. Since Kotlin is JVM-compatible, it will compile down to JVM bytecode that is understood by Android.\n\n_**Important**: This article will assume that you have a basic understanding of Kotlin and Anko._\n\n### Using Kotlin in an Android project\n\nAs with anything new, you’d probably like to try out Kotlin but you don’t want to commit an entire project to it just yet. With Kotlin and Android Studio, you can have both Java and Kotlin sitting side by side in your application. I recommend taking a screen, a feature, or a simple custom widget, and writing it in Kotlin to see how it feels. Integrating Kotlin into your codebase slowly allows you to give the language a test run and allows you to keep existing application code untouched.\n\nThankfully it’s quite easily to integrate Kotlin into an existing Android application with the free Kotlin plugin for Android Studio. To get started, you’ll need to install the plugin. Open Android Studio and select `Configure > Plugins`. If the screen below is not visible, close all your projects and `Welcome to Android Studio` window will present itself.\n\n![Configure Plugin](http://f.cl.ly/items/0h2Q0f0I3g471m3j190s/Screen%20Shot%202016-03-01%20at%2010.45.09%20AM.png)\n\nThen select `Install JetBrains Plugin` as shown below.\n\n![Install Plugin](http://cl.ly/312E3M123n2L/3_1_16__10_46_AM.png)\n\nNow search for `Kotlin` and install the `Kotlin` plugin as shown below. The main Kotlin plugin includes the Android extensions.\n\n![](http://cl.ly/2I1k3H0X2i0o/Untitled-1___100___Layer_1__RGB_8____.png)\n\nYou’re now ready to start building your first feature with Kotlin!\n\n### The Application\n\nThe application that I’m going to be working with is a simple to-do list application. The main screen has a list of to-dos that looks like this:\n\n![Example Screenshot](http://cl.ly/2t15210V3r3l/3_1_16__11_05_AM.png)\n\nTo add a to-do, users tap on the FAB (Floating Action Button). To edit a to-do, they tap on the to-do itself. This will load the add/edit screen. The add/edit screen is what I will write in Kotlin and Anko.\n\n### What is Anko?\n\n[Anko](https://github.com/Kotlin/anko) is a DSL (Domain-Specific Language) for Android written in Kotlin. Traditionally, Android views are expressed as XML layouts. This XML is usually duplicated in various parts of your application and is not re-used (sometimes it is, with includes). At runtime, the XML is then transformed into the Java representation of the view which wastes CPU and battery. Anko allows you to write this view in Kotlin, in an Activity or Fragment (or even as an [AnkoComponent](https://github.com/Kotlin/anko#ankocomponent), an external Kotlin file that represents the view).\n\nHere’s an example of a simple XML file that is transformed to Anko.\n\n**XML**\n\n```xml\n<LinearLayout\n    xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    android:layout_height=\"match_parent\"\n    android:layout_width=\"match_parent\">\n\n    <EditText\n        android:id=\"@+id/todo_title\"\n        android:layout_width=\"match_parent\"\n        android:layout_heigh=\"wrap_content\"\n        android:hint=\"@string/title_hint\" />\n\n    <!-- Cannot directly add an inline click listener as onClick delegates implementation to the activity -->\n    <Button\n        android:layout_width=\"match_parent\"\n        android:layout_height=\"wrap_content\"\n        android:text=\"@string/add_todo\" />\n\n</LinearLayout>\n```\n\n**The same view expressed in Anko**\n\n\n```kotlin\nverticalLayout {\n    var title = editText {\n        id = R.id.todo_title\n        hintResource = R.string.title_hint\n    }\n    button {\n        textResource = R.string.add_todo\n        onClick { view -> {\n                // do something here\n                title.text = \"Foo\"\n            }\n        }\n    }\n}\n```\n\nNotice the inline click listener in the layout definition above. Since this is Kotlin, you can also access other view members, such as `title` and use them in the click listener.\n\n### Getting Started\n\nUsing this [starter app](https://github.com/donnfelker/KotlinMix/archive/fresh.zip) you can start with a blank slate. (Final code is available [here](https://github.com/donnfelker/KotlinMix/)). This app has the following:\n\n* An Activity (`MainActivity`) that acts as a simple controller of the application.\n* A [RecyclerView](https://github.com/thorbenprimke/realm-recyclerview) to show the to-dos on the first screen (TodosFragment)\n* A Realm database to store the to-dos\n* A `Todo.java` Realm model\n* An adapter for the RecyclerView\n\nYou will now build the add/edit screen using Kotlin and Anko.\n\n### Set Up Your Application for Kotlin and Anko\n\nNow that you have the Kotlin extension installed, you’ll want to configure your application using the `Configure Kotlin in Project` action. In Android Studio, press `CMD+SHIFT+A` to open the action finder window. Type in `Kotlin` and select `Configure Kotlin in Project` action as shown below:\n\n![Actions](http://cl.ly/2f023X2q1r2r/Screenshot_3_1_16__11_57_AM.png)\n\nAfter this runs, your `build.gradle` file will have been updated with `kotlin-android` applied at the top of the file, a Kotlin `sourceSet` added, and Kotlin added to your dependencies.\n\nDuring this time you’ll also want to add Anko to your dependencies. Your `build.gradle` file should look similar to this:\n\n\n```groovy\napply plugin: 'com.android.application'\napply plugin: 'kotlin-android'\n\nandroid {\n    compileSdkVersion 23\n    buildToolsVersion \"23.0.2\"\n\n    defaultConfig {\n        applicationId \"com.donnfelker.kotlinmix\"\n        minSdkVersion 16\n        targetSdkVersion 23\n        versionCode 1\n        versionName \"1.0\"\n    }\n    buildTypes {\n        release {\n            minifyEnabled false\n        }\n    }\n    packagingOptions {\n        exclude 'META-INF/services/javax.annotation.processing.Processor'\n    }\n    sourceSets {\n        main.java.srcDirs += 'src/main/kotlin'\n    }\n}\n\ndependencies {\n    compile fileTree(dir: 'libs', include: ['*.jar'])\n    testCompile 'junit:junit:4.12'\n\n    // Kotlin\n    compile \"org.jetbrains.kotlin:kotlin-stdlib:$kotlin_version\"\n\n    // Anko\n    compile 'org.jetbrains.anko:anko-sdk15:0.8.2' // sdk19, sdk21, sdk23 are also available\n    compile 'org.jetbrains.anko:anko-support-v4:0.8.2' // In case you need support-v4 bindings\n    compile 'org.jetbrains.anko:anko-appcompat-v7:0.8.2' // For appcompat-v7 bindings\n\n    compile 'com.android.support:appcompat-v7:23.1.1'\n    compile 'com.android.support:design:23.1.1'\n    compile 'io.realm:realm-android:0.87.1'\n    compile 'com.github.thorbenprimke:realm-recyclerview:0.9.12'\n    compile 'com.jakewharton:butterknife:7.0.1'\n    compile 'com.android.support:support-v4:23.1.1'\n}\nbuildscript {\n    ext.kotlin_version = '1.0.0'\n    repositories {\n        mavenCentral()\n    }\n    dependencies {\n        classpath \"org.jetbrains.kotlin:kotlin-gradle-plugin:$kotlin_version\"\n    }\n}\nrepositories {\n    mavenCentral()\n}\n```\n\nYou’re now ready to start creating the add/edit to-do screen.\n\n### Adding a Fragment with Kotlin\n\nIf the `src/main/kotlin/com.donnfelker.kotlinmix/` directory does not exist, create it. You’ll notice that the `kotlin` folder turns blue indicating that this is a source folder.\n\nRight-click on the `/src/main/kotlin/com.donnfelker.kotlinmix/` folder, select `New > Kotlin File/Class`, and give it the name `EditFragment`. The new file is created and only contains a package declaration.\n\nCopy the code below and past it into the `EditFragment` file.\n\n```kotlin\npackage com.donnfelker.kotlinmix\n\nimport android.os.Bundle\nimport android.support.v4.app.Fragment\nimport android.view.LayoutInflater\nimport android.view.View\nimport android.view.ViewGroup\nimport android.widget.Button\nimport android.widget.EditText\nimport com.donnfelker.kotlinmix.models.Todo\nimport io.realm.Realm\nimport org.jetbrains.anko.*\nimport org.jetbrains.anko.support.v4.UI\nimport org.jetbrains.anko.support.v4.find\nimport java.util.*\n\nclass EditFragment : Fragment() {\n\n    val TODO_ID_KEY: String = \"todo_id_key\"\n\n    val realm: Realm = Realm.getDefaultInstance()\n\n    var todo: Todo? = null\n\n    companion object {\n        fun newInstance(id: String): EditFragment {\n            var args: Bundle = Bundle()\n            args.putString(\"todo_id_key\", id)\n            var editFragment: EditFragment = newInstance()\n            editFragment.arguments = args\n            return editFragment\n        }\n\n        fun newInstance(): EditFragment {\n            return EditFragment()\n        }\n    }\n\n    override fun onActivityCreated(savedInstanceState: Bundle?) {\n        super.onActivityCreated(savedInstanceState)\n\n        if(arguments != null && arguments.containsKey(TODO_ID_KEY)) {\n            val todoId = arguments.getString(TODO_ID_KEY)\n            todo = realm.where(Todo::class.java).equalTo(\"id\", todoId).findFirst()\n            val todoTitle = find<EditText>(R.id.todo_title)\n            todoTitle.setText(todo?.title)\n            val todoDesc = find<EditText>(R.id.todo_desc)\n            todoDesc.setText(todo?.description)\n            val add = find<Button>(R.id.todo_add)\n            add.setText(R.string.save)\n        }\n    }\n\n    override fun onDestroy() {\n        super.onDestroy()\n        realm.close()\n    }\n\n    /**\n     *  A private function to create a TODO item in the database (Realm).\n     *\n     *  @param title the title edit text.\n     *  @param desc the description edit text.\n     */\n    private fun createTodoFrom(title: EditText, desc: EditText) {\n        realm.beginTransaction()\n\n        // Either update the edited object or create a new one.\n        var t = todo?: realm.createObject(Todo::class.java)\n        t.id = todo?.id?: UUID.randomUUID().toString()\n        t.title = title.text.toString()\n        t.description = desc.text.toString()\n        realm.commitTransaction()\n\n        // Go back to previous activity\n        activity.supportFragmentManager.popBackStack();\n    }\n\n}\n```\n\nThe example above has a few methods: `newInstance`, `onActivityCreated`, `onDestroy`, and `createTodoFrom`. `createTodoFrom` accepts two `EditText` widgets as parameters, which are used to either create a new `Todo` or to update an existing one, all in a single line of code.\n\n```kotlin\nvar t = todo?: realm.createObject(Todo::class.java)\n```\n\nThis will check to see if the field-level `todo` value is null. If it is, then it will create a new `Todo` instance. If it is not null, it will use that local field instance. The field instance is instantiated in the `onActivityCreated` method near the top of the file.\n\nIn `onActivityCreated`, the arguments of the fragment are checked. If they’re not null, the id of the `Todo` is pulled from the intent extras and the `Todo` object is obtained from Realm. The `todo` field is now instantiated, indicating that the `Todo` object is being edited. The views are updated with the corresponding values at that point.\n\n### Adding the View with Anko\n\nYou’ve probably noticed that there is no view present in the Fragment. To add a view, copy and paste this code into the fragment:\n\n\n```kotlin\noverride fun onCreateView(inflater: LayoutInflater?, container: ViewGroup?, savedInstanceState: Bundle?): View? {\n    return UI {\n        verticalLayout {\n            padding = dip(30)\n            var title = editText {\n                id = R.id.todo_title\n                hintResource = R.string.title_hint\n            }\n\n            var desc = editText {\n                id = R.id.todo_desc\n                hintResource = R.string.description_hint\n            }\n            button {\n                id = R.id.todo_add\n                textResource = R.string.add_todo\n                onClick { view -> createTodoFrom(title, desc) }\n            }\n        }\n    }.view\n}\n```\n\nThis Anko code creates a LinearLayout with a vertical orientation (`verticalLayout`). Inside of the `verticalLayout` block, three Android widgets are created - two `editText` views and one `button` view. The view attributes are set in line. There is something interesting happening in the widget declaration of the button. The button has a click listener set in the view declaration. The method `createTodoFrom` is called with the `title` and `desc` variables that are declared prior to the button. Finally, the view is returned by calling the `view` property on the AnkoContext (`UI` class).\n\nThe `id`s are set with `R.id.<id_name>`. These `id`s had to be created manually in a file named `ids.xml` located in `app/src/main/res/values/ids.xml`. Create this file if it does not exist. The contents of this file are as follows:\n\n```xml\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<resources>\n    <item name=\"todo_title\" type=\"id\" />\n    <item name=\"todo_desc\" type=\"id\" />\n    <item name=\"todo_add\" type=\"id\" />\n</resources>\n```\n\nThis `ids.xml` file declares `id`s that can be used in an Android application for various view `id`s.\n\n### Java and Kotlin Commingling\n\nAt this point, the view can now be shown on the screen. The only thing left is to show the Fragment when a user taps on an item.\n\nOpen the `TodosFragment` and add the following code to the `onTodoClick` method:\n\n```java\nEditFragment editFragment = EditFragment.Companion.newInstance(task.getId());\n        getActivity().getSupportFragmentManager()\n                .beginTransaction()\n                .replace(R.id.content_main, editFragment, editFragment.getClass().getSimpleName())\n                .addToBackStack(editFragment.getClass().getSimpleName())\n                .commit();\n```\n\nThe `EditFragment` is written in pure Kotlin, yet it can be called from Android code as a regular Java object very easily.\n\nNotice the `EditFragment.Companion.newInstance` call? This is necessary because Kotlin does not have static methods. Therefore, a [companion object](https://kotlinlang.org/docs/reference/classes.html#companion-objects) is necessary to accomplish a similar feat in Kotlin.\n\nFinally, you’ll need to wire up the FAB to start the fragment. In the FAB’s click listener, in the `MainActivity`, you’ll need to add the following code:\n\n```java\nEditFragment editFragment = EditFragment.Companion.newInstance();\ngetSupportFragmentManager()\n    .beginTransaction()\n    .replace(R.id.content_main, editFragment, editFragment.getClass().getSimpleName())\n    .addToBackStack(editFragment.getClass().getSimpleName())\n    .commit();\n```\n\nBuild and install the application and tap the FAB. This starts the Kotlin part of the application. Add a to-do and tap `Add`. Back on the list of to-dos, tap a to-do so you can edit it. The button text in the Kotlin `EditFagment` will change to ‘save’. Update the to-do and tap save.\n\n![Example](https://dl.dropboxusercontent.com/u/888640/Realm/kotlin-mix-example.gif)\n\n### Congratulations, you’ve now mixed Java and Kotlin together! \uD83D\uDC4F\n\nYou’ve built a feature with Kotlin while the rest of your application remains functional with typical Java that is used in Android. You can continue on your path of Kotlin development or only bring it in where you find it useful.\n\nYou can also continue to use Anko as your view mechanism for Kotlin. If you prefer XML, you can still use XML layouts. For example, you can replace the above `onCreateView` method called with the following:\n\n```kotlin\noverride fun onCreateView(inflater: LayoutInflater?, container: ViewGroup?, savedInstanceState: Bundle?): View? {\n    return inflater?.inflate(R.layout.your_layout, container, false)\n}\n```\n\nThis gives you the flexibility to work with Kotlin with or without Anko.\n\nBest of luck on your Kotlin adventures!\n\n### Sample Code\n\n*   [Starter Project](https://github.com/donnfelker/KotlinMix/archive/fresh.zip)\n*   [Finished Code For This Article](https://github.com/donnfelker/KotlinMix/)\n\n","author":"Donn Felker","date":"2016-03-09","type":"article","categories":["Android","Kotlin"],"features":["highlightjs"],"description":"","filename":"","lang":"EN","enclosure":null},{"title":"Kotlin and Ceylon","url":"https://medium.com/@elviraw/kotlin-and-ceylon-3ee011125b7d#.lzdgs065k","body":"\nI recently got a chance to dive into two interesting JVM languages, Kotlin (1.0) and Ceylon (1.2.1). They’re both attempts at being better Javas. My thoughts and observations in no particular order:\n\n* Kotlin has many commercial users already and it’s the JVM language besides Java and Scala that people talk about at the conferences I attend.\n* Kotlin is _very_ solid. Except for an obscure type inference bug, I haven’t encountered much in the way of bugs at all. I unfortunately hit quite a few Ceylon bugs in both the compiler and the SDK.\n* Ceylon has JBoss modules as part of the language. I think it’s exactly the right idea. The fact that Kotlin doesn’t have a language level module system is disappointing. If they’re waiting for Jigsaw, they’ll end up with something inferior.\n* Both languages have typesafe null. This is the single most important improvement over Java.\n* Kotlin supports Android very well, which I think explains the popularity of this young language. Who wants to code in pre-Java 8? It helps that Android Studio is based on IntelliJ IDEA. Ceylon does not support Android at all.\n* Kotlin feels a lot like TypeScript, which I use for the web clients. Helps me switch back and forth. I _could_ use Kotlin in the browser, but I don’t see the point. With both Google and Microsoft backing it, TypeScript is the future of the web (I think both the Kotlin and Ceylon teams should put a bullet in the head of their Javascript backends. It’s a colossal waste of time.)\n* Ceylon has the best Eclipse support. Kotlin has the best IntelliJ support.\n* Kotlin has a fast compiler and programs start quickly under the JVM. Ceylon programs takes some time to both compile and launch. While running, they seem to perform equally well.\n* Kotlin has a quirky object literal syntax (think JSON-ish structures). Ceylon got this one right.\n* Kotlin has unchecked exceptions, and that’s it. Good. I still don’t know how I’m supposed to deal with errors consistently in Ceylon.\n* Ceylon has a very nice Tour to get you started. Kotlin, not so much.\n* Ceylon has reified generics. Ok, so why doesn’t Kotlin have reified generics again? I find no reasonable excuses for this omission.\n* Kotlin manages to be both terse and readable. It has the right amount of annotations to make intentions clear. Ceylon is basically just as verbose as Java, except when “programming in the small” where list comprehensions and stuff like that shines. The syntax for Ceylon generics is an acquired taste.\n* Using union types is like driving around in a brand new Ferrari with your mother-in-law in the passenger seat. Mixed emotions. Flow typing and union types are very powerful ideas, but they trick you into not paying attention to proper type abstractions. Result? Unmaintainable and unrefactorable code.\n* Ceylon lacks overloading because union types and default arg values are supposed to remove the need for them. At times, I still ended up with “overloads” having arbitrary naming schemes.\n* Both languages have multiple return values, using tuples and destructuring respectively. Useful when contained, but don’t expose this in public signatures if you want readable, maintainable and interop friendly code.\n* The number one priority of any JVM language? Frictionless interop with Java and the SDK of course. Kotlin gets Java interop exactly right. Ceylon’s Java interop is surprisingly quirky.\n\nI ended up liking Kotlin a lot and I’m already using it in a real Android-client, AWS-backend project. Ceylon has a lot of good ideas, but I never felt at home. You should try both languages though.\n\nI’m currently learning Clojure. It will be interesting to see if I can get the chance to finally do a lisp project.\n","author":"Elvira","date":"2016-02-28","type":"article","categories":["Ceylon","Kotlin"],"features":["highlightjs"],"description":"","filename":"","lang":"EN","enclosure":null},{"title":"Kotlin 1.1 Event","url":"https://blog.jetbrains.com/kotlin/2017/03/kotlin-1-1-event-2/","body":"\nIn addition to the new features that Kotlin 1.1 brings to your projects, it is also a good reason to meet up with your local community and friends to learn about new opportunities behind the release and impact on the future of Kotlin.\n\nYou can organize a Kotlin 1.1 Event together with the JetBrains team and your community on **March 23**. We will hold 2 live stream sessions to accommodate different time zones. You can join the live stream at **5pm or 7pm CET (9am and 11am PDT)**.\n\n[Let us know about your event](https://docs.google.com/forms/d/e/1FAIpQLSf6iXcrIpaNIqeeUJI2L6pntS5yy_iI01PbrO9gTMmX0kg5Lw/viewform) so we can announce it at the blog.\n\n![1600](https://i1.wp.com/blog.jetbrains.com/kotlin/files/2017/03/1600.png?resize=640%2C320&ssl=1)\n\n## The Kotlin 1.1 Event timing:\n\n* **5pm/7pm CET (9am/11am PDT)** – Andrey Breslav’s demo presentation (30 minutes, live stream on YouTube). The link will be provided later;\n* **5.30pm/7.30pm CET (9.30am/11.30am PDT)** – 30-minute break. You can have your say on features you want the most in some future versions of Kotlin. Use the Future Features kit and share the result on Twitter. Rules are given below;\n* **6.00pm/8.00pm CET (10.00am/12.00pm PDT)** – Interactive Q&A session with the Kotlin team. Rules are given below (45 minutes, live stream);\n* Talks and/or workshops from local speakers are welcome. You can schedule them at your own discretion.\n\n## Q&A session rules\n\n* You can start tweeting your questions with the #kotlinQA hashtag on March 21 and until the end of the Q&A session – March 23, 8.45pm CET (12.45pm PDT);\n* A Kotlin team representative will sort the questions out;\n* The team will answer the questions during the Q&A session live stream;\n* If some questions remain unanswered during the session, we will respond to them via Twitter;\n* During the session we will give special priority to frequently asked questions.\n\n## Future Features kit rules\n\nThe purpose of this survey is to gather the preferences and needs for language features from the community. You can have your say on features you want to see the most in some future versions of Kotlin. Please note it’s more likely that you won’t see those features in v1.2, but we will take your opinion into account when prioritizing our work.\n\n* The Kotlin Future Features kit includes 20 cards with the names and descriptions of features, and stickers for bidding;\n* The feature cards should be put on a board (or wall);\n* Every attendee gets 3 (three) stickers that she/he can distribute freely among features: bid on up to three different features, or put two or even three bids on a single feature;\n* Attendees can read through the descriptions on the cards to learn about the features, and then proceed to bidding as described above;\n* Take a picture of the result;\n* Post it on twitter with #kotlinevent.\n\n#### [Let us know about your event.](https://docs.google.com/forms/d/e/1FAIpQLSf6iXcrIpaNIqeeUJI2L6pntS5yy_iI01PbrO9gTMmX0kg5Lw/viewform)\n","author":"Alina Dolgikh","date":"2017-03-06","type":"article","categories":["Kotlin"],"features":["highlightjs"],"description":"","filename":"","lang":"EN","enclosure":null},{"title":"The Rise and Fall of JVM Languages","url":"http://www.javamagazine.mozaicreader.com/MarApr2017","body":"\nA viable business model is key to language adoption.\n\nFor the last 18 months, we at Java Magazine have been covering all sorts of interesting JVM languages — from the well known to the obscure. There is no doubt we could continue doing this for another couple of years without covering the same language twice. That’s in many ways the glory of the JVM: it is a great platform for language back ends.\n\nThe benefits of the JVM include performance, wide availability and familiarity, excellent tools, and thorough documentation. In addition, there’s a high level of confidence that the JVM will continue to be widely used, so languages that depend on it won’t suddenly need to ind a new platform (as those that targeted Adobe Flash, for example, were forced to do).\n\nJVM languages generally fall into two major categories: those that are ports of existing languages (such as the JRuby port of Ruby and the Jython port of Python) and those that are built from the ground up for the JVM (Groovy, Kotlin, Scala, Golo, Fantom, and many others). Those in the latter group often position themselves as an improved alternative to Java the language. And indeed these languages do provide features or syntax that Java has not implemented — often for specific reasons. Other times, the languages lead to Java’s adoption of features, in which case the Java team has the benefit of examining those implementations when formulating its own. That Oracle sees value in this dialogue is apparent in its longtime production of the JVM Language Summit at midyear, where JVM language designers come together to compare notes among themselves and with the Java team members.\n\nBecause of our long coverage of JVM languages, I am occasionally asked which of them will become popular enough to “cross the chasm.” This term, which originated in Geoffrey Moore’s [book of the same name](https://en.wikipedia.org/wiki/Crossing_the_Chasm), refers to an increase in popularity that drives a technology from the exclusive domain of visionaries and early adopters into the wider embrace of pragmatists and especially of businesses. I believe there are only three languages that are capable of this crossing or have already done so: Groovy, Scala, and Kotlin.\n\nGroovy found success as a quirky scripting language that has filled numerous niches where quick but expressive coding is needed. It is the scripting language for many testing frameworks and is used for writing build scripts in Gradle. It is also unique among the primary JVM languages (the three mentioned above plus Java) in that it did not require corporate sponsorship to become popular. (Even though Pivotal did support it for a few years, Groovy was popular long before Pivotal’s acquisition and has continued to be since Pivotal stopped sponsorship.) This is testament to the community skills of the project’s longtime leader, Guillaume Laforge.\n\nToday, no language can hope to cross the chasm as Groovy did — that is, without serious financial backing. Writing a language is a very expensive proposition, as is promoting it. While originally an academic creation, Scala was backed by the startup Typesafe until the company realized — as Pivotal did with Groovy — that there is no revenue to be made in selling a new language. As a result, Typesafe changed its name to Lightbend and refocused on its nonlanguage products. The break from being the “Scala company” was so clean that the press release announcing the name change did not even mention the language in the body of the announcement. As I said, there’s just no money in languages.\n\nKotlin relies on a rather different model. The language was devised in part for JetBrains’ internal use. Its design is pragmatic and aimed at helping the company reduce costs in developing its extensive line of developer tools. The benefits of developing and promoting Kotlin outweigh its costs and, crucially, JetBrains derives its income from products other than Kotlin. The costs, however, are significant. According to Andrey Breslav at JetBrains, more than two dozen [full-time equivalents](https://en.wikipedia.org/wiki/Full-time_equivalent) are developing and promoting Kotlin.\n\n\nIn the process, Kotlin has morphed into more than just an efficiency tool for JetBrains. Its intensely pragmatic orientation has strongly resonated with a significant and active community, which accelerates its movement across the chasm. Kotlin thereby enables JetBrains to bring new developers into its tool ecosystem. But the growing user base also presents the company with the challenge that successful languages often face: managing the demands of users versus the company’s own desires for the language.\n\nBecause economics support Kotlin’s evolution and JetBrains’ longstanding knowledge of developers will help it work with the community, I expect that within the next few years Kotlin will fully cross the chasm and emerge as a—or possibly the—primary non-Java JVM language, so proving yet again the robustness of the JVM ecosystem.\n\nAndrew Binstock, Editor in Chief\n* javamag_us@oracle.com\n* [@platypusguy](https://twitter.com/platypusguy)\n","author":"Andrew Binstock","date":"2017-04-03","type":"article","categories":["Kotlin"],"features":["highlightjs"],"description":"","filename":"","lang":"EN","enclosure":null},{"title":"Announcing KotlinConf","url":"https://blog.jetbrains.com/kotlin/2017/03/announcing-kotlinconf/","body":"\nOver the past year we have seen significant growth in Kotlin adoption, represented not only by the lines of Kotlin code on GitHub ([8M new lines of code since 1.0 release][]) but also by the numerous companies that have been reaching out to us about their usage, the number of talks being presented by community members at conferences, the increase in new frameworks and libraries, new user groups and meet-ups, as well as community events\n\nTo thank the wonderful Kotlin community, and to also share the most exciting things happening in Kotlin, we’re happy to announce [KotlinConf][]**,** a two-day event taking place in San Francisco, November 2017.\n\n\n[![KotlinConf][KotlinConf 1]][KotlinConf]\n\n\nWe’ll be opening up registration soon with early-bird tickets, so make sure you [sign-up for updates][KotlinConf].\n\n## Call for Papers now open ##\n\nWe have keynotes lined up by **Andrey Breslav** and **Erik Meijer**, and talks by some other speakers that we’ll be announcing shortly. But this is a community event and we want you, as members of the Kotlin community to also participate in the conference. As such, there is an open [Call for Papers][] where you can submit talks on things you’ve been doing with Kotlin and would like to share. While there is no rush, don’t delay because the call ends on the 1st of May 2017. \n\nIf you have any questions regarding the conference, please send an email to [info@kotlinconf.com][info_kotlinconf.com]. You can also ask questions on \\#kotlinconf on [Slack][]. For sponsorship enquires, please email [sponsorship@kotlinconf.com][sponsorship_kotlinconf.com].\n\n**2017 is going to be an exciting year for Kotlin and we hope to celebrate it with you in November!**\n\n\n[8M new lines of code since 1.0 release]: https://blog.jetbrains.com/kotlin/2017/03/kotlin-1-1/\n[KotlinConf]: https://kotlinconf.com/\n[KotlinConf 1]: https://i0.wp.com/blog.jetbrains.com/kotlin/files/2017/03/KotlinConfBannerSmaller.png?resize=640%2C332&ssl=1\n[Call for Papers]: https://sessionize.com/kotlinconf\n[info_kotlinconf.com]: mailto:info@kotlinconf.com\n[Slack]: https://kotlinlang.slack.com/\n[sponsorship_kotlinconf.com]: mailto:sponsorship@kotlinconf.com\n","author":"Hadi Hariri","date":"2017-03-14","type":"article","categories":["Kotlin"],"features":["highlightjs"],"description":"","filename":"","lang":"EN","enclosure":null},{"title":"400% faster layouts with Anko","url":"https://medium.com/@vergauwen.simon/400-faster-layouts-with-anko-da17f32c45dd#.okv8w4291","body":"\nI’ve been playing with Anko for a while now and I was curious what advantages Anko offered. So I did some performance tests.\n\n![](https://cdn-images-1.medium.com/max/660/1*5ZzaJr-LterwFJUy-Mu40g.png)\n\n_Skeuomorphism_\n\nSo I decided to migrate a quite advanced layout I used a while back to Anko. The layout contains a RelativeLayout container with 17 child ImageViews (all with a drawables using 9 slice), 1 SurfaceView as the viewfinder, 2 TextViews and a regular View. Which is still a quite decent layout since there are no nested containers.\n\n### Why does Anko preform better?\n\nXML Layouts are parsed at runtime. In other the XML needs to be retrieved form the assets, and the XmlPullParser needs to parse all the elements and create them one by one. The attributes need to be parsed and be set correctly. This all is overhead, but how much time is actually getting wasted?\n\n![](https://cdn-images-1.medium.com/max/880/1*cZgL3CXQrkeAeW7WrzYcrg.png)\n\n_Anko performance test_\n\nI’ve run the test on 4 older devices, but devices that all Android Devs have to deal with every day. I ran the layout about 4 times on all devices running [DevMetrics](https://github.com/frogermcs/AndroidDevMetrics). And we see a staggering difference from 350% to 600%.\n\nWith the increasing requirements for design / animations and performance, I think we all care about how fast and good our application preform. So I hope to convince you that using Anko will not cost you a lot of effort.\n\nBeside the fact that layouts are a lot faster due to avoiding overhead, we are now building are layouts at runtime so we can include any logic while building if wanted! So let’s recreate the master-detail sample from Android Studio with Anko.\n\n\n```kotlin\nclass MainActivity : AppCompatActivity() {\n  private var toolBar: Toolbar? = null\n  private var container: ViewGroup? = null\n\n  override fun onCreate(savedInstanceState: Bundle?) {\n    super.onCreate(savedInstanceState)\n    coordinatorLayout {\n      fitsSystemWindows = true\n\n      appBarLayout {\n        toolBar = toolbar {\n          if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) elevation = 4f\n        }.lparams(width = matchParent, height = actionBarSize())\n      \n      }.lparams(width = matchParent)\n\n      container = frameLayout()\n        .lparams(width = matchParent, height = matchParent) {\n          behavior = AppBarLayout.ScrollingViewBehavior()\n        }\n    }\n  }\n}\n```\n\n_MainActivity_\n\nSo as you can immediately see, there is not so much different from writing layouts in Anko compared to xml. And we’re already taking advantage of building layouts in xml, we can do a compatibility check and set elevation depending on the OS version, compared to doing so in a separate xml layout folder.\n\nBut now we’re cluttering our MainActivity with all that Anko code, so let’s extract that. Anko offers a solution using `AnkoComponent` but, you still have to use `findViewById` and thus it also still requires casting. We can easily solve that.\n\n```kotlin\ninterface ViewBinder<in T> {\n    fun bind(t: T) : View\n    fun unbind(t: T)\n}\n```\n\nLet’s create an interface that offers a bind and an unbind method. Similar like you’d bind and unbind views with Butter Knife.\n\nWe can now easily extract our previous layout into a `MainLayout.kt` class.\n\n```kotlin\nclass MainLayout : ViewBinder<MainActivity> {\n\n  override fun bind(mainActivity: MainActivity): View =\n    mainActivity.UI {\n      coordinatorLayout {\n        fitsSystemWindows = true\n\n        appBarLayout {\n          mainActivity.toolBar = toolbar {\n            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) elevation = 4f\n          }.lparams(width = matchParent, height = actionBarSize())\n      \n        }.lparams(width = matchParent)\n\n        mainActivity.container = frameLayout()\n          .lparams(width = matchParent, height = matchParent) {\n            behavior = AppBarLayout.ScrollingViewBehavior()\n          }\n      }\n    }.view\n\n  override fun unbind(mainActivity: MainActivity) {\n    mainActivity.container = null\n    mainActivity.recycView = null\n  }\n}\n```\n\n```kotlin\npublic class MainActivity extends AppCompatActivity {\n\n    LinearLayout container;\n    RecyclerView recycView;\n    FrameLayout detailContainer;\n    \n    private MainLayout mainLayout = new MainLayout();\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(mainLayout.bind(this));\n        ...\n    }\n}\n```\n\nAnd now our activity looks a lot neater doesn’t it? Not anything special going on here, aside of the fact that we can now just call `setContentView(mainLayout.bind(this))`, it will set the content view, and bind your views to your view fields. And as you can see, there is no need for `findViewById` nor is there a need for casting!\n\n### Runtime layouts\n\nIf you ever wanted logic during building layouts, you’re going to love this.\n\n```kotlin\nconfiguration(orientation = Orientation.LANDSCAPE, smallestWidth = 700) {\n  recyclerView {\n    init()\n  }.lparams(width = widthProcent(50), height = matchParent)\n  \n  frameLayout().lparams(width = matchParent, height = matchParent)\n}\n\nfun <T : View> T.widthProcent(procent: Int): Int =\n  getAppUseableScreenSize().x.toFloat().times(procent.toFloat() / 100).toInt()\n```\n\nLet’s analyse the code from above, anko offers `configuration` which is basically a fancy `if` for checking runtime configuration with a nice syntax. Anko offers checking config for `screenSize, density, language, orientation, fromSdk, sdk, uiMode, nightMode, rightToLeft and smallestWidth`. So this layout DSL will run if the device is in Landscape and the screen width in landscape is 700dp.\n\nWe can now also easily calculate sizes, and the width here will be calculate at runtime and set for 50% of the screen width.\n\n### Conclusion\n\nAnko offers several solutions to the traditional way of building layouts in XML. It bypasses all overhead that Android deals with when building xml layouts. You don’t have to deal with `findViewById` nor with casting. And by building layouts at runtime you can add any logic you want. It could improve your MVVM setup, or you could make your layouts more dynamic by adding some logic. And this all for a very small cost, considering all the extreme effort we do for clean and high performing apps.\n\nAll code used in this example can be found on [github](https://github.com/nomisRev/FasterLayoutsWithAnko)\n\n","author":"Simon Vergauwen","date":"2016-11-10","type":"article","categories":["Kotlin","Android"],"features":["highlightjs"],"description":"","filename":"","lang":"EN","enclosure":null},{"title":"Kotlin + RxJava = Functional Powerhouse","url":"http://tomstechnicalblog.blogspot.com.by/2016/02/kotlin-rxjava-what-rxjava-should-be.html?spref=tw","body":"\nAs a software developer working in a tactical business environment, I'm always looking for ways to do more with less code. Even better, if I can modify and scale code to constantly adapt to business demands then I have to do less code re-writes.\n\nJava has been my go-to language as it is practical, scalable, performant, portable, and statically-typed. As I became proficient and took on more ambitious projects, it started to feel cumbersome (and I kept eyeing C# wishfully). Thankfully I found RxJava last year, and reactive programming enabled me to take on tasks that I would hesitate to do before.\n\nUtilizing RxJava almost exclusively for all my projects, I became much more productive and the quality of my applications increased. But I slowly started to realize the limitations of the Java language were holding RxJava back. Even with Java 8's lambdas, some functional programming tasks became very verbose.\n\nFor instance, using the `compose()` operator which accepts a custom `Transformer` allows you to create your own operator with existing RxJava operators. The problem is it can quickly become wordy and less fluid.\n\nHere is a simple example. I can create a custom `Transformer` that turns an `Observable<T>` into an `Observable<ImmutableList<T>>` since I like Google Guava's immutable collections.\n\n```java\npublic final class Launcher {\n\n    public static void main(String[] args) {\n        Observable<String> source = Observable.just(\"Alpha\", \n            \"Beta\", \"Gamma\", \"Delta\", \"Epsilon\");\n\n        source.compose(toImmutableList()).subscribe(System.out::println);\n    }\n\n    public static <T> Observable.Transformer<T,ImmutableList<T>> toImmutableList() {\n        return obs -> obs.collect(() -> ImmutableList.<T>builder(),\n             (b,t) -> b.add(t)).map(b -> b.build());\n    }\n}\n```\n\nWith Java 8 this is not a very big deal. But this `Transformer` factory exists in the same class, and if I stored it in a separate factory class it would slowly start getting verbose.\n\n```java\npublic final class Launcher {\n\n    public static void main(String[] args) {\n        Observable<String> source = Observable.just(\"Alpha\", \"Beta\", \"Gamma\", \n            \"Delta\", \"Epsilon\");\n\n        source.compose(GuavaTransformers.toImmutableList()).subscribe(System.out::println);\n    }\n\n    /*This would be in the GuavaTransformers class */\n    public static <T> Observable.Transformer<T,ImmutableList<T>> toImmutableList() {\n        return obs -> obs.collect(() -> ImmutableList.<T>builder(), \n            (b,t) -> b.add(t)).map(b -> b.build());\n    }\n}\n```\n\nEven worse if I start to create more complicated Transformers or Operators with arguments, my `compose()` statement can start to get pretty ugly. If I wanted to collect items into an `ImmutableListMultimap`, it starts to get less fluid with the lambda arguments.\n\n```java\npublic final class JavaLauncher {\n\n    public static void main(String[] args) {\n\n        Observable<String> source = Observable.just(\"Alpha\", \"Beta\", \"Gamma\",\n             \"Delta\", \"Epsilon\");\n\n        source.compose(GuavaTransformers\n            .toImmutableListMultiMap(s -> s.length())).subscribe(System.out::println);\n    }\n\n    /*This would be in the GuavaTransformers class */\n    public static <T> Observable.Transformer<T,ImmutableList<T>> toImmutableList() {\n        return obs -> obs.collect(() -> ImmutableList.<T>builder(), \n            (b,t) -> b.add(t)).map(b -> b.build());\n    }\n\n    public static <T,K> Observable.Transformer<T,ImmutableListMultimap<K,T>> \n            toImmutableListMultiMap(Func1<T,K> keyMapper) {\n\n        return obs -> obs.collect(() -> ImmutableListMultimap.<K,T>builder(),\n            (b,t) -> b.put(keyMapper.call(t), t)).map(b -> b.build());\n    }\n}\n```\n\nThese may be trivial examples, but for larger applications these problems can quickly become amplified. Precious code real estate becomes eaten away even with the efficiencies of RxJava and Java 8 lambdas, and we have not even gotten to the subject of Tuples and data classes! But Kotlin solves all of these problems and more.\n\n### Introducing Kotlin\n\nI tried looking at Scala, Python, and other languages. I especially looked at Scala but despite all the praise it gets, I found it too esoteric. Then one day I found JetBrains sharing their new language called [Kotlin](https://kotlinlang.org/). They advertised it as an industry-grade, business-focused language emphasizing practicality rather than convention. JetBrains, the creator of the popular Java IDE Intellij IDEA, built it because they felt they could be more productive using a language that Java should have been. After studying Kotlin and re-writing two home projects with it, I quickly became sold and am ready to use it exclusively. The fact it is 100% interoperable with Java and all Java libraries made it a quick sell as well.\n\nBut in this post, what I really want to share is my experience using RxJava with Kotlin. **Ironically, I found RxJava works better with Kotlin than Java itself.** It just expresses functional programming concepts so much better.\n\nFor instance, I can \"add\" methods to the `Observable` using **extension methods**, without even extending the class! This is nothing new if you came from a C# background, but this was always the #1 thing I wished Java would have. Below I add `toImmutableList()` and `toImmutableListMultimap()` methods to the `Observable` (in Kotlin methods are actually called **functions**). I can then call those methods directly on the `Observable` rather than creating a `compose()` statement.\n\n```kotlin\nfun main(args: Array<String>) {\n\n    val source = Observable.just(\"Alpha\", \"Beta\", \"Gamma\", \"Delta\", \"Epsilon\")\n\n    source.toImmutableListMultimap { it.length }.subscribe { println(it) }\n\n}\n\nfun <T> Observable<T>.toImmutableList() =\n        collect({ ImmutableList.builder<T>()},{ b, t -> b.add(t)}).map { it.build() }\n\ninline fun <K,T> Observable<T>.toImmutableListMultimap(\n    crossinline keyMapper: (T) -> K) = collect({ ImmutableListMultimap.builder<K,T>()},\n        { b, t -> b.put(keyMapper(t), t)}).map { it.build() }\n```\n\nThere are a lot of observations to make here.\n\n1.  We did not have to wrap these functions inside a class. Unlike Java, Kotlin does not force you to put static methods in a class. This is really helpful and helps eliminate a lot of boilerplate, especially for procedural programs.\n\n2.  The type of the `source` variable is inferred, allowing us to not have to explicitly declare it as an `Observable<String>`. You can do that if you want to as shown below. In Kotlin the type comes _after_ the variable name (separated by a colon `:`). This is done because the variable name is likely more pertinent to you than the type, so it is declared first to making finding it easy.\n\n    ```kotlin\n    val source: Observable<String> = Observable.just(\"Alpha\", \"Beta\", \"Gamma\", \"Delta\", \"Epsilon\")\n    ```\n\n3.  You can express lambdas much more easily. Instead of having to write out a lambda for a simple one-to-one mapping like `s -> s.length()`, you can express this with a much more succint `it.length`, where `it` refers to the single incoming item emitted (this is featured in other JVM languages). Also, there are no paranthesis `()` to receive functional arguments. Instead you use curley braces `{}` and express the entire function for that operator in it. This is especially helpful because you can put multiple lines in the curly braces `{ }` at any time.\n\n    ```kotlin\n    source.toImmutableListMultimap { it.length }.subscribe{ println(it)}\n    ```\n\n4.  You can \"add\" functions/methods to a class without actually extending a class using extension functions. This single statement below adds a `toImmutableList()` function to the `Observable` everywhere in your application (unless you make it `private` or alter its scope). How is this done? The compiler simply makes it a `static` method when turned into bytecode, but you get the nice syntactic sugar as well as seeing it in your auto-complete. You do not have to target generic types either with extension methods. For example, I could make a `concatStr()` extension method specifically targeting `Observable<String>` and not `Observable<T>`.\n\n    ```kotlin\n    fun <T> Observable<T>.toImmutableList() =\n       collect({ ImmutableList.builder<T>()},{ b, t -> b.add(t)}).map { it.build()}\n    ```\n\n5.  Functional argument types are much simpler. Instead of expressing a functional type as `Func1<T,K>`, you can use a SAM-less type expression `(T) -> K`. This gets across much more easily that this function receives a `T` and turns it into a `K`. It is not a single-abstract-method type (SAM) which makes it easier to reason with and leaves out the question \"which single-method interface am I using?\". Of course, [Kotlin will handle converting lambdas to SAM when calling Java libraries, but it will not do it in Kotlin](http://stackoverflow.com/questions/34583595/behavior-with-kotlin-higher-order-functions-and-single-method-interfaces). Also, using the `inline` and `crossinline` keywords for a function accepting function arguments, [you can get great efficiency by eliminating object overhead](https://kotlinlang.org/docs/reference/inline-functions.html).\n    \n    ```kotlin\n    inline fun <K,T> Observable<T>.toImmutableListMultimap(\n       crossinline keyMapper: (T) -> K) = collect({ImmutableListMultimap.builder<K,T>()},\n             { b, t -> b.put(keyMapper(t), t)}).map { it.build() }\n    ```\n\n### Data Classes\n\nAnother great feature of Kotlin is data classes. Have you ever wanted to simply zip two values together, but had to create an entire class just to pair them up with `hashCode()`, `equals()`, and `toString()` implemented?\n\n```java\npublic final class JavaLauncher {\n\n    public static void main(String[] args) {\n        Observable<String> letter = Observable.just(\"Alpha\", \"Beta\", \"Gamma\", \n            \"Delta\", \"Epsilon\");\n\n        Observable<Integer> number = Observable.just(1,2,3,4,5);\n\n        Observable<CodePair> zipped = Observable.zip(letter,number, \n            (l,n) -> new CodePair(l,n));\n\n        zipped.subscribe(System.out::println);\n    }\n\n    private static final class CodePair {\n        private final String letter;\n        private final Integer number;\n\n        CodePair(String letter, Integer number) {\n            this.letter = letter;\n            this.number = number;\n        }\n\n        @Override\n        public boolean equals(Object o) {\n            if (this == o) return true;\n            if (o == null || getClass() != o.getClass()) return false;\n\n            CodePair codePair = (CodePair) o;\n\n            if (!letter.equals(codePair.letter)) return false;\n            return number.equals(codePair.number);\n\n        }\n\n        @Override\n        public int hashCode() {\n            int result = letter.hashCode();\n            result = 31 * result + number.hashCode();\n            return result;\n        }\n\n        @Override\n        public String toString() {\n            return \"CodePair{\" +\n                    \"letter='\" + letter + '\\'' +\n                    \", number=\" + number +\n                    '}';\n        }\n    }\n}\n```\n\nIt is not fun I had to write 36 lines of code just to create a `CodePair` class holding two properties. This problem comes up in functional programming quite a bit, and the only alternative is creating esoteric tuples which only obfuscate the code.\n\nBut in Kotlin, you can declare something called a [data class](https://kotlinlang.org/docs/reference/data-classes.html). This allows you to quickly declare a class in one line with all its properties, and it will take care of the `hashCode()`, `equals()`, `toString()` and even clone/modify builders for you.\n\nThat 48-line mess in Java now becomes 5 lines in Kotlin.\n\n```kotlin\nfun main(args: Array<String>) {\n\n    data class CodePair(val letter: String, val number: Int)\n\n    val letter = Observable.just(\"Alpha\", \"Beta\", \"Gamma\", \"Delta\", \"Epsilon\")\n    val number = Observable.just(1, 2, 3, 4, 5)\n\n    val zipped = Observable.zip(letter, number) { l, n -> CodePair(l, n) }\n\n    zipped.subscribe { System.out.println(it) }\n}\n```\n\nWe declared a `CodePair` class right inside the `main()` function, and it only exists in the scope of the `main()` function. It has named properties `letter` and `number` you can access. This opens up a lot of tactical possibilities that were borderline impractical to do in Java. Being able to declare simple classes on the fly and have the common method implementations done allows fast, organized, and legible code to be developed quickly.\n\n### Conclusions\n\nI have only scratched the surface in sharing what Kotlin can do, with or without RxJava. This was not a tutorial but just a quick showcase of how RxJava expresses differently in Kotlin. I hope I have effectively shared my experience and you are curious to check out Kotlin. I know Scala can do quite a bit with RxScala, but Kotlin is different. It really serves folks who need the tactical abilities and simplicity of Python with the scalability and power of Java. When you throw RxJava into the mix with Kotlin, I have found it to be a very rewarding combination. Did I forget to mention that there are no primitives or boxed types either? There are so many features in Kotlin that would be out of scope to post here, [like nullable types](https://kotlinlang.org/docs/reference/null-safety.html)\n\nAs a sidenote, [Kotlin is supported on Android](https://kotlinlang.org/docs/tutorials/kotlin-android.html). You can also checkout the [RxKotlin](https://github.com/ReactiveX/RxKotlin) library which extends RxJava to take advantage of Kotlin functionalities (such as adding `toObservable()` methods to collections).\n\n","author":"Thomas Nield","date":"2016-02-04","type":"article","categories":["Kotlin"],"features":["highlightjs"],"description":"","filename":"","lang":"EN","enclosure":null},{"title":"Crafting Log4j Configuration DSL","url":"http://jonnyzzz.com/blog/2016/09/09/log4j-dsl/","body":"\nIn this post I show how to implement The DSL Way to manage \nLog4j configuration and extend an IDE without writing a plugin for it\n\nThe Problem\n===========\n\n[Log4j](http://logging.apache.org/log4j/1.2/) configuration can be \neither in `.xml` file or in `.properties` files. Both formats are not \nsupported well in IDEs. \n\nI'll show how to create a decent IDE support for Log4j configuration files\n*without* writing an IDE plugin at all. We illustrate \nhow [The DSL Way](http://jonnyzzz.com/blog/2016/09/02/dsl-building/) is applied here.\n\n\nThe Basic Assumptions\n=====================\n\nI decided to use [IntelliJ IDEA](https://www.jetbrains.com/idea/) as an IDE \nand [Kotlin](https://kotlinlang.org) as \\\\(Target Language \\\\).\n\nKotlin is a static typed opensource language by JetBrains. It's easy to learn\nand use. For us it's vital that is has a static typed \n[DSLs](https://kotlinlang.org/docs/reference/type-safe-builders.html).\n\n\nThe Original Language\n=====================\n\nA configuration of a Log4j loggers looks like this:\n\n``` \n log4j.rootLogger=ERROR,stdout\n log4j.logger.corp.mega=INFO\n # meaningful comment goes here\n log4j.logger.corp.mega.itl.web.metrics=INFO\n log4j.appender.stdout=org.apache.log4j.ConsoleAppender\n log4j.appender.stdout.layout=org.apache.log4j.PatternLayout\n log4j.appender.stdout.layout.ConversionPattern=%p\\t%d{ISO8601}\\t%r\\t%c\\t[%t]\\t%m%n\n````\n\n\nA Transformation\n================\n\nLet's implement the following scheme for Log4j configurations in `.properties` file format.\n\n![](http://i.imgur.com/3NyHYlD.png)\n\nSee [The DSL Way](http://jonnyzzz.com/blog/2016/09/02/dsl-building/) post for more details on the approach\n\nThe implementation of \\\\(generate\\\\) and \\\\(execute\\\\) transitions is an engineering task of average complexity.\nBelow I focus mostly on a creativity part -- on a build of a DSL API that provides good readability, refactoring \nand find-usages in an IDE\n\nBuilding a DSLs\n===============\n\nCreating a DSL is a repeating process. You create a first version of it, check how it looks and how one \ncan use it. Next some improvements are done. Next you repeat. At some point you have a nice solution. \n\nBuilding a DSL requires detailed knowledge of \\\\(Target Language\\\\), you should understand how \nto translate any strings into some valid expression in your language.\nI would recommend checking the following articles on [Kotlin](https://kotlinlang.org) to learn \nmore about how DSLs are created: \n- [Type-Safe builder in Kotlin](https://kotlinlang.org/docs/reference/type-safe-builders.html)\n- [Delegated properties](https://kotlinlang.org/docs/reference/delegated-properties.html)\n- [Operator overloading](https://kotlinlang.org/docs/reference/operator-overloading.html)\n- [Kotlin Koans](https://kotlinlang.org/docs/tutorials/koans.html)\n\n\nStep 0. A Straightforward DSL\n=============================\n\nWe start with simplistic thing.  \nAs a starting point we need an entry function `log4j`, a builder interface `Log4J` with \ntwo methods `comment` and `param`. `Log4JBase` is added here for compatibility with future\ncode samples.\n\n```kotlin` \ninterface Log4JBase {\n  fun comment(text: String)\n  fun param(name: String, value: String)\n}\n\ninterface Log4J: Log4JBase\n\nfun log4j(builder: Log4J.() -> Unit) \n\n```\n\nPlease follow to [Kotlin](https://kotlinlang.org) documentation for better understanting \nof the code above. \n\nThis allows us to \\\\(generate\\\\) the following Kotlin code for a Logger configurations\n\n```kotlin\n log4j {\n  param(\"log4j.rootLogger\", \"ERROR,stdout\")\n  param(\"log4j.logger.corp.mega\", \"INFO\")\n  comment(\"meaningful comment goes here\")\n  param(\"log4j.logger.corp.mega.itl.web.metrics\", \"INFO\")\n  param(\"log4j.appender.stdout\", \"org.apache.log4j.ConsoleAppender\")\n  param(\"log4j.appender.stdout.layout\", \"org.apache.log4j.PatternLayout\")\n  param(\"log4j.appender.stdout.layout.ConversionPattern\", \"%p\\t%d{ISO8601}\\t%r\\t%c\\t[%t]\\t%m%n\")\n }\n```\n\nAt that point we have a trivial DSL. Next we will be improving it. There is still no support \nfor semantic checks or model. We now have all Kotlin language features opened for crafting \na `.properties` file. The DSL Way handles `.properties` escaping allowing us to write strings as is.\n\nUsing Kotlin here creates a way to meta-extend the original format. We are able now to \nuse functions, conditions, string manipulation, libraries and everything we have in Kotlin. \nAll such tools are projected into the \\\\(Original Language\\\\), a `.properties` file. A \\\\(generator\\\\) \ncan be smart to generate a compact code with use of Kotlin features. It may, for example,\nfold duplicates into loops or function calls.\n\nLet's make the DSL for Log4j configuration more expressive and readable\n\nStep 1. Improving the DSL\n=========================\n\nThere is a wellknown parameter `log4j.rootLogger`. IDE code completion is unaware about\na fancy property one should use. A user also may not know which is the right property. \nFinally, one may misprint the name of it. \nLet's replace it with an explicit call. For an \n[extension property](https://kotlinlang.org/docs/reference/extensions.html) in Kotlin is used\n  \n```kotlin\nvar Log4J.rootLogger : String\n  set(value: String) = param(\"log4j.rootLogger\", value)\n  get() = throw Error(\"Read API is not implemented\")\n```\n\nNow the improved part is \n\n```kotlin\nlog4j {\n  rootLogger = \"stdout\"\n\n  //instead of\n  param(\"log4j.rootLogger\", \"stdout\")\n}\n```\n\nStep 2. Builders for Appenders\n==============================\n\nLet's take a look on the code \n```kotlin\n  param(\"log4j.appender.stdout\", \"org.apache.log4j.ConsoleAppender\")\n  param(\"log4j.appender.stdout.layout\", \"org.apache.log4j.PatternLayout\")\n  param(\"log4j.appender.stdout.layout.ConversionPattern\", \"%p\\t%d{ISO8601}\\t%r\\t%c\\t[%t]\\t%m%n\")\n```\n\nLog4j uses a key name encoding to achieve the goal. This requires one to re-type similar strings \non and one. This may be a source of typos. From the other hand, this can be hard to read.\nLet's avoid constant repeating strings and make those lines more expressive. For that we define\nthe following [extension methods](https://kotlinlang.org/docs/reference/extensions.html) in the \n\\\\(DSL Library\\\\).\n\n```kotlin\nfun Log4J.appender(name : String, type : String, builder : Log4JAppender.() -> Unit)\n           \ninterface Log4JAppender : Log4JBase {\n  fun layout(type: String, builder : Log4JLayout.() -> Unit)\n}\n\ninterface Log4JLayout : Log4JBase \n```\n\nAnd this allows us to tune the \\\\(generator\\\\) to have the following Kotlin code\n```kotlin\n\n//use this\nappender(\"stdout\", \"org.apache.log4j.ConsoleAppender\") {\n  layout(\"org.apache.log4j.PatternLayout\") {\n    param(\"ConversionPattern\", \"%p\\t%d{ISO8601}\\t%r\\t%c\\t[%t]\\t%m%n\")\n  }\n}\n\n//instead of\nparam(\"log4j.appender.stdout\", \"org.apache.log4j.ConsoleAppender\")\nparam(\"log4j.appender.stdout.layout\", \"org.apache.log4j.PatternLayout\")\nparam(\"log4j.appender.stdout.layout.ConversionPattern\",             \n   \n```\n\nStep 3. Builder for Loggers\n===========================\n\nLet's simplify the rest of Log4j configuration code. Consider the following code \n\n```kotlin\nrootLogger = \"ERROR,stdout\"\nparam(\"log4j.logger.corp.mega\", \"INFO\")\nparam(\"log4j.additivity.corp.mega\", \"false\")\n```\n\nHere we refer to a logger called `stdout` by typing it's name as a string. There are several keys used to encode\nthe logger. Let's normalize values and improve readability by spliting appender binging and level.\n\n```kotlin\ninterface Log4JLogger : Log4JBase {\n  var additivity : Boolean?\n  var level : Log4JLevel?\n  var appenders : List<String>\n}\n\nfun Log4J.logger(category: String, builder : Log4JLogger.() -> Unit)\n\nfun Log4J.rootLogger(builder : Log4JLogger.() -> Unit)\n```\n\n\nNow the generated code would look like that\n```kotlin\nrootLogger {\n  level = ERROR\n  appenders += \"stdout\"\n}\n\nlogger(\"corp.mega\") {\n  additivity = false\n  level = INFO\n}\n```\n\nNow one can specify parameters explicitly. And it reads way better.\n\n\nStep 1 & 2 & 3. Outcome\n=======================\n\nAt that point we managed to remove all common strings, encoded keys and values. Readability is now \nbetter as we replaced all bare `Log4J#param` calls with a dedicated API calls from a dedicated builders. \n\nThere is a domain model created. We now have Logger, Appender, Layout entities. Each with a dedicated \ninterfaces. Semantic checks are now implemented on compilation, meaning incorrect code would not compile at all. \nThe rest of checks are implemented in the \\\\(emitter\\\\) implementation from the other.\n\nThanks to Kotlin static typed DSLs, IntelliJ IDEA understands code and provides code completion and navigation\nfor every expression.\n \nThe DSL code is more typo-resistant. All strings are now used once. There are no more tricky-encoded keys too. It' \nmuch harder now to author a misprint.\n\nThe generated DSL code is more expressive. One can read it and understand the meaning. There is no requirement \nto know Kotlin for that\n\nStep 4. Find Usages and Rename for Appenders\n============================================\n\nNow we are ready to implement an IDE feature. We'd like to be able to rename appenders as well as be able to see\nwhere a given appender is used. \n\nFor every possible IDE feature we need for \\\\(Original Language\\\\). We need to find an equivalent construction \nin the \\\\(Target Language\\\\) and a similarly looking IDE feature for \\\\(Target Language\\\\). Next we shall\nfind the way to use such construction in the DSL. \n\nFor appender usages and rename feature the Kotlin variable declaration suites the best.\n\nWe introduce `Log4JAppenderRef` interface. Make `Log4J#appender` function to return it. Next, in logger\nconfiguration we replace the type of appender from `String` into `Log4JAppenderRef`.\n\nNow appender usages are found via the respective variable usages. The appender name is specified only \nin `Log4JLogger#appender` function call. All other places uses the variable. Not it's safe to \nrename appender by changing this field.\n\n\nOutcome\n=======\n\nThis is a DSL for Log4j configurations usage example\n\n```kotlin\nlog4j {\n  val stdout = appender<ConsoleAppender>(\"stdout\") {\n    layout<PatternLayout> {\n      conversionPattern = \"%p\\t%d{ISO8601}\\t%r\\t%c\\t[%t]\\t%m%n\"\n    }\n  }\n\n  rootLogger {\n    level = ERROR\n    appenders += stdout\n  }\n\n  logger(\"corp.mega.itl.web.metrics\") {\n    level = INFO\n  }\n\n  logger(\"corp.mega\") {\n    level = INFO\n    appenders += stdout\n  }\n}\n```\n\nCreating a DSL is a iterative process. It is strongly dependent on subjective things like 'readability' \nor 'good looking'. Different DSLs are possible. And the way they are created depends on one's taste.\n\nConclusion\n==========\n\nBy those steps we turned a `.properties` file of Log4j configuration into a well-looking DSL code in Kotlin. \nThe DSL Way is implemented with that DSL and provides IDE support for authoring and reading Log4j configuration\nfiles. \n\nThe \\\\(generator\\\\) and \\\\(execution\\\\) parts implementation details are left uncovered. You may ask me\nfor details in the comments.\n\nThe DSL we created illustrates how once can turn a IDE language support problem \ninto [The DSL Way](http://jonnyzzz.com/blog/2016/09/02/dsl-building/) approach.\n\nYou may have a look (or contribute) to the project sources on [my GitHub](https://github.com/jonnyzzz/Log4j2DSL)\n\nYou may follow to [this post](http://jonnyzzz.com/blog/2016/03/08/gradle-for-dsl/) for details on how to create \na zero-configuration package for such DSLs and for The DSL Way approach.\n\n\n","author":"Eugene Petrenko","date":"2016-09-09","type":"article","categories":["Kotlin","DSL"],"features":["mathjax","highlightjs"],"description":"","filename":"","lang":"EN","enclosure":null},{"title":"Where We Stand & What's Next for Kotlin","url":"https://realm.io/news/andrey-breslav-whats-next-for-kotlin-roadmap/","body":"\n\nAndrey Breslav, the Kotlin project lead, gives an overview of what Kotlin is today, as a tool for developers and as an ecosystem. He then takes a peek into the near future, to their next release.\n\nSee the discussion on [Hacker News](http://news.ycombinator.com/item?id=11814488).\n\n\nTranscription below provided by Realm: a replacement for SQLite that you can use in Java or Kotlin. [Check out the docs!](https://realm.io/docs/java/latest/)\n\n<iframe width=\"960\" height=\"480\" src=\"https://www.youtube.com/embed/LtfxNPOImyg\" style=\"border-radius: 5px;\" frameborder=\"0\" allowfullscreen></iframe>\n\n<iframe width=\"960\" height=\"480\" src=\"//speakerdeck.com/player/f1dea41f659a4c70a6e8fb20291b871b?\" allowfullscreen=\"true\" mozallowfullscreen=\"true\" webkitallowfullscreen=\"true\" style=\"border-radius: 5px;\" frameborder=\"0\"></iframe>\n\nAndrey Breslav, the lead language designer for Kotlin, began his career at Borland, where he worked on language implementations for MDA support. After spending a few years as a college teacher, he joined JetBrains in 2010 to lead Project Kotlin and currently serves as a member of the Java Community Process Expert Group for JSR 335, “Project Lambda.” He is a frequent conference speaker at venues such as OSCON, JavaOne, Strange Loop, and Devoxx.\n\n\n[@abreslav](https://twitter.com/abreslav)\n\n### Introduction 00:00\n\nMy name is Andrey, I lead the [Kotlin](http://kotlinlang.org) team at [JetBrains](https://www.jetbrains.com). I am here to tell you about where we stand and about what is next.\n\n### Learning Materials 00:30\n\nThis talk is not an introduction to Kotlin. If you want to learn Kotlin, there are many sources to learn from. There is [language reference, tutorials, talk videos](http://kotlinlang.org). Check out our [mini-IDE](http://try.kotlinlang.org), Kotlin Koans is a set of problems that walks you through the language, similar to an IDE with a educational plug-in. _I am here to motivate you to learn!_\n\n### Where We Stand 01:03\n\nKotlin 1.0 released in February 2016. Since then we were doing incremental updates: 1.0.2 is our current version, and we are working on 1.1 (a feature driven release, although I am not giving you a date yet). The Early Access Program (EAP) will start this summer.\n\nIn this slide (_see video_) we have the people that have used Kotlin (_maybe not admitting it publicly!_). JetBrains is a big user, we were probably the first to start trying it in production. We have over half a million lines of code and production in different projects, from IntelliJ production of our main IDE to server side products (...to everything). A few projects are written in Kotlin from scratch. Others are catching up. We are grateful to everyone trying Kotlin in production. It is such an early stage of the release time! Join in, you will be in a good company.\n\nAnd being in a good company, you will not be alone. We have a lively community, Slack, forums, StackOverflow, full of people who are happy to tell you what you are doing wrong, and how to fix whatever issues you have. Come over to our GitHub Project, it is open source, you can join (we already have over 100 OSS contributors!). If you are stuck, we will work as hard as we can to be responsive. If you have a critical issue, we will role it out as an EAP build, which you can use to work on the problem.\n\n### KEEP 03:14\n\nKotlin Evolution and Enhancement Process (KEEP): we try to accumulate all the design process we are having, and be as open as possible. If you go to this [GitHub repo](https://github.com/Kotlin/KEEP) you will see all the proposals that are considered for Kotlin 1.1 at the moment. You can provide your ideas, feedback, do corrections. We are very grateful: use cases are what drive our design. KEEP is the venue for our plans.\n\n### Our Plans - Lines of Development 03:56\n\nNow we have 1.0, 1.0.2, as the main release, and our development is in two lines. We have those incremental updates, 1.0.2, 1.0.3, which are source compatible (meaning that language does not change more than the bugs). We fix bugs in the compiler; this sometimes slightly changes the language (but that is always for the better). There you find bugfixes, performance updates, and tooling features. This is where IDEs are improved: build systems.\n\n1.1 is another parallel line, where we do language features, and their source compatibility is backward compatibility. 1.0 may not be able to compile 1.1 (because there are new features 1.0 does not know about). Backwards is always compatible. If you have your old code, it will work with 1.1.\n\n_This slide does not mention anything about binary compatibility, because that goes without saying._\n\n### Tooling Plans: 1.0.X 05:18\n\n*   We released 1.0.2, which has incremental compilation for Gradle (_and speeds things up quite a bit_). Now, when you change something you are calling code, and recompile it with Gradle, with the incremental flag enabled (it is an experimental flag, you do not have it on by default), you only have those files recompiled that actually need recompilation. The whole project is not rebuilt, only those individual files touched or that were affected by your changes. And we will be working on this feature; after some time it will be not experimental anymore (_hopefully!_). That is one big infrastructural change.\n\n*   Spring Support in the IDE. You have some of the features that the big IntelliJ idea has for Java, but in caudlen.\n\n*   Reduce our standard library size. That is not because our standard library is big (it is probably the smallest among the alternative jvm languages). Last time we shaved off some 1500 methods off the library binary, without changing the API. It is a compatible change, but there are fewer functions now. If you are an Android developer, it matters to you.\n\n*   Android Lint Checks (_people were asking for those_). The IDE warns you if you do something wrong in Android specific terms (not language specific terms). We will have more and more Lint Checks added over time.\n\n*   Jack&Jill, the new Android tool chain we are integrating with. We are fixing bugs to be able to Jill compile the Kotlin center library (because, without the bug fixes, it would not).\n\n### New Targets 07:49\n\nAnd for 1.1... we are planning many things!\n\n1.  **Java 8/9**. Our current target is Java 6: whatever you compile in Kotlin can run on anything that runs Java 6, including Java 8/9 (but it does not use the features of 8/9). We are working on generating default methods for Java 8. In Kotlin, you can always implement methods and interfaces, but if you want to extend such an interface in Java, Java 6 would not know that those methods are implemented (Java 8 would). We also have some issues with Stream API collection in Java 8. We have a support library for Java 8 streams, but that will be removed in Kotlin 1.1 and we will just support natively in the compiler.\n\n2.  The JavaScript backend for Kotlin has been around for years, but we de-prioritized it to shape 1.0 for Java as soon as we could. We are working on it again, and all the language features are covered. We are working on runtime module support (amd, umd, common.js). JavaScript has many common toolchains (npm, browserify, gulp, ...), and we will try to support as many of them as we can.\n\n3.  Another popular question, can I run Kotlin in a native environment without a virtual machine? The current answer is no; at least, not easily. No code is written in this section yet, and it is probably not going to be available in 1.1, but we are looking into this and we will probably have some news sometime later.\n\n### Scripting: example.kts 10:08\n\nOne thing that is needed from any modern language is to be a scripting language. This is more or less supported, although it has not been officially promoted that much. You can write a script in Kotlin, the file extension would be .kts. For now, you can import anything and write the expressions and statements on the top level of the file. It will be compiled to a Java class and run as normal.\n\nHowever, you cannot define dependencies inside a script, which means you have to either configure your class path, or be stuck with the jtk and the Kotlin standard library. This is something we are working on now, and it will probably help many other usages of Kotlin. This is an infrastructural change.\n\n#### Type Aliases 11:04\n\nWhen you want to pass a function (say, a foo and bar to buzz), you end up repeating this function signature many times. That is why people want some abbreviation mechanism, to give a name to this complex type.\n\n```kotlin\ntypealias Int32 = Int\ntypealias Predicate<T> = (T) -> Boolean\n```\n\nHere my complex type is T to Boolean, a function, and I want a name for it. I say `typealias Predicate<T> = (T) -> Boolean`. This is not a new type, this is just an abbreviation; an alias. `Int32` here is just an `Int`. These are interchangeable, but they will help you abbreviate your long types and make your APIs more speaking. The new type is something many people want. It is not something a type alias is. It will be covered later, probably in 1.1, with value types (or something related to those). You have probably heard about Project Valhalla (those of you interested in Java), it is easier.\n\n### Bound Method References 12:35\n\nYou probably know that Kotlin has reflection (on top of whatever platform reflection there is). There is language support for reflection.\n\n```kotlin\nval p: Predicate<String> = “foo”::equals\n    // behaves as { x -> “foo”.equals(x) }\n\nval c: KClass<Foo> = x.foo()::class\n```\n\nThose two colons (type ::foo) is something that is supported now. You can take a type, and take a reference to it is member, a function or a property. Or, you can take a type and make it a class literal by saying Type::class. This is something you can do now, but in 1.1 you will be able to do that with an object. It can take a foo (“foo” is a string, obviously), and it can take an `equals` of that string, which is a function of one argument, and put to a variable as a predicate. It will be comparing any string you pass to it to foo. This is a partial application, but a limited one. Convenient, according to our use-case surveys.\n\nMore or less works, like lamda over there. Same thing you will be able to do with a class; you can take a class of x to foo by saying ::class.\n\n### Enhancements for Properties 13:54\n\nIf you do not know what delegated properties are... Google it, because they are cool. _(Ed. note: [Here you go!](https://kotlinlang.org/docs/reference/delegated-properties.html))_ This is something that allows good re-using code, Kotlin. Good news: in 1.1 we will allow that as a local variable. Now you can use **delegated properties** on a top level or in a class; you will be able to do it in a function. This enables DSLs, and this will help us with new cases.\n\n```kotlin\nfun foo() {\n    val lazyBar by lazy { ... }\n    while (...) {\n        if (...) {\n            lazyBar.doBaz()\n    ...\n}\n```\n\nInline properties: technical thing for some libraries; for binary compatibility, it is better to have properties inlineable.\n\n```kotlin\nval foo: Foo\n    inline get() = ...\n    inline set(v) { ... }\n```\n\n### Hierarchies for Data Classes 14:53\n\n(_If you have not heard of data classes, learn about them_). _(Ed. note: [Here you go!](https://kotlinlang.org/docs/reference/data-classes.html))_\n\n```kotlin\ndata class User(val name: String, val age: Int)\n\n// automatically gets\nequals() / hashCode() / toString()\ncopy() // val newUser = someUser.copy(name = “Jane Doe”)\ncomponentN() // val (name, age) = someUser\n```\n\n\nKotlin has this simple but useful feature, where it can define a class with two members. It is a `class User`, which has a name and an age (these are fields). It can mark it data, and the compiler can generate all this for you. It will give you equals() and hashCode() based on those values, toString(), rendering those. A copy() method to change a name of an object in a shallow copy of it. And componentN() functions for destructuring. It can say: I have a user (a user is a pair of name and age), I declare a local variable, name and age at the same time and assign the user to two of them. I have two values at the same time assigned to those names.\n\nData classes are good, but we did not support any inheritance for those. 1.1 will fix that; you will be able to say, have a sealed class, and be able to extend a data class from it.\n\n```kotlin\nsealed class C() {\n    data class Example(...) : C()\n}\n```\n\nThis covers everything people need about algebraic data types in Kotlin. It is not Haskell yet (it will never be), but it is as close to Haskell as use cases we see require.\n\n### Destructuring in Lambdas 16:22\n\n```kotlin\nmyMap.forEach {\n    (k, v) ->\n    println(“$k => $v”)\n}\n```\n\nA map from N to string is a sequence of pairs, map entries of keys and values. In the library, Map has a .forEach method. That simply iterates through the pairs, and you can do whatever with them. In Kotlin 1.0, you only have one variable for the whole pair. You can say, forEach has an entry, and it can say `(k, v) -> println(“$k => $v”)`. And this new syndex in 1.1 will help you destructure right away. If you say K and V is a pair (which means that the entry is structured in the two), and then you can print the two. _Have I lost all of my audience by now?_\n\nI have a black screen for you (_see video_). You are not supposed to read the code. All you care about is this staircase of brackets. This is the picture I Googled by the query ‘callback hell’. This picture is a typical piece of JavaScript (not only JavaScript, other languages suffer from this as well). This illustrates the world of asyncronist computation as it is, more or less, today in many languages.\n\nWe want to be asynchronist as much as we can, because we like to offload things on different threads or other different ways of execution. The way I want to read from a file is: “Here is my file, I want to read from it. When the read is done, here is my callback, call it when it is finished”. That is great; I can call something, I am not blocking. I can continue working; the read will do its work. But, if after that read I want to write, and then another read, each next asynchronist call has to be nested inside that callback. It is a callback in a callback in a callback in a callback... and at the end I have this staircase. It is okay if it fits in 115 lines, but sometimes it does not. And this is why some languages have async/await.\n\n### Asynchronous Computation 19:10\n\nSome languages want to write the same asyncronist code that does not block on many calls, but in a sequential way.\n\n```kotlin\nfun loadImage(url: URL) = async {\n    val bytes = await(loadBytes(url))\n    bytesToImage(bytes)\n}\n```\n\nI just say loadBytes and then bytesToImage, meaning that loadBytes should work asynchronistically and execute bytes image only when it is done. There is this `await` keyword, that means call load bytes, put the rest of the computation away somewhere, do not block the thread, give the thread up to somebody else who can use it. And, when the loadBytes is done, resurrect the whole computation and run the next line.\n\nThis is what C# introduced in version five. Many other languages adopted this idea because it is fruitful, and this is something we want to cover. But we do not want to copy it from others because it is not general enough, in our opinion. They have a asynchronist computation, a sync block, and a suspension point. Await means we can suspend here and then resurrect afterwards.\n\n#### Coroutines 20:24\n\nAlternatively, we want to do coroutines. It is a generalization. We want to cover async/await/yield on generator blocks from other languages, but with maximum flexibility. We want to support virtually all existing asynchronous APIs, futures, callbacks, promises. And this means that the language is not bound to a given task framework.\n\n```kotlin\nfun loadImage(url: URL) = async {\n    val bytes = await(loadBytes(url))\n    bytesToImage(bytes)\n}\n```\n\n\nWe have these `async` and `await`: these are library functions, not keywords. It is the same machinery with a different API, and much flexibility. The prototype for this is under way (maybe available in June), and we will be able to play with library making and library using, using this abstraction.\n\n### Conclusion 21:25\n\nI invite you to come to KEEP, and review the proposals. Give us your feedback, ideas, use cases.\n\nKotlin has been known for making nice APIs, and some people like making APIs so much that I have the honor to invite Hans Docter on stage, because he has [something to show you](https://realm.io/news/gradle-kotlin/).\n\nSee the discussion on [Hacker News](http://news.ycombinator.com/item?id=11814488).\n\n","author":"Andrey Breslav","date":"2016-06-01","type":"article","categories":["Kotlin"],"features":["highlightjs"],"description":"","filename":"","lang":"EN","enclosure":null},{"title":"Kotlin Configuration Scripts: An Introduction","url":"https://blog.jetbrains.com/teamcity/2016/11/kotlin-configuration-scripts-an-introduction/","body":"\nThis is a five part series on working with Kotlin to create Configuration Scripts for TeamCity.\n\n1. **An Introduction to Configuration Scripts**\n2. Working with Configuration Scripts\n3. Creating Configuration Scripts dynamically\n4. Extending the TeamCity DSL\n5. Testing Configuration Scripts\n\nWith TeamCity 10, we brought the ability to define configurations using Kotlin as opposed to using XML or the User Interface.\n\nThis provides several benefits amongst which are\n\n* A human-readable and editable configuration script, not relying on the user interface\n* Ability to do diffs on changes to a configuration script\n* Ability to check in your configuration scripts alongside your source code<sup>1</sup>\n* Ability to dynamically create configuration scripts, as well as test them\n\n## Why Kotlin?\n\nYou might ask why [Kotlin](http://kotlinlang.org) and not some other language? For those not familiar with Kotlin, it is a statically-typed language developed by us at JetBrains and open sourced under the Apache 2 license. It targets the JVM, JavaScript (and we also have native in the works). It’s designed to be a pragmatic language that cuts down boilerplate code, remains expressive, and facilitates tooling. Kotlin provides a series of features that allow the creation of DSL’s (Domain Specific Languages) and TeamCity is a perfect fit for this purpose. Kotlin enables the benefits we’ve outlined and we’ll see.\n\nWhy not something more common such as YAML? Based on our experience, we believe that while YAML is great for the simpler setups, at some point it does fall short, and can lose clarity when it comes to defining more complex configuration scripts. We wanted to provide a solution that works for the simplest to the most demanding of scenarios, and that’s why we’ve gone with Kotlin. It’s important to understand though that we’re not providing just a DSL for creating configuration scripts. Kotlin is a programming language and as such we have the ability to write any kind of code in our configuration scripts (which, of course, like anything can be also abused). This enables many scenarios such as those we’ll see when creating dynamic configurations.\n\n## What is needed\n\nGiven Kotlin is a proper language, you might be wondering what tooling is required to edit configuration scripts. In principle any editor will do. Kotlin is built so that it can be used with any editor or IDE. In fact we ship support for not only IntelliJ IDEA (both Ultimate and the free OSS community editions), but also Eclipse and NetBeans. If Vim or another editor is your thing, you can also use that along with a command line compiler.\n\nFor the purpose of this blog post series, we’ll be using [IntelliJ IDEA](https://www.jetbrains.com/idea).\n\n## Creating a first script\n\nWhile we can start with a completely blank script, the easiest way to create a Kotlin build script is to take an existing TeamCity project and either\n\n* Download it as a Kotlin Script\n* Enable Versioned Settings\n\nThe first is a great way to start playing with Kotlin configuration scripts and get a feel for them. The second option not only provides us with the configuration scripts checked in to source control, but it’s actually a required step for us to use Kotlin build scripts in production.\n\nThe recommended approach is to use the second option once we’re ready to enable Kotlin scripting in our projects. The first option, as mentioned, is great for discovering how things work and getting familiar with Kotlin configuration scripts.\n\n### Download Settings as a Kotlin Script\n\nIn order to see what a build configuration looks like in Kotlin, simply **Edit Project Settings** on the selected project and click on the **Actions** menu, picking the entry **Download Configuration Script in Kotlin format**\n\n![download-kotlin-settings](https://d3nmt5vlzunoa1.cloudfront.net/teamcity/files/2016/10/download-kotlin-settings.png)\n\nThis downloads a zip file that contains a Maven project which can be obtained in IntelliJ IDEA. Note that the folder it contains is prefixed with a dot, which indicates it’s hidden under MacOS. The idea is that this folder can essentially be placed in version control at some point (TeamCity marks its configuration files as hidden).\n\n### Enable Versioned Settings\n\nThe second option, which is required for us to actually use Kotlin configuration scripts, is to enable Versioned Settings. This is done under **Versioned Settings** and selecting **Enable**, and Kotlin as the file format.\n\n![versioned-settings](https://d3nmt5vlzunoa1.cloudfront.net/teamcity/files/2016/10/versioned-settings.png)\n\nAs soon as we activate this, the TeamCity UI will no longer allow any changes and all the configuration will be stored in version control and modifications have to take place via the build script.\n\nThese script files will have the same folder layout as that of the downloaded zip file (first option). For instance, the [following are the files checked in to version control for the Joda-Time project](https://github.com/hhariri/joda-time/tree/master/.teamcity). We can see that once again it’s a Maven project containing a series of Kotlin files (_.kt). _\n\n## Opening the script in IntelliJ IDEA\n\nOnce we have the configuration script (be it as a zip file or checked in to version control on enabled versioned settings), we can open it in IntelliJ IDEA, and Maven will pull down the correct dependencies. Our project layout should look like the one below\n\n![project-structure](https://d3nmt5vlzunoa1.cloudfront.net/teamcity/files/2016/10/project-structure.png)\n\nDon’t feel overwhelmed by the number of files in there. In fact, TeamCity really only needs one file, which is _settings.kts. _Let’s examine each file in more detail.\n\n**_settings.kts_**\n\n_kts _is a Kotlin Script file, different from a Kotlin file (_.kt_) in that it can be run as a script. As mentioned above, all the code relevant to the TeamCity configuration could be stored in this single file, but it is divided into several files to provide a better separation of concerns.\n\nThis file contains usually two lines\n\n![settings](https://d3nmt5vlzunoa1.cloudfront.net/teamcity/files/2016/10/settings.png)\n\n_version_ indicates the TeamCity version, and _project() _is the main entry point to the configuration script. It represents a function call, which takes as parameter a **Project**, representing the entire TeamCity project.\n\nThe parameter _GitExtensions.Project _is an object in Kotlin. Think of objects in Kotlin as you would in JavaScript. Or to compare it to Java, they’d be a Singleton, a single instance of a Kotlin class. While Kotlin script could work with singletons, having a first-class support for objects, makes things much easier.\n\nIn this case, _Project _is the name of the actual object, and _GitExtensions _is the package name.\n\n**_Project.kt_**\n\nThis file contains the _GitExtensions.Project _object, and is where all the magic happens. If you look at the script layout, it’s basically a code representation of the build steps we’re accustomed to seeing the TeamCity user interface\n\n![project](https://d3nmt5vlzunoa1.cloudfront.net/teamcity/files/2016/10/project.png)\n\nwhich would correspond to the following entries in the UI, in addition to VCS roots and Build Types.\n\n![settings-ui](https://d3nmt5vlzunoa1.cloudfront.net/teamcity/files/2016/10/settings-ui.png)\n\n**_GitExtensions_HttpsGithubComJetbrainsGitextensions.kt_**\n\nThis object defines the VCS root configuration. It’s important to note that we could have just placed all this information directly in the code above, as opposed to making the call _vcsRoot(GitExtensions_...).  _However, the advantage to doing this, as we’ll see, is not only to make the code cleaner and separate concerns, but also to provide  reusability.\n\n![vcs-settings-root](https://d3nmt5vlzunoa1.cloudfront.net/teamcity/files/2016/10/vcs-settings-root.png)\n\n**_GitExtensions_Main.kt_**\n\nFinally, we have the actual meat of where the build happens. This object defines the build steps, failure conditions, and everything else you’d come to expect for a build configuration in TeamCity\n\n![build-type](https://d3nmt5vlzunoa1.cloudfront.net/teamcity/files/2016/10/build-type.png)\n\n## Summary\n\nIn this first part we’ve seen the components of a TeamCity configuration script. In the next part we’ll dive a little deeper into the DSL, modify the script, and see some of the benefits that Kotlin and IntelliJ IDEA already start providing us in terms of guidance via code assistants.\n\n[1] While enabling [version control storage for settings](https://confluence.jetbrains.com/display/TCD10/Storing+Project+Settings+in+Version+Control) has been available since version 9, it was only available in XML format. TeamCity 10 brings Kotlin to this.\n\n","author":"Hadi Hariri","date":"2016-11-18","type":"article","categories":["Kotlin","TeamCity"],"features":["highlightjs"],"description":"","filename":"","lang":"EN","enclosure":null},{"title":"Немного о Kotlin.","url":"https://habrahabr.ru/post/277479/","body":"\n![Kotlin](https://habrastorage.org/getpro/habr/post_images/b30/fc2/317/b30fc231752f0d1d270b4c80538a28dc.jpg)\n\n\nНа днях JetBrains после пятилетней работы выпустила первый релиз языка Kotlin. Давайте посмотрим, что же это за язык, попробуем разобраться зачем и для кого он, какие имеет функциональные особенности. Скорее всего в статью затесались и личные впечатления от языка, но я старался, чтобы они не влияли на изложение полезной информации. Если вы еще ничего или почти ничего не знаете о Kotlin, то я завидую вам, ибо по моему ощущению почитать про инструмент, который ты долго ждал, сродни распаковке новогоднего подарка. Впрочем судите сами.\n\n## Что такое Котлин\n\nКотлин — это небольшой остров в Финском заливе недалеко от Санкт-Петербурга. Видимо, тем самым создатели дают отсылку к тому, что новый язык, как остров Котлин — младший русский брат далекого острова [Ява](https://ru.wikipedia.org/wiki/%D0%AF%D0%B2%D0%B0).\n\n## Для кого этот язык\n\nДействительно, новый язык компилируется в JVM байт-код (есть еще и компиляция в JavaScript, но так как релиз компилятора именно в JVM, эту тему придется опять отложить). А это значит, что он может заинтересовать всех, кто имеет дело с Java-машиной и в целом с языками со сборщиком мусора (а с выходом релиза компиляции в JavaScript покрытие и возможности будут еще шире).\n\n## Простой и совместимый\n\nДве главных особенности котлина, на мой взгляд, это его простота и полная совместимость с Java. Котлин создавался компанией, которая делает очень много продуктов на Java и которая хорошо разбирается в современных инструментах разработки. Запрос на новый язык витает в воздухе давно, но сделать такой язык, который бы позволил взять (огромную) готовую кодовую базу Java, обычных Java-разработчиков, дать им новый инструмент и бесшовно (но более эффективно) продолжать разработку — такого инструмента до появления котлина не существовало. Создатели нового языка, на мой взгляд, очень хорошо почувствовали потребности бизнеса и разработчиков: бизнесу дали возможность увеличить эффективность разработчиков, а разработчикам дать современный инструмент для разработки. И когда я говорю о «современном инструменте», я, конечно, имею ввиду не только компилятор, но и поддержку в IDE, без которой лично моя деятельность разработчика мне видится совсем немыслимой.\nВ итоге: простота позволяет использовать язык почти любому Java-разработчику, который готов потратить полчаса на то, чтобы посмотреть туториал или спецификацию языка, обратная совместимость же позволяет использовать язык в уже существующем проекте.\n\n## Production-ready\n\nКонечно, в первую очередь, запрос на этот язык был у самой JetBrains, отсюда и некоторое понимание, каким он должен быть. Более того, JetBrains же внутри компании его и тестировала: к моменту выхода этого релиза у компании уже есть как минимум один [крупный продукт сделанный чисто на котлине](https://blog.jetbrains.com/dotnet/2016/01/13/project-rider-a-csharp-ide/) (да, я понимаю, что платформа по прежнему написана на Java). Отсюда можно предположить, что заявления о готовности языка к продакшену не голословны. А из своего же опыта использования котлина с 2012 года могу сказать, что из тех проблем, с которыми я сталкивался в дорелизные времена, до релиза ни одна не дожила. Есть еще небольшие проблемы с плагином для IDEA, но сам компилятор работает как часы.\n\n## Совместим с Java 1.6\n\nЭто очень важный момент, ведь именно эта версия Java используется во всех современных версиях Android, и, не смотря на [запланированный переход на OpenJDK](http://venturebeat.com/2015/12/29/google-confirms-next-android-version-wont-use-oracles-proprietary-java-apis/), восьмая версия попадет в руки разработчикам под мобильные устройства не так скоро как хотелось бы. Конечно, есть всякие ретролямбды и другие ухищрения, но котлин — это не только лямбды для андроид, но и современный язык, позволяющий сделать разработку под андроид [проще](https://kotlinlang.org/docs/tutorials/android-plugin.html) и приятней без особых затрат. А увеличение размера apk совсем не значительно по нынешним временам: 823KB (для версии 1.0.0)\n\n## Особенности\n\nПолный список возможностей, конечно, лучше искать в [документации](https://kotlinlang.org/docs/reference/), я же постараюсь отразить наиболее важные на мой взгляд моменты в общих словах:\n\n## Null safety\n\nПочему-то исторически так сложилось, что [эта](https://kotlinlang.org/docs/reference/null-safety.html) особенность котлина вспоминается первой. И хотя она безусловно важна, на мой взгляд не является важнейшей. Здесь язык позволяет, определяя переменные, поля, константы и тд, указать, может ли в них храниться ссылка на null. Поднимает на новый уровень идею аннотаций вроде @Nullable и NotNull, позволяет умно приводить к не-nullable типу после проверки её на null. Надо отметить, что бывают случаи, когда эта особенность расходится с моим закостенелым разработкой на Java представлением о том как должны быть сделаны некоторые вещи, но после некоторого раздумья хорошее решение всегда находится.\n\n```kotlin\n/* вопросом помечаем, что может прийти null */\nfun someFunction(someNullableParam:SomeType?) {\n    if(someNullableParam != null) {\n         // smart cast. Компилятор видит, что передаваемое\n         // значение не null и разрешает его передать в функцию\n        anotherFunction(someNullableParam)\n    }\n}\n\n/* здесь же уже null не пройдет, в попытке передать\n * null или nullable значение компилятор выдаст ошибку */\nfun anotherFunction(someParam:SomeType) {\n    // делаем что-то без опаски, что переданное значение null\n}\n```\n\n## Выведение типов\n\nДа, котлин почти везде где возможно, умеет вывести тип, однако тип всё же придется определить для публичных методов и свойств, что очень разумно (мне подсказывают, что это неправда — с какой-то версии это убрали):\n\n```kotlin\n// Kotlin в курсе, что здесь List<Char>\nval result = sequenceOf(10).map { it.toString() }.flatMap { it.toCharArray().asSequence() }.toList()\n```\n\n\n## Extension methods\n\n[Возможность](https://kotlinlang.org/docs/reference/extensions.html), которой мне остро не хватает в Java для увеличения гибкости языка и решений. Заключается в возможности определить метод для типа отдельно от его (типа) объявления. Такая функция, конечно, не будет виртуальной и никак не меняет класса, которому мы добавляем метод, однако позволяет добавить как утилитарную функциональность для уже существующего кода, так и разгрузить интерфейс от этих же утилитарных методов.\n\n```kotlin\ninterface Vector2 {\n    val x:Float // это не поле, а ридонли свойство (property)\n    val y:Float // в Java были бы методы getX() и getY()\n}\n\n/* Extension property. Без поля в классе, просто getLength() */\nval Vector2.length:Float\n    get() = (x * x + y  * y).sqrt() // притворимся, что такая extension-функция для Float уже существует\n\n/* переопределяем оператор + */\noperator fun Vector2.plus(other:Vector2):Vector2 = createVector(x+this.x, y+this.y) // какой-то способ создать новый вектор\n\n/* без тела, после знака = пишем одно выражение */\nfun Vector2.dot(x: Float, y: Float): Float = x * this.x + y * this.y\n\n/* Помечая функцию с одним параметром как infix,\n * мы позволяем вызывать её через пробел: v1 dot v2 */\ninfix fun Vector2.dot(vec2: Vector2): Float = dot(vec2.x, vec2.y)\n\nfun usage(vec1:Vector2, vec2:Vector2) {\n    val dotProduct = vec1 dot vec2\n    val sum = vec1 + vec2 // на выходе новый вектор\n    val length = sum.length // обращаемся просто как к свойству\n\n}\n```\n\n## Лямбды\n\nКонечно, как любой современный язык с претензией на возможности функцинального программирования, у котлина функция — это сущность первого класса, если переводить дословно. Т.е. функции можно не только объявлять прямо в пакете (из джавы они видны всё равно в классах — по имени файла), но и передавать в качестве параметров, возвращать из других функций и тд. И сейчас, конечно, никого этим не удивишь, но например в сравнении с Java, где синтаксически функций как таковых нет (а только функциональные интерфейсы), в котлине полноценный синтаксис для объявления функции:\n\n```kotlin\n/* передаем в одну функцию другую -- принимает в параметр Int\n * и Int же возвращает. Возвращаем её же, только с фиксированным\n * значением в качестве параметра */\nfun passTen(func: (Int)->Int ): ()->Int {\n    return { func(10) }\n}\n```\n\n## Extension-лямбды\n\nНаряду с extension-методами, это еще одна моя любимая фича. Позволяет определить лямбду, которая будет еще и extension-методом. Звучит не очень, да. Посмотрим на примере:\n\n```kotlin\nclass World(val name:String = \"world\")\n\nval printName:World.()->Unit = {\n     // интерполяцией в синтаксисе языка сейчас уже\n     // никого не привлечь на темную сторону\n    println(\"Hello $name\")\n}\n\nval world = World()\n\n // вызываем нашу функцию как будто это метод нашего класса!\nworld.printName()\n```\n\nЭта возможность особенно интересно смотрится в [билдерах](https://kotlinlang.org/docs/reference/type-safe-builders.html), посмотреть на которые я предлагаю вам самостоятельно — на случай, если вам интересно, как получаются вот такие конструкции:\n\n```kotlin\nhtml {\n    head {\n      title {+\"XML encoding with Kotlin\"}\n    }\n    body {\n      h1 {+\"XML encoding with Kotlin\"}\n      a(href = \"http://kotlinlang.org\") {+\"Kotlin\"}\n    }\n}\n```\n\n## Inline-фукнции\n\nПомечая функцию как inline мы просим компилятор поместить её по месту использования. Чаще всего такими вещами занимается рантайм, но есть кейзы, когда мы точно знаем, что фукнция это просто шорткат для какого-то действия — особенно эффективно это работает с передаваемыми лямбдами:\n\n```kotlin\n/* передаваемой лямбдой block сейчас уже никого не удивишь.\n * Главно, что лишних затрат на вызов этой функции не будет вообще,\n * иногда мне кажется, что это что-то вроде макросов */\ninline fun lock(lock:Lock, block:()->Unit) {\n    lock.lock()\n    try {\n        block()\n    } finally {\n        lock.unlock()\n    }\n}\n\nfun usage() {\n    lock(Lock()) {\n        // делаем что-то внутри блокировки\n    }\n}\n```\n\nКонечно, на такие функции накладывается серия ограничений, подробнее см. [документацию](https://kotlinlang.org/docs/reference/inline-functions.html).\n\n## Делегирование\n\nВ котлине есть два типа делегирования. [Первый](https://kotlinlang.org/docs/reference/delegation.html), который позволяет делегировать все методы реализуемого интерфейса к какому-то инстансу этого типа:\n\n```kotlin\ninterface Connection {\n    fun connect()\n}\n\n/* здесь мы видим стандартный для котлина синтаксис определения\n * класса вместе с параметрами конструктора и свойствами --\n * в данном случае connection будет и в конструкторе и в поле.\n * Есть возможность определить и множественный конструктор\n * см https://kotlinlang.org/docs/reference/classes.html#constructors\n * И, наконец, мы видим что класс реализует интерфейс Connection, все методы\n * которого делегируются к переданному в конструктор экземпляру Connection-а.\n * При желании их конечно можно переопределить в теле класса */\nclass ConnectionWrapper(val connection:Connection) : Connection by connection\n```\n\n\nУ этого синтаксиса есть ряд ограничений. Например, инстанс для делегирования должен быть известен до вызова конструктора.\n\nВторой тип делегирования — это [delegated properties](https://kotlinlang.org/docs/reference/delegated-properties.html). Позволяет определить объект с методами get (и set для var), к которым будет осуществляться делегирование доступа при обращении к свойству объекта.\n\n```kotlin\nclass Foo {\n    /* это делегат из стандартной библиотеки,\n       позволяет отложить инициализацию поля\n       до первого обращения к нему */\n    private val someProeprty by lazy { HavyType() }\n}\n```\n\n## Generics\n\nСоздатели котлина несколько [улучшили](https://kotlinlang.org/docs/reference/generics.html) Java-дженерики. Из-за совместимости с джавой не всё получилось как хотелось бы, но им удалось исправить много неприятных моментов, которые не учли их предшественники при работе над Java 5.\n\n## Деструктуризация\n\n```kotlin\nval (first, second) = someFunc()\n```\n\nЧтобы такой код заработал, возвращаемое значение из someFunc() должно быть типа, у которого есть (можно extension) методы component1(), component2():\n\n```kotlin\nclass Foo {\n    fun component1():String = \"test\"\n    fun component2():Int = 10\n}\nfun someFunc():Foo = Foo()\n\n// или так, to -- в это такой infix extension-метод определенный\n// для Any, который создает экземпляр класса Pair, метод hashMapOf\n// в свою очередь принимает vararg параметр таких пар\nval map = hashMapOf(1 to \"test\")\nfor ((id, name) in map) {\n    //  такой синтаксис возможен, потому что для Map-а определен метод iterator()\n    // возвращающий набор Map.Entry, а для него в свою очередь определены два\n    // extension-метода component1() и component2()\n}\n```\n\n## Data-классы\n\nСахар компилятора для создания бинов:\n\n```kotlin\ndata class Bean(val a:String, val b:Int)\n```\n\nСоздает бин с полями + автогенерирует equals+hashCode+toString()+componentN из раздела выше, что позволяет писать такой код:\n\n```kotlin\nfun someFunc():Bean = Bean(\"test\", 10)\nval (a, b) = someFunc()\n```\n\nПолезная вещь, но о нюансах см. пункт «О грустном».\n\n## Стандартная библиотека\n\nКонечно, нельзя не упомянуть и [стандартную библиотеку](https://kotlinlang.org/api/latest/jvm/stdlib/index.html). Так как котлин нацелен в первую очередь на работу вместе с Java, то и целиком своей стандартной библиотеки у него нет. Большая часть стандартной библиотеки Kotlin нацелена на улучшение и исправление библиотеки старшего брата — Java. Однако, это тема для другой большой статьи.\n\n## О грустном\n\nВы могли подумать, что это идеальный продукт, но нет, есть и неприятные моменты:\n\n## IDE\n\nНад плагином еще работать и работать, периодически выдает эксепшены, плохо умеет в toString() в дебаге, а так же любит промахиваться по ссылке на исходник, иногда (видимо из за особенностей инлайна) путает где поставлен брэкпоинт и тому подобные проблемы. Это всё конечно со временем наверняка поправят, но сейчас мы имеем именно это.\n\n## Data-классы\n\nНадо признать, что идея была хорошая, но в данный момент есть масса [ограничений](https://kotlinlang.org/docs/reference/data-classes.html), наложенных на этот тип классов, что позволяет их использовать в сильно более ограниченном числе кейзов, нежели хотелось бы. Создатели языка обещают поработать над решением этой проблемы, но пока так.\n\n## Некоторая неряшливость\n\nКонечно, неряшливость в первую очередь в головах, но краткость синтаксиса иногда играет злую шутку, и местами код выглядит неважно. Возможно, наличие стайл-гайда несколько эту проблему исправило бы, но пока иногда приходится постараться, чтобы не только хорошо работало, но и красиво выглядело. Особенно на мой субъективный взгляд страшно выглядят get, set для свойств.\n\n## В заключение\n\nОдной статьёй невозможно охватить все особенности и аспекты языка, но я и не пытался. Моей задачей было познакомить с языком, может быть обратить на него внимание. Тот, кто заинтересовался, сможет найти больше в [документации](https://kotlinlang.org/docs/reference/), посмотреть [исходники](https://github.com/JetBrains/kotlin), [попробовать](http://try.kotlinlang.org/), [задать вопрос](https://habrahabr.ru/company/JetBrains/blog/277573/). Сложно предсказать популярность этого языка, но уже сейчас видно, что такого продукта многие ждали, проекты на котлине появляются как грибы, а после релиза частота их появления увеличится еще. По моему впечатлению, языка хорошо сбалансирован и продуман — во время написания кода, складывается ощущение, что всё на своем месте. Если вы используете jvm или любой другой язык со сборкой мусора, есть смысл обратить внимание на котлин. Лично для меня, котлин — это тот инструмент, которого я долго ждал и теперь не представляю, как мог бы обходиться без него.\n\n","author":"@fogone","date":"2016-02-20","type":"article","categories":["Kotlin","Review"],"features":["highlightjs"],"description":"","filename":"","lang":"RU","enclosure":null},{"title":"A clean status bar with Android System UI and QuickDemo","url":"https://pspdfkit.com/blog/2016/clean-statusbar-with-systemui-and-quickdemo/","body":"\nMore often than necessary, screenshots and videos of Android apps suffer from showing an untidy status bar with unwanted notification icons, a drained battery indicator, and a different time on every screenshot. In this blog post, we take a look at the Android System UI demo mode that remedies the aforementioned problems and present a tool [_QuickDemo_](https://github.com/PSPDFKit-labs/QuickDemo) for fast and convenient status bar cleansing.\n\n> A special _Thank You_ to everyone who joined this month's [Android Heads Meetup](https://www.meetup.com/de-DE/AndroidHeads/events/234524954/) at Google Vienna. It was a real pleasure talking to you. You can [find my talk's slides here](https://speakerdeck.com/davidschreiberranner/writing-a-system-ui-demo-mode-quick-settings-tile-in-kotlin). For all of you that couldn't listen to my presentation, check out this blog post! \uD83D\uDE09\n\nAt PSPDFKit, we're developing [PDF Viewer](https://pdfviewer.io) – a PDF app for Android and iOS that has a clean look, is simple to use, and enormously powerful! We put a lot of effort into making the app, as well as [the PDF framework powering it](https://pspdfkit.com/blog/2016/pspdfkit-android-2-7/), look as clean as possible. However, our quality control does not end with the app, but extends to screenshots and videos taken of the app, as well. A high quality screenshot speaks for itself and shows the level of detail that goes into every aspect of our products.\n\n![PDF Viewer for Android](https://pspdfkit.com/images/blog/2016/clean-statusbar-with-quickdemo/viewer.opt-cce806d8.gif)\n\nIn the past we had two primary ways of capturing clean screenshots and videos on Android:\n\n1.  [_Clean status bar_](https://play.google.com/store/apps/details?id=com.emmaguy.cleanstatusbar) is an app for developers. It draws on top of the original dirty status bar, hiding it below a clean-looking overdraw. While this works well when showing opaque status bars with a fixed background color, it cannot be used for transparent status bars or background colors that dynamically change based on the displayed activity's theme (like the real status bar does). The lack of color adaption is immediately noticeable in videos that show transitions between differently styled activities or when opening modal dialogs that darken the activity and status bar in the background.\n\n![Overdrawn status bar](https://pspdfkit.com/images/blog/2016/clean-statusbar-with-quickdemo/overdrawn-statusbar.opt-dfd3c10f.gif)\n\n_Previously: Opaque drawing on top of the original status bar._\n\n2.  Since the launch of Android 6.0 Marshmallow, we've been using the System UI demo mode – an operating system setting that populates the systems status bar with fake data, to give it a cleaner look. However, since the standard System UI demo mode did not deliver all the features we required, we went ahead and started customizing this component.\n\nToday, we're open sourcing [QuickDemo for Android](https://github.com/PSPDFKit-labs/QuickDemo) – a small tool that helps developers capture clean screenshots and videos of their apps without a cluttered status bar. If you're interested in how QuickDemo works, make sure to read the rest of this blog post. \uD83D\uDE4C\n\n![QuickDemo in action](https://pspdfkit.com/images/blog/2016/clean-statusbar-with-quickdemo/quickdemo.opt-b0e6c6d6.gif)\n\n## Android System UI\n\nWith Android 6.0 Marshmallow, Google introduced a new customizable system component, the _System UI Tuner_. Once enabled, the System UI Tuner allows you to change appearance of the status bar, notifications, and other system UI components.\n\nOne more feature that was added with the System UI Tuner is the so-called \"Demo Mode.\" When enabling the demo mode, Android provides fake data to the status bar, giving it a clean and uncompromised look. This allows for shooting clean screenshots and videos (for blog posts, presentation slides, and your app's Google Play Store page). It's also great for doing live demos, without suffering from a dirty notification tray, empty battery indicators, or a clock showing a time that indicates yet another late night coding marathon.\n\nHowever, there are two downsides of the \"vanilla\" Android demo mode:\n\n1.  **Inflexible**: You can't decide on what you would like to show in the status bar. The system settings don't provide any way to customize the demo mode. Luckily, there is a way to do this via system broadcast intents, which we're going to show further down in this article.\n2.  **Inconvenient**: It is complicated to enable and disable demo mode, as the switch to enable it is buried deep inside the developer options. That's where _quick settings_ become interesting, since they provide a way to quickly access actions from any screen on your phone.\n\nThe next section will look at how to control the demo mode. The final section will round up the QuickDemo app by implementing a quick settings tile.\n\n## Controlling the demo mode\n\nThere's an [internal documentation page of the System UI demo mode](https://android.googlesource.com/platform/frameworks/base/+/android-6.0.0_r1/packages/SystemUI/docs/demo_mode.md), which shows how the System UI can be set to demo mode and how demo mode can be configured. All that is required is sending broadcast messages to the System UI, carrying the desired commands.\n\nThis is an example of how you could access the demo mode from the command line via `adb`.\n\n```bash\n# Sets the clock to 07:00\nadb shell am broadcast -a com.android.systemui.demo -e command clock -e hhmm 0700\n```\n\nYour app can do the same, with the right permissions. Since demo mode is a system component and not part of the Android framework, your app requires the permission `android.permission.DUMP` to control it.\n\n```xml\n<!--  This snippet omits some manifest entries and attributes for brevity. -->\n<manifest xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    package=\"com.pspdfkit.tools.demotile\">\n\n    <uses-permission\n        android:name=\"android.permission.DUMP\"\n        tools:ignore=\"ProtectedPermissions\" />\n\n    ...\n</manifest>\n```\n\nMoreover, since this is a _protected permission_, you can't simply request that permission at runtime like you do with normal permissions, but need to use `adb` to manually grant that permission.\n\n```bash\nadb shell pm grant com.pspdfkit.tools.demotile android.permission.DUMP\n```\n\nNote that this must be done _every time you uninstall the app or clear its data_. After permissions have been acquired, you can use a broadcast intent to control the demo mode. The equivalent code for the command to set the time looks like this:\n\n```kotlin\nval intent = Intent(\"com.android.systemui.demo\")\nintent.putExtra(\"command\", \"clock\")\nintent.putExtra(\"hhmm\", \"0700\")\ncontext.sendBroadcast(intent)\n```\n\nHave a look at the [`DemoMode`](https://github.com/PSPDFKit-labs/QuickDemo/blob/master/app/src/main/kotlin/com/pspdfkit/labs/quickdemo/DemoMode.kt) class in QuickDemo, which implements controls for most of the existing demo mode properties. In the next section, we're implementing a custom quick settings tile, to control the demo mode's visibility with just a single tap.\n\n## Adding a `DemoModeTileService`\n\nEver since Android launched, the operating system features the status bar and the notification drawer. Both vanilla Android and OEM specific OS versions also provided \"quick settings,\" small buttons at the top of the notification drawer that would give access to important functions like Wi-Fi, flight mode, the phone's torch, etc.\n\nWith 5.0 Lollipop and Material design's triumphal entry into Android, Google reworked the quick settings section, making it simpler to use and friendlier on the eye. One major version later, 6.0 Marshmallow refined the quick settings, giving the user the possibility to change his/her order, appearance, or completely remove unwanted items.\n\nFast forward to 2016 and Android 7.0 Nougat, the Android API 24 added [support for creating custom quick setting tiles](https://developer.android.com/about/versions/nougat/android-7.0.html#tile_api). The new [`TileService`](https://developer.android.com/reference/android/service/quicksettings/TileService.html) provides access to a single quick settings [`Tile`](https://developer.android.com/reference/android/service/quicksettings/Tile.html). An app can register as many tile services (thus tiles) as it wants by declaring them inside its `AndroidManifest.xml` file.\n\n```xml\n<!--  This snippet omits some manifest entries and attributes for brevity. -->\n<manifest xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    package=\"com.pspdfkit.tools.demotile\">\n\n    <application>\n        <service\n            android:name=\".service.DemoModeTileService\"\n            android:icon=\"@drawable/ic_demo_mode\"\n            android:label=\"@string/demo_mode_tile_title\"\n            android:permission=\"android.permission.BIND_QUICK_SETTINGS_TILE\">\n            <intent-filter>\n                <action android:name=\"android.service.quicksettings.action.QS_TILE\" />\n            </intent-filter>\n        </service>\n    </application>\n</manifest>\n```\n\nThe registered [`DemoModeTileService`](https://github.com/PSPDFKit-labs/QuickDemo/blob/master/app/src/main/kotlin/com/pspdfkit/labs/quickdemo/service/DemoModeTileService.kt) declares the required permissions for using the tiles API, as well as an `<intent-filter>` that will allow the service to register itself inside the \"tiles picker\" so it can be discovered by the user. Moreover, it specifies the tiles default icon and title. While both values can be changed dynamically at runtime, the operating system will use the manifest's values when displaying the tile inside the tiles picker (think of it as a preview).\n\nNow for implementation. Don't be scared of it – it's really simple. The [`DemoModeTileService`](https://github.com/PSPDFKit-labs/QuickDemo/blob/master/app/src/main/kotlin/com/pspdfkit/labs/quickdemo/service/DemoModeTileService.kt) extends Android framework's [`TileService`](https://developer.android.com/reference/android/service/quicksettings/TileService.html) class. To allow toggling of the demo mode by tapping it, the tile service overrides three methods:\n\n*   [`#onCreate`](https://developer.android.com/reference/android/app/Service.html#onCreate()) is called when the service is created. Our service creates its custom [`DemoMode`](https://github.com/PSPDFKit-labs/QuickDemo/blob/master/app/src/main/kotlin/com/pspdfkit/labs/quickdemo/DemoMode.kt) for controlling visibility of the demo mode.\n*   [`#onStartListening`](https://developer.android.com/reference/android/service/quicksettings/TileService.html#onStartListening()) is called when the service should start updating the tile, normally before the tile becomes visible. When this happens the [`DemoModeTileService`](https://github.com/PSPDFKit-labs/QuickDemo/blob/master/app/src/main/kotlin/com/pspdfkit/labs/quickdemo/service/DemoModeTileService.kt) refreshes the tile's title, icon, and state.\n*   [`#onClick`](https://developer.android.com/reference/android/service/quicksettings/TileService.html#onClick()) is called whenever the user tapped the tile in the quick settings. This is where we're toggling the demo mode between being enabled or disabled. Since the tile service requires a special permission to control the System UI demo mode, we're also checking for that permission.\n\n```kotlin\nclass DemoModeTileService : TileService() {\n\n    private lateinit var demoMode: DemoMode\n\n    override fun onCreate() {\n        super.onCreate()\n        demoMode = DemoMode.get(this)\n    }\n\n    override fun onStartListening() {\n        qsTile.icon = Icon.createWithResource(this, R.drawable.ic_demo_mode)\n        qsTile.label = \"Demo mode\"\n        updateIcon()\n    }\n\n    override fun onClick() {\n        if(!demoMode.requiredPermissionsGranted) {\n            startActivityAndCollapse(SetupGuideActivity.intent(this))\n            return\n        }\n\n        demoMode.enabled = !demoMode.enabled\n        updateIcon()\n\n        val it = Intent(Intent.ACTION_CLOSE_SYSTEM_DIALOGS)\n        sendBroadcast(it)\n    }\n\n    private fun updateIcon() {\n        qsTile.state = if (demoMode.enabled) Tile.STATE_ACTIVE else Tile.STATE_INACTIVE\n        qsTile.updateTile()\n    }\n}\n```\n\nThat's it! You can check out the full source code of [QuickDemo on GitHub](https://github.com/PSPDFKit-labs/QuickDemo). If you have any questions on the System UI Demo Mode or the Android tiles API, feel free to [ping me on Twitter](https://twitter.com/Flashmasterdash) or [Google+](https://plus.google.com/112371263315253005287).\n\n","author":"David Schreiber‑Ranner","date":"2016-11-17","type":"article","categories":["Kotlin","Android"],"features":["highlightjs"],"description":"","filename":"","lang":"EN","enclosure":null},{"title":"Exploring Kotlin","url":"http://blog.cacoethes.co.uk/software/exploring-kotlin","body":"\n\n_This post is outdated, because Kotlin have a lot changes from June, 2015_\n\nWelcome to the start of an intermittent series of blog posts where I just talk about various bits of technology that I’m in the process of discovering. Don’t expect much in the way of teaching, but do expect much in the way of erroneous comments as I discuss stuff I don’t yet properly understand.\n\nI’m starting the series with Kotlin, one of a new wave of languages for the JVM. I say wave, but the only other one I can think of is Ceylon. Still, Kotlin and Ceylon are important because, as I understand it, they both aim to provide a solid alternative (AKA replacement) to Java. As you’d expect if you follow me, this post has a definite Groovy flavour with most of the comparisons between that and Kotlin.\n\nSo why am I looking at Kotlin anyway? Partly to expand my horizons, partly in search of a statically-typed alternative to Java that I’m happy with, and partly because I think it has a reasonable chance of picking up a sizeable following. It seems like a pragmatic evolution to Java that respects the need for good Java integration and doesn’t introduce anything that’s terribly hard for an older programmer like me to understand. It does include a whole bunch of features I like.\n\n## There is no static\n\nSometimes the best way to learn about a language is to just jump into the deep end. In this case, I thought I’d try to migrate my Lazybones project from Groovy to Kotlin. I do have a small ulterior motive for doing this: the Lazybones tool has a small but noticeable startup delay when running it. If I can eliminate that, I’ll be very happy.\n\nYou can follow my progress on [GitHub](https://github.com/pledbrook/lazybones-kotlin). One thing to bear in mind is that the code would probably look a bit different if I started with Kotlin. I tend to rely on Groovy’s dynamic features, which don’t translate so well to a statically-typed language. All the more surprising then that the migration has gone fairly smoothly.\n\nThe first thing that struck me though, and had me scratching my head for a while, was the complete lack of the `static` keyword. It’s not even available on the `import` statement. I first came across `static` a long time ago when I was learning C and it took an embarrassingly long time to work out what it did. Almost as embarrassing as not knowing how many ‘r’s are in ‘embarrass’. It did eventually click and that understanding has helped me through C, C++, Java and Groovy. So I was a bit at sea initially, especially as I had lots of `static`s dotted around the code base.\n\nAfter that initial shock, I admit I quickly came around to Kotlin’s way of thinking. The `static` keyword is mostly a kludge in Java and has a variety of use cases that could be handled differently. For example, functions can’t exist independently of a class, even if they don’t belong on an object. This is the tyranny of Java’s particular Object-oriented viewpoint. Kotlin eliminates this use case by allowing functions defined outside of classes. The same goes for constants. Sharing data between objects of the same type can be achieved through companion objects. If you absolutely need a static field or method, for example when you’re calling Kotlin code from Java, you can use a `@platformStatic` annotation.\n\n## The good stuff\n\nSubsequent work highlighted a lot of similarities with Groovy, such as the Elvis operator (not sure if it’s called that in Kotlin), null-safe navigation, lambda function syntax, embedded string expressions, and multi-line strings. The Kotlin extension methods for the standard types are also a reasonably close match to those of Groovy, although Kotlin thankfully uses the more standard names such as ‘map’, ‘fold’ and ‘filter’. Just remember to add the ‘kotlin-stdlib’ JAR to your project’s classpath, or you’ll miss out on a lot of essential features like I did and remain confused as to why none of the examples on the web work for you.\n\nOn the flip side, there were a lot of repetitive tasks I had to undertake during the migration. Types always go after variable and function declarations, which allows for the essential `fun`, `val` and `var` keywords, but does result in a lot of cutting and pasting. Kotlin also handles properties differently. The `get()` and `set()` syntax is nice, but getters and setters on Java and Groovy code are not treated as properties. This means you have to invoke the methods explicitly. Yuck.\n\nBeyond the feeling of familiarity, Kotlin provides some other very pleasant surprises. Unlike Java 8, you don’t need to define or use an interface to take advantage of lambdas:\n\n```kotlin\nenum class NameType(val intermediateType : NameType?,\n                    val toIntermediateFn : (String) -> String,\n                    val fromIntermediateFn : (String) -> String) {\n    ...\n}\n```\n\nSimply use the syntax `(<arg types>) -> <return type>` on your properties or function signatures.\n\nThe most far-reaching feature is Kotlin’s null handling. Types come in two forms: those that allow null values, and those that don’t. It’s easy to distinguish between them because the former have a ‘?’ suffix, for example `String?` vs `String`. The compiler then checks that you don’t attempt to use a potentially null value for an argument or variable that can’t be null. This causes all sorts of fun when using non-Kotlin libraries because almost every value can potentially be null, but Kotlin provides some nice get out of jail free cards for such occasions. And most importantly, it forces you to really think about when and where you want to allow null values and how you should be dealing with them.\n\nI won’t go into any more details, but what could have been a really frustrating feature when working with existing code and libraries turned out to be less bothersome than expected once I’d become familiar with most of its aspects. It even highlighted bits of code that probably weren’t handling nulls properly. I was particularly shocked at how laissez-faire my Groovy code appeared to be with regard to nulls.\n\n**Update** Jetbrains provide a tool called [KAnnotator](https://github.com/jetbrains/kannotator) that analyses Java libraries for whether they accept and/or return nulls. This makes the libraries much easier to integrate into Kotlin code. Thanks to Rob Fletcher for the pointer.\n\nThe compiler is also a lot more intelligent than Java’s (I suspect at the cost of compilation speed). It follows branches appropriately and can tell when they return with what types. This picked up at least one bug in my code, albeit nothing major. It also seems to be aware of null and `instanceof` checks (although in Kotlin these use is instead). That means you don’t need an explicit cast or null-safe navigation after such a check. Unfortunately this feature only seemed to work some of the time and I couldn’t work out why it didn’t in those cases. Hopefully the edge cases will be ironed out or at least well documented as Kotlin approaches 1.0.\n\n## What I miss\n\nIt’s not all great for a Groovy developer like me. The number one concern is that I can’t seem to mix the two languages in the same project. At least with the Gradle integration the Kotlin compilation takes place before Java, which in turn comes before Groovy. My limited understanding suggests that you can use Kotlin-compiled code from Groovy, but not vice versa. This is a shame as Groovy is particularly strong in dealing with configuration data, JSON, and the like.\n\nI initially thought that Kotlin’s `dynamic` keyword, which disables type checking on the marked object, would give me similar behaviour to Groovy in such cases, but IntelliJ IDEA kept on saying that it couldn’t be used in the current context. Err...what? What context would that be? It transpires that in this case the context is the JVM! In other words, `dynamic` only seems to work for KotlinJS (a version that compiles to Javascript). This seems like a lost opportunity considering the addition of `invokedynamic` to the JVM. Perhaps the implementation would complicate the language or maybe the language designers want to maintain Java 6 as the minimum JVM version.\n\nI also desperately miss Groovy Truth. This allows you to treat various values, such as empty strings, as if they were equivalent to the boolean `true` or `false`. For example, if I have a nullable string and just want to check whether it contains at least one character I prefer:\n\n```groovy\nif (str) doSomething()\n```\n\nrather than\n\n```java\nif (str != null && str.isNotEmpty()) doSomething()\n```\n\nThe kludge I’ve gone for seems a bit dangerous as I don’t know how widely applicable it is:\n\n```kotlin\nif (str?.isNotEmpty() ?: false) doSomething()\n```\n\nAnyway, I’m hoping that I’ve missed a particular feature of Kotlin that prevents the return of the dreaded explicit null checks.\n\nList and map literals would have been nice, but methods like `arrayListOf()` and `hashMapOf()` do the job fine. Regular expression literals plus something like the `=~` operator would also have made my life easier, but the Kotlin approach isn’t massively worse. In fact, the `Regex` class is growing on me.\n\nLastly, I really wanted to make use of method references in the `NameType` class, but I just couldn’t get them to work the way I want. I suspect that method references on instance methods have a different signature to function references. Unfortunately, this area of Kotlin isn’t particularly well documented. That’s not too surprising when you consider that the language hasn’t even hit 1.0 yet, but I do think that adoption is only for the brave right now.\n\n## Do I like it?\n\nWhen all is said and done, I’m pleasantly surprised by Kotlin. Although I perhaps hadn’t realised how reliant I was on some of Groovy’s more dynamic features, the transition to a fully statically typed language wasn’t nearly as bad as it had every right to be. There were a few struggles, but nothing that kept me from almost completing the transition in a short timeframe. The only thing left to do is convert a couple of configuration-related classes – probably the hardest ones to do over all.\n\nOne final thing I learned is that I hate generics. Really. I think Kotlin’s ‘*’ wildcard was the only thing that helped me retain my sanity.\n\nAs I said at the beginning of the post, Kotlin is an evolution rather than a revolution. That’s why I think it has a reasonable chance of success. Will it prove a significant competitor to Java? I don’t know, but I doubt it. There is so much inertia around Java that sometimes it feels like nothing will supersede it. Nonetheless, Kotlin is definitely worth an investigation if you’re looking for a statically-typed alternative to Java for your own projects. As I understand it, Jetbrains are pretty reliant on it, so it’s unlikely to disappear soon if at all. And you’re guaranteed first class support in at least one IDE!\n\nDo remember that this is a first impressions account of the language, so don’t take anything as gospel truth other than these were my experiences. I’ll try to post additional articles as I gain a better understanding of the language.\n\n","author":"Peter Ledbrook","date":"2015-06-27","type":"article","categories":["Kotlin","Groovy"],"features":["highlightjs"],"description":"","filename":"","lang":"EN","enclosure":null},{"title":"Kotlin 1.0.6 is here!","url":"https://blog.jetbrains.com/kotlin/2016/12/kotlin-1-0-6-is-here/","body":"\nWe are happy to announce the release of Kotlin 1.0.6, the new bugfix and tooling update for Kotlin 1.0. This version brings a significant number of improvements related to the IDE plugin and Android support.\n\nWe’d like to thank our external contributors whose pull requests are included in this release: [Kirill Rakhman](https://github.com/cypressious) and [Yoshinori Isogai](https://github.com/shiraji). We also want to thank everyone of our EAP users for their feedback. It is really valuable for us, as always.\n\nYou can find the full list of changes in the [changelog](https://github.com/JetBrains/kotlin/blob/1.0.6/ChangeLog.md#106). Some of the changes worth highlighting are described below.\n\n## Convert `try-finally` to `use()` intention\n\nWe continue to add intentions for converting code to idiomatic Kotlin. The IDE now automatically suggests to replace `try-finally` block with the [use()](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.io/use.html) call when all the `finally` block does is closing a resource.  \n\n![](https://d3nmt5vlzunoa1.cloudfront.net/kotlin/files/2016/12/try.gif)\n\n## “Add names to call arguments” intention\n\nNamed arguments help to increase code readability. With the new “Add names to call arguments” intention you can easily add the name to an argument, or just substitute names for all call arguments at once.\n\n![](https://d3nmt5vlzunoa1.cloudfront.net/kotlin/files/2016/12/args.gif)\n\n## Other notable IDE plugin changes\n\n* Inspection/intention for removing empty secondary constructor body, as well as empty primary constructor declaration;\n* “Join declaration and assignment” intention;\n* Fixes for inline functions and performance improvements in debugger;\n* Numerous fixes in intentions, KDoc and Quick Doc.\n\n## Android Support\n\n* Android Studio 2.3 beta 1 is now supported, as well as the Android Gradle plugin version 2.3.0-alpha3 and newer.\n* “Create XML resource” intention is added;\n* Android Extensions support is now active in the IDE only if the corresponding plugin is enabled in the `build.gradle`;\n* Significant number of fixes in Android Lint. Also the “Suppress Lint” intention is added.\n\n## Kapt Improvements\n\nWe continue to work on the experimental version of Kotlin annotation processing tool (kapt). While there are still some things to do in order to fully support incremental compilation, performance of the annotation processing is significantly increased since Kotlin 1.0.4.\n\nTo enable experimental kapt, just add the following line to your `build.gradle`:\n\n`apply plugin: 'kotlin-kapt'`\n\n## All-open compiler plugin\n\nThe **all-open** compiler plugin makes classes annotated with a specific annotation and their members open without the explicit `open` keyword, so it becomes much easier to use frameworks/libraries such as Spring AOP or Mockito. You can read the detailed information about all-open in the corresponding [KEEP](https://github.com/Kotlin/KEEP/pull/40).\n\nWe provide all-open plugin support both for Gradle and Maven, as well as the IDE integration.\n\n### How to use all-open with Gradle\n\n```gradle\nbuildscript {\n    dependencies {\n        classpath \"org.jetbrains.kotlin:kotlin-allopen:$kotlin_version\"\n    }\n}\n\napply plugin: \"kotlin-allopen\"\n\nallOpen {\n    annotation(\"com.your.Annotation\")\n}\n```\n\nIf the class (or any of its superclasses) is annotated with `com.your.Annotation`, the class itself and all its members will become open. It even works with meta-annotations:\n\n```kotlin\n@com.your.Annotation\nannotation class MyFrameworkAnnotation\n\n@MyFrameworkAnnotation\nclass MyClass // will be all-open\n```\n\nWe also provide the “kotlin-spring” plugin that already has all required annotations for the Spring framework:\n\n```gradle\nbuildscript {\n    dependencies {\n        classpath \"org.jetbrains.kotlin:kotlin-allopen:$kotlin_version\"\n    }\n}\n\napply plugin: \"kotlin-spring\"\n```\n\nOf course, you can use both `kotlin-allopen` and `kotlin-spring` in the same project.\n\n### How to use all-open with Maven\n\n```xml\n<plugin>\n    <artifactId>kotlin-maven-plugin</artifactId>\n    <groupId>org.jetbrains.kotlin</groupId>\n    <version>${kotlin.version}</version>\n\n    <configuration>\n        <compilerPlugins>\n            <!-- Or \"spring\" for the Spring support -->\n            <plugin>all-open</plugin>\n        </compilerPlugins>\n\n        <pluginOptions>\n            <!-- Each annotation is placed on its own line -->\n            <option>all-open:annotation=com.your.Annotation</option>\n            <option>all-open:annotation=com.their.AnotherAnnotation</option>\n        </pluginOptions>\n    </configuration>\n\n    <dependencies>\n        <dependency>\n            <groupId>org.jetbrains.kotlin</groupId>\n            <artifactId>kotlin-maven-allopen</artifactId>\n            <version>${kotlin.version}</version>\n        </dependency>\n    </dependencies>\n</plugin>\n```\n\n## No-arg compiler plugin\n\nThe **no-arg** compiler plugin generates an additional zero-argument constructor for classes with a specific annotation. The generated constructor is synthetic so it can’t be directly called from Java or Kotlin, but it can be called using reflection. You can see motivating discussion [here](https://discuss.kotlinlang.org/t/feature-request-a-modifier-annotation-for-data-classes-to-provide-a-non-arg-constructor-on-jvm/1549/4).\n\n### How to use no-arg in Gradle\n\nThe usage is pretty similar to all-open.\n\n```gradle\nbuildscript {\n    dependencies {\n        classpath \"org.jetbrains.kotlin:kotlin-noarg:$kotlin_version\"\n    }\n}\n\n// Or \"kotlin-jpa\" for the Java Persistence API support\napply plugin: \"kotlin-noarg\"\n\nnoArg {\n    annotation(\"com.your.Annotation\")\n}\n```\n\n### How to use no-arg in Maven\n\n```xml\n<plugin>\n    <artifactId>kotlin-maven-plugin</artifactId>\n    <groupId>org.jetbrains.kotlin</groupId>\n    <version>${kotlin.version}</version>\n\n    <configuration>\n        <compilerPlugins>\n            <!-- Or \"jpa\" for the Java Persistence annotation support -->\n            <plugin>no-arg</plugin>\n        </compilerPlugins>\n\n        <pluginOptions>\n            <option>no-arg:annotation=com.your.Annotation</option>\n        </pluginOptions>\n    </configuration>\n\n    <dependencies>\n        <dependency>\n            <groupId>org.jetbrains.kotlin</groupId>\n            <artifactId>kotlin-maven-noarg</artifactId>\n            <version>${kotlin.version}</version>\n        </dependency>\n    </dependencies>\n</plugin>\n```\n\n## How to update\n\nTo update the IDEA plugin, use Tools | Kotlin | Configure Kotlin Plugin Updates and press the “Check for updates now” button. Also, don’t forget to update the compiler and standard library version in your Maven and Gradle build scripts.\n\nAs usual, if you run into any problems with the new release, you’re welcome to ask for help on the [forums](https://discuss.kotlinlang.org/), on Slack (get an invite [here](http://kotlinslackin.herokuapp.com/)), or to report issues in the [issue tracker](https://youtrack.jetbrains.com/issues/KT).\n\nLet’s Kotlin!\n\n","author":"Yan Zhulanow","date":"2016-12-27","type":"article","categories":["Kotlin"],"features":["highlightjs"],"description":"","filename":"","lang":"EN","enclosure":null},{"title":"Без слайдов: интервью с Дмитрием Жемеровым из JetBrains","url":"https://habrahabr.ru/company/jugru/blog/263905/","body":"\nСегодня пятница, а пятница на хабре — это отличный день для чего-то необычного. Сегодня я предлагаю вашему вниманию интервью с **Дмитрием [yole](https://habrahabr.ru/users/yole/) Жемеровым**, человеком, который приложил руку и к IntelliJ IDEA, PyCharm, Kotlin и многим другим продуктам компании JetBrains.\n\nО чем мы поговорили:\n\n* как развивается IDEA, куда она движется\n* в чем разница между IntelliJ и JetBrains\n* зачем в компании два CEO\n* что происходит в Kotlin'e\n* с какими трудностями столкнулась команда Kotlin в процессе разработке языка\n* что такое Language Design Review\n* что представляет собой современный Google\n* почему закрылся Google Code\n* почему хабр важен для разработчиков IDE\n\n<iframe src=\"https://www.youtube.com/embed/pr7faOqruQY?feature=oembed\" allowfullscreen=\"\" height=\"315\" frameborder=\"0\" width=\"560\"></iframe>\n\n— **Добрый день! Это «Без слайдов». У нас выпуск сегодня с Дмитрием Жемеровым, ветераном компании JetBrains. Дима, давай начнем с того, что ты чуть-чуть о себе расскажешь: что делал, и в JetBrains в том числе?**\n\nВ JetBrains я пришел в 2003 году. Я был 28-м или 29-м сотрудником, и за это время успел довольно много чем позаниматься. Я вначале был руководителем разработки проекта [Omea](https://www.jetbrains.com/omea/) – был такой information-агрегатор, то есть это программа, которая собирала информацию из разных источников типа почты, news’ов, RSS-фидов. Он позволял делать по ним всем поиск, это все организовывать, категоризовывать и так далее. Потом проект Omea был закрыт, и я перешел в команду IntelliJ IDEA. Можно сказать, стоял у истоков такой сущности, как IntelliJ-платформа, то есть занимался переводом монолитной среды разработки IntelliJ IDEA в платформу, на базе которой можно строить IDE для разных языков, а не только для Java. Понятно, что в этом много кто поучаствовал, но я тоже там довольно много сделал. Потом я занимался различными IDE на базе этой платформы: я успел позаниматься и RubyMine, и PyCharm, и WebStorm.\n\n— **Куда, по-твоему, сейчас движется вообще IDEA как продукт, как платформа? Есть ощущение, что возникла некоторая стагнация: мне как пользователю IntelliJ IDEA кажется, что ничего не происходит. Выходят новые версии, они, может быть, быстрее работают, поддерживают новые framework'и. Так это, не так?**\n\nБыстрее – это самое главное. Скорость – это такая фича, от которой никто никогда не отказывается. Мы уже довольно долгое время вкладываемся в качество пользовательских интерфейсов, юзабилити, в то, чтобы было все аккуратно, гладенько. Большие фичи, которые меняют ваш experience как девелопера, тоже появляются в каком-то количестве. Например, Inline Debugging, который у нас появился в 14ой версии. Когда вы step’аетесь по коду, вы сразу прямо в коде, в редакторе видите значение переменных, которые на этих строчках вычисляются. Или, например, незадолго до этого появилась поддержка нескольких кареток в редакторе – это тоже большая фича, которая для многих имеет значение. Что будет следующим, я сказать на самом деле не могу, потому что у нас процесс разработки не очень сильно далеко вперед планируется, и просто разработчику может внезапно прийти в голову идея: «Давайте-ка я займусь этой функциональностью. Давайте-ка я ее сделаю». Он пойдет и сделает, и она появится в релизе, и будет все здорово.\n\n— **Около 3 лет назад Олег Степанов и Максим Шафиров стали CEO компании JetBrains. Во-первых, почему их два? Я не помню каких-то таких случаев, когда CEO сразу двое. Что изменилось за эти годы? Какие, может быть, задачи и цели перед ними ставились, если это открытая информация, и насколько это успешно? Что в компании изменилось?**\n\nДва CEO — это довольно удобно оказалось, потому что два офиса. Олег живет в Мюнхене, Макс живет в Питере, и каждый из них отвечает в первую очередь за то, что происходит в их офисе. Там просто много работы, и они как-то эту работу между собой делят. Макс сейчас очень активно занимается вообще всей нашей инфраструктурой продаж, то есть нашей внутренней корпоративной информационной системой, если угодно, магазином. Тем, чтобы пользователи имели в этом месте хороший experience. Олег занимается довольно много нашими серверными инструментами, чтобы из нашего зоопарка в лице YouTrack, TeamCity и Upsource, сделать какое-то единое решение, которое можно просто поставить, и оно решит все проблемы с процессом разработки, которые есть в вашей в команде.\n\n— **То есть, кроме разделения по офисам, есть еще разделение по продуктам?**\n\nЭто даже не столько по продуктам, сколько по областям деятельности. У нас, как и все в JetBrains, это как-то органически случается. Когда мы эту схему внедряли, у нас не было такого сразу, что давайте договоримся, кто за что отвечает – просто по ходу дела получается, что эта деятельность, ею надо заниматься, и, соответственно, тот человек, который может ее на себя взять, ее на себя берет.\n\n— **Как ты оцениваешь эти 3 года? Что изменилось глобально?**\n\nВ плане организации работы в принципе, JetBrains остался тем же самым. Случились какие-то довольно большие проекты, например, переезд в наш новый офис на Васильевском острове, в котором Сергей Дмитриев, который до этого был руководителем компании, вообще никакого участия не принимал. Или, например, в организации продаж. Много чего изменилось за это время у нас внутри компании, какие-то вещи смогли сделать большие.\n\n— **Два CEO — это такой эксперимент, который продолжается? Уже видны его результаты, или все еще в процессе? Или в принципе не ожидалось каких-то глобальных изменений?**\n\nНет, на самом деле просто в первую очередь мотивация для этого решения была очень простая. Сергей Дмитриев в какой-то момент сказал: «Я уже не молодой, грубо говоря. Я могу либо продолжать делать дальше JetBrains, либо я могу оставить JetBrains, который был сделан, каким-то другим людям из команды, и сам пойти заниматься какой-то другой деятельностью». Судя по тому, что он эти 3 года успешно занимается другой деятельностью, не отвлекаясь на JetBrains или очень мало отвлекаясь на JetBrains, то, в общем-то, все получилось. JetBrains за это время растет, успешно разется и так далее. Эта задача была в полной мере выполнена.\n\n— **На твоем [старом сайте](http://yole.ru) есть запись, датированная 2003 годом, что ты устроился в IntelliJ Labs. Сейчас мы компанию знаем как JetBrains. Ты можешь немножко рассказать о связи JetBrains и IntelliJ Labs?**\n\nЭто очень просто. IntelliJ Labs – это название, под которым компания появилась. В 2000-2001 году первые версии IntelliJ IDEA были выпущены под маркой IntelliJ Software или IntelliJ Labs. Потом, когда стало понятно, что мы хотим делать продукты не только для Java, соответственно, название с буквой «J» нам не годится. Мы поставили букву «J» в начало и придумали название JetBrains. IntelliJ Labs до сих пор сохранилось в названии российского юридического лица нашей компании — ООО «ИНТЕЛЛИДЖЕЙ ЛАБС». «JetBrains» – это, соответственно, юрлицо headquarters компании.\n\n— **JetBrains, который был в середине 2000-х, и JetBrains образца 2015 года — чувствуешь ли ты какую-то разницу между ними, и если да, то что тебе нравится, что тебе не нравится?**\n\nПонятно, что в компании такого размера просто уже другой уровень личных связей. Когда я из Мюнхена приезжаю в Питер, я хожу по офису и вижу массу людей, про которых я часто даже не знаю: они работают у нас в компании, они зашли к кому-то в гости или они просто пиццу привезли. Это люди, которых я не знаю; я не знаю, чем они занимаются. Положительно то, что JetBrains очень долгое время был хронически understaffed, то есть все время было состояние, что работы было больше, чем людей, которые имеются, чтобы ее делать. Мне кажется, что в последнее время в очень многих проектах мы из этого состояния выходим – не во всех, но во многих. Грубо говоря, у нас столько людей, сколько нужно, чтобы реально продукты вперед двигать.\n\n— **Сейчас у вас 300 человек, 400?**\n\n400 с чем-то.\n\n— **Это в основном Питер и Мюнхен, да?**\n\nДа, у нас сейчас, наверное, 80 человек в Мюнхене и, соответственно, 400 с чем-то в Питере пока.\n\n— **Сотни людей. Распределенность создает вам какие-то сложности?**\n\nМне не кажется, что создает. Как правило, в Мюнхен уезжают люди, которые уже какое-то время проработали в питерском офисе, которые уже знакомы с командой, с которой они вместе работают. Соответственно, нет такого, что у тебя появляется какой-то внезапный человек в другом офисе, с которым тебе нужно как-то налаживать отношения. Плюс к этому, мы часто друг к другу ездим.\n— **Ты сам часто ездишь сюда?**\n\nКаждые два-три месяца я точно в Питере бываю. Плюс к тому, у нас каждый день стендапы по видеоконференции, то есть каждый день есть какое-то количество личного общения через видеосвязь. Мне кажется, что у нас нет проблем из-за того, что мы распределенные.\n\nБолее того, я бы хотел, чтобы мы были более распределенными. Я бы хотел, чтобы мы имели возможность нанимать на работу людей, например, в Silicon Valley. Тех, которых там все устраивает, и они не хотят переезжать.\n\n— **У вас рабочий язык английский, русский?**\n\nРусский. Комментарии в коде всегда по-английски, всякая внутренняя коммуникация – стараемся всегда по-английски, а устное общение всегда по-русски, за исключением тех редких случаев. У нас все-таки есть некоторое количество не говорящих на русском сотрудников, и с ними, конечно, мы по-английски общаемся.\n\n— **Понятно. Теперь еще одна интересная история. Буквально пару недель назад Андрей Бреслав выпустил [пост](http://megamozg.ru/p/15794/), на который очень многие обратили внимание, в котором, в общем, активно искал на самом деле product-менеджеров. Такой вопрос отсюда: вы недовольны своими product-менеджерами или просто ищите?**\n\nМы ищем людей на позицию, которая называется «Product Marketing Manager» (PMM). На самом деле, у нас очень хорошая команда подобралась. Насколько я знаю, мы довольны всеми, кто у нас сейчас на этой позиции работает. Андрей искал человека конкретно в Kotlin, где сейчас PMM просто нет. Или, например, в IntelliJ IDEA сейчас всего один человек, Андрей Чепцов, занимается продуктовым маркетингом. Это большой продукт, сложный, с большим количеством разных фич, и понятно, что там есть работа и на второго человека, и, может быть, на третьего тоже.\n\n— **Около года назад в Kotlin пришел Илья Рыженков. Разве он не на позицию PMM пришел?**\n\nСейчас, по факту, получилось так, что Илья занимается в первую очередь библиотеками и инфраструктурой вокруг Kotlin'а. Он руководит командой, которая делает фреймворки для Kotlin’а, сам тоже код пишет. Мы постоянно экспериментируем с новыми фреймворками для Kotlin'а. Один у нас уже есть, но мы пробуем другие варианты, ищем, как можно было бы лучше сделать.\n\n— **А Андрей Бреслав?**\n\nАндрей, во-первых, главный дизайнер языка, а во-вторых, он до недавних пор был проектным менеджером всей команды. Я недавно у него забрал менеджмент IDE-команды — у нас уже есть 5 человек, которые занимаются плагинами для IntelliJ IDEA, и теперь я их руководитель. Программировать Андрей как раз решил перестать недавно, потому что не хватает на это все времени. Мы стремимся сделать релиз поскорее, и в данный момент просто есть какое-то количество открытых вопросов по дизайну языка. Мы хотим как можно скорее их закрыть, и Андрей в первую очередь сосредоточен сейчас на этом.\n\n— **Пять человек — в одной только IDE? Когда я в последний раз плотно общался с командой Kotlin'а, это было пару лет назад, там было всего, по-моему, 9 человек. Видать, команда Kotlin’a с тех пор сильно выросла?**\n\nТам больше 20 человек сейчас.\n\n— **То есть, компания реально инвестирует в Kotlin?**\n\nДа.\n\n— **Два-три года назад складывалось ощущение, что выйдет Java 8, и все, дальше Kotlin будет не нужен. А вы сейчас только увеличили инвестиции. Вы делаете на него какую-то серьезную ставку? Пишете ли вы сами на нем?**\n\nДа, у нас сейчас есть какое-то количество проектов, которые разрабатываются на Kotlin'e, но не так много, как мне лично бы хотелось. Например, следующая версия YouTrack пишется на Kotlin'е. У нас есть один не анонсированный продукт, он пишется тоже на Kotlin'е. Новая CRM-система, про которую я упоминал, вся на Kotlin'е от начала и до конца написана. Это business critical решение, через него все наши продажи проходят. Мы доверяем коду на Kotlin'е наши продажи, и это, как мне кажется, говорит о чем-то.\n\nРебята постоянно берут Kotlin из master'а, то есть они сидят не на релизных версиях, а каждые несколько дней апгрейдятся на самую последнюю версию Kotlin'а из свежесобранного. При этом довольны, все работает.\n\nНасчет Kotlin vs. Java 8 — на самом деле, это некоторая распространенное заблуждение. В первую очередь, Java довольно сильно завязана на свое legacy. В [прошлом выпуске](http://habr.ru/p/255219/) «Без слайдов» это тоже обсуждалось. Сергей Куксенко говорил, что было бы здорово все выкинуть и написать с нуля. Он, наверное, скорее имел в виду библиотеку и виртуальную машину, но с точки зрения дизайна языка Java тоже есть решения, которые когда-то были приняты и которые будут с нами навсегда. Например, Raw Types, Wildcards, разделение на примитивные и непримитивные типы и так далее – это никуда не денется, и сколько бы Java не развивалась, эта legacy останется навсегда. Само по себе то, что мы не завязаны на эту обратную совместимость, нам уже развязывает руки, уже дает нам возможность делать какие-то интересные вещи.\n\nСейчас, когда я кому-то рассказываю о Kotlin'е, а я время от времени делаю доклады, я первые примерно 20 минут вообще никаких лямбд не упоминаю – просто показываю разные фичи Kotlin'а. Там есть очень много всего, что вообще не затрагивает тех изменений, которые произошли между седьмой и восьмой Jav'ой — просто вещи, в которых мы улучшаем ту часть Java, которая никак этим всем не затронута.\n\nПотом уже, конечно, лямбды. У нас есть лямбды, и они лучше, чем в Java 8, потому что у нас есть на уровне языка поддержка инлайнинга. Смысл в том, что когда вы используете лямбду просто для того, чтобы пройтись по циклу какой-то очень простой функции – например, найти все элементы, которые больше, чем 8. Наивный способ это транслировать – сгенерировать inner class с одним методом, который проверяет, что число больше, чем 8. Потом у вас есть функция filter, которая, собственно, получает экземпляр этого класса и применяет его к каждому элементу коллекции, и есть код, из которого это все вызывается.\n\nВ Java все примерно так и работает. Там используется invokedynamic и method handle. Поэтому там часть этого генерируется во время исполнения. Как мы [узнали](https://vimeo.com/131394615) на конференции Geekout, Java на данный момент не умеет это все инлайнить. А у нас есть поддержка на уровне языка. Мы просто говорим, что функция Filter помещается в инлайн. Это означает, что этот код, который внутри самой лямбды, и само тело функции записываются прямо в место, где мы вызываем. Соответственно, получается, что у нас нет никакого оверхеда по перформансу. У нас нет создания отдельных объектов. У нас нет каких-то виртуальных вызовов, не дай бог, еще мегаморфных. Наш код делает ровно то же, что происходило бы, если бы вы написали все руками без использования лямбды.\n\n— **Я так понимаю, что именно invokedynamic является какой-то помехой для инлайна?**\n\nНет, я бы не сказал, что именно в invokedynamic'е дело, но инлайнинг так работает, что он не умеет понимать, что сквозь лямбду и функцию, через которую она передается, можно это все заинлайнить. Возможно, когда-нибудь этот недостаток в JVM будет устранен. Насколько я понимаю, над этим ведется работа, но в Kotlin'е на уровне языка это решено.\n\n— **Понятно. А сам Kotlin когда появился? Как вообще идея такая пришла в голову?**\n\nНачинали мы, насколько я помню, примерно в конце 2010 года. Я не буду говорить, что это прямо я все придумал. В какой-то момент я пришел к Сергею Дмитриеву (одному из основателей JetBrains — прим. автора) и сказал, что было бы клево, если бы в JetBrains появился свой язык. Для меня это выглядело как естественное развитие. Наш слоган, —«Develop with pleasure», по-русски — «Разрабатывай с удовольствием». Мы довольно много делаем в области инструментов, чтобы люди действительно разрабатывали с удовольствием: рефакторинг, комплишен, подсветка ошибок – все, что мы очень хорошо умеем делать для 25 разных языков. Все равно мы видим, что IDE приходится делать затычки для недостатков языка.\n\nНапример, IDEA умеет анонимный класс показывать в виде лямбд. Если вы используете Java 6 или Java 7, вы пишете анонимные классы: new Instance, декларация метода, тело. В IDEA все это сворачивается в лямбду. Это в чистом виде затычка для недостатка языка. Мы решили, что мы можем попробовать просто сделать язык, в котором затычки будут не нужны, на котором будет просто приятно писать.\n\nIDEA, конечно, все равно полезна и помогает, но она не является каким-то костылем. Было ощущение, что мы это сможем сделать, потому что у нас достаточно накоплен релевантный опыт с разработкой IDE-плагинов и поддержкой языков. Было ощущение, что у нас достаточно веса на рынке, чтобы народ это заинтересовало. Было ощущение, что это нам нужно самим, потому что мы так все там написали в поддержку того, сего, пятого, десятого, а сами программируем на Java.\n\nВся IDEA до сих пор написана на Java 6. Мы начали использовать Kotlin, но все остальное написано на Java 6. Было ощущение, что это то, что может выстрелить. Понятно было, что это история долгая, но наверное, я недооценивал, насколько она долгая.\nДальше это заронило какое-то зерно, там тоже это обсуждалось с разными другими людьми в разных других контекстах и так далее. Потом нам очень повезло познакомиться с Андреем Бреславом, и мы, собственно, начали делать сам язык. Я на начальном этапе тоже приложил руку — писал первую версию генератора байт-кода для JVM. Потом этим занимались другие люди, а я переключился на другие проекты. Я довольно долгое время Kotlin'ом не занимался и сейчас я вернулся именно в Kotlin.\nА еще я название придумал. В какой-то момент пришел Дмитриев и сказал, что нужно название прямо сейчас. Типа, придумай название – и стоит над душой!\n\n— **Нравится название?**\n\nПоначалу мы немного смущались, потому что у нас немецкий офис есть, а в немецком языке словом Kot обозначают нечто не очень благозвучное. Но на самом деле ни немцы, ни кто-то другой – не слышали этого. Так что вначале это было как временное название, коднейм, «Project Kotlin». Мы лишь потом поняли, что нам никакое другое название не нужно, нам и так неплохо.\n\n— **Буквально недавно анонсировалось, что вы со [Светой Исаковой](https://www.youtube.com/watch?v=-BvN0X5tqjw) будете писать книжку про Kotlin. Расскажи, пожалуйста, что за книжка, кто был инициатором этого проекта, и как вообще весь процесс написания технической книги про язык устроен?**\n\nМы хотим сделать книжку про Kotlin именно для Java-разработчиков. Kotlin, конечно, не ограничен одной только Java: в нем есть поддержка компиляции в JavaScript, но на данный момент мы просто не готовы говорить про это, потому что у нас там много чего не доделано и будет доделываться, скорее всего, после релиза 1.0. Сейчас мы сосредоточены на поддержке компиляции под JVM: cерверная разработка, веб-разработка, компиляция под Android. Android на самом деле — сейчас очень горячее направление для нас.\nСоответственно, книжка будет для людей, которые уже умеют программировать на Javа, которые знают про Generics и про JVM. Наличие такой книги позволит им легко переключиться на Kotlin. Книга расскажет, как именно при помощи Kotlin'а решить их задачи, и в частности, как интегрировать Kotlin в существующий Java-проект.\n\nВажное свойство Kotlin'а заключается в том, что вам не нужно ничего выкидывать или менять — вы просто берете один класс и переписываете на Kotlin'е. Он становится в полтора раза меньше, в два раза красивее. Потом вы повторяете процедуру, в общем-то, с любым кодом, который вам зачем-то нужно менять. Код, который вы написали на Java и не трогаете, может оставаться на Java: он никому не мешает, никому не вредит. Зачем лишний шум вносить? А код, который вы активно модифицируете, вы просто по мере модификации переписываете на Kotlin. Мы, собственно, в IDEA планируем ровно таким путем пойти.\n\nТеперь насчет того, как появилась книжка. Хорошо известно, что книжка — это очень полезная штука для популярности языка. Про Scala есть книжка, которую тоже очень многие читали и хвалили, и популярность Ruby on Rails началась с книжки. Поэтому в какой-то момент я понял, что заняться написанием книги было бы самой значимой штукой, которую я мог бы сделать. Я поговорил с коллегами, и они одобрили эту идею. Света Исакова, инженер Kotlin’а, сказала, что ей тоже было бы интересно этим заниматься.\nМы почитали, как устроен процесс написания книги про язык программирования. Нужно иметь Table of Contents (оглавление) и иметь первую главу. С этим можно идти в издательство. Мы накидали какое-то оглавление и начали собираться писать первую главу. В этот момент параллельно пришло письмо от издательства Manning, довольно абстрактное, мол, давайте поговорим про Kotlin. Не то, что они прямо звали нас писать книжку. Мы сказали им, что мы собираемся писать книжку, и что если им интересно, то мол, давайте приступать. Они ответили, что им интересно. Так мы и начали работу.\n\n— **Как будет называться книжка?**\n\n«Kotlin in Action». In Action – это название серии их книг.\n\n![](https://habrastorage.org/files/7d8/46b/e36/7d846be36989482a9d078dd573c64c9f.jpg)\n\n— **А как Manning вас заметил в плане Kotlin'а? Они как-то мониторят информационное пространство?**\n\nДа, есть такие люди, называются acquisition editors, обязанность которых заключается в том, чтобы выискивать темы, про которые было бы интересно издать книжку, и выискивают людей, которые могут такую книжку написать. Они на нас вышли, и мы с ними договорились. Тут взаимный интерес.\n\n— **Тогда немного странный вопрос. Обычно, когда автор пишет книжку, ему за это платят гонорар. Тут вы пишете книгу про продукт, который разрабатывается не только вами, но вашей компанией. Как этот вопрос вообще решается? Какие есть подходы к этому?**\n\nМы просто пишем книжку, нам платят гонорар. У нас будет гонорар, у нас прописано в контракте – обычные совершенно условия royalty.\n\n— **А JetBrains просто выделяет вам со Светой бюджет времени на это?**\n\nДа. Дело в том, что у нас нет какого-то жесткого регламента, мол, можно вот этим заниматься Х часов в неделю. Книжка – это не единственное, чем я сейчас занимаюсь. Возможно, я об этом еще пожалею, но сейчас я книжку сочетаю с какой-то еще работой.\n\n— **Есть люди типа Венката Субраманиама, для которых написание книг и тренинги – это вообще основное направление деятельности.**\n\nЯ все-таки программист, я не могу не программировать.\n\n— **Понятно. У вас в какой-то момент это было вообще частью культуры**\n\nДо сих пор так, все программируют, оба CEO программируют.\n\n— **Интересно, что язык Kotlin в том виде, в котором он будет зарелизен, это не все, о чем думают люди, которые его разрабатывают. Есть такое ощущение, что вы еще думаете на несколько лет вперед. Почему это ощущение возникло? Я услышал в одном из выступлений Ильи Рыженкова о процедуре Language Design Review. Он тогда объяснил, что это делается для того, чтобы вы примерно понимали, какие проблемы в будущем у вас могут возникнуть. Не мог бы ты поподробнее про этот момент рассказать?**\n\nУ нас есть в голове какое-то количество направлений, куда может развиваться язык. Понятно, за 5 лет у нас накопилось какое-то количество мыслей. Мы понимаем, что это и это хорошо было бы сделать. Мы примерно знаем, если мы это будем делать, в каком месте нам нужно будет менять язык. Соответственно, мы сейчас хотим зафиксировать синтаксис в таком состоянии, чтобы те направления изменений, которые мы планируем, не требовали от нас сломать обратную совместимость с кодом.\n\nЭто для компании JetBrains, на самом деле, совершенно новая тема. Те, кто занимался разработкой плагинов IntelliJ IDEA, с проблемой ломающегося API сталкивались постоянно. В Kotlin’е мы хотим избежать этих проблем. Более того, мы знаем, что ничего не получится, если у нас будет совместимость Kotlin'а на том же уровне, на котором существует совместимость плагинов в IDEA. Мы берем на себя commitment, что если вы напишете код для версии Kotlin'а 0.1, то следующая версия Kotlin'а 1.Х, а может быть, и 2.Х, если что-то такое когда-нибудь будет, будут продолжать этот код компилировать.\n\nНасколько у нас получится, насколько мы сейчас подстилаем соломку в правильных местах, неизвестно. Жизнь покажет. Может быть, нам придется идти на какие-то корявые компромиссы, чтобы сделать какие-то вещи, которых у нас сейчас в голове вообще нет. По крайней мере, те вещи, которые мы хотим менять в будущем, мы стараемся зафиксировать в таком состоянии, чтобы у нас была возможность для развития.\n\n— **Ты можешь какой-то пример привести? Или это трудно?**\n\nНу, например, мы думаем про то, чтобы сделать литералы для коллекций. И хотим в литералах для коллекций иметь возможность использовать символ двоеточия.\n\n— **А что такое литералы для коллекций?**\n\nЧтобы как в Python могли написать что-то в квадратных скобочках, просто. Не `new ArrayList` от параметров, а просто написать в квадратных скобочках что-то, и это был бы там `new ArrayList`. И, соответственно, мы резервируем символ двоеточия, например, чтобы его можно было в какой-то роли использовать.\n\n— **То есть, свободный символ, это как раз пример такого зазора на будущее?**\n\nДа, мы просто оставляем возможность для развития синтаксиса. И на самом деле, еще более насущно – мы просто понимаем, что мы вот сейчас в релизе 1.0 какие-то элементы оставим не в идеальном состоянии. Потому что мы не можем делать релиз вечно, нам нужно в этом году его выпустить. Соответственно, мы находим такой вариант функциональности, такое состояние, которое можно будет расширять, не ломая совместимость.\n\n— **Правильно ли я услышал, что релиз будет в этом году?**\n\nОчень хочется. У нас сейчас есть список задач, которые нужно до релиза делать. И мы пытаемся спланировать, сколько это все займет точно времени, чтобы точно понять, успеем ли мы до конца года зарелизить.\n\n— **Интересная очень история, ты затронул – это история API для плагинов. В свое время очень долго команда NetBeans билась с этой проблемой, и решили они следующим образом: они взяли специальный фреймворк, кажется SigTest, и просто зафиксировали сигнатуры своих методов, API-шных, и ввели некие правила, по которым API может меняться. То есть, условно говоря, добавить метод можно, а удалить нельзя. И какие-то другие простые вещи. А как это делали вы?**\n\nМы очень долгое время ее не решали никак, и не могли решать. На сегодняшний день в IDEA нет Plugin API как отдельной сущности, нет фасада, который представляет некие функции, которыми вы пользуетесь. В очень многих местах у людей есть доступ непосредственно к внутренностям IDEA. То есть, плагинописатель может работать напрямую с теми классами, которые какую-то функциональность реализуют. И поэтому нам очень сложно иметь совместимость, потому что она будет сильно ограничивать развитие продукта.\n\nРазвитие кода за 15 лет было довольно феноменальное. Вначале это была монолитная Java IDE, у которой не было вообще никакого API. То есть когда делался релиз 1.0 мы поняли, что сделать API для плагинов – это два лишних месяца работы, а денег тогда было очень ограниченное количество. Надо было выпускать продукт, и получать деньги от продаж. Потом в версии 3.0 появился какой-то Plugin API, потом он постоянно расширялся. Потом появилась поддержка не только Java, но и других языков. В версии 5.0 появился JavaScript в частности. В итоге получилось сделать IDE, в которой про Java нет ничего.\nВ PyCharm нет ничего про Java внутри. Это стоило заметного количества усилий. Потом у нас появились компилятор Kotlin и Upsource. Код, который был распилен по одной оси, чтобы отделить Java от не Java, нужно было теперь распилить по другой оси, чтобы отделить UI от не-UI. В Kotlin’овском компиляторе нет никакого редактора. Там компилятор. Там есть файловая система, есть PSI, то есть, модель для работы с кодом. Есть еще несколько таких абстракций. Но там нет ничего визуального.\n\nСоответственно, это была отдельная большая работа – сделать так, чтобы можно было сложить в такую кучку классы и платформы, чтобы они этим свойствам удовлетворяли. Не было никаких шансов сохранить совместимость API в процессе всех этих трансформаций.\n\n— **Для этого все используют механизм версионности. Вы можете сказать, что внутри Major-версии у вас API фиксированный. От Major к Major менять API и сопровождать изменения гайдлайнами или туториалами.**\n\nЭто мы старались делать. Все большие пертурбации обычно происходили между major-релизами. Мы старались писать migration guides, когда у нас были большие пертурбации, правда, нам это не всегда удавалось. Конкретно сейчас стало заметно лучше, потому что сейчас вроде как все большие пертурбации завершены. У нас просто есть build-конфигурация на TeamCity, которая для каждого build'a IDEA берет все плагины из плагин-репозитория, и проверяет, что ни один из них не отвалился. — **Статические сигнатурные проверки?**\n\nДа. Просто проверка, что там не будет NoSuchMethodError или еще чего-то в этом духе.\n\n— **А идеи выносить все это в какой-то публичный API?**\n\nТам есть какой-то API.\n\n— **Там есть разделение насчет того, что вот это можно использовать, а вот это лучше нельзя?**\n\nНет, и я не очень верю, что оно когда-либо появится.\n\n#### Год без JetBrains\n\n— **Года два назад ты на какое-то время JetBrains покинул. Можешь ли ты про это немножко рассказать?**\n\nЯ уходил из JetBrains в Google. На тот момент я провел уже 10 лет в JetBrains. Хотелось чему-то новому научиться.\n\n— **Чем ты занимался в тот момент, когда уходил?**\n\nНа тот момент я формально был CTO, но выполнять эту роль уже не очень получалось. Я скорее был тимлидом PyCharm и WebStorm. Это были две основные задачи, которыми я тогда занимался. И, кажется, это был довольно хороший момент, чтобы уйти, потому что какой-то большой следующей задачи, в которой мне надо было бы обязательно участвовать, не было. Было кому передать мои проекты.\n\nЯ хотел попробовать чего-то нового. И я был готов и к такому варианту, что я вернусь в JetBrains, и к тому варианту, что я останусь в Google. Я заранее обговаривал возможность вернуться, и мне сказали: Да, будем рады тебя видеть. В итоге, так и получилось.\n\n— **Если не секрет, чем ты занимался в Google? В какой области ты работал?**\n\nЯ делал инструменты для разработки под Google Cloud Platform. Например, есть такая штука — Сloud Debugger: вы можете на своем production-приложении, на App engine, на compute engine ставить какие-то точки. Но это не точки останова, это точки снятия информации. Прямо в source code в этом месте у вас собирается call stack, собираются значения всех локальных переменных. И вам это все отсылается, и при этом не останавливается процесс. То есть это реально происходит в production’е. Вы там можете ставить условные breakpoint’ы. Наконец, это довольно эффективно по производительности, то есть, не приводит к какому-то заметному замедлению. Мы занимались фронтендом: возможностью в браузере смотреть call stack, значения переменных, source code\n\n— **В итоге тебе там не понравилось? Или какие-то обстоятельства были, вынудившие тебя?**\n\nНет, меня ничего не вынуждало. В Google довольно важно найти свое правильное место. Google – компания большая, компания очень разная. У них есть слоган «do cool things that matter», то есть, «занимайся клевыми штуками, которые имеют значение». Но это верно совсем не для всех сотрудников компании Google. То есть, есть сотрудники, которые занимаются очень клевыми штуками, которые очень имеют большое значение, но есть сотрудники, которые занимаются просто разной работой, которая должна быть сделана.\n\n— **Современный Google — это более 50 тысяч человек. А сколько там девелоперов?**\n\nТысяч 25-30.\n\n— **Вокруг Google существует огромное количество мифов, вплоть до таких, что некоторые сотрудники жалуются, что не могут работать, потому что справа и слева от их рабочего места находятся на одинаковом расстоянии находятся два бассейна, и они мучаются от того, что не знают, какой выбрать. Насколько это соответствует действительности?**\n\nНа самом деле, не соответствует. То есть как сказать? В Google можно довольно долго искать себя. А заниматься этим можно с очень разной степенью продуктивности.\n\n— **Ты решил пойти по другому пути, ты решил не искать. Ты решил вернуться.**\n\nЕсли бы я был готов еще 3-4 года потратить на такие поиски, съездить в Mountain View на годик, попробовать разные команды, близко познакомиться с большим количеством разных людей, то у меня было бы все хорошо в Google через какое-то время. Но я просто понял, что сейчас, сегодня, есть Kotlin, с которого меня очень прет, и в который я могу прийти и начать делать, я очень хочу, чтобы у JetBrains с ним все получилось. И не надо ничего искать.\n\nТам, опять же, это одни из самых сильных людей в JetBrains, с которыми я работал — Андрей Бреслав, Илья Рыженков и многие другие ребята в команде. Лучше я в JetBrains, чем в Google буду куда-то тыкаться. На самом деле, я очень рад, что сходил в Google, это был ценный опыт, я получил желаемую смену обстановки. И очень рад, что вернулся.\n\n— **Ты затронул тему команды Kotlin. Она формировалась где-то в 2011ом году. Ребята, которые нанимались в тот период (я просто знаю довольно много людей из этой команды), фактически были на тот момент вчерашними выпускниками ВУЗов. И тут получается некоторый казус. С одной стороны, вы на всех углах тогда трубили, что мол, JetBrains накопила большой опыт по написанию компиляторов и поддержке языков, и поэтому сейчас будете делать свой язык. А с другой стороны, вы наняли на это вчерашних студентов в большом количестве, у которых очевидно такого опыта нет. Как так? Как этот факт вообще повлиял на разработку?**\n\nЯ думаю, что повлиял. Например, команде пришлось потратить какое-то время, прежде, чем performance плагина стал таким, чтобы можно с ним было нормально работать. С другой стороны, что какие-то из старожилов всегда участвовали в разработке. Например, Максим Шафиров участвовал и на самой ранней стадии. Да и сейчас он пользуется Kotlin, приходит на дизайн-митинги, дает feedback по поводу развития языка. А в целом, команда сейчас довольно молодая. То есть там есть несколько старожилов, например, Валя Кипятков, я, Илья Рыженков. И в принципе этого достаточно, как мне кажется, чтобы передавать опыт.\n\n— **Были ли в этапе в жизненном в развитии Kotlin какие-то большие ошибки? То есть было ли такое, что вас куда-нибудь уносило не в ту сторону надолго? Или в принципе такого не было?**\n\nБыло. Я не буду говорить, что это ошибка, это скорее, поиски пути, которые заняли время. Одним из ключевых пунктов в дизайне языка было то, что мы хотим решить проблему nullability, чтобы мы всегда знали, где у нас значения могут быть null, а где они не могут.\n\n— **[The billion dollar mistake.](https://en.wikipedia.org/wiki/Tony_Hoare#Apologies_and_retractions)**\n\nДа-да, она самая. Мы живем на платформе Java, и в Java этих средств нет. Соответственно, нам нужно уметь работать с кодом на Java, в котором этой информации нет. Соответственно, для того, чтобы эту информацию для Java-класса получить, нам нужно что-то изобрести.\n\nИзначально у нас была модель фиксированной аннотации: есть класс, и где-то рядышком для него лежит файлик, который откуда-то взялся, в котором в xml про каждый метод написано, что это метод, у которого два параметра: первый – not nullable, второй – nullable, и возвращаем значение nullable. Мы написали такой файлик для JDK и решили, что какие-то другие люди напишут такие файлики для известных библиотек. А если у вас свой проект, то вы можете для своего кода просто прямо в коде писать аннотации, обычные Java. Это не взлетело.\n\nПотом мы придумали KAnnotator – решение, которое сканирует байткод и делает анализ. Например, если где-то передается параметр, который сразу же дереференсится, значит, он not nullable. И возвращаемые значение тоже трекаются. Соответственно, KAnnotator — это внешний инструмент, который генерирует вот эти же файлики с фиксированными аннотациями. Фактически, это глобальный data flow анализ в программе. Это оказалось штукой прикольной, но тоже не очень практичной. Потому что исходный код распадается на две независимых части — сам код и вот эти аннотации, которые могут потеряться или могут разъехаться по версиям. И мы в итоге признали, что это тоже не работает.\n\nИ теперь у нас более простое решение — платформенные типы. Это отдельные сущности, типы, для которых у нас нет nullability информации. Они пришли из Java. Когда человек имплементирует метод Java-интерфейса, он может у типов параметров написать любое nullability. То есть он сам знает, какая nullability правильная, и либо пишет вопросик, либо не пишет вопросик. И то, и другое компилятор разрешает. И ведет себя в соответствии с тем, что написал пользователь. Но при этом никакого отдельного файла, никакого осложнения workflow нет. Если хочется, в Java-коде можно написать аннотации Nullable и NotNullable — мы их по-прежнему понимаем.\n\nВся эта история с KAnnotator'ом отняла у нас довольно много сил и времени. Но с другой стороны, мы не знали, что это неработающий вариант, когда начинали.\n\n— **Не каждый же день пишешь новый язык программирования. Я вот не уверен, что если бы команда была существенно более опытная, вас бы это спасло от всех ошибок.**\n\nМожет быть.\n\n— **Если я правильно понял, вы теперь даете пользователям самим решать, где выстраивать периметр вот этой null-защиты?**\n\nПериметр – это граница между Java и Kotlin кодом. То есть мы все равно генерим assertion, если там нет вопросиков. Просто конфигурация этого периметра задается пользователем самостоятельно.\n\n— **То есть он сам может выбрать, где на стэке вызовов он будет это проверять?**\n\nЭто проверятся всегда на уровне перехода между Java и Kotlin.\n\n— **Окей. Тогда, может быть, чуть-чуть возвращаясь к Google. Когда ты туда уходил, ты, наверное, ожидал чего-то. И насколько это совпало с тем, что ты реально увидел?**\n\nДа, у меня были разного рода ожидания, и не все из них оправдались. Например, наивное ожидание, что у меня будет менеджер, которые меня будет «менеджерить», будет заботиться о моем развитии и совершенствовании. Нет.\n\n— **Но ведь в JetBrains, я так понимаю, тоже такого не было?**\n\nВ JetBrains такого не было, и мне как раз хотелось посмотреть, как это.\n\n— **Если не секрет, в JetBrains в каком возрасте попал примерно?**\n\nМне было 22, получается. Я работал до этого разных компаниях, я очень рано начал работать. Фактически, первая работа, за которую мне какие-то денежки платили – мне было лет 17.\n\n— **Это было программирование?**\n\nДа, программирование. А первая работа, за которую мне вообще платили деньги — переводы. Мне вообще 13 тогда было. Поэтому у меня какой-то опыт уже был на тот момент. У меня был успешный OpenSource-проект, например.\n\nВозвращаясь к Google. Google делает обалденно фантастические вещи. Ты заходишь на их сайт, печатаешь, он тебе в реальном времени показывает результаты поиска того, что ты тут 100 миллисекунд назад печатал. Ты нажал клавишу, и через 100 миллисекунд ты видишь результаты поиска фразы с этой клавишей, с этой буковкой по всему мировому интернету. Это же реально очень круто.\n\nИ глядя на Google, ты думаешь, что вот, я туда приду, и там просто что-то совершенно волшебное, благодаря чему это все так работает, и на чем это все держится. Оказывается, нет. Оказывается, секретного ингредиента не существует. Рецепт, как я сформулировал для себя (наверное, это главное, что я вынес из Google) — это рецепт, как делать, чтобы так получалось.\n\nВо-первых, очень важное значение имеет хорошая storage-система. С репликацией, с масштабированием. То есть система хранения данных — это действительно то, на чем все держится. Не зря сейчас появляются десятки стартапов, которые пишут свои NoSQL-хранилища.\n\n— **Правильно ли я понимаю, что это ноу-хау Google? И что это, за счет чего компания вообще является технологическим лидером?**\n\nТрудно сказать. На самом деле Google довольно много всего рассказывает. И про BigTable, на котором до сих пор дофига всего написано. Есть статья, в которой написано, как он работает. Потом новая система Spanner, на которую сейчас довольно много сервисов мигрирует внутри Google, которая делает вообще волшебные вещи — прозрачную репликацию между континентами. Про нее тоже статья есть о том, как она работает.\n\nТо есть большого секрета, как такового, нет, и слово «ноу-хау» не очень применимо. То, что написано в статье дальше это нужно правильно, хорошо, грамотно реализовать. А вот это дано не всем. Соответственно, если у вас хороший data storage, то вам можно и нужно запускать много копий вашего приложения. Если ты все что угодно запускаешь в Google, то по умолчанию ты запускаешь три экземпляра. Соответственно, по сравнению с этим, мне очень грустно смотреть на TeamCity, Youtrack, которые все такие монолитные, все, у Youtrack вообще встроенная база данных.\n\n— **[Xodus](https://github.com/JetBrains/xodus).**\n\nXodus, да. Репликации нету, масштабирования нету... То есть понятно, что такое решение на каком-то этапе упрощает жизнь. Но я говорю, что мне на это смотреть грустно. Потому что понятно, что Youtrack не будет работать также хорошо, как Google поиск.\n\n— **Вадим Гуров (бывший менеджер Youtrack — прим. автора) рассказывал, что как-то раз на одной из конференций они спросили ребят из Atlassian, сколько людей у них занимается поддержкой SaaS-версии JIRA. Оказалось, что 30 человек. А в Youtrack поддержкой SaaS-версии занимается всего один разработчик.**\n\nЭто история про understaffed, которую я упоминал. Может быть, с какой-то точки зрения она не настолько разрешилась, как мне кажется.\n\nCледующий ингредиент Google — это не стесняться использовать ресурсы. Оперативная память вообще не очень дорого стоит. Можно загрузить все данные в память, то есть, иметь столько оперативной памяти, чтобы, например, загрузить в нее всю базу данных боевого Youtrack, без attachment-ов. Можно поставить сервер, или несколько серверов, в которых будет столько оперативки, скольконужно. Потом сделать шардинг, репликацию, по науке. Следующий ингредиент, обязательный — это мониторинг производительности. То есть нужно обязательно всегда следить за тем, как это все работает. 95 перцентиль lanency, median latency — нужно за всем этим следить. И нужно просто постоянно работать над улучшением всего, что у вас есть. И, в конце концов, если это все сделать, то получается Google Search.\n\n— **Иными словами, это не какая-то магия и волшебство, а просто отлаженный процесс. Этот процесс работает только в каких-то топовых продуктах типа поиска? Или эта культура распространяется по всей компании, по всем продуктам?**\n\nПо-разному. Всем рассказывают, как правильно. Даже не столько рассказывают, сколько показывают примеры. Но, например, настройка мониторинга, о которой я говорил, это довольно большая, сложная задача. Которая, причем, ни в какой момент не заканчивается. То есть мониторинг, alerting, что-то еще в этом духе — непрерывно подкручивается. Вот этот alert слишком шумный, он разбудил ночью программиста, чтобы он бежал чинить, а чинить ничего не надо. Было там, на самом деле, все хорошо, просто alert сработал не по тому условию. И есть проекты, которым помогают SRE (Site Reliability Engineers), это роль такая в Google, многие про это знают, много где рассказывали. Это одна из основных вещей, которыми они занимаются. Весь мониторинг, alerting, распределение ресурсов, правильное распределение по кластерам.\n\nИ если у вас SRE есть, то у вас все хорошо. Но есть много мелких сервисов, у которых просто SRE нету. То есть программисты сами занимаются поддержкой. И на самом деле, это занимает страшное количество времени и сил — поддержание сервисов в работающем состоянии. Что у сервиса всего хватает, что он не падает, что у него не кончилась storage quota, у него нормальный response time по всем запросам, которые к нему, что его никто не DoS-ит и так далее.\n\n— **Из последнего, что было больно – это закрытие Google Сode. Что-то знаешь про это?**\n\nЯ собственно даже пытался спасти Google Code. История простая: Google Code просто был сделан на довольно старом, не поддерживаемом наборе фреймворков, как очень часто бывает в Google. Это проблема, которая автоматически случается, когда у вас в компании 20 000 программистов. Программисты – они программируют. Они любят делать всякие фреймворки, технологии, middleware какой-то. И потом на этом middleware строят продукты. А потом с этим middleware становится неинтересно, или люди, которые его делали, уходят и приходят другие люди и так далее. И появляется какое-то новое middleware, на котором теперь все полагается писать.\n\nGoogle Code — продукт, написанный на довольно старом наборе технологий, который довольно долго и дорого переводить в состояние, чтобы его можно было нормально поддерживать и нормально сопровождать. И плюс к тому, это как сервис, который позволяет хостить всякие штуки в интернете, он всегда был большой мишенью для abuse разного рода. Раз туда можно залить файлики, давайте туда зальем порнушку, или, например, крякнутое какое-нибудь android-приложение, или еще что-то такое. И народ тратил много сил на то, чтобы с этим бороться. Там в какой-то момент функциональность download просто исчезла. Но были там другие способы abuse...\n\nИ вот это просто все тянулось, и было ощущение, что это, на самом деле, не нужно. Потому что GitHub победил, и все равно все, все равно жизнь вся там, и у Google на тот момент была куча своих проектов на GitHub. И поэтому решили Google Code закрыть.\n\n— **Ты говоришь, что как-то пытался его реанимировать?**\n\nЯ решил, что нельзя же так, это же плохо и грустно. И решил поговорить с соответствующими людьми. Вроде я придумал, что можно сделать. Потом пришел к людям, но оказалось, что они про все это уже подумали, придумали, у них есть документ на 15 страниц, в котором написано почему это не сработает, и... «спасибо за ваш фидбек, но мы и сами все знаем». Если ты думаешь, что самый умный, то в Google это гарантировано не так. Если ты хочешь что-то предложить — с вероятностью 75% другие люди уже про это подумали. И либо поставили в план и собираются сделать, либо знают почему это не сработает, либо знают почему это не соответствует каким-то целям и так далее.\n\n— **Это эффект большой компании или чего-еще?**\n\nВ Google все-таки хорошие люди, сильные работают. Это эффект гуглового рекрутинга.\n\n#### ЖЖ и хабр\n\n— **Пара вопросов, которые лично меня интересуют. ЖЖ-сообщество ru_java, ты участвовал в этом комьюнити. Сейчас пациент скорее мертв. Как ты думаешь, как так вышло? То есть эволюция того, то есть тот дискуcс, он куда-то сместился, отпала вообще необходимость в таких дискуссиях?** Я не то, чтобы там что-то активно делал, насколько я помню. Но я там отвечал на какие-то вопросы об IDEA. Сам ЖЖ — довольно странная платформа. А сейчас все перешло на хабр, как мне кажется.\n\n— **Я ждал от тебя такого ответа. На хабре [твой последний пост](http://habrahabr.ru/post/134544/) датирован 2011 годом, а твой последний заход, внимание, залогиненый, на хабр, это конец 2013 года.**\n\nЭто странно, потому что мне приходит еженедельный newsletter с интересными материалами.\n\n— **Но, тем не менее, видимо ты 2 года уже не логинишься и не отвечаешь на комментарии, и так далее.**\n\nДа, я видимо не залогиненым читаю.\n\n— **Писать в ближайшее время не собираешься? Другие люди у вас уже этим занимаются?**\n\nПро хабр стоит сказать отдельно. Для PhpStorm, на его ранних стадиях, этот канал был крайне важен, как возможность для общения с пользователями. Мы постоянно рассказывали, что там появилось, что поменялось. Шла дискуссия, там всегда было много обсуждений, всегда разработчики отвечали. Мы с PyCharm тоже всегда активно участвовали в обсуждениях.\n\nНаверное, надо туда постить что-нибудь и про Kotlin. Просто у нас никто специально не занимается сейчас промоушеном в соцсетях, скажем так. Мы пишем, на англоязычных ресурсах что-то, на Reddit у нас появляются дискуссии. Есть [subreddit про Kotlin](https://www.reddit.com/r/Kotlin), еще что-то. А на русскоязычное сообщество нам, наверное, просто не сил не хватает. И опять-же, я сейчас пишу книжку. Поэтому вписываться в то, что сейчас писать еще что-то большое, другое, я не очень хочу.\n\n#### JUG и конференции\n\n— **И такой, еще личный. У нас на [новом сайте JUG.ru](http://jug.ru/), есть кавер-фотография, я не знаю, ты видел или нет. На ней ты. Что рассказывал на старом JUG?**\n\n[![](https://habrastorage.org/files/ea8/e53/a9e/ea8e53a9e1d54e1a8db6aaca95822e8b.jpg)](http://jug.ru/history)\n\nНа JUG я точно рассказывал про TeamCity, когда-то давно, еще в 2006, по-моему, году. И что-то я еще рассказывал, но сейчас не вспомню. Я знаком с Яшей Сироткиным довольно хорошо.\n\n— **Я хочу сейчас официально пригласить в твой, наверное, следующий уже, или через следующий твой приезд в Питер. Да, обязательно что-нибудь у нас на JUG рассказать. И может быть выступить на ближайшей какой-то конференции. Это официальное приглашение перед всеми зрителями и читателями.**\n\nДа, я с удовольствием расскажу.\n\n* * *\n\n_P.S.: И действительно расскажет:_\n\n**Дмитрий Жемеров на Joker 2015**\n\n**Опыт использования Kotlin в JetBrains**\n\n![jemerov](https://habrastorage.org/files/0f7/9ea/71f/0f79ea71f8974a39ae5266c4cc9b9da5.jpg)\nKotlin — новый язык программирования для JVM, Android и JavaScript, который с 2010 года разрабатывается компанией JetBrains. Язык ориентирован на написание элегантного, компактного и безопасного кода, свободно интегрируется с существующим Java-кодом и имеет мощную поддержку в IDE. В последнее время язык все более активно используется как внутри JetBrains, так и внешними разработчиками.\n\nВ докладе Дмитрий расскажет об использовании Kotlin в двух проектах JetBrains — в системе поддержки продаж и менеджмента лицензий (это Web-приложение, целиком сделанное на Kotlin) и в IntelliJ IDEA (здесь Kotlin интегрируется в большой существующий проект). Будут показаны различные фреймворки, которые появились в процессе разработки и которые могут пригодиться и вам. Так же Дмитрий расскажет о том, какие плюсы они получили от внедрения Kotlin и с какими трудностями встретились.\n\n* * *\n\nЭтот и другие доклады Joker 2015 — **[на сайте конференции](http://jokerconf.com/#talks)**.\n\n","author":"Алексей Фёдоров","date":"2015-07-31","type":"article","categories":["Kotlin"],"features":["highlightjs"],"description":"","filename":"","lang":"RU","enclosure":null},{"title":"Gradle Script Kotlin 0.8.0 Release Notes","url":"https://github.com/gradle/gradle-script-kotlin/releases/tag/v0.8.0","body":"\nGradle Script Kotlin v0.8.0 is a major step forward in usability, bringing a more consistent DSL, convenient and type-safe access to contributed project extensions and conventions, much better error reporting, bug fixes and, of course, the latest and greatest Kotlin release.\n\nv0.8.0 is expected to be included in the upcoming Gradle 3.5 RC1.\n\nThe features in this release are also available for immediate use within the latest Gradle Script Kotlin distribution snapshot. To use it, upgrade your Gradle wrapper in the following fashion:\n\n    $ cd $YOUR_PROJECT_ROOT\n    $ gradle wrapper --gradle-distribution-url https://repo.gradle.org/gradle/dist-snapshots/gradle-script-kotlin-3.5-20170305000422+0000-all.zip\n\n## Updates since v0.7.0\n\n * **Kotlin 1.1.0** ([#289](https://github.com/gradle/gradle-script-kotlin/issues/289)). Build scripts are now compiled against [Kotlin 1.1.0](https://blog.jetbrains.com/kotlin/2017/03/kotlin-1-1/)! This enables, among other things, [the use of coroutines in build scripts](https://github.com/gradle/gradle-script-kotlin/issues/292#issuecomment-284367696).\n\n * **Better error reporting** ([#177](https://github.com/gradle/gradle-script-kotlin/issues/177), [#170](https://github.com/gradle/gradle-script-kotlin/issues/170), [#254](https://github.com/gradle/gradle-script-kotlin/issues/254), [#290](https://github.com/gradle/gradle-script-kotlin/issues/290)). Gradle will now report the correct location for compilation errors occurring inside `buildscript` and `plugins` blocks, will do so in a format that's readily recognised by many tools - clicking a compilation error in a console window should open the configured text editor, for instance - and will only ever display stack traces when explicitly instructed via the `--stacktrace` argument.\n\n * **Consistent DSL across core and community plugins** ([#156](https://github.com/gradle/gradle-script-kotlin/issues/156), [#155](https://github.com/gradle/gradle-script-kotlin/issues/155), [#157](https://github.com/gradle/gradle-script-kotlin/issues/157), [#224](https://github.com/gradle/gradle-script-kotlin/issues/224)). The build script compiler will now treat [Gradle's `Action<T>`](https://docs.gradle.org/current/javadoc/org/gradle/api/Action.html) type as an alias to the `T.() -> Unit` type (a [function literal with receiver](https://kotlinlang.org/docs/reference/lambdas.html#function-literals-with-receiver) in Kotlin parlance) finally solving the [_dreaded `it` problem_](https://www.youtube.com/watch?v=vv4zh_oPBTw&feature=youtu.be&t=1387) once and for all. _WARNING: This is a breaking change and some scripts will fail to compile due to `it` no longer being defined inside lambda expressions passed as `Action<T>` parameters. Simply replace `it` by `this` or remove it altogether._\n\n * **Type-safe accessors for project extensions and conventions** ([#235](https://github.com/gradle/gradle-script-kotlin/issues/235), [#229](https://github.com/gradle/gradle-script-kotlin/issues/229), [#230](https://github.com/gradle/gradle-script-kotlin/issues/230)). This long awaited feature enables the replacement of type-heavy configuration code such as:\n\n   ```kotlin\n   configure<ApplicationPluginConvention> {\n       mainClassName = \"my.App\"\n   }\n   ```\n\n   by the terser and familiar looking:\n\n   ```kotlin\n   application {\n       mainClassName = \"my.App\"\n   }\n   ```\n\n   Given the inherent flexibility in Gradle's plugin system, it's not possible to cover all the different plugin application scenarios with a single, one-size-fits-all solution so type-safe accessors can be used in three different modes: _just-in-time_, _ahead-of-time_ and _ad hoc_.\n\n   *TL;DR*: Opt-in to type-safe accessors by setting the `org.gradle.script.lang.kotlin.accessors.auto` project property to `\"true\"` and hack on, if you get _Unresolved reference_ compilation errors, read on.\n\n    * **just-in-time** In just-in-time mode, accessors are generated immediatelly after the evaluation of the `plugins` block, just before the evaluation of the build script body and, because of that, accessors for extensions and conventions registered later in the process are not available. In summary, the following example works in just-in-time mode:\n\n        ```kotlin\n        plugins {\n            application\n        }\n\n        // type-safe accessor for `application` convention generated as:\n        //\n        //   `fun application(configuration: ApplicationPluginConvention.() -> Unit): ApplicationPluginConvention`\n        //\n\n        application {\n            mainClassName = \"my.App\"\n        }\n        ```\n\n        But the following one does not:\n\n        ```kotlin\n        apply {\n            plugin(\"application\")\n        }\n\n        application { // \uD83D\uDCA3 Unresolved reference\n            mainClassName = \"my.App\"\n        }\n        ```\n        Due to the potential for build script compilation failures resulting from unaccessible extension types or illegal extension names, just-in-time accessors must be explicitly enabled via the `org.gradle.script.lang.kotlin.accessors.auto` project property set to `\"true\"`, check out the [gradle.properties file from the hello-world sample](https://github.com/gradle/gradle-script-kotlin/blob/e75d7d99734c5c6fbe67f9b2f7128a8e037f2fbd/samples/hello-world/gradle.properties) for an example.\n\n    * **ahead-of-time** In ahead-of-time mode, type-safe accessors must be explicitly requested via the `gskGenerateAccessors` task. The upside is that all extensions and conventions available at task execution time will be taken into account. The downside is that for the task to even execute, the build script must compile cleanly, which implies we must edit the build script in two steps: step one, apply desired plugins and run `gskGenerateAccessors`, step two, proceed to configure the available extensions and conventions. Additionally, the `buildSrc` file created by `gskGenerateAccessors` must be added to our VCS.\n\n      * Step 1:\n        ```kotlin\n        // build.gradle.kts\n        apply {\n            plugin(\"application\")\n        }\n        ```\n\n        Followed by:\n\n            $ ./gradlew gskGenerateAccessors\n            :gskGenerateAccessors\n\n            BUILD SUCCESSFUL\n\n            Total time: 1.867 secs\n\n\n      * Step 2:\n        ```kotlin\n        // build.gradle.kts\n        apply {\n            plugin(\"application\")\n        }\n\n        // type-safe accessor for `application` convention\n        application {\n            mainClassName = \"my.App\"\n        }\n        ```\n\n    * **ad-hoc** In this usage mode, the `gskProjectAccessors` task is executed whenever a new type-safe accessor is needed. `gskProjectAccessors` will then write the Kotlin code for all available type-safe accessors to stdout from where it can be copied into the build script or to a Kotlin file under `buildSrc`.\n\n * **Improved Gradle API**([#239](https://github.com/gradle/gradle-script-kotlin/issues/239), [#122](https://github.com/gradle/gradle-script-kotlin/issues/122), [#219](https://github.com/gradle/gradle-script-kotlin/issues/219), [#246](https://github.com/gradle/gradle-script-kotlin/issues/246), [#245](https://github.com/gradle/gradle-script-kotlin/issues/245), [#247](https://github.com/gradle/gradle-script-kotlin/issues/247), [#244](https://github.com/gradle/gradle-script-kotlin/issues/244), [#243](https://github.com/gradle/gradle-script-kotlin/issues/243), [#242](https://github.com/gradle/gradle-script-kotlin/issues/242), [#241](https://github.com/gradle/gradle-script-kotlin/issues/241), [#240](https://github.com/gradle/gradle-script-kotlin/issues/240), [#238](https://github.com/gradle/gradle-script-kotlin/issues/238), [#206](https://github.com/gradle/gradle-script-kotlin/issues/206), [#226](https://github.com/gradle/gradle-script-kotlin/issues/226)). Many methods in the Gradle API previously only available to Groovy have been overloaded with versions better suited to Kotlin.\n\n * **Improved Groovy interoperability**([#286](https://github.com/gradle/gradle-script-kotlin/issues/286)). Groovy closures can now be invoked using regular function invocation syntax.\n\n * **Sub-project build scripts inherit parent project compilation classpath** ([#190](https://github.com/gradle/gradle-script-kotlin/issues/190)).\n\n * **Projects can use `kotlin-gradle-plugin` 1.0.x again** ([#189](https://github.com/gradle/gradle-script-kotlin/issues/189)). Thanks to the upgrade to Kotlin 1.1.0, compatibility with Kotlin 1.0.x has been restored.\n\n * **Custom task actions will no longer interfere with the build cache** ([#263](https://github.com/gradle/gradle-script-kotlin/issues/263), [#171](https://github.com/gradle/gradle-script-kotlin/issues/171)).\n\n * **Build scripts can contain Windows line endings** ([#227](https://github.com/gradle/gradle-script-kotlin/issues/227), [#220](https://github.com/gradle/gradle-script-kotlin/issues/220)).\n","author":"Rodrigo B. de Oliveira","date":"2017-03-09","type":"article","categories":["Kotlin","Gradle Script Kotlin"],"features":["highlightjs"],"description":"","filename":"","lang":"EN","enclosure":null},{"title":"Revisiting Types In Kotlin","url":"https://www.youtube.com/watch?v=zBs8Jptdb-g","body":"\nWith A Domain Driven Approach, This Talk Will Go Through Several Coding Examples And How They Can Be Improved By Leveraging The Powerful Type System In Kotlin With Function Objects, Sealed Classes, Tuples, And The Core Collections. We'll Review The Way Your Application Communicates Across Layers, And How You Can Improve Your Apis With Explicit Types.\n\n<iframe width=\"960\" height=\"480\" src=\"https://www.youtube.com/embed/zBs8Jptdb-g\" frameborder=\"0\" allowfullscreen></iframe>\n\n","author":"Francisco Estevez","date":"2016-12-17","type":"video","categories":["Kotlin"],"features":["highlightjs"],"description":"","filename":"","lang":"EN","enclosure":null},{"title":"JVM Newcomer Kotlin 1.0 is GA","url":"https://www.voxxed.com/blog/2016/02/kotlin/","body":"\nAfter a long and winding road to development, pragmatic JVM and Android newcomer [Kotlin](http://blog.jetbrains.com/kotlin/2016/02/kotlin-1-0-released-pragmatic-language-for-jvm-and-android/) 1.0 is officially GA. The open source progeny of Java IDE supremo JetBrains (it was developed on [GitHub](https://github.com/JetBrains/kotlin) under the Apache 2.0 Open-Source license), Kotlin has been cooking since 2010, and as you’d expect, runs seamlessly on the company’s signature Java IDE, [IntelliJ](https://www.voxxed.com/blog/2015/09/partying-with-intellij-idea-dart-java-websocket-and-glassfish/) IDEA.\n\nA key characteristic of Kotlin is its end user focus, and a steadfast effort has been made in its development to ensure features lists are sharp and concise. It’s also lightweight and fully interoperable with the Java language, making it a natural fit for mobile development.\n\nAlthough originally intended to be a contemporary answer to the legacy issues Java brought in its wake, Kotlin could prove an excellent choice for Android developers in 2016 looking for a JVM alternative that reaches beyond the capabilities for version 6 of the platform. And thanks to the kotlin-android-extensions plugin in for the Kotlin compiler, developers can access views in a type-safe fashion without the need for extra user code or runtime libraries.\n\nMoreover, as Antonio Leiva [notes](https://www.voxxed.com/blog/2016/01/kotlin-android-developers/), Kotlin’s library is small enough to let developers work without proguard during development. Then there’s the not-inconsequential fact that Android Studio (the official Android IDE) was constructed on top of IntelliJ.\n\nAside from its aptitude for Android development, lead language designer [Andrey Breslav](http://blog.jetbrains.com/kotlin/author/andrey-breslav/) highlights that, because Kotlin can run wherever Java runs – be that server-side applications, mobile applications (Android), or desktop applications, it plays nicely with most of the leading Java ecosystem tools, including things like Maven, Gradle and Ant, GitHub, Slack, and, as of today, officially supports [Spring Boot](https://spring.io/blog/2016/02/15/developing-spring-boot-applications-with-kotlin). And, because you can use libraries interchangeably between Java and Kotlin, you can keep bytecode footprints nice and small.\n\nBreslav comments that, even before its official release, a number of companies have judged Kotlin fit for production, and JetBrains themselves have been utilising the language, along with its compiler and tooling projects, on extensive “real-life” projects for the past two years. In terms of adoption, over 11,000 people used Kotlin last month, and there are already two books – [Kotlin in Action](https://www.manning.com/books/kotlin-in-action) and [Kotlin for Android Developers](https://leanpub.com/kotlin-for-android-developers) – to get developers going with the language.\n\nGoing forward, JetBrains will look to make Kotlin development more transparent by establishing a centralized venue for design proposals and discussions. You can expect standardization efforts to happen in the near future too. Aside from bug fixes, plans for the roadmap ahead include formalised support for JavaScript (at the moment this is strictly experimental), performance improvements to the Kotlin toolchain, and support for generating Java 8 bytecode with things like optimized lambdas.\n\nFor a taste of what Kotlin has to offer, its creators recommend giving this online mini-IDE [try.kotl.in](https://try.kotlinlang.org/) a whirl and having a go at [Koans](http://try.kotlinlang.org/koans) — a set of introductory problems to guide you through the basics of the language.\n\nTo learn more about Kotlin and how it compares to fellow Java-botherer Ceylon, as well as Java itself, we suggest checking out this Devoxx UK 2015 session by Russel Winder:\n\n[https://www.youtube.com/watch?v=Q_Z_8HXt68k](https://www.youtube.com/watch?v=Q_Z_8HXt68k)\n\n","author":"Lucy Carey","date":"2016-02-15","type":"article","categories":["Kotlin","JVM,"],"features":["highlightjs"],"description":"","filename":"","lang":"EN","enclosure":null},{"title":"Exploring the Kotlin Standard Library - Part 3","url":"http://jamie.mccrindle.org/2013/02/exploring-kotlin-standard-library-part-3.html","body":"\nIn [Part 1](http://jamie.mccrindle.org/2013/01/exploring-kotlin-standard-library-part-1.html) and [Part 2](http://jamie.mccrindle.org/2013/01/exploring-kotlin-standard-library-part-2.html) of this series, I went through the default Kotlin namespace and kotlin.io. In Part 3 I'll be going over kotlin.concurrent.\n\nThe public functions in kotlin.concurrent are all utilities for creating timers, threads or timer tasks e.g.\n\n```kotlin\n// create a fixed rate timer that prints hello world every 100ms\n// after a 100ms delay\nval fixedRateTimer = fixedRateTimer(name = \"hello-timer\",\n        initialDelay = 100, period = 100) {\n    println(\"hello world!\")\n}\ntry {\n    Thread.sleep(1000)\n} finally {\n    fixedRateTimer.cancel();\n}\n```\n\nNote: by default the timers are not daemon timers. Without the cancel the timer would run indefinitely. This can often cause issues if you have a timer deployed in a container (like Tomcat). Naming them is always helpful in finding rogue non-daemon timers.\n\nThe thread() method creates a new thread\n\n```kotlin\n// run in a different thread\nthread() {\n    println(\"async\")\n}\nprintln(\"sync\")\n```\n\nalthough I would usually use an ExecutorService rather than managing threads directly. Fortunately the Kotlin standard library provides a number of extension methods on Executor and ExecutorService too.\n\n```kotlin\n// create a single thread executor\nval singleThreadPool = Executors.newSingleThreadExecutor();\ntry {\n    // Executor and ExecutorService are extended with an\n    // invoke method\n    val future = singleThreadPool<String>{\n        \"async\"\n    }\n    println(\"sync\")\n    println(future.get(10, TimeUnit.SECONDS))\n} finally {\n    singleThreadPool.shutdown();\n```\n\njava.util.Timer also gets a couple of extension methods: schedule and scheduleAtFixedRate\n\n```kotlin\n// create a daemon thread\nval timer = Timer(\"schedule\", true);\n\n// schedule a single event\ntimer.schedule(1000) {\n    println(\"hello world!\")\n}\n// schedule at a fixed rate\ntimer.scheduleAtFixedRate(1000, 1000) {\n    println(\"hello world!\")\n}\n```\n\nOnce again, I'd normally use a ScheduledExecutorService in preference. The standard library doesn't provide extension methods on ScheduledExecutorService but it is easy enough to add our own:\n\n```kotlin\n/**\n * Extension method on implementations of ScheduledExecutorService to schedule\n * an action\n */\nfun <V, T: ScheduledExecutorService> T.schedule(\n        delay: Long,\n        unit: TimeUnit = TimeUnit.MILLISECONDS,\n        action: () -> V): ScheduledFuture<V> {\n    return this.schedule(\n            callable { action() },\n            delay, unit);\n}\n```\n\nWhich can be used as follows:\n\n```kotlin\nval scheduledExecutor = Executors.newScheduledThreadPool(1)\ntry {\n    scheduledExecutor.schedule(1000) {\n        println(\"hello world\")\n    }\n} finally {\n    scheduledExecutor.shutdown()\n}\n```\n\nThe kotlin.concurrent package also provides additional methods for using locks e.g.:\n\n```kotlin\nval lock = ReentrantLock();\nval result = lock.withLock {\n    // access a locked resource\n}\nval readWriteLock = ReentrantReadWriteLock()\nreadWriteLock.read {\n    // execute an action with a read lock\n}\nreadWriteLock.write {\n    // execute an action with a write lock\n}\n```\n\nIf instead of locking, our code needs to try the lock and do one thing if the resource is available, and another if it is locked, we could extend Lock as follows:\n\n```kotlin\n/**\n * Only run if you can acquire a lock\n */\npublic inline fun <T> Lock.tryLock(action: ()->T, alternative: ()->T): T {\n    if(tryLock()) {\n        try {\n            return action()\n        }\n        finally {\n            unlock();\n        }\n    } else {\n        return alternative();\n    }\n}\n```\n\nWhich could be used like this:\n\n```kotlin\nval tryLock = ReentrantLock();\nval tryLockResult = tryLock.tryLock({\n    // run if we can get a lock\n}, {\n    // run if we couldn't get a lock\n});\n```\n\n","author":"Jamie McCrindle","date":"2013-02-07","type":"article","categories":["Kotlin"],"features":["highlightjs"],"description":"","filename":"","lang":"EN","enclosure":null},{"title":"Mimicking Kotlin Builders in Java and Python","url":"https://programmingideaswithjake.wordpress.com/2016/01/16/mimicking-kotlin-builders-in-java-and-python/","body":"\n## **Intro**\n\nKotlin is probably my favorite language right now, and possibly one of the coolest things it has to offer is type-safe builders, built upon several features (explained in a bit). I find myself really _really_ wanting to have this feature in my other two primary languages, Java and Python. This article explains what I believe to be the closest we can get to having type-safe builders in those languages\n\n## **Kotlin**\n\nTo start, I need to explain Kotlin’s ability to do type-safe builders. For a quick explanation of what these builders are, you should check out [their page about them](https://kotlinlang.org/docs/reference/type-safe-builders.html). In this article, we’ll be implementing a tiny subset of their html builder.\n\nKotlin’s ability to create type-safe builders is due to many small features. The first is the lambda syntax; `{param, list -> block.of.code()}`. If the lambda has zero parameters, you can ignore the parameter list and the arrow. The same is true when it only has one parameter, as that parameter is implicitly called `it`. For example, `{doSomethingWith(it)}` is a legitimate lambda, assuming `doSomethingWith()` takes an object that is the same type as what is being passed into the lambda.\n\nThe next feature is how to pass lambdas into functions. If the last argument is a lambda, it can be passed _after_ the parentheses of the function call. For example, `myFunc(arg1){lambdaArg()}`. If the lambda is the _only_ argument, the parentheses can be ignored altogether: `aFunc{lambdaArg()}`. This allows you to define functions that can look like language features. You could technically define your own if-else blocks, or any of the loops, if it weren’t for the fact that those keywords are reserved.\n\nNext is extension methods and the fact that you can define lambdas that work like them. Extension methods are new methods that are defined for a class or interface _outside_ the class of the interface. For example, you could create new methods for the `String` class. In actuality, they’re just static methods that take an implicit first parameter of the type they’re for. In the Kotlin code, that first parameter is assigned to the `this` identifier, which is used implicitly, just like in a real method.\n\nYou can define lambdas that work like extension methods (`SomeClass.() -> Unit` instead of `(SomeClass) -> Unit`, too, so that inside the lambda, you can make calls on the object without explicitly referencing it.\n\nAll these features, plus really good type inferencing, come together to create the ability to make type-safe builders from functions taking extension lambdas. So, we can write this:\n\n```kotlin\nhtml {\n   head {\n      title(\"A Title\")\n   }\n   body {\n      p = \"paragraph\"\n      p = \"'nother one\"\n      p = \"last paragraph\"\n   }\n}\n```\n\nTo return an `Html` object that contains a `Head` and a `Body`, the `Head` containing a `Title` with the text, “A Title”. The `Body` contains 3 `Paragraphs`.\n\nYou may note that `title` and [p] are different in how they’re defined. It probably would have been smarter to have `title` to use the `=` syntax instead of `p`, but `p` shows off how creative these builders can be better than `title`. I did a similar thing with Python, since it also supports properties.\n\nLet’s look at the Kotlin code that allows up to create these objects\n\n```kotlin\nfun html(htmlBuilder: Html.() -> Unit): Html {\n   val html = Html()\n   html.htmlBuilder()\n   return html\n}\n\nclass Html {\n   private var head: Head? = null\n   private var body: Body? = null\n\n   fun head(headBuilder: Head.() -> Unit) {\n      head = Head()\n      head?.headBuilder()\n   }\n\n   fun body(bodyBuilder: Body.() -> Unit) {\n      body = Body()\n      body?.bodyBuilder()\n   }\n}\n```\n\nWe start with the `Html` class and the `html()` function used to start the builder. The `html` function isn’t necessary, since the code could be used as an `Html` constructor, but it allows us to keep the constructor simple and all the functions lowercase without going against naming conventions.\n\nYou’ll note that everything is actually pretty darn short. Only the `html` function is 3 lines, and that’s only because it has to return the result at the end. If we used a constructor on `Html` instead, it would only have the line `htmlBuilder()`.\n\nHere’s `Head` and `Title`.\n\n```kotlin\nclass Head {\n   private var title: Title? = null\n\n   fun title(text: String) {\n      title = Title(text)\n   }\n}\n\nclass Title (private val text: String) { }\n```\n\nStill going pretty nicely. `Title` doesn’t require a builder, since it just holds text. If it weren’t for the fact that there would need to be some more complex build mechanics, I’d actually have `Head` just hold the `String` itself instead of creating a `Title` class and object.\n\n```kotlin\nclass Body {\n   private val paragraphs: ArrayList<Paragraph> = ArrayList()\n\n   var p: String\n      private get() = null!!\n      set(value) {\n         paragraphs.add(Paragraph(value))\n      }\n}\n\nclass Paragraph (private val text: String) { }\n```\n\nHere’s the really interesting thing. Instead of having a `p()` method, like we did for `Title`, we used `p`‘s setter to keep adding `Paragraph` objects to the list. In this case, it’s not the most intuitive; it’s just there to show you how creative one could get with these builders.\n\nKeep in mind, too that these classes are just the builder classes, so they’re allowed to be stateful. There should be a `build()` method that recursively calls the `build()` methods of all the the enclosed objects to create a nice, immutable object.\n\n## **Java**\n\nIn Java, you can pretty much create the exact same classes, except that the builder doesn’t look as clean, since it doesn’t have all the lovely features above. So, to start you off, here’s what the builder code ends up looking like.\n\n```kotlin\nhtml(html -> {\n   html.head(head ->\n      head.title(\"A Title\")\n   );\n   ht.body(body -> {\n      body.p(\"paragraph\");\n      body.p(\"'nother one\");\n      body.p(\"last paragraph\");\n   });\n});\n```\n\nAnd _that_ is as close to the builder syntax that you can get in Java. Note that there’s no difference in the way that `title()` and `p()` are called, since Java doesn’t provide any property-like construct. Also, notice that you need to have a name for everything. With the implicit `this`, you must write something like `hd.title(...)` rather than just `title(...)`, and that’s not even mentioning the fact that we have to define the parameter list for the lambda.\n\nThere’s a couple other things you could do, but those are even worse, the first being just using normal code:\n\n```java\nHtml html = new Html();\n   Head head = html.head();\n      head.title(\"A Title\");\n   Body body = html.body();\n      body.p(\"paragraph\");\n      body.p(\"'nother one\");\n      body.p(\"last paragraph\");\n```\n\nThis isn’t _terrible_, but it ends up being relatively verbose because of the lack of full type inference (I have to specify that `head` and `body` are of their respective types), and the extra tabbing is purely for looks, since no brackets are used. The other way I thought of doing it will be shown after the Python version, since it tries to sort of replicate _that_ version.\n\nSo, let’s look at the code\n\n```java\npublic class Html {\n   public static Html html(Consumer<Html> htmlBuilder)\n   {\n      Html html = new Html();\n      htmlBuilder.accept(html);\n      return html;\n   }\n\n   private Head head = null;\n   private Body body = null;\n\n   public void head(Consumer<Head> headBuilder) {\n      head = new Head();\n      headBuilder.accept(head);\n   }\n\n   public void body(Consumer<Body> bodyBuilder) {\n      body = new Body();\n      bodyBuilder.accept(body);\n   }\n}\n```\n\nThis is as direct of a port to Java as it gets. The `html()` function was moved into the `Html` class as static method, since it has to go _somewhere_ in Java. We used a `Consumer<Html>`, since that’s the closest thing Java has to the kind of lambdas we want.\n\nHere are `Head` and `Title`:\n\n```java\npublic class Head {\n   private Title title = null;\n\n   public void title(String text) {\n      title = new Title(text);\n   }\n}\n\npublic class Title {\n   private final String text;\n\n   public Title(String text) {\n      this.text = text;\n   }\n}\n```\n\nNot much of note here. It’s probably about what you expected. Now to finish off with `Body` `Paragraph`.\n\n```java\npublic class Body {\n   private final List paragraphs = new ArrayList<>();\n\n   public void p(String text) {\n      paragraphs.add(new Paragraph(text));\n   }\n}\n\npublic class Paragraph {\n   private final String text;\n\n   public Paragraph(String text) {\n      this.text = text;\n   }\n}\n```\n\nIt almost feels like it’s not worth writing these classes, doesn’t it, they’re so simple. Keep in mind, this is the bare-bones builder part. Again, this code doesn’t actually include the functionality for building the actual, immutable DOM tree.\n\nThat’s what it takes to build the Java version. Other that some of the syntax verbosity, it’s almost easier to create in Java than in Kotlin because there aren’t any extra features to think about and apply![\uD83D\uDE1B](https://s0.wp.com/wp-content/mu-plugins/emoji/twemoji/svg/1f61b.svg)\n\n## **Python**\n\nTrying to figure out a way to do something like this in Python required me to get lucky enough to see a video that showed a novel (but unintuitive) way of using context managers (`with` statements). The problem in Python is that lambdas are only allowed to have a single expression or statement. Context managers allow a (very limited) way of getting around single-line lambdas by effectively allowing you to return an object (or nothing) at entry that can be used while within the context manager as if being within lambda.\n\nSo, for example, the builder would look like this in Python:\n\n```python\nmyhtml = Html()\nwith myhtml as html:\n    with html.head() as head:\n        head.title(\"A Title\")\n    with html.body() as body:\n        body.p = \"paragraph\"\n        body.p = \"'nother one\"\n        body.p = \"last paragraph\"\n```\n\nThis may actually look like a waste because this can written as the following almost as easily:\n\n```python\nhtml = Html()\nhead = html.head()\nhead.title(\"A Title\")\nbody = html.body()\nbody.p = \"paragraph\"\nbody.p = \"'nother one\"\nbody.p = \"last paragraph\"\n```\n\nThe biggest benefit of the `with` blocks is the indentation, since Python has indentation restrictions due to it using indentation over curly braces. Context managers are possibly worth it just for _that_ benefit. But there’s another benefit that I’ll bring up near the end, after showing you the basic code required for making these in Python\n\n```python\nclass Html:\n    def __enter__(self):\n        return self\n\n    def __exit__(self, exc_type, exc_val, exc_tb):\n        return False\n\n    def head(self):\n        self._head = Head()\n        return self._head\n\n    def body(self):\n        self._body = Body()\n        return self._body\n```\n\nHere, you can see that the `Html` class has the required `__enter__()` and `__exit__()` methods to be a context manager. They do practically nothing; `__enter__()` only returns `self`, and `__exit__()` simply signifies that it didn’t deal with any exceptions that may have been passed in. The `head()` and `body()` methods do pretty much what you’d expect by now, with the assumption that `Head` and `Body` are also context manager types.\n\n```python\nclass Head:\n    def __enter__(self):\n        return self\n\n    def __exit__(self, exc_type, exc_val, exc_tb):\n        return False\n\n    def title(self, text):\n        self._title = Title(text)\n\nclass Title:\n    def __init__(self, text):\n        self.text = text\n\nclass Body:\n    p = property()\n\n    def __enter__(self):\n        return self\n\n    def __exit__(self, exc_type, exc_val, exc_tb):\n        return False\n\n    @p.setter\n    def p(self, text):\n        if not hasattr(self, 'paragraphs'):\n            self.paragraphs = []\n        self.paragraphs.append(Paragraph(text))\n\nclass Paragraph:\n    def __init__(self, text):\n        self.text = text\n```\n\nThe only new thing here to bother looking at is the use of `property` on `Body` for its `p` tag. Luckily, we can don’t need getters on `property`s that we need to have return `None`, like in Kotlin.\n\nOkay, now we look at the interesting, less obvious reason why it’s helpful to use context managers for this situation. In Java and Kotlin, we would have needed an additional call at the end to a `build()` method (or else have the `html()` function do it for us) and have it do a recursive traversal all at once in the end to take care of it. With the context manager, the `__enter__()` and `__exit__()` methods could pass out the builder version of the object upon entry, then build it on exit. That means that each intermediate stage of the builders already contain the fully built versions by the time they exit.\n\nThis can actually be a little difficult to wrap your head around. Here’s an example that does a partial implementation using `Html`, `HtmlBuilder`, and `Head`:\n\n```python\nclass Html:\n    def __enter__(self):\n        self._builder = HtmlBuilder()\n        return self._builder\n\n    def __exit__(self, exc_type, exc_val, exc_tb):\n        self.head = self._builder._head\n        self.body = self._builder._body\n        del self._builder\n        return False\n\nclass HtmlBuilder:\n    def head(self):\n        self._head = Head()\n        return self._head\n\n    def body(self):\n        ...\n\nclass Head:\n    def __enter__(self):\n        self._builder = HeadBuilder()\n        return self._builder\n\n    def __exit__(self, exc_type, exc_val, exc_tb):\n        self.title = self._builder._title\n        del self._builder\n        return False\n```\n\nHere, the `Html` object’s `__enter__()` method creates and saves a builder on itself, then returns it. Upon `__exit__()`, it builds itself from values stored on the builder and deletes the builder from itself. Upon first thought, at least for me, one might think that the objects stored on the builder aren’t finished objects, but they are. The methods on the builder object return a proper class with its own `__enter__()` and `__exit__()` methods which will also guarantee that it’s built properly, as is seen with `HtmlBuilder`‘s `head()` method and with the implementation of `Head`. With this setup, the calling code is actually still the same as it was the first time.\n\nLast thing: now that we know that we can use context managers to do this, you might think that Java’s `try` resource manager might actually work okay for it. And you’d be right. In fact, it ends up with a cleaner syntax (other than the random `try` keywords) than the lambda version, too. Here’s what the resource manager version would look like when called:\n\n```java\nHtml html = Html();\ntry(html) {\n   try(Head head = html.head()) {\n      head.title(\"A Title\");\n   }\n   try(Body body = html.body()) {\n      body.p(\"paragraph\");\n      body.p(\"'nother one\");\n      body.p(\"last paragraph\");\n   }\n}\n```\n\nAt this point, I’ll leave it to you to try and figure out how to implement this. Hint: I don’t think it can work like the second version of the Python build, where it builds as it goes. I think everything in this Java version of the code requires builders until, at the end, you call the `build()` method on `html` to create the true versions.\n\n## **Outro**\n\nHoly cow, this thing ended up being kind of long, didn’t it? I hope that you had some fun with this exercise, since I’m not sure how useful it really is (other than learning that you could potentially simulate 0- or 1-parameter lambdas with context managers.\n\nSadly, I never did get around to talking about adding the additional parameters like the Kotlin site’s example does, such as assigning a class, id, etc in the function calls. There are additional features that Kotlin has that makes this really clean and easy, but this article clearly doesn’t have room for it. I’ll tackle it next week.\n\nThanks for reading!\n\nNote: As of yesterday, all editing is finished. From here, I “just” need to get a cover designed, which I have an idea for; get all the formatting figured out for both print and e-book versions; write the appendix (mostly just a collection of code snippets from the book, fleshed out more); and finish writing the GitHub repo that will have all the super helpful classes and functions for building your own descriptors more quickly, easily, and with fewer problems. I expect to get all of this done by the end of summer, but hopefully sooner. My life is about to get a little busier, so I don’t know how much time I’ll be able to devote to all of this.\n\n","author":"Jacob Zimmerman","date":"2016-01-16","type":"article","categories":["Builders","Kotlin"],"features":["highlightjs"],"description":"","filename":"","lang":"EN","enclosure":null},{"title":"Scala vs Kotlin: inline and infix","url":"https://blog.frankel.ch/scala-vs-kotlin/3/","body":"\nThis is the third post in the Scala vs Kotlin comparison serie:\n\n1.  [Pimp my library](/scala-vs-kotlin/1/)\n2.  [Operator overloading](/scala-vs-kotlin/2/)\n\nThis week, I’d like to address two features: inline and infix - not because they’re related but because neither of them would be enough to fill a post.\n\nInlining comes from C (and then C++). In those languages, a hint could be provided to the compiler through the `inline` keyword. By doing so, it may replace an inlined function call by the function body itself in order to skip the overhead of a function call.\n\nInfix notation is to be in line with prefix and postfix, it’s relative to the place of the operator compared its 2 operands. Hopefully, the following example is clear enough:\n\n* _Prefix_: **+** 2 2\n* _Postfix_: 2 2 **+**\n* _Infix_: 2 **+** 2\n\n## Scala\n\nScala offers inlining through the `@inline` annotation on a function. As for C/C++, this is a an hint to the compiler. As per the [ScalaDocs](http://www.scala-lang.org/api/current/#scala.inline):\n\n> An annotation on methods that requests that the compiler should try especially hard to inline the annotated method.\n\nThe compiler has the final say in whether the function will be inlined, or not. On the opposite site, a function can be annotated with `@noinline` to prevent inlining altogether:\n\n> An annotation on methods that forbids the compiler to inline the method, no matter how safe the inlining appears to be.\n\nAs for infix annotation, it’s interestingly quite different from the definition above. In this context, it means that dot and parentheses can be omitted while calling functions that have a single parameter. There are some additional constraints:\n\n*   Either the function must have **no** side-effects - be _pure_\n*   **Or** the parameter must be a function\n\n```scala\nval isLess1 = 1.<(2)\nval isLess2 = 1 < 2\n```\n\nLines 1 and 2 are equivalent. Obviously, line 2 is much more readable. Thanks to infix annotation, Scala doesn’t need operators, as every function can not only [look](/scala-vs-kotlin/2/#scala) but be called like an operator.\n\n## Kotlin\n\nIn Kotlin, inlining is set with the `inline` _keyword_. However, it’s much more than just a compiler hint: it’s a requirement. Whenever `inline` is used, the compiler **will** inline the function, no matter what.\n\nAs such, it’s very important to use inlining only on small functions. Other limitations might include keeping its use to code under our control, _e.g._ to use it only for application code or code that is not part of a library’s public API.\n\nNote that inlining affects both the function itself as well as arguments that are lambdas. To make lambda arguments not inlined, use the `noinline` keyword.\n\nInfix notation is not automatic in Kotlin as it requires the function to be marked with the `infix` keyword. Additionally, the function needs to be attached to a class, either because it’s a member or an extension. Of course, the single parameter still applies.\n\n```kotlin\n// Defined in Kotlin's runtime\ninfix fun and(other: kotlin.Int): kotlin.Int { /* compiled code */ }\n\nval bool1 = 1.and(2)\nval bool2 = 1 and 2\n```\n\nBe aware that infix notation only looks similar to an operator, it’s still a regular method call underneath.\n\n```kotlin\n// This is valid\nval bool3 = 1 < 2\n\n// This is not valid, because < is an operator\nval bool4 = 1.<(2)\n```\n\n","author":"Nicolas Fränkel","date":"2016-08-21","type":"article","categories":["Kotlin","Scala"],"features":["highlightjs"],"description":"","filename":"","lang":"EN","enclosure":null},{"title":"10 Features I Wish Java Would Steal From the Kotlin Language","url":"http://blog.jooq.org/2016/03/31/10-features-i-wish-java-would-steal-from-the-kotlin-language/","body":"\nThis article is overdue. After the hype around the [release of Kotlin 1.0](https://blog.jetbrains.com/kotlin/2016/02/kotlin-1-0-released-pragmatic-language-for-jvm-and-android/) has settled, let’s have a serious look at some Kotlin language features that we should have in Java as well.\n\nIn this article, I’m not going to wish for unicorns. But there are some low hanging fruit (as far as I naively can see), which could be introduced into the Java language without great risk. While you’re reading this article, be sure to copy paste examples to [http://try.kotlinlang.org](http://try.kotlinlang.org), an online REPL for Kotlin\n\n## 1. Data class\n\nLanguage designers hardly ever agree on the necessity and the feature scope of what a class is. In Java, curiously, every class always has _identity_ a concept that is not really needed in 80% – 90% of all real world Java classes. Likewise, [a Java class always has a monitor on which you can synchronize](http://blog.jooq.org/2016/01/12/if-java-were-designed-today-the-synchronizable-interface/).\n\nIn most cases, when you write a class, you really just want to group values, like Strings, ints, doubles. For instance:\n\n```java\npublic class Person {\n    final String firstName;\n    final String lastName;\n    public JavaPerson(...) {\n        ...\n    }\n    // Getters\n    ...\n \n    // Hashcode / equals\n    ...\n \n    // Tostring\n    ...\n \n    // Egh...\n}\n```\n\nBy the time you’ve finished typing all of the above, your fingers will no longer be. Java developers have implemented ugly workarounds for the above, like IDE code generation, or [lombok](https://projectlombok.org), which is the biggest of all hacks. In a better Java, nothing in Lombok would really be needed.\n\nAs, for instance, if Java had Kotlin’s [data classes](https://kotlinlang.org/docs/reference/data-classes.html):\n\n```kotlin\ndata class Person(\n  val firstName: String,\n  val lastName: String\n)\n```\n\nThe above is all we need to declare the equivalent of the previous Java code. Because a data class is used to store data (duh), i.e. values, the implementation of things like `hashCode()`, `equals()`, `toString()` is obvious and can be provided by default. Furthermore, data classes are first class tuples, so they can be used as such, e.g. to destructure them again in individual references:\n\n```kotlin\nval jon = Person(\"Jon\", \"Doe\") \nval (firstName, lastName) = jon\n```\n\nIn this case, we may hope. [Valhalla / Java 10](https://en.wikipedia.org/wiki/Project_Valhalla_(Java_language)) is being designed and with it, [value types](http://cr.openjdk.java.net/~jrose/values/values-0.html). We’ll see how many features will be provided on the JVM directly, and in the Java language. This will certainly be an exciting addition.\n\nNotice how `val` is possible in Kotlin: [Local variable type inference. This is being discussed for a future Java version right now](http://blog.jooq.org/2016/03/10/java-as-new-local-variable-type-inference/).\n\n## 2. Defaulted parameters\n\nHow many times do you overload an API like the following:\n\n```java\ninterface Stream<T> {\n    Stream<T> sorted();\n    Stream<T> sorted(Comparator<? super T> comparator);\n}\n```\n\nThe above are exactly the same JDK `Stream` operations. The first one simply applies [`Comparator.naturalOrder()`](https://docs.oracle.com/javase/8/docs/api/java/util/Comparator.html#naturalOrder--) to the second one. [So we could write the following, in Kotlin](https://kotlinlang.org/docs/reference/functions.html):\n\n```kotlin\nfun sorted(comparator : Comparator<T>\n         = Comparator.naturalOrder()) : Stream<T>\n```\n\nThe advantage of this isn’t immediately visible, when there is only one defaulted parameter. But imagine a function with tons of optional parameters:\n\n```kotlin\nfun reformat(str: String,\n             normalizeCase: Boolean = true,\n             upperCaseFirstLetter: Boolean = true,\n             divideByCamelHumps: Boolean = false,\n             wordSeparator: Char = ' ') {\n...\n}\n```\n\nWhich can be called in any of the following ways:\n\n```kotlin\nreformat(str)\nreformat(str, true, true, false, '_')\nreformat(str,\n  normalizeCase = true,\n  upperCaseFirstLetter = true,\n  divideByCamelHumps = false,\n  wordSeparator = '_'\n)\n```\n\nThe power of defaulted parameters is that they are especially useful when passing arguments by name, rather than by index. This is currently not supported in the JVM, which until Java 8, doesn’t retain the parameter name at all ([in Java 8, you can turn on a JVM flag for this](https://docs.oracle.com/javase/tutorial/reflect/member/methodparameterreflection.html), but with all of Java’s legacy, you shouldn’t rely on this yet).\n\nHeck, this feature is something I’m using in PL/SQL every day. Of course, [in Java, you can work around this limitation by passing a parameter object](http://blog.jooq.org/2016/02/11/dear-api-designer-are-you-sure-you-want-to-return-a-primitive/).\n\n## 3. Simplified instanceof checks\n\nIf you will, this is really an instanceof switch. Some people may claim that this stuff is evil, bad OO design. Nja nja. I say, this happens every now and then. And apparently, in Java 7, string switches were considered sufficiently common to modify the language to allow them. Why not instanceof switches?\n\n```kotlin\nval hasPrefix = when(x) {\n  is String -> x.startsWith(\"prefix\")\n  else -> false\n}\n```\n\nNot only is this doing an instanceof switch, it is doing it in the form of an assignable expression. [Kotlin’s version of this `when` expression is powerful](https://kotlinlang.org/docs/reference/control-flow.html). You can mix any sort of predicate expressions, similar to SQL’s `CASE` expression. For instance, this is possible as well:\n\n```kotlin\nwhen (x) {\n  in 1..10 -> print(\"x is in the range\")\n  in validNumbers -> print(\"x is valid\")\n  !in 10..20 -> print(\"x is outside the range\")\n  else -> print(\"none of the above\")\n}\n```\n\nCompare to SQL (not implemented in all dialects):\n\n```sql\nCASE x\n  WHEN BETWEEN 1 AND 10 THEN 'x is in the range'\n  WHEN IN (SELECT * FROM validNumbers) THEN 'x is valid'\n  WHEN NOT BETWEEN 10 AND 20 'x is outside the range'\n  ELSE 'none of the above'\nEND\n```\n\nAs you can see, only SQL is more powerful than Kotlin.\n\n## 4. Map key / value traversal\n\nNow this could really be done very easily only with syntax sugar. Granted, having [local variable type inference](http://blog.jooq.org/2016/03/10/java-as-new-local-variable-type-inference/) would already be a plus, but check this out\n\n```kotlin\nval map: Map<String, Int> = ...\n```\n\nAnd now, you can do:\n\n```kotlin\nfor ((k, v) in map) {\n    ...\n}\n```\n\nAfter all, most of the time when traversing a map, it’ll be by [`Map.entrySet()`](https://docs.oracle.com/javase/8/docs/api/java/util/Map.html#entrySet--). Map could have been enhanced to extend `Iterable<Entry<K, V>>` in Java 5, but hasn’t. That’s really a pity. After all, it has been enhanced in Java 8 to allow for internal iteration over the entry set in Java 8 via [`Map.forEach()`](https://docs.oracle.com/javase/8/docs/api/java/util/Map.html#forEach-java.util.function.BiConsumer-):\n\n```kotlin\nmap.forEach((k, v) -> {\n    ...\n});\n```\n\nIt’s not too late, JDK gods. You can still let `Map<K, V> extend Iterable<Entry<K, V>>`\n\n## 5. Map access literals\n\nThis one is something that would add tons and tons of value to the Java language. We have arrays, like most other languages. And like most other languages, we can access array elements by using square brackets:\n\n```java\nint[] array = { 1, 2, 3 };\nint value = array[0];\n``` \n\nNote also the fact that we have array initialiser literals in Java, which is great. So, why not also allow for accessing map elements with the same syntax?\n\n```kotlin\nval map = hashMapOf<String, Int>()\nmap.put(\"a\", 1)\nprintln(map[\"a\"])\n```\n\nIn fact, `x[y]` is just syntax sugar for a method call backed by `x.get(y)`. This is so great, we have immediately proceeded with renaming our `Record.getValue()` methods in jOOQ to `Record.get()` (leaving the old ones as synonyms, of course), such that you can now dereference your database record values as such, in Kotlin\n\n```kotlin\nctx.select(a.FIRST_NAME, a.LAST_NAME, b.TITLE)\n   .from(a)\n   .join(b).on(a.ID.eq(b.AUTHOR_ID))\n   .orderBy(1, 2, 3)\n   .forEach {\n       println(\"\"\"${it[b.TITLE]}\n               by ${it[a.FIRST_NAME]} ${it[a.LAST_NAME]}\"\"\")\n   }\n```\n\nSince jOOQ holds all column type information on individual record columns, you can actually know in advance that `it[b.TITLE]` is a String expression. Great, huh? So, not only can this syntax be used with JDK maps, it can be used with any library that exposes the basic `get()` and `set()` methods.\n\nStay tuned for more jOOQ and Kotlin examples here:\n[https://github.com/jOOQ/jOOQ/blob/master/jOOQ-examples/jOOQ-kotlin-example/src/main/kotlin/org/jooq/example/kotlin/FunWithKotlinAndJOOQ.kt](https://github.com/jOOQ/jOOQ/blob/master/jOOQ-examples/jOOQ-kotlin-example/src/main/kotlin/org/jooq/example/kotlin/FunWithKotlinAndJOOQ.kt)\n\n## 6. Extension functions\n\nThis one is a controversial topic, and I can perfectly understand when language designers stay clear of it. But every now and then, [extension functions](https://kotlinlang.org/docs/reference/extensions.html) are very useful. The Kotlin syntax here is actually just for a function to pretend to be part of the receiver type:\n\n```kotlin\nfun MutableList<Int>.swap(index1: Int, index2: Int) {\n  val tmp = this[index1] // 'this' corresponds to the list\n  this[index1] = this[index2]\n  this[index2] = tmp\n}\n```\n\nThis will now allow for swapping elements in a list:\n\n```kotlin\nval l = mutableListOf(1, 2, 3)\nl.swap(0, 2)\n```\n\nThis would be very useful for libraries like [jOOλ](https://github.com/jOOQ/jOOL), which extends the Java 8 `Stream` API by wrapping it in a jOOλ type ([another such library is StreamEx](https://github.com/amaembo/streamex), with a slightly different focus). The jOOλ `Seq` wrapper type is not really important, as it pretends to be a `Stream` on steroids. It would be great, if jOOλ methods could be put onto `Stream` artificially, just by importing them:\n\n```java\nlist.stream()\n    .zipWithIndex()\n    .forEach(System.out::println);\n```\n\nThe `zipWithIndex()` method isn’t really there. The above would just translate to the following, less readable code:\n\n```java\nseq(list.stream())\n    .zipWithIndex()\n    .forEach(System.out::println);\n```\n\nIn fact, extension methods would even allow to bypass wrapping everything explicitly in a `stream()`. For instance, you could then do:\n\n```java\nlist.zipWithIndex()\n    .forEach(System.out::println);\n```\n\nAs all of jOOλ’s method could be designed to also be applied to `Iterable`.\n\nAgain, this is a controversial topic. For instance, because\n\n<blockquote class=\"twitter-tweet\" data-lang=\"en\"><p lang=\"en\" dir=\"ltr\"><a href=\"https://twitter.com/lukaseder\">@lukaseder</a> that does not allow for virtual dispatch. Extension methods are not virtual.</p>&mdash; Rafael Winterhalter (@rafaelcodes) <a href=\"https://twitter.com/rafaelcodes/status/692652876959711232\">January 28, 2016</a></blockquote>\n<script async src=\"//platform.twitter.com/widgets.js\" charset=\"utf-8\"></script>\n\nWhile giving the illusion of being virtual, extension functions really are just sugared static methods. It’s a significant risk for object oriented application design to engage in that trickery, which is why this feature probably won’t make it into Java.\n\n## 7. Elvis operator\n\nOptional is meh. It’s understandable that an `Optional` type needed to be introduced in order to abstract over the absence of primitive type values, which cannot be null. We now have things like [`OptionalInt`](https://docs.oracle.com/javase/8/docs/api/java/util/OptionalInt.html), e.g. to model things like:\n\n```kotlin\nOptionalInt result =\nIntStream.of(1, 2, 3)\n         .filter(i -> i > 3)\n         .findFirst();\n \n// Agressive programming ahead\nresult.orElse(OR_ELSE);\n```\n\nOptional is a monad\n\n<blockquote class=\"twitter-tweet\" data-lang=\"en\"><p lang=\"en\" dir=\"ltr\">Also Google seems to be a bit confused about what a Monad is ... <a href=\"http://t.co/eJp9jY9cwG\">pic.twitter.com/eJp9jY9cwG</a></p>&mdash; Mario Fusco (@mariofusco) <a href=\"https://twitter.com/mariofusco/status/389450525466296320\">October 13, 2013</a></blockquote>\n<script async src=\"//platform.twitter.com/widgets.js\" charset=\"utf-8\"></script>\n\nYes. It allows you to `flatMap()` the absent value.\n\n![o_O](http://s0.wp.com/wp-content/mu-plugins/wpcom-smileys/o_O.svg)\n\nSure, if you want to do sophisticated functional programming, you’ll start typing `map()` and `flatMap()` everywhere. Like today, when we’re typing getters and setters. Along will come lombok generating flatmapping calls, and Spring will add some [`@AliasFor` style annotation](http://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/core/annotation/AliasFor.html) for flatmapping. And only the enlightened will be able to decipher your code.\n\nWhen all we needed was just a [simple null safety operator](https://kotlinlang.org/docs/reference/null-safety.html) before getting back to daily business. Like:\n\n```kotlin\nString name = bob?.department?.head?.name\n```\n\nI really like this type of pragmatism in Kotlin. Or do you prefer (flat)mapping?\n\n```java\nOptional<String> name = bob\n    .flatMap(Person::getDepartment)\n    .map(Department::getHead)\n    .flatMap(Person::getName);\n```\n\nCan you read this? I cannot. Neither can I write this. If you get this wrong, you’ll get boxoxed.\n\n<blockquote class=\"twitter-tweet\" data-lang=\"en\"><p lang=\"en\" dir=\"ltr\">“<a href=\"https://twitter.com/EmrgencyKittens\">@EmrgencyKittens</a>: cat in a box, in a box. <a href=\"http://t.co/ta976gqiQs\">pic.twitter.com/ta976gqiQs</a>”   And I think flatMap</p>&mdash; Channing Walton (@channingwalton) <a href=\"https://twitter.com/channingwalton/status/447778554114502657\">March 23, 2014</a></blockquote>\n<script async src=\"//platform.twitter.com/widgets.js\" charset=\"utf-8\"></script>\n\nOf course, [Ceylon is the only language that got nulls right](http://blog.jooq.org/2016/03/15/ceylon-might-just-be-the-only-language-that-got-nulls-right/). But Ceylon has tons of features that Java will not get before version 42, and I’m not wishing for unicorns. I’m wishing for the elvis operator, which could be implemented in Java too. The above expression is just syntax sugar for:\n\n```java\nString name = null;\nif (bob != null) {\n    Department d = bob.department\n    if (d != null) {\n        Person h = d.head;\n        if (h != null)\n            name = h.name;\n    }\n}\n```\n\nWhat can possibly be wrong with that simplification?\n\n## 8. Everything is an expression\n\nNow this might just be a unicorn. I don’t know if there is a JLS / parser limitation that will forever keep us in the misery of prehistoric distinction between statement and expression.\n\nAt some point in time, people have started using statements for things that yield side-effects, and expressions for more functional-ish things. It is thus not surprising, that all `String` methods are really expressions, operating on an immutable string, returning a new string all the time.\n\nThis doesn’t seem to go well with, for instance, `if-else` in Java, which is expected to contain blocks and statements, each possibly yielding side-effects.\n\nBut is that really a requirement? Can’t we write something like this in Java as well?\n\n```kotlin\nval max = if (a > b) a else b\n```\n\nOK, we have this weird conditional expression using `?:`. But what about Kotlin’s `when` (i.e. Java’s `switch`)?\n\n```kotlin\nval hasPrefix = when(x) {\n  is String -> x.startsWith(\"prefix\")\n  else -> false\n}\n```\n\nIsn’t that much more useful than the following equivalent?\n\n```java\nboolean hasPrefix;\n \nif (x instanceof String)\n    hasPrefix = x.startsWith(\"prefix\");\nelse\n    hasPrefix = false;\n```\n\n(yes, I know about `?:`. I just find `if-else` easier to read, and I don’t see why that should be a statement, not an expression. Heck, in Kotlin, even `try` is an expression, not a statement:\n\n```kotlin\nval result = try {\n    count()\n} catch (e: ArithmeticException) {\n    throw IllegalStateException(e)\n}\n```\n\nBeautiful!\n\n## 9. Single expression functions\n\nNow this. This would save so much time reading and writing simple glue code. And in fact, we already have the syntax in annotations. Check out Spring’s magical [@AliasFor](http://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/core/annotation/AliasFor.html) annotation, for instance. It yields:\n\n```java\npublic @interface AliasFor {\n    @AliasFor(\"attribute\")\n    String value() default \"\";\n    @AliasFor(\"value\")\n    String attribute() default \"\";\n}\n```\n\nNow, if you squint really hard, these are just methods yielding constant values, because annotations are just interfaces with generated byte code for their implementations. We can discuss syntax. Of course, this irregular usage of `default` is weird, given that it was not re-used in Java 8 for default methods, but I guess Java always needs the extra syntax so developers feel alive as they can better feel their typing fingers. That’s OK. We can live with that. But then again, why do we have to? Why not just converge to the following?\n\n```java\npublic @interface AliasFor {\n    String value() = \"\";\n    String attribute() = \"\";\n}\n```\n\nAnd the same also for class / interface default methods?\n\n```java\n// Stop pretending this isn't an interface\npublic interface AliasFor {\n    String value() = \"\";\n    String attribute() = \"\";\n}\n```\n\nNow _that_ would look nice. But given Java’s existing syntax, this might just be a unicorn, so let’s move on to...\n\n## 10. Flow-sensitive typing\n\nNow _this_. THIS!\n\n[We’ve blogged about sum types before.](http://blog.jooq.org/2016/02/16/an-ingenious-workaround-to-emulate-sum-types-in-java/) Java has sum types with exceptions since Java 7:\n\n```java\ntry {\n    ...\n}\ncatch (IOException | SQLException e) {\n    // e can be of type IOException and/or SQLException\n    // within this scope\n}\n```\n\nBut Java, unfortunately, doesn’t have flow-sensitive typing. Flow-sensitive typing is of the essence in a language that supports sum types, but it is also useful otherwise. For instance, in Kotlin:\n\n```kotlin\nwhen (x) {\n    is String -> println(x.length)\n}\n```\n\nWe don’t need to cast, obviously, because we already checked that `x is String`. Conversely, in Java:\n\n```java\nif (x instanceof String)\n    System.out.println(((String) x).length());\n```\n\nAaagh, all this typing. IDE autocompletion is smart enough to offer a contextual type’s methods already and then generate the unnecessary cast for you. But it would be great if this was never needed, every time we explicitly narrow a type using control flow structures.\n\n[For more info, see this wikipedia entry about flow sensitive typing](https://en.wikipedia.org/wiki/Flow-sensitive_typing). A feature that could absolutely be added to the Java language. After all, we already got flow-sensitive final local variables since Java 8.\n\n## 11. (Bonus) Declaration site variance\n\n[Last but not least, better generics via declaration site variance](https://kotlinlang.org/docs/reference/generics.html). Many other languages know this, for instance also C#’s [`IEnumerable`](https://msdn.microsoft.com/en-us/library/9eekhta0(v=vs.110).aspx):\n\npublic interface IEnumerable<out T> : IEnumerable\n\nThe keyword `out` here means that the generic type `T` is _produced_ from the type `IEnumerable` (as opposed to `in`, which stands for consumption). In C#, Scala, Ceylon, Kotlin, and many other languages, we can declare this on the type declaration, rather than on its usage (although, many languages allow for both). In this case, we say that `IEnumerable` is covariant with its type `T`, which means again that `IEnumerable<Integer>` is a subtype of `IEnumerable<Object>`\n\nIn Java, this isn’t possible, which is why we have a [bazillion question by Java newbies on Stack Overflow](http://stackoverflow.com/q/4288084/521799). Why can’t I...\n\n```java\nIterable<String> strings = Arrays.asList(\"abc\");\nIterable<Object> objects = strings; // boom\n```\n\nIn languages like Kotlin, the above would be possible. After all, why shouldn’t it? A thing that can produce strings can also produce objects, and we can even use it in this way in Java:\n\n```java\nIterable<String> strings = Arrays.asList(\"abc\");\nfor (Object o : strings) {\n    // Works!\n}\n```\n\nThe lack of declaration site variance has made a lot of APIs very intelligible. Consider `Stream`:\n\n```java\n<R> Stream<R> flatMap(Function<? super T, ? extends Stream<? extends R>> mapper);\n```\n\nThis is just noise. A function is contravariant with its argument type and covariant with its result type _by nature_ a better definition of `Function` or `Stream` would be:\n\n```java\ninterface Function<in T, out R> {}\ninterface Stream<out T> {}\n```\n\nIf this were possible, all that `? super` and `? extends` garbage could be removed without losing any functionality.\n\nIn case you’re wondering what I’m even talking about?![:)](http://s1.wp.com/wp-content/mu-plugins/wpcom-smileys/simple-smile.svg)\n\n<blockquote class=\"twitter-tweet\" data-lang=\"en\"><p lang=\"en\" dir=\"ltr\">Covariance and contravariance explained. Source: <a href=\"https://t.co/2S4ChNeAvq\">https://t.co/2S4ChNeAvq</a> <a href=\"https://t.co/BfOME8puj2\">pic.twitter.com/BfOME8puj2</a></p>&mdash; Lukas Eder (@lukaseder) <a href=\"https://twitter.com/lukaseder/status/686917793472753665\">January 12, 2016</a></blockquote>\n<script async src=\"//platform.twitter.com/widgets.js\" charset=\"utf-8\"></script>\n\nThe great news is, this is being discussed for a (near) future version of Java:\n[http://openjdk.java.net/jeps/8043488](http://openjdk.java.net/jeps/8043488)\n\n## Conclusion\n\nKotlin is a promising language, even if it is very late to a game that already seems to have been decided, not in favour of alternative languages on the JVM. Nonetheless, it is a very interesting language to learn from, and with a lot of very good decisions made about some simple things.\n\nSome of these decisions will hopefully be picked up by the Java language gods and integrated into Java. This list here shows some features that might be “easy” to add.\n\n<blockquote class=\"twitter-tweet\" data-lang=\"en\"><p lang=\"en\" dir=\"ltr\"><a href=\"https://twitter.com/shipilev\">@shipilev</a> <a href=\"https://twitter.com/lukaseder\">@lukaseder</a> And then it&#39;s yacc-shaving from there!</p>&mdash; Brian Goetz (@BrianGoetz) <a href=\"https://twitter.com/BrianGoetz/status/708350584294920193\">March 11, 2016</a></blockquote>\n<script async src=\"//platform.twitter.com/widgets.js\" charset=\"utf-8\"></script>\n\nMore info about Kotlin idioms:\n[https://kotlinlang.org/docs/reference/idioms.html](https://kotlinlang.org/docs/reference/idioms.html)\n\n","author":"Lukas Eder","date":"2016-03-31","type":"article","categories":["Kotlin","Java"],"features":["highlightjs"],"description":"","filename":"","lang":"EN","enclosure":null},{"title":"Kotlin for Scala Developers","url":"http://www.51zero.com/blog/2016/4/14/kotlin-for-scala-developers","body":"\nAt [51zero](/about) we pride ourselves on being flexible when it comes to language choice. Java, Scala, C#, and more recently, [Kotlin](https://kotlinlang.org/).  Kotlin is a JVM language developed by Jetbrains (the people behind IntelliJ amongst other things) and recently has just reached version 1.0 public. We’ve even ported ScalaTest over to Kotlin in the guise of [KotlinTest](https://github.com/kotlintest/kotlintest) (of which we’ll do a blog soon).\n\nThere are some great articles already published on the main features of Kotlin, for example [here](http://petersommerhoff.com/dev/kotlin/kotlin-for-java-devs/), [here](https://medium.com/@octskyward/why-kotlin-is-my-next-programming-language-c25c001e26e3#.8e0v3qg1x) and [here](https://opencredo.com/kotlin/), which are useful introductions for Java developers wishing to look at a different language. This blog is for Scala developers interested in having a play with Kotlin, where we review features of Scala you use every day, and their equivalents, or closest features, are in Kotlin.\n\n## Data classes vs Case classes\n\nOne of the main selling points of Scala when you first start to use it over Java is the use of case classes to take away all the boilerplate from Java beans. (Quite why Java didn't add this years ago I have no idea, surely the addition of an annotation that the compiler can pick up on wouldn't break existing code). But anyway, Kotlin has the same case class functionality in the form of data classes. The minor difference is that Kotlin won’t automatically infer the constructor parameters to be fields, so you must declare them as either val or var.  Eg, the following scala case class:\n\n\n```scala\ncase class Person(name: String, age: Int)\n```\n\nWould become:\n\n```kotlin\ndata class Person(val name: String, val age: Int)\n```\n\n\nThe automatic derivation of equals(), hashCode() etc works in the same way as Scala.\n\n## Implicit Conversions\n\nKotlin doesn’t support implicits as such but it does allow us to achieve one common use of implicits, which is the _pimp-my-library_ pattern. In Scala, when we want to invoke foo() on a type A which contains no foo() method, the compiler will check in the appropriate scopes for an implicit method that accepts an A and returns a type B which does have the foo() method. So we create another type B, which contains all the extra methods we want for A, and then add a conversion from A to B (or mark B as an implicit class that accepts an A).  In Kotlin we can use extension methods defined on A directly.\n\nSo the scala code:\n\n```scala\nimplicit class RichString(str: String) {\n\n def reverse: String = ...\n\n def take(k: Int): String = ...\n\n}\n```\n\nBecomes this Kotlin code:\n\n```kotlin\nfun String.reverse() = ... // the “string” is available as “this”\n\nfun String.take(k: Int) = ...\n```\n\nAllows us to invoke this as `\"hello\".reverse()`\n\nThis works for generic types too.\n\n## Option\n\nKotlin doesn't have an Option type provided by the SDK (other than the Optional type available in Java 8) instead focusing on offering null safety as a first class feature. Whether you prefer this over the Haskell inspired Options is a matter of preference. I’ll explain a way to do something very common with options.\n\nOften given an option returning method, you want to map over the result before calling getOrElse or something similar. The equivalent in Kotlin would be the ?. operator which says, if the value is null, keep it null, otherwise execute the method. So this\n\n```scala\nmap.get(\"key\").map(_.foo)\n```\n\nWould become\n\n```kotlin\nmap.get(\"key\")?.foo\n```\n\nGetting the value out of the option in Scala usually involves a getOrElse or a fold. In Kotlin we would use the so called Elvis operator (am I the only one that thinks this name is ridiculous! Let's call it the getOrElse operator). So this\n\n```scala\noption.getOrElse(-1)\n```\n\nwould become\n\n```kotlin\nvalue ?: -1\n```\n\n## Property access\n\nIn Scala, we can access methods that declare a single empty parameter list without the parenthesis, so that methods and fields can both appear as properties. Eg,\n\n```scala\nclass Foo {\n\n def wibble(): String = \"wibble\"\n\n}\n```\n\nCan be invoked as either foo.wibble or foo.wibble()\n\nIn Kotlin, we can do something similar for methods that adopt the java-bean standard. So if you have a method called fun getName() then we can do foo.name and that will be compiled into a call to the getName() function.\n\nKotlin provides something similar for setters. If there is a method called setName(str: String) then we can invoke this as either `foo.setName(\"moo\")` or `foo.name = \"moo\"`. The second form will be compiled into the first form.\n\n## Operator Overloading\n\nScala allows us to declare methods with almost any operators to make (for what its proponents would argue) richer and more readable symbols for methods where operators make sense (the canonical example tends to be matrices, vectors or complex numbers). The opponents would say you end up with things like [this](http://www.flotsam.nl/dispatch-periodic-table.html). Personally, I don’t mind either way.\n\nKotlin allows us to override some operators, but only ones predefined. Eg, plus, minus etc. To do this we just declare a method with the name that matches the symbol, and annotate the function declaration with the keyword operator. Eg\n\n```kotlin\noperator fun plus(vector: Vector): Vector = ...\n```\n\nThe full list of supported operators can be found [here](https://kotlinlang.org/docs/reference/operator-overloading.html).\n\n## Pattern Matching\n\nKotlin unfortunately doesn't support full pattern matching, so you cannot do things like\n\n```scala\nperson match {\n case Person(\"bobby\", age) =>\n case _ =>\n}\n```\n\nThere is a limited form of extraction, which you can read about later, and there is a replacement for switch which allows matching on types and invocation of functions on the argument. This uses the keyword when, eg,\n\n```kotlin\nwhen(obj) {\n is String -> // matches on the type\n parseInt(obj) -> // invoked method parseInt\n else -> // otherwise\n}\n```\n\nThere is a neat way to use when’s as a replacement for if-else-if chains, you just use when without an argument, as such\n\n```kotlin\nwhen {\n person.name == \"bobby\" ->\n x.isOdd() ->\n else ->\n\n}\n```\n\n## Apply method\n\nIn Scala, methods named apply() do not need to have the method name in order to be invoked, eg\n\n```scala\nobject Foo {\n def apply() = println(\"hello\")\n def apply(str: String) = println(str)\n}\n```\n\nCan be invoked simply as Foo() or Foo(“hello”)\n\nIn Kotlin, the equivalent is to name the method invoke() with the additional operator annotation, eg\n\n```kotlin\nobject Foo {\n operator fun invoke() = println(\"hello\")\n operator fun invoke(str: String) = println(str)\n}\n```\n\nAnd then we can do the same, Foo() or Foo(“hello”)\n\n## Anonymous Lambda Parameter\n\nIn scala we can refer to the lambda parameter using an underscore, eg list.map(_.name) which is very concise and very readable. Kotlin doesn’t offer a direct equivalent but there is an implicit **it** parameter available: list.map { **it**.name }.\n\nThis has the drawback that its ever so slightly more verbose, but offers the advantage that you can use it in multiple places, eg, in Scala we can’t do\n\n```scala\nlist.map(_.firstname + _.lastname)\n```\n\nbut instead must introduce a parameter\n\n```scala\nlist.map(x => x.firstname + x.lastname)\n```\n\nIn Kotlin we can use the **it** parameter multiple times, eg\n\n```kotlin\nlist.map { it.firstname + it.lastname }\n```\n\n## Companion objects\n\nCompanion objects are supported in Kotlin using slightly different syntax. Instead of declaring an object with the same name, declare an object with the keyword companion inside the class itself.\n\n```kotlin\nclass Foo {\n companion object {\n   // methods here\n }\n}\n```\n\n## Extractors\n\nWhile kotlin doesn’t have extractors as such, it does support a limited form of extraction called desugaring declarations which go some way to performing the same job. Any class that implements the functions component1(), component2(), and so on (similar to the product() provided by Scala’s Product1, Product2, ProductN traits) can be desugared into component variables. For example\n\n```kotlin\nval person = Person(\"billy\", 21)\nval (name, age) = person\n```\n\nWhich is compiled into\n\n```kotlin\nval person = Person(\"billy\", 21)\nval name = person.component1()\nval age = person.component2()\n```\n\nIn Scala, case classes automatically extend the appropriate ProductN trait. In Kotlin data classes automatically implement the appropriate componentN() functions.\n\nThis also works in for statements, replacing the scala code:\n\n```scala\nfor ((a,b) <- person) { }\n```\n\nWith the almost identical\n\n```kotlin\nfor ((a,b) in person) { }\n```\n\nThat’s all for now. Hopefully this article provides some hints and tips for Scala developers who are interested in exploring a little bit of Kotlin.\n\n","author":"Stephen Samuel","date":"2016-04-14","type":"article","categories":["Scala","Kotlin"],"features":["highlightjs"],"description":"","filename":"","lang":"EN","enclosure":null},{"title":"Kotlin vs Java puzzlers","url":"https://vimeo.com/105758307","body":"\n\n[Kotlin vs Java puzzlers - Svetlana Isakova](https://vimeo.com/105758307)\n\n","author":"Svetlana Isakova","date":"2014-09-10","type":"video","categories":["Kotlin"],"features":["highlightjs"],"description":"","filename":"","lang":"EN","enclosure":null},{"title":"Scala vs Kotlin","url":"https://agilewombat.com/2016/02/01/scala-vs-kotlin/","body":"\nIt’s been a long time since I’ve updated this blog. Over the year I’ve moved away from Scala as my preferred language and towards Kotlin. I’ve found Kotlin a refreshing approach as its borrowed a lot of the good things I liked about Scala but kept it simple and practical by avoiding a lot of the gotchas and ambiguity that can exist in Scala.\n\nHere is a collection of things I like about Scala and Kotlin and also a comparison of how these features are accomplished in each language.\n\n## Type Declaration and Inference\n\nSomething I love about both these languages is they both have static typing with type inference. This gives you the power of compile time type checking with out the declarative boiler plate. Largely it works the same in both languages. Both languages also have preference to immutable type declaration as well with the optional type declaration being placed after the variable name.\n\nExample, the below code is the same in both languages:\n\nDeclare a immutable variable named age of type Int:\n\n```kotlin\nval age = 1\n```\n\nDeclare a mutable variable of type String:\n\n```kotlin\nvar greeting = \"Hello\"\n```\n\nBoth languages support lambda functions as first class citizens that can be assigned to variables or passed as function parameters.\n\nScala:\n\n```scala\nval double = (i: Int) => { i * 2 }\n```\n\nKotlin:\n\n```kotlin\nval double = {i: Int -> i * 2}\n```\n\n## Data / Case Class\n\nBoth Scala and Kotlin have a similar concept of a data class which can be use to represent a data model object.\n\n### Scala’s Approach\n\nScala calls this a case class and it can be defined like:\n\n```scala\ncase class Person(name: String, age: Int)\n```\n\nThis gives you the following main advantages over a normal class:\n\n* Has an apply method (You don’t need to use the ‘new’ word to construct instances)\n* Accessor methods are defined for each property (If property are defined as var then setters are also defined)\n* toString, equal and hashCode is sensibly defined\n* copy function\n* Has an unapply method (which allows use in match expressions)\n\n### Kotlin’s Approach\n\nKotlin calls this a data class and it’s defined like:\n\n```kotlin\ndata class Person(val name: String, val age: Int)\n```\n\nKey Features\n\n* Accessor methods are defined for each property (If property are defined as var then setters are also defined). This is not unique to data class and works on any class in Kotlin.\n* Sensibly defined toString, equal and hashCode\n* copy function\n* component1..componentN functions. Similar use to unapply.\n* Implements JavaBean getter and setters defined so native Java frameworks (Hibernate, Jackson) without change\n\nKotlin doesn’t need a special ‘apply’ method as it doesn’t require a ‘new’ keyword to instantiate class constructors. So this is a standard constructor definition like any other class.\n\n### Comparison\n\nGenerally data and case classes are similar.\n\nThis example usage works the same in Kotlin or Scala:\n\n```kotlin\nval jack = Person(\"Jack\", 1)\nval olderJack = jack.copy(age = 2)\n```\n\nGenerally I’ve found data and case classes interchangeable in day to day use. Kotlin does enforce some restriction on extending a data class with inheritance but its done for good reasons when you consider the implementations of equals and componentN functions and prevents the gotcha moments.\n\nThe Scala case classes can be more powerful in a match statements compared to Kotlin’s handling of data classes in ‘when’ statements which is something I miss.\n\nKotlin approach works a lot better when being used from existing Java frameworks as it will look like a normal java bean.\n\nBoth languages support supplying parameters by name and allow for default values.\n\n## Null Safety / Optionality\n\n### Scala’s Approach\n\nScala’s approach to null safety is the option monad. Simply an option can be one of two concrete types; Some(x) or None.\n\n```scala\nval anOptionInt: Option[Int] = Some(1)\n```\n\nOR\n\n```scala\nval anOptionInt: Option[Int] = None\n```\n\nYou can operate on the option using functions on the option class like “isDefined” and “getOrElse” (to provide a default value) but more commonly you would use monad operations like map, foreach or fold which will treat the option as a collection containing 0 or 1 elements.\n\nFor example to sum two Optionally defined Ints you could do:\n\n```scala\nval n1Option: Option[Int] = Some(1)\nval n2Option: Option[Int] = Some(2)\nval sum = for (n1 <- n1Option; n2 <- n2Option) yield { n1 + n2 }\n```\n\nThe variable sum will have the value Some(3). This is leveraging Scala’s for comprehension which can be foreach or a flat map function depending on the use of the yield keyword.\n\nAnother example of chaining could be:\n\n```scala\ncase class Person(name: String, age: Option[Int])\nval person:Option[Person] = Some(Person(\"Jack\",Some(1)))\nfor (p <- person; age <- p.age) {\n println(s\"The person is aged $age\")\n}\n```\n\nThis will print “The person is aged 1”\n\n### Kotlin’s Approach\n\nKotlin’s approach borrows from groovy style syntax and is very practical in every day use. In Kotlin all types are non-nullable and must be explicitly declared nullable using ‘?’ if it can contain null.\n\nThe same example could be written\n\n```kotlin\nval n1: Int? = 1\nval n2: Int? = 2\nval sum = if (n1 != null && n2 != null) n1 + n2 else null\n```\n\nThis is much closer to Java syntax except Kotlin will enforce compile time checks so its not possible to use a nullable variable without checking it is not null first so you won’t fear NullPointerExceptions. Its also not possible to assign a null to a variable declared as non-nullable. The compiler is quite smart in checking branch logic so you don’t have the situation of over guarding that you see in Java where the same variable is checked for null multiple times.\n\nAn equivalent Kotlin code for the second example of chaining is:\n\n```kotlin\ndata class Person(val name: String, val age: Int?)\nval person:Person? = Person(\"Jack\", 1)\nif (person?.age != null) {\n  println(\"The person is aged ${person?.age}\")\n}\n```\n\nAn alternative is also available using “let” which could replace the if block with\n\n```kotlin\nperson?.age?.let {\n  println(\"The person is aged $it\")\n}\n```\n\n## Comparison\n\nI really prefer the Kotlin approach. It’s a lot easier to read and understand what’s going on and multiple levels of nesting is easy to handle. The scala approach has symmetry in that other monads can be acted on the same as option can (e.g. futures) which some people like but I’ve found it can get complicated really fast once there is a little bit of nesting. There are also a lot of gotcha’s with for comprehension as under the covers they are maps or flat maps but you don’t get the compile time warnings if you do something wrong like mix monads or do a pattern match without covering alternative paths which leads to runtime exceptions that are cryptic.\n\nKotlin’s approach also bridges the gap when integrating with Java code as they can default to nullable types where as Scala still has to support null as a concept without null safety protection.\n\n## Functional Collections\n\nScala of course supports many functional goodies. Kotlin is a little more restrictive but the basics are covered.\n\nThere isn’t much difference in the basic fold and map functions.\n\nScala\n\n```scala\nval numbers = 1 to 10\nval doubles = numbers.map {_ * 2}\nval sumOfSquares = doubles.fold(0) {_ + _}\n```\n\nKotlin\n\n```kotlin\nval numbers = 1..10\nval doubles = numbers.map {it * 2}\nval sumOfSquares = doubles.fold(0) {x,y -> x+y}\n```\n\nBoth support the concept of lazy evaluated sequences. For example printing first 10 even squares.\n\nScala\n\n```scala\nval numbers = Stream.from(1) // all natural numbers\nval squares = numbers.map {x => x * x}\nval evenSquares = squares.filter {_%2 == 0}\nprintln(evenSquares.take(10).toList)\n```\n\nKotlin\n\n```kotlin\nval numbers = sequence(1) {it + 1} // all natural numbers\nval squares = numbers.map {it * it}\nval evenSquares = squares.filter {it%2 == 0}\nprintln(evenSquares.take(10).toList())\n```\n\n## Implicits Conversion vs Extension Functions\n\nThis is an area where Scala and Kotlin diverge a little.\n\n### Scala’s Approach\n\nScala has a a concept of implicit conversion that allows you to add extra behaviour to a class by automatically converting to another class when needed. An example of this\n\n```scala\nobject Helpers {\n implicit class IntWithTimes(x: Int) {\n   def times[A](f: => A): Unit = {\n    for (i <- 1 to x) {\n     f\n    }\n  }\n }\n}\n```\n\nThen later in the code you can do:\n\n```scala\nimport Helpers._\n5.times(println(\"Hello\"))\n```\n\nThis will print “Hello” 5 times. How this works is when you try to use the “times” function which doesn’t exist on the Int the object will be automatically boxed into an IntWithTimes object and the times function will executed on that.\n\n### Kotlin’s Approach\n\nKotlin has the concept of extension functions that can be used to accomplish a similar job. In the Kotlin approach you define a normal function but prefix the function name with a type to extend.\n\n```kotlin\nfun Int.times(f: ()->Unit) {\n  for (i in 1..this) {\n    f()\n  }\n}\n \n5.times {println(\"Hello\")}\n```\n\n### Comparison\n\nKotlin approach fits the use case that I generally would use this Scala capability for and has the advantage of being a little simpler to understand.\n\n## Scala Features Not Present in Kotlin that I won’t Miss\n\nOne of the best part of the Kotlin language for me is not the features it has but more the features from Scala that are not in Kotlin\n\n* Call by name – This destroys readability. If a function is being passed its a lot easier when its visible that its a function pointer in a basic review of the code. I don’t see any advantage this gives over passing explicit lambdas\n* Implicit parameters – This is something I’ve really hated. It leads to situation of code changing drastically based on a change of import statement. It makes it really hard to tell what values will be passed to a function without good IDE support\n* Overloaded FOR comprehension – To me this is a clunk to get around the problem with dealing with multiple monads\n* The mess with optional syntax on infix and postfix operators – Kotlin is little more prescriptive and means that the code is less ambiguous to read and not as easy for simple typo to become a non-obvious error\n* Operator Overload to the Max – Kotlin allows basic operator overloads for the basic operators (+, – etc.) but Scala allows any bunch of characters to be used and it seems to have been embraced by library developers. Am I really meant to remember difference between “~%#>” and “~+#>”?\n* Slow compile times\n\n","author":"Lionel","date":"2016-02-01","type":"article","categories":["Kotlin","Scala"],"features":["highlightjs"],"description":"","filename":"","lang":"EN","enclosure":null},{"title":"Kotlin 1.0.4 is here","url":"https://blog.jetbrains.com/kotlin/2016/09/kotlin-1-0-4-is-here/","body":"\nWe’re happy to announce the release of a new bugfix and tooling update of Kotlin, version **1.0.4**. This version brings many improvements related to the IDE and build tools, as well as JavaScript support.\n\nOnce again we’d like to thank our external contributors who implemented some of the features in this release, [**Kirill Rakhman**](https://github.com/cypressious) and [**Yoshinori Isogai**](https://github.com/shiraji), as well as everyone who tried the EAP builds of 1.0.4 and sent us feedback.\n\nYou can find the full list of fixes and improvements in the [changelog](https://github.com/JetBrains/kotlin/blob/1.0.4/ChangeLog.md). Some of the changes deserve special mention:\n\n### Language Change: Assignment of ‘val’ in try/catch\n\nIn versions of Kotlin before 1.0.4, you could initialize the same `val` both in the `try` and `catch` branches of a `try/catch` statement. For example, the following code was allowed:\n\n```kotlin\nval x: Int\ntry {\n    x = 1\n}\ncatch(e: Exception) {\n    x = 2\n}\n```\n\nIn effect, a final variable could be assigned twice, and it was possible to observe two different values for it (for example, if the value in the `try` statement was captured in a lambda). In Java, the equivalent code is not allowed.\n\nTo maintain consistent semantics, the code which assigns the same `val` in both `try` and `catch` branches **becomes a warning** in Kotlin 1.0.4 and will **become an error** in version 1.0.5. In most cases, the code can be easily fixed by converting the code to an expression form, and the IDE will **offer a quickfix** to convert this code automatically. The above example would be converted to:\n\n```kotlin\nval x = try { \n    1\n}\ncatch(e: Exception) {\n    2\n}\n```\n\n### New Experimental Annotation Processing\n\nKotlin 1.0.4 includes a new experimental implementation of the annotation processing API. To enable it, add the following to your build.gradle:\n\n`apply plugin: 'kotlin-kapt'`\n\nYou also need to **remove** the snippet that enables old annotation processing:\n\n```kotlin\nkapt {\n    generateStubs = true\n}\n```\n\nThe new annotation processing still has known issues and may not be compatible with all annotation processors. You should enable it only if you’ve run into problems with the default `kapt` annotation processing implementation.\n\n### JavaScript Backend Improvements\n\nThe JavaScript backend can now compile code to modules which are compatible with AMD, CommonJS and UMD module systems. See [the documentation](http://kotlinlang.org/docs/reference/js-modules.html) for more details.\n\nIn addition to that, a limited form of reflection is now supported: you can use the `jsClass` property to access the runtime class of any object, and `jsClass<TypeName>()` to get the runtime representation of a specific class. Here’s a more complete example:\n\n```kotlin\nclass A\nclass B\nclass C\n\ninline fun <reified T> foo() {\n    println(jsClass<T>().name)\n}\n\nprintln(A().jsClass.name) // prints \"A\"\nprintln(jsClass<B>().name) // prints \"B\"\nfoo<C>() // prints \"C\"\n```\n\n### Compiler Improvements\n\n* Better type inference for callable expressions\n* More efficient bytecode for several cases of `when` and `for` expressions\n* Better parser recovery after syntax errors\n* Fixed several cases when “Cast never succeeds” warning was incorrectly reported\n\n### Build Tools Improvements\n\n* Full compatibility with Gradle 2.14 and later.\n* Gradle incremental compilation can now track changes between subprojects.\n* CLI and Ant builds add the Kotlin reflection library to the classpath by default; use the `no-reflect` switch to disable.\n\n### New Features in the IDE\n\n[![kotlinevaluate](https://i1.wp.com/blog.jetbrains.com/kotlin/files/2016/09/KotlinEvaluate.png?resize=640%2C648&ssl=1)](https://i1.wp.com/blog.jetbrains.com/kotlin/files/2016/09/KotlinEvaluate.png?ssl=1)\n\n* You now have the option to use Kotlin syntax when evaluating expressions and watches in Java files\n* New inspection to detect “leaking `this`” – possible NullPointerException issues caused by access to incompletely initialized data.\n* Intention to convert a lambda to a function reference\n* Inspection to detect mismatches between Gradle version and Kotlin plugin version\n* Many other new intentions, inspections and quickfixes\n\n### How to update\n\nTo update the plugin, use Tools | Kotlin | Configure Kotlin Plugin Updates and press the “Check for updates now” button. Also, don’t forget to update the compiler and standard library version in your Maven and Gradle build scripts.\n\nAs usual, if you run into any problems with the new release, you’re welcome to ask for help on the [forums](https://discuss.kotlinlang.org/), on Slack (get an invite [here](http://kotlinslackin.herokuapp.com/)), or to report issues in the [issue tracker](https://youtrack.jetbrains.com/issues/KT).\n\nLet’s Kotlin!\n\n","author":"Dmitry Jemerov","date":"2016-09-22","type":"article","categories":["Kotlin","Release"],"features":["highlightjs"],"description":"","filename":"","lang":"EN","enclosure":null},{"title":"What’s in store for Kotlin this year","url":"https://jaxenter.com/whats-in-store-for-kotlin-this-year-126672.html","body":"\n*Taking a peek into the near future*\n\nAndrey Breslav, the lead language designer of Kotlin at JetBrains, is spilling the beans about the next Kotlin release in a new [video](https://realm.io/news/andrey-breslav-whats-next-for-kotlin-roadmap/). Breslav talks about where Kotlin stands right now and what’s next for it.\n\nThree months after releasing Kotlin 1.0.1, Andrey Breslav,  the lead language designer of Kotlin, shared a [video](https://realm.io/news/andrey-breslav-whats-next-for-kotlin-roadmap/) in which he explained where this programming language stands and what’s next for it.\n\n<iframe webkitallowfullscreen=\"true\" mozallowfullscreen=\"true\" allowfullscreen=\"true\" src=\"//speakerdeck.com/player/f1dea41f659a4c70a6e8fb20291b871b?\" style=\"border: 0px none; background: transparent none repeat scroll 0% 0%; margin: 0px; padding: 0px; border-radius: 5px; width: 960px; height: 480px;\" frameborder=\"0\"></iframe>\n\nBreslav announced that the development is in two lines: the incremental updates, 1.0.2, 1.0.3, which are source compatible, and 1.1 —another parallel line where they do language features, and their source compatibility is backward compatibility. 1.0 may not be able to compile 1.1.\n\n## Goals: Java 8/9\n\nBreslav revealed that their current target is Java 6, which means that whatever users compile in Kotlin can run on anything which runs Java 6, including Java 8/9. JetBrains is now working on generating default methods for Java 8 because even though one can always implement methods and interfaces in Kotlin, extending such an interface in Java is not possible with Java 6 since it wouldn’t know that those methods are implemented.\n\nFurthermore, the support library for Java 8 streams will be removed in Kotlin 1.1.\n\nThe lead language designer of Kotlin answered a question that has been on everybody’s lips in the past few months, namely “Can I run Kotlin in a native environment without a virtual machine?” Although the answer is “No,” Breslav sweetened it by suggesting that this is not a permanent answer.\n\nClick [here](https://realm.io/news/andrey-breslav-whats-next-for-kotlin-roadmap/) if you want to see the video or read the entire summary.\n\n**SEE ALSO: [10 features I wish Java would steal from the Kotlin language](https://jaxenter.com/10-features-i-wish-java-would-steal-from-the-kotlin-language-2-125308.html)**\n\n## An unexpected ode to Kotlin\n\nKotlin is loved —we can conclude this after seeing Java champion [Lukas Eder](https://jaxenter.com/10-features-i-wish-java-would-steal-from-the-kotlin-language-2-125308.html) and former Bitcoin core developer [Mike Hearn](https://medium.com/@octskyward/why-kotlin-is-my-next-programming-language-c25c001e26e3#.b3lyfhjmr) praise this language. In his ode to Kotlin, Hearn opined that this programming language will be a very successful project because it comes from industry, not academia, it costs nothing to adopt, it can be learned in a few hours and it enforces no particular philosophy of programming. Kotlin imposes no runtime overhead, is highly suitable for enterprise Java shops and adopting it is low risk.\n\nBecause nothing is perfect in this world, Hearn also encountered some issues while using Kotlin: there are no type aliases yet, the IDE plugin still throws exceptions more often than it should and it targets Java 6 bytecode. Plus, the community is still experiencing its growth pains and is pickier about some things than Java, but the good news is that Kotlin is outgrowing its minuses.\n\n","author":"Gabriela Motroc","date":"2016-06-02","type":"article","categories":["Kotlin"],"features":["highlightjs"],"description":"","filename":"","lang":"EN","enclosure":null},{"title":"The Future of Kotlin: How agile can language development be?","url":"https://mixitconf.org/en/2017/the-future-of-kotlin-how-agile-can-language-development-be-","body":"\nA successful project usually grows, and Kotlin is no exception. We are adding new targets (JavaScript and Native) and new computation models (coroutines). This talk is about our vision of the future of Kotlin as a language and a ecosystem.\n\nWe'll talk strategy: what we think our industry needs at large and how we are going to fit Kotlin into this picture. We'll talk tactics: how we deal with legacy and compatibility issues, and whether there will ever be Kotlin 2.0. We'll talk operations: can we do “continuous delivery” for language features? Or, more generally, how agile can language development be?\n\n<iframe src=\"https://player.vimeo.com/video/215556547?title=0&byline=0&portrait=0\" width=\"960\" height=\"540\" frameborder=\"0\" webkitallowfullscreen mozallowfullscreen allowfullscreen></iframe>\n","author":"Andrey Breslav","date":"2017-04-30","type":"video","categories":["Kotlin"],"features":["highlightjs"],"description":"","filename":"","lang":"EN","enclosure":null},{"title":"Rest API plumbing with kotlin","url":"https://medium.com/@gz_k/rest-api-plumbing-with-kotlin-b161af052178#.tdrmb8p5w","body":"\n### Rest API plumbing with kotlin\n\nAs a startup developper, I spend a lot of my time dealing with REST APIs. It can be internal APIs for our web applications or external APIs for integration with online services (email, documents, ...). For both uses, Kotlin features help a lot. Lets see how.\n\n![](https://d262ilb51hltx0.cloudfront.net/max/800/1*hzb7OdfBZ9vYEosTTfLddg.png)\n_Internal and external REST calls_\n\n#### Internal APIs\n\nRegardless the web framework we use (my preferred one is currently _Ember.js_) the client/server communication is commonly implemented via a REST API exchanging data in JSON.\n\nWe define our API by specifying URLs and the JSON Format. URLs’ definition is managed by the web framework. As for the JSON format, jackson is a good solution for serializing POJOs. The structure of the JSON object is defined by the POJOs property names. To be sure to have an API independent of our domain objects, we need to have specific classes for the client-server communication.\n\nJackson is a nice framework that converts java classes to JSON seamlessly. The main problem with java is the verbosity of those POJOs classes. Even basic javabeans with no logic and no method seems bloated.\n\nIn the other hand, Kotlin data classes are really concise and allow generally to define data objects in a single line.\n\nFor all JSON inputs and outputs, we can have the data classes contained in the same file/class as the Rest Controller.\n\n![](https://d262ilb51hltx0.cloudfront.net/max/800/1*xdUrq3OnbITKiS4yXQhBnw.png)\n_Kotlin files that contains both the controller and the data classes_\n\n![](https://d262ilb51hltx0.cloudfront.net/max/800/1*XVMVPgmMzeBa4dBCa0TGAA.png)\n_Defining a PUT call with spring and kotlin_\n\n\nThe Nullabillity type system of Kotlin gives more control and information on the input/output format. In the example above, the documentId can be null by specification.\n\nIn that call, the client expects an empty JSON object (?!). We can provide it by returning an instance of the _Empty_ class.\n\nFor inputs, we need to use [jackson’s Kotlin](https://github.com/FasterXML/jackson-module-kotlin) module. It manages the constructor calls to avoid creating unnecessary empty constructors.\n\nIn less than 20 lines of kotlin we have defined our REST call, the URL and the format.\n\n#### External APIs and the bounded context pattern\n\nBeyond the issue of connecting with an external API and the technical part of it (remote calls, authentication,...) as developers we have to manage the [**Bounded Context pattern**](http://martinfowler.com/bliki/BoundedContext.html).\n\nThe external system has its own domain model, which makes sense in its context, but is certainly different from our model/context.\n\nFor example, the representation of Google Files in Google Drive is different from our file domain.\n\nWhen retrieving objects from the external API we have to **transform those objects in our own model**. The transformation must deal with the values (retrieved or not) and the type of (generally different) properties .\n\nImagine the following naive class for my domain file:\n\n```kotlin\nclass MyFile(\n   val name:String,\n   val creationDate: Instant,\n   val modificationDate:Instant)\n```\n\nIn the [Google API](https://developers.google.com/resources/api-libraries/documentation/drive/v2/java/latest/) dates are using _com.google.api.client.util.DateTime_ type for creation and modification dates.\n\nA first conversion function could be:\n\n```kotlin\nfun gFileToMyFile(gFile: File) = MyFile(\n    gFile.title,\n    Instant.ofEpochMilli(gFile.createdDate.value),\n    Instant.ofEpochMilli(gFile.modifiedDate.value))\n```\n\nIt’s quite verbose and hard to read. We can improve the code by implementing a **property extension** on the google DateTime class:\n\n```kotlin\nval DateTime.instant: Instant\n    get() = Instant.ofEpochMilli(value)\n```\n\nThe DateTime class now has a new property simplifying the previous code snippet:\n\n```kotlin\nfun gFileToMyFile(gFile: File) = MyFile(\n    gFile.title,\n    gFile.createdDate.instant,\n    gFile.modifiedDate.instant)\n```\n\nWe can go further and **replace this function** with an **extension function** on the Google File class to call the transformation directly on the Google File instances.\n\n```kotlin\nfun File.toMyFile() = MyFile(\n    title,\n    createdDate.instant,\n    modifiedDate.instant)\n```\n\nConverting a single Google File is now as easy as:\n\n```kotlin\nval myFile = gFile.toMyFile()\n```\n\nAnd the conversion of a list of files is done by mapping the original list using a function reference:\n\n```kotlin\nval myFiles = gFiles.map ( File::toMyFile )\n```\n\nImplementing the 2 conversions (_Google DateTime => java Instant_ and _Google File => MyFile)_ with small **extensions** results in much more readable code.\n\n**For both uses, managing internal and external APIs, Kotlin appears to be** [**a great tool**](https://blog.jetbrains.com/kotlin/2016/02/kotlin-1-0-released-pragmatic-language-for-jvm-and-android/)**.**\n\n","author":"Gaetan Zoritchak","date":"2016-03-29","type":"article","categories":["Spring","Kotlin"],"features":["highlightjs"],"description":"","filename":"","lang":"EN","enclosure":null},{"title":"Kotlin in Practice with Spring Boot and Vaadin","url":"https://blog.philipphauer.de/kotlin-practice-spring-boot-vaadin/","body":"\nCoding with Kotlin is great fun. But things are getting really interesting when we try to use Kotlin in conjunction with popular frameworks like Spring Boot and Vaadin. The development with those frameworks can benefit a lot from Kotlin. However, we have to pay attention to some pitfalls.\n\n![Kotlin in Practice with Spring Boot and Vaadin](https://blog.philipphauer.de/wp-content/uploads/2016/12/kotlin-in-practice-featured-image.png \"Kotlin in Practice\")\n\n# TL;DR\n\n* The development with Spring Boot and Vaadin significantly benefits from Kotlin.\n* **Spring**:\n    * Due to Kotlin’s compact constructor and field declaration, there is no reason for using field injection anymore. Constructor injection comes without any boilerplate.\n    * Placing all classes for the external configuration properties in a single Kotlin file comes in handy.\n    * However, you have to pay attention to some pitfalls when using Kotlin’s data classes. Especially the missing default constructor is a problem for some libraries like Jackson or Spring Data MongoDB.\n* **Vaadin**:\n    * Vaadin is highly event-driven. You are dealing a lot with event listeners. Fortunately, Kotlin allows us to write very concise event listeners using function references and lambdas.\n    * Kotlin’s `apply()` method is extremely useful when you define UI components and layouts in Vaadin. It increases the readability: You can group your initialization code for a component and directly see the layout nesting in the code.\n    * Using Kotlin’s data classes we can easily write beans that can be bound to Vaadin’s `BeanItemContainers`. The single expression functions can be used to map from one data classes to another (e.g. persistence entities to UI beans).\n    * The mentioned points also apply for other GUI Frameworks like Swing, JavaFX and GWT.\n\n# Source\n\nI create a small project using Kotlin, Spring Boot, Spring Data MongoDB and Vaadin. Check out my GitHub repository [kotlin-spring-boot-vaadin-scaffolding](https://github.com/phauer/blog-related/tree/master/kotlin-spring-boot-vaadin-scaffolding).\n\n# General\n\n## Putting Multiple Classes in a Single File\n\nKotlin allows putting multiple classes in a single file. This is great to overcome the flood of files in Java. Moreover, you can group classes together, that belong semantically together. Examples:\n\n* Entity classes for the persistence layer\n* DTO classes for JSON serialization\n* Classes for Spring’s external configuration properties (YAML)\n* UI Components that belong together (like a Window class that is only used in a certain View)\n\n```kotlin\ndata class BlogEntity (\n        val author: AuthorEntity,\n        val date: Instant,\n        val content: String\n)\ndata class AuthorEntity(val firstName: String, val lastName: String)\n```\n\n## Value Objects\n\nDomain-Driven Design tells us to use Value Objects to increase readability and safety. But in chatty Java you won’t create a whole new class (in a new file) only to wrap a single String. Just think about a class like `EmailAddress`. However, in Kotlin, the definition of such a Value Object is a one-liner.\n\n```kotlin\ndata class EmailAddress(val address: String)\n\n//without value object:\nfun process1(emails: List<String>) {}\n\n//with value object:\nfun process2(emails: List<EmailAddress>) {}\n//=> expressive, readable, safe\n```\n\nThere is no excuse for not using Value Objects anymore!\n\n# Spring Boot\n\nIf you want to use Kotlin in conjunction with Spring Boot the post [“Developing Spring Boot applications with Kotlin”](https://spring.io/blog/2016/02/15/developing-spring-boot-applications-with-kotlin) is a good starting point.\n\n## Constructor Injection without Boilerplate\n\n[Field injection is evil](http://olivergierke.de/2013/11/why-field-injection-is-evil/) due to poor testability. So constructor injection is the preferred way, but it requires more boilerplate in Java.\n\n```java\npublic class CustomerResource {\n\n    private CustomerRepository repo;\n    private CRMClient client;\n\n    public CustomerResource(CustomerRepository repo, CRMClient client) {\n        this.repo = repo;\n        this.client = client;\n    }\n}\n```\n\nThat’s why I used to prefer field injection – until I started to use Kotlin. Kotlin completely removes the boilerplate.\n\n```kotlin\nclass CustomerResourceKotlin(private val repo: CustomerRepository,\n                             private val client: CRMClient) {\n}\n```\n\nFirst, Kotlin combines the class definition with the constructor definition. Second, the `val` keyword before the constructor parameters tells Kotlin to create a field and to assign the parameter to this field. Note, that we can [leave out the `@Autowired` annotation](https://spring.io/blog/2016/03/04/core-container-refinements-in-spring-framework-4-3) if you only have a single constructor.\n\nSo you get the benefits of constructor injection without having the drawbacks. This way, there is no reason to use field injection anymore.\n\n## The Missing Default Constructor in Kotlin\n\nKotlin’s data classes don’t have a default constructor (non-arg). However, many mapping/serialization libraries rely on the existence of this default constructor. Jackson and Spring Data MongoDB are such libraries.\n\n### Jackson\n\nJackson’s deserialization fails with the following error:\n\n```\nFailed to instantiate [ClassName]: No default constructor found;\nnested exception is java.lang.NoSuchMethodException: ClassName.<init>()\n```\n\nThe solution is easy: Adding the [jackson-module-kotlin](https://github.com/FasterXML/jackson-module-kotlin) to you classpath will do the trick.\n\n### Spring Data MongoDB\n\nSpring Data MongoDB also requires a default constructor if you use default parameter values.\n\n```\nCaused by: org.springframework.data.mapping.model.MappingInstantiationException:\nFailed to instantiate de.philipphauer.blog.scaffolding.db.SnippetEntity using constructor NO_CONSTRUCTOR with arguments\n...\nCaused by: org.springframework.beans.BeanInstantiationException:\nFailed to instantiate [de.philipphauer.blog.scaffolding.db.SnippetEntity]: No default constructor found;\nnested exception is java.lang.NoSuchMethodException: de.philipphauer.blog.scaffolding.db.SnippetEntity.<init>()\n```\n\nBut you can fix this easily by adding the `@PersistenceConstructor` annotation.\n\n```kotlin\n@Document(collection=\"snippets\")\ndata class SnippetEntity @PersistenceConstructor constructor(\n        @Id val id: ObjectId? = null, //default value\n        val code: String,\n        val author: AuthorEntity\n)\ndata class AuthorEntity(\n        val firstName: String,\n        val lastName: String\n)\n```\n\n## External Configuration Properties (YAML)\n\n```kotlin\n@Configuration\n@ConfigurationProperties(prefix = \"myapp\")\nopen class MyAppProps {\n    @NotNull lateinit var requiredProp: String\n    var optionalProp: String? = null\n}\n\n@Configuration\n@ConfigurationProperties(prefix = \"myapp.authentication\")\nopen class AuthenticationProps {\n    @NotNull lateinit var url: String\n    var credentials: Credentials? = null\n}\nclass Credentials{\n    @NotNull lateinit var userName: String\n    @NotNull lateinit var userPassword: String\n}\n```\n\n* I personally really like to have all my configuration classes in a single file.\n* In order to enable Spring to set the values, you have to use `var` instead of `val`.\n* Use `lateinit` to tell the Kotlin compiler, that this field is initialized by a framework. This way, we can make the field null-safe without having to initiate it.\n* The `@NotNull` annotation will cause Spring to check _during startup_ if a property is specified. So the service won’t start at all. Without the annotation, you’ll only get an error when you _access_ the value. So you may not notice a misconfiguration immediately.\n\n## Open you Classes and Methods for Spring\n\nBy default classes and methods in Kotlin are final. If you want to open a class for subclassing or a method for overriding you have to explicitly declare them as `open`. Spring requires this in several cases:\n\n* Classes for external configuration properties.\n* Spring Configuration: Make both the class and the `@Bean`-methods non-final.\n\n```kotlin\n@Configuration\nopen class SpringConfiguration {\n    @Bean\n    @Scope(\"prototype\")\n    open fun logger(injectionPoint: InjectionPoint): Logger {\n        return LoggerFactory.getLogger(injectionPoint.methodParameter.containingClass)\n    }\n}\n```\n\nBut that’s no big deal at all because Spring will raise an error if you forget the `open` keyword:\n\n```\norg.springframework.beans.factory.parsing.BeanDefinitionParsingException:\nConfiguration problem: @Configuration class 'SpringConfiguration' may not be final.\nRemove the final modifier to continue.\n```\n\n# Vaadin\n\n## Concise Even Listener with Kotlin’s Lambdas\n\n[Vaadin is highly event-driven](https://blog.philipphauer.de/evaluating-vaadin-strengths-weaknesses/): You are dealing a lot with event listeners. Fortunately, Kotlin allows us to write very concise event listeners.\n\nOption 1: Use function references. That’s the most compact notation. But, it’s not really different from Java 8:\n\n```kotlin\nbutton.addClickListener(::greet)\n```\n\nOption 2: Use lambdas. Kotlin’s lambda notation is more intuitive and slightly shorter than Java’s. First, we use curly braces to specify a lambda in Kotlin. This makes them look like a function body (which is what they are). Second, we can leave out the regular parameter braces `()`, if the lambda is the last parameter.\n\n```kotlin\nbutton.addClickListener {event -> greet(event)}\n```\n\nOption 3: Use lambdas with the implicit single parameter name `it`. If the lambda has only a single parameter, we can omit the parameter declaration and use `it` to refer to the parameter.\n\n```kotlin\nbutton.addClickListener {greet(it)}\n```\n\n## Structuring UI Definitions with apply()\n\nEvery object in Kotlin has the built-in [`apply()` method](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/apply.html). It returns the receiver object and takes a function as a parameter. Within this function, you can call methods on your object. This comes in handy when we want to define and initialize UI components in Vaadin.\n\n```kotlin\nval myTable = Table(\"MyTable\", container).apply {\n   setSizeFull()\n   setColumnHeader(PropertyIds.CODE, Labels.CODE)\n   setColumnHeader(PropertyIds.AUTHOR, Labels.AUTHOR)\n   setColumnHeader(PropertyIds.DATE, Labels.DATE)\n   setColumnHeader(PropertyIds.STATE, Labels.STATE)\n   addGeneratedColumn(PropertyIds.CODE, ShortenedValueColumnGenerator)\n   setConverter(PropertyIds.DATE, StringToInstantConverter)\n}\n```\n\nFirst of all, it’s concise. We don’t have to write the variable name `myTable` again and again. Secondly, we group the initialization logic for the UI component at a single point. This makes the code more readable.\n\nMoreover, we can use this approach to make the UI hierarchy and nesting visible in the code:\n\n```kotlin\nval layout = FormLayout().apply {\n   setMargin(true)\n   isSpacing = true\n   val codeLabel = Label().apply {\n       contentMode = ContentMode.HTML\n       caption = Labels.CODE\n       value = snippet.code\n   }\n   val stateLabel = Label().apply {\n       contentMode = ContentMode.HTML\n       caption = Labels.STATE\n       value = \"${snippet.state.toIcon().html} ${snippet.state.toLabel()}\"\n   }\n   val authorLabel = Label().apply {\n       caption = Labels.AUTHOR\n       value = snippet.author\n   }\n   val closeButton = Button(\"Close\", FontAwesome.CLOSE).apply {\n       addClickListener { close() }\n   }\n   addComponents(codeLabel, authorLabel, stateLabel, closeButton)\n}\n```\n\nIt’s obvious which component is contained in which layout. You just have to look at the indent. But don’t exaggerate this. If your method gets to long, consider using submethods or a dedicated component class.\n\n`Apply()` is also useful, when you [bind member fields](https://vaadin.com/docs/-/part/framework/datamodel/datamodel-itembinding.html#datamodel.itembinding.formclass) of a form to item properties (using `FieldGroup.bindMemberFields()`).You can bundle the definition and configuration of the form field in one place. So the constructor becomes very short.\n\n```kotlin\nclass CreateSnippetForm : FormLayout() {\n\n    @PropertyId(PropertyIds.CODE)\n    val code = TextArea(Labels.CODE).apply {\n        nullRepresentation = \"\"\n        setWidth(100f, Sizeable.Unit.PERCENTAGE)\n        isRequired = true\n        addStyleName(\"monospace\")\n    }\n\n    @PropertyId(PropertyIds.AUTHOR)\n    val author = TextField(Labels.AUTHOR).apply {\n        nullRepresentation = \"\"\n        setWidth(100f, Sizeable.Unit.PERCENTAGE)\n    }\n\n    val createButton = Button(\"Create Snippet\", FontAwesome.CODE)\n\n    init {\n        setSizeFull()\n        isSpacing = true\n        addComponents(code, author, createButton)\n    }\n}\n\n//usage:\nval form = CreateSnippetForm().apply {\n   createButton.addClickListener { createSnippet() }\n}\nval emptySnippet = SnippetCreationBean()\nval fieldGroup = BeanFieldGroup.bindFieldsUnbuffered(emptySnippet, form)\n```\n\n## Data Classes for Beans and Concise Mapping\n\nVaadin’s `BeanItemContainer` is very handy. It allows binding arbitrary beans to UI controls. In Java, however, the bean class definition is [extremely verbose, hard to read and error-prone](/kotlin-java-ecosystem-language/#Example_1_Define_and_Map_Beans). Using Kotlin, we only need a few lines:\n\n```kotlin\n// Persistence entities in Entities.kt:\ndata class SnippetEntity(\n        val code: String,\n        val author: AuthorEntity,\n        val date: Instant\n)\ndata class AuthorEntity(val firstName: String, val lastName: String)\n\n// UI beans in Beans.kt:\ndata class SnippetOverviewBean(\n        val code: String,\n        val author: String,\n        val date: Instant\n)\n```\n\nAlso the mapping from one class to another is very concise and readable. Thanks to single expression functions and named arguments. Let’s assume we want to map the MongoDB entities to their beans counterparts (which are supposed to be used within a `BeanItemContainer`).\n\n```kotlin\nfun mapToBeans(entities: List<SnippetEntity>) = entities.map(::mapToBean)\n\nfun mapToBean(entity: SnippetEntity) = SnippetOverviewBean(\n        code = entity.code,\n        date = entity.date,\n        author = \"${entity.author.firstName} ${entity.author.lastName}\"\n)\n```\n\n## Putting UI classes together\n\nAs already mentioned above, Kotlin allows putting several top-level (public) classes in one file. Yes, you should use this with sound judgment. But in cases where a UI component (like a window or a form class) is only used in a single location (like a view) I locate these classes in a single Kotlin file. This arrangement states clearly: This window belongs to this view and is only used here. Sure, if the window class grows, you may need to move them to separate file in order to keep the view class readable.\n\n## Extension Functions for Adding UI-Related Logic\n\nWith Kotlin’s extension functions you can add a method to an existing class. On the one hand, this can be useful when the class is not under your control (like `String`). On the other hand, it can be a nice mean to clearly separate concerns and layers.\n\nLet’s assume the following enum:\n\n```kotlin\nenum class SnippetState {ACTIVATED, DEACTIVATED}\n```\n\nLet’s say that we want to write the functions `toLabel()` and `toIcon()`, but we don’t want to put these UI-related methods in the enum, which is also used in the persistence layer. In good old Java we would define static helper methods, but in Kotlin there are the elegant extension methods:\n\n```kotlin\nfun SnippetState.toIcon() = when (this){\n    SnippetState.ACTIVATED -> FontAwesome.THUMBS_O_UP\n    SnippetState.DEACTIVATED -> FontAwesome.THUMBS_O_DOWN\n}\nfun SnippetState.toLabel() = when (this){\n    SnippetState.ACTIVATED -> \"Activated\"\n    SnippetState.DEACTIVATED -> \"Deactivated\"\n}\n//usage:\nval icon = state.toIcon()\n//intuitive and readable\n```\n\n## Stateless UI Classes with Lambdas or `object`-Singletons\n\nIn Vaadin you often have to write stateless UI classes implementing `Table.ColumnGenerator` or `Converter`. The easiest way to implement them is to use function references.\n\n```kotlin\nprivate fun generateDetailsButton(source: Table, itemId: Any, columnId: Any) = Button(\"Details\").apply {\n    addStyleName(ValoTheme.BUTTON_LINK)\n    addClickListener { Notifications.show(\"Details!\") }\n}\n//Usage:\ntable.addGeneratedColumn(\"Details\", ::generateDetailsButton)\n```\n\nHowever, there might be cases where this approach is not sufficient. In those cases, Kotlin’s built-in way to define singleton comes in handy. Just use the keyword `object` instead of `class`.\n\nCase 1: You want to group multiple fields and methods together. This way, you can show that a field or method is only relevant in a certain context/class. This leads to high [cohesion](https://en.wikipedia.org/wiki/Cohesion_(computer_science)).\n\n```kotlin\nprivate object ShortenedValueColumnGenerator : Table.ColumnGenerator {\n    private val MAX_LENGTH = 20\n\n    override fun generateCell(source: Table, itemId: Any, columnId: Any): Any?{\n        val log = source.getItem(itemId).getItemProperty(columnId).value as? String\n        return log?.shortenWithEllipsis()\n    }\n\n    fun String.shortenWithEllipsis(): String{\n        if (this.length > MAX_LENGTH){\n            return \"${this.substring(0, MAX_LENGTH)}...\"\n        }\n        return this\n    }\n}\n//It's easy to reference the singleton:\ntable.addGeneratedColumn(PropertyIds.CODE, ShortenedValueColumnGenerator)\n```\n\nCase 2: The interface has more than one method. So it’s not a SAM/Functional Interface and you can’t use a lambda.\n\n```kotlin\nobject StringToInstantConverter : Converter<String, Instant> {\n    private val DATE_FORMATTER: DateTimeFormatter = DateTimeFormatter.ofPattern(\"dd.MM.yyyy HH:mm:ss Z\")\n            .withLocale(Locale.UK)\n            .withZone(ZoneOffset.UTC)\n\n    override fun convertToPresentation(value: Instant?, targetType: Class<out String>?, locale: Locale?)\n            = DATE_FORMATTER.format(value)!!\n\n    override fun convertToModel(value: String?, targetType: Class<out Instant>?, locale: Locale?): Instant {\n        throw UnsupportedOperationException(\"Not yet implemented\")\n    }\n\n    //enjoy the beauty of the following method definitions:\n    override fun getPresentationType() = String::class.java \n    override fun getModelType() = Instant::class.java\n}\n```\n\n","author":"Philipp Hauer","date":"2016-12-21","type":"article","categories":["Kotlin","Vaadin"],"features":["highlightjs"],"description":"","filename":"","lang":"EN","enclosure":null},{"title":"Kotlin, rockin’ in production","url":"https://medium.com/@nimtiazm/kotlin-rockin-in-production-c9469a6ea46f#.rghu09qbd","body":"\nArguably, Kotlin has been getting a lot more attention in Android circles compared to otherwise. The reasons mostly cited are:\n\n* It has rich and succinct syntax\n* Null-safety is built into the language\n* It comes with a compact runtime (~736 KB)\n* It’s interoperability with Java (and standard/OSS Java libraries) actually works\n* It generates efficient bytecode\n\nSeasoned Kotlin developers generally add two more:\n\n* Extension functions are game changers\n* Kotlin community is very helpful and diverse ([https://kotlinlang.slack.com/](https://kotlinlang.slack.com/))\n\nWhat might actually surprise you is, “being mobile first/friendly” was the reason I chose Kotlin to do the backend stuff over other choices on the JVM. The design decisions you make at various levels reflect in the code you write and ultimately manifest themselves in the quality of work you produce. Kotlin allows rich, clean and succinct constructs with very low to no allocataion overhead in the generated bytecode. Of course if you overdose yourself with declarative paradigm and use it where you shouldn’t, Kotlin will try to be as efficient as possible but the responsibility of all those extra GC pauses are on you.\n\nLet me elaborate on that. For the sake of brevity, consider writing a loop over a range of values, say, `0..100`. Out of various possibilities, we will consider two way which are arguably clean and expressive:\n\n* For loop with range:\n\n```kotlin\n//Kotlin\nfor (i in 0..100) {\n  println(i)\n}\n```\n\nwhich generates the bytecode that is equivalent to the following Java code (taken straight from Intellij Idea’s decompiler):\n\n```kotlin\n//Java\nint i = 0;\nbyte var1 = 100;\nif(i <= var1) {\n   while(true) {\n      System.out.println(i);\n      if(i == var1) {\n         break;\n      }\n      ++i;\n   }\n}\n```\n\n* Declarative ForEach loop with range:\n\n```kotlin\n//Kotlin\n(0..100).forEach(::println)\n```\n\nwho’s Java equivalent would be:\n\n```kotlin\n//Java\nIterable $receiver$iv = (Iterable)(new IntRange(0, 100));\nIterator var1 = $receiver$iv.iterator();\n\nwhile(var1.hasNext()) {\n   int element$iv = ((IntIterator)var1).nextInt();\n   System.out.println(element$iv);\n}\n```\n\nNotice how both approaches achieves the same result but have different performance metrics because of required object allocations.\n\nYou might really need to use the declarative style when you’re using a framework which handles the iteration for you and does a lot more stuff besides iteration. For example, Apache Spark’s RDD operations. For everything else, avoiding unnecessary allocation isn’t a bad idea.\n\nTo add more capabilities to the`for` loops, currently there’s an open feature request to “[Support guards/filters in foor loops](https://youtrack.jetbrains.com/issue/KT-15348)”.\n\nBut, add the same time, do not underestimate the power of `inline`'ed Extension Functions and the kind of optimizations Kotlin’s compiler does to allow for some very neat constructs like:\n\n```kotlin\nval user: User? = ...\nuser?.let {\n user.name = \"Nabeel\"\n}\n```\n\nAnd it’s implicit version:\n\n```kotlin\nval user: User? = ...\nuser?.apply {\n name = \"Nabeel\"\n}\n```\n\nBoth of these constructs generate bytecode which simply performs null-check on reference followed by conditional assignment. Verification is left as an exercise to the reader.\n\n_Pro-tip: Use Intellij IDEA Kotlin bytecode viewer/decompiler and see the Java equivalent code_.\n\nSo far, I’ve had the following backend/server-side artifacts serving happily in production that involve Kotlin:\n\n* A legacy server, now with mixed Java & Kotlin code. It is user-facing and has to scale horizontally on-demand.\n* An ETL utility purely written in Kotlin which talks to remote REST services as well. It’s has some strict memory and performance requirements.\n* An upcoming Spring boot based server. It’s core components are security (Spring Security with OAuth2) and microservice-architecture style services. It’s being written entirely in Kotlin and is targeted for mid 2017 release.\n\nKotlin team at JetBrains has done a great job so far and has been putting a lot of effort to polish 1.1 release by Q1 2017. Features like coroutines in the upcoming Kotlin 1.1 will allow writing clean and easier-to-reason-about concurrent code which is otherwise infamous to be hard and bug-prone. If you want to take a sneak peak at coroutines, check the following:\n\n[https://github.com/Kotlin/kotlinx.coroutines](https://github.com/Kotlin/kotlinx.coroutines)\n\nFor all the Kotlin related news, keep checking: [https://blog.jetbrains.com/kotlin](https://blog.jetbrains.com/kotlin/)\n\n","author":"Nabeel Ali Memon","date":"2016-12-31","type":"article","categories":["Kotlin"],"features":["highlightjs"],"description":"","filename":"","lang":"EN","enclosure":null},{"title":"Kotlin 1.0.5 is here","url":"https://blog.jetbrains.com/kotlin/2016/11/kotlin-1-0-5-is-here/","body":"\nWe’re happy to announce that we’ve just released **Kotlin 1.0.5**, which continues the series of bugfix and tooling updates for Kotlin 1.0.\n\nWe’d like to thank our external contributors whose pull requests were included in this release: [Kirill Rakhman](https://github.com/cypressious), [Vladislav Golub](https://github.com/ensirius), [Vsevolod Tolstopyatov](https://github.com/qwwdfsad), [Yoshinori Isogai](https://github.com/shiraji), [takahirom](https://github.com/takahirom) and [gitreelike](https://github.com/gitreelike). Thanks to everyone who tried the EAP builds and sent us feedback, too!\n\nThe complete list of changes in the release can be found in the [changelog](https://github.com/JetBrains/kotlin/blob/1.0.5/ChangeLog.md). Some of the changes worth highlighting are:\n\n### Loop to Lambda Conversion\n\nThe IntelliJ IDEA plugin can now detect many cases where imperative `for` loops can be rewritten in a more compact and idiomatic manner using standard library functions such as `filter` and `map`. As a simple example, the following snippet:\n\n```kotlin\nval result = arrayListOf<String>()\nfor (s in list) {\n    if (s.isNotEmpty()) {\n        result.add(s)\n    }\n}\n```\n\n...will be automatically converted to:\n\n```kotlin\nval result = list.filter { it.isNotEmpty() }\n```\n\nTo trigger the conversion, put the caret on the `for` keyword and press <kbd>Alt-Enter</kbd>.  \n\n### Postfix Code Completion\n\nIntelliJ IDEA’s [postfix code completion](https://blog.jetbrains.com/idea/2014/03/postfix-completion/) is now supported for Kotlin, with a large array of templates. Note that the feature depends on platform changes made in IntelliJ IDEA 2016.2 and is therefore unavailable in Android Studio 2.2; it will be supported in newer versions of Android Studio based on newer IntelliJ Platform versions.\n\n[![1-0-5-postfixcompletion](https://i2.wp.com/blog.jetbrains.com/kotlin/files/2016/11/1.0.5-postfixCompletion.png?zoom=1.5&resize=640%2C465&ssl=1)](https://i2.wp.com/blog.jetbrains.com/kotlin/files/2016/11/1.0.5-postfixCompletion.png?ssl=1)\n\n### New Refactorings\n\nThe Kotlin plugin now supports “Extract Interface” and “Extract Superclass” refactorings, which were previously only supported only for Java and some other languages, as well as an entirely new refactoring “Introduce Type Parameter”, providing an easy way to change a class or function into a generic one.\n\n[![1-0-5-extractinterface](https://i2.wp.com/blog.jetbrains.com/kotlin/files/2016/11/1.0.5-extractInterface.png?zoom=1.5&resize=640%2C364&ssl=1)](https://i2.wp.com/blog.jetbrains.com/kotlin/files/2016/11/1.0.5-extractInterface.png?ssl=1)\n\n### Android IDE Support Improvements\n\nKotlin 1.0.5 updates the Kotlin Lint checks to feature parity with Android Studio 2.2’s Java Lint checks, fixing a lot of issues in the process. It also adds a long-awaited feature: “Extract string resource” intention, allowing to move a hard-coded string literal from Kotlin code to a string resource file.\n\n[![1-0-5-android-extract-string-resource](https://i2.wp.com/blog.jetbrains.com/kotlin/files/2016/11/1.0.5-android-extract-string-resource.png?zoom=1.5&resize=640%2C188&ssl=1)](https://i2.wp.com/blog.jetbrains.com/kotlin/files/2016/11/1.0.5-android-extract-string-resource.png?ssl=1)\n\n### JavaScript Support Improvements\n\nKotlin 1.0.5 adds two major new features to the JavaScript backend:\n\n*   The `@JsName` annotation allows to control the names of JavaScript functions and properties generated from Kotlin code, making it much easier to call Kotlin-compiled code from plain JavaScript;\n*   Class literals (`Foo::class`) are now supported. The value of a `::class` expression does not implement the full `KClass` API; it only defines a `simpleName` property to access the class name.\n\n### How to update\n\nTo update the plugin, use Tools | Kotlin | Configure Kotlin Plugin Updates and press the “Check for updates now” button. Also, don’t forget to update the compiler and standard library version in your Maven and Gradle build scripts.\n\nAs usual, if you run into any problems with the new release, you’re welcome to ask for help on the [forums](https://discuss.kotlinlang.org/), on Slack (get an invite [here](http://kotlinslackin.herokuapp.com/)), or to report issues in the [issue tracker](https://youtrack.jetbrains.com/issues/KT).\n\nLet’s Kotlin!\n\n","author":"Dmitry Jemerov","date":"2016-11-08","type":"article","categories":["Kotlin"],"features":["highlightjs"],"description":"","filename":"","lang":"EN","enclosure":null},{"title":"Дмитрий Полищук - Kotlin + Android: практический ликбез","url":"https://www.youtube.com/watch?v=2oVpnArCdWI","body":"\n\n<iframe width=\"960\" height=\"480\" src=\"https://www.youtube.com/embed/2oVpnArCdWI\" frameborder=\"0\" allowfullscreen></iframe>\n\n","author":"Дмитрий Полищук","date":"2016-03-09","type":"video","categories":["Kotlin","Android"],"features":["highlightjs"],"description":"","filename":"","lang":"RU","enclosure":null},{"title":"A Very Peculiar, but Possibly Cunning Kotlin Language Feature.","url":"http://blog.jooq.org/2016/02/22/a-very-peculiar-but-possibly-cunning-kotlin-language-feature/","body":"\nThis has caught me by surprise. After studying the [Kotlin language](https://kotlinlang.org/) to learn about how to best leverage this interesting new language for [jOOQ](http://www.jooq.org/), I stumbled upon this puzzler. What do you think the following program will print?\n\n```kotlin\nfun main(args: Array) {\n    (1..5).forEach {\n        if (it == 3)\n            return\n        print(it)\n    }\n\n    print(\"done\")\n}\n```\n\nWell... You might have guessed wrong. The above will print:\n\n```\n12\n```\n\nIt will NOT print what most people might expect:\n\n```\n1245done\n```\n\n**Note to those of you who are not surprised**:\n\nThe above is peculiar for someone used to working with Java 8, where the following code will indeed print 1245done:\n\n```java\npublic static void main(String[] args) {\n    IntStream.rangeClosed(1, 5).forEach(it -> {\n        if (it == 3)\n            return;\n\n        System.out.print(it);\n    });\n\n    System.out.print(\"done\");\n}\n```\n\nThe syntactical reason is explained in this section of the Kotlin manual:\n[https://kotlinlang.org/docs/reference/returns.html](https://kotlinlang.org/docs/reference/returns.html)\n\nIn lambdas / closures, the return statement will not (necessarily) return from the lambda / closure, but from the immediate enclosing scope of the lambda / closure. The rationale has been kindly given to me by Dmitry Jemerov from JetBrains in two tweets:\n\n<blockquote class=\"twitter-tweet\" data-lang=\"en\"><p lang=\"en\" dir=\"ltr\"><a href=\"https://twitter.com/lukaseder\">@lukaseder</a> <a href=\"https://twitter.com/kotlin\">@kotlin</a> reason is very simple: we want to have lambdas that work exactly like built-in language features (e.g. synchronised)</p>&mdash; Dmitry Jemerov (@intelliyole) <a href=\"https://twitter.com/intelliyole/status/701729566453321728\">February 22, 2016</a></blockquote>\n<script async src=\"//platform.twitter.com/widgets.js\" charset=\"utf-8\"></script>\n\n<blockquote class=\"twitter-tweet\" data-lang=\"en\"><p lang=\"en\" dir=\"ltr\"><a href=\"https://twitter.com/lukaseder\">@lukaseder</a> therefore ‘return’ in a lambda passed to ‘synchronised’ function must do the same as a ‘return’ in a Java ‘synchronised’ block</p>&mdash; Dmitry Jemerov (@intelliyole) <a href=\"https://twitter.com/intelliyole/status/701729699198799874\">February 22, 2016</a></blockquote>\n<script async src=\"//platform.twitter.com/widgets.js\" charset=\"utf-8\"></script>\n\nCunningly, the Kotlin language has removed language-based support for Java constructs like try-with-resources, or the synchronized statement. That’s very reasonable, because these language constructs don’t necessarily belong in the language ([as we’ve previously claimed in another blog post](http://blog.jooq.org/2016/01/12/if-java-were-designed-today-the-synchronizable-interface/)), but could be moved to libraries instead. For example:\n\n```kotlin\n// try-with-resources is emulated using an\n// extension function \"use\"\nOutputStreamWriter(r.getOutputStream()).use {\n    it.write('a')\n}\n```\n\n(criticism here)\n\nOr:\n\n```kotlin\n// Synchronized is a function!\nval x = synchronized (lock, { computation() })\n```\n\nSee also:\n[https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/synchronized.html](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/synchronized.html)\n\nAfter all, even in Java, the language feature only works because the language depends on library types, like Iterable (foreach), AutoCloseable (try-with-resources), or JVM features (monitor on each reference for synchronized)\n\n## So, what’s the deal with return?\n\nAlong the lines of the above rationale, when language designers want to avoid language constructs for things that can be implemented with libraries, but still want you to feel like these were language constructs, then the only reasonable meaning of return inside of such a “construct-ish” lambda / closure is to return from the outer scope. So, when you write something like:\n\n```kotlin\nfun main(args : Array) {\n    val lock = Object()\n    val x = synchronized(lock, {\n        if (1 == 1)\n            return\n\n        \"1\"\n    })\n\n    print(x)\n}\n```\n\nThe real intention is for this to be the equivalent of the following Java code:\n\n```java\npublic static void main(String[] args) {\n    Object lock = new Object();\n    String x;\n\n    synchronized (lock) {\n        if (1 == 1)\n            return;\n\n        x = \"1\";\n    }\n\n    System.out.println(x);\n}\n```\n\nIn the Java case, obviously, the return statement exits the main() method, because there is no other reasonable stack frame to return from. Unlike in Kotlin, where one might argue the lambda / closure would produce its own stack frame.\n\nBut it really doesn’t. The reason for this is the inline modifier on the synchronized function:\n\n```kotlin\npublic inline fun <R> synchronized(lock: Any, block: () -> R): R {\n    monitorEnter(lock)\n    try {\n        return block()\n    }\n    finally {\n        monitorExit(lock)\n    }\n}\n```\n\nSee also:\n[https://kotlinlang.org/docs/reference/inline-functions.html](https://kotlinlang.org/docs/reference/inline-functions.html)\n\nWhich means that the block closure passed as an argument isn’t really a pure lambda expression, but just syntactic sugar embedded in the call-site’s scope.\n\nWeird. Cunning. Clever. But a bit unexpected.\n\nIs this a good idea? Or will the language designers regret this, later on? Are all lambdas / closures potentially “language construct-ish”, where such a return statement is expected to leave the outer scope? Or are there clear cases where this inline behaviour just makes total sense?\n\nWe’ll see. In any case, it is very interesting for a language to have chosen this path.\n\n","author":"Lukas Eder","date":"2016-02-22","type":"article","categories":["Kotlin","Puzzlers"],"features":["highlightjs"],"description":"","filename":"","lang":"EN","enclosure":null},{"title":"Production Ready Kotlin","url":"https://www.linkedin.com/grp/post/7417237-6042285669181648896","body":"\nI see a lot of people asking \"Is Kotlin ready for production?\" ... maybe these are people that are not already using Kotlin wanting a bit of comfort before they put effort into their own investigation. Most people I know that do actually use Kotlin daily think it is obvious Kotlin is already ready. here is why:\n\n- If it compiles, it runs perfectly\n- If it doesn't compile due to some rare compiler bug, there is always a work around\n- If that doesn't work, drop to Java for 1 class and come back (really rare)\n\nThe only real breaking point is source code level changes between versions. And JetBrains even helps with those by providing global refactorings in IntelliJ IDEA that will update your code.\n\nA huge benefit to Kotlin is that the company doing a lot of the development has a very high quality level of focus, represented in the extensive tests that back and protect each Kotlin build. This is a company that knows the cost of an error after shipping a product. And if there is an error, the responsiveness of the team is stellar. Bugs are triaged within a day, breaking bugs are fixed quickly, and other issues are considered thoughtfully. You can also submit pull requests and help out when something is within your coding grasp.\n\nWe have taken Kotlin into production via Solr-Undertow at some really large companies who trust it more than they trusted \"Solr on Jetty\" which has been around for many years. With Kotlin, back in my consulting days, we built a billion record processing pipeline that kicked the pants off of the previous Scala version, and it is the livelihood behind a billion dollar education company's search system. And now we have Kotlin in production in our startup, in fact we ONLY have Kotlin and are using it happily with Vert-x3, Amazon AWS services, ElasticSearch and other Java libraries.\n\nHere is what is NOT helping Kotlin to be perceived as production ready:\n\n- version number sounds fishy, 0.12.1230. This is solely a perception problem and ignores the years of work and the quality level behind that number.\n\n- few major up-to-date Kotlin libraries. First, you don't need a Kotlin library to replace every Java library. Scala loved doing that, and used Killer Frameworks to sell Scala. Kotlin doesn't need it. In some areas bigger libraries are coming because they will be end-to-end more \"Kotlin-loving\" but it isn't required.\n\n- trash left laying around. If you see an old GitHub repository from 2 years ago with M6 Kotlin code, ask the owner to delete it. A library should be active, at least current to M12, ready for M13 when it arrives, or the owner should hand it off or close it down so they do not confuse and hurt an emerging ecosystem around Kotlin. GitHub has so much trash these days, but it is important place in which people look for libraries.\n\n- LinkedIn seems to resist Kotlin as a skill / search keyword. For 1 day we had Kotlin appearing in search, then it vanished again. LinkedIn engineering says we need higher frequency of the term in skills and CV's (positions). So if you use Kotlin, add it to your LinkedIn and help it break through the threshold.\n\nTo help out, my company is open-sourcing anything we can, and are taking this approach with the Kotlin community:\n\n\"We will open-source anything we can that does not hurt our competitiveness, we will document it, release it on maven central, we will keep it up to date to any Kotlin milestone/release changes, we will integrate nicely with other Kotlin libraries, we will report all bugs and issues to Kotlin YouTrack and follow up with testing; and we will not stop supporting Kotlin until every one of the key players in Kotlin sphere show up at a bar in Dublin, and we all agree to quit together. Until then, we are all in.\"\n\nIf you are a Kotlin supporter, step up your support because Kotlin can be the biggest player in the JVM space, is the best candidate, and deserves help from those that benefit from its existence.\n\n","author":"Jayson Minard","date":"2015-08-26","type":"article","categories":["Kotlin"],"features":["highlightjs"],"description":"","filename":"","lang":"EN","enclosure":null},{"title":"Logging in Kotlin & Android: AnkoLogger vs kotlin-logging","url":"https://medium.com/@OhadShai/logging-in-android-ankologger-vs-kotlin-logging-bb693671442a#.pi8n1ojoh","body":"\n# Logging in Kotlin & Android: AnkoLogger vs kotlin-logging\n\nIn the [previous post](https://medium.com/@OhadShai/logging-in-kotlin-95a4e76388f2) _kotlin-logging_ framework was introduced. In this post I am going to compare it with _anko_ in the aspect of logging in Android.\n\n[Anko](https://github.com/Kotlin/anko) is probably one of the most popular libraries in Kotlin today. It was written by JetBrains as a DSL (Domain Specific Language) for view editing instead of the plain old xml used in Android-Java.\n\nAlong with that _anko_ provide other helpers for android development, among them is the [_AnkoLogger_](https://github.com/Kotlin/anko/blob/d40dfa016a9cf74286127de16273a131e48348bd/doc/ADVANCED.md#logging) for logging. I am going to observe this specific aspect and compare it to using [_kotlin-logging_](https://github.com/MicroUtils/kotlin-logging) for logging in android.\n\n### Installation simplicity\n\nIf you are a user of anko, then using _AnkoLogger_ has no additional installation. Super easy. If you are not using anko, then it is an overkill to install it just for logging. kotlin-logging is pretty simple to install with gradle, and there is an example [in here](https://github.com/MicroUtils/kotlin-logging-example-android).\n\n### Package size\n\nFor anko this is not relevant since the AnkoLogger is just one class among many. kotlin-logging jar is about 10kb but requires additional dependencies of ~50kb (slf4j+android bridge). Pretty light-weight.\n\n### Interface\n\nIn kotlin-logging the recommended interface is like that:\n\n```kotlin\nclass FooWithLogging {  \n    companion object: KLogging()  \n    fun bar() {  \n        logger.info { \"twinkle twinkle $little star\" }\n    }  \n}\n```\n\nThe logger is defined as a parent for the companion object. The companion object then has a property called _logger._ In the bytecode, that translates into a static member.\n\nThe logger in turn is an extension of slf4j Logger called KLogger. Hence original methods are available as well as lazy evaluation extensions (with curly braces).\n\nIn AnkoLogger the recommended interface is like that:\n\n```kotlin\nclass SomeActivity : Activity(), AnkoLogger {  \n    private fun someMethod() {  \n        info(\"London is the capital of Great Britain\")  \n        debug(5) // .toString() method will be executed  \n        warn(null) // \"null\" will be printed  \n    }  \n}\n```\n\nThe logger is defined in an interface called _AnkoLogger_ that your class is extending. You don’t access it directly, instead just call the log methods by the level. Again, a lazy flavors exists for different log levels. AnkoLogger also “pollutes” your class with a public property called _loggerTag_, and all logging methods are public. Of course this can be fixed with a companion object.\n\n### Logger name\n\nLooks like a small detail but still...\n\nIn kotlin-logging the name of the logger is inferred from the class and package name. In cases the name is too long it is truncated and replaced with stars. more details in [Logger name mapping](http://www.slf4j.org/android). In AnkoLogger, the name of the logger is the class name only without package name. Again, if it is long it is getting truncated.\n\nOne notable different is that AnkoLogger doesn’t handle inheritance, so in case of inheritance the logger name is of the child class even when the log message was issued in the parent class. A little bit confusing :-(\n\n### Performance and resource consumption\n\nFirst I will start with a note about premature optimization: performance measurements can be very misleading and differ from one use case to another.\n\nUnder the hood both frameworks use the native logging of android so only minor differences should be expected.\n\nThe main difference in the design is that kotlin-logging has a companion (static) member of the logger as opposed to AnkoLogger that has a property for each object instance.\n\nFrom my small tests kotlin-logging has slightly better speed, but I did not see any absolute advantage hence you should check that for your use case if it is required.\n\n### Conclusion\n\nI compared AnkoLogger with kotlin-logging for Android developers, that writes applications in Kotlin.\n\nIn case you would like to play with it a bit, I created a project with both frameworks in github: [https://github.com/MicroUtils/anko-vs-kotlin-logging](https://github.com/MicroUtils/anko-vs-kotlin-logging)\n\nFor me the bottom line is that if you use anko in your application then probably AnkoLogger is the solution for you, otherwise I think [kotlin-logging](https://github.com/MicroUtils/kotlin-logging) is easier. The rest is a matter of style.\n\nAs always, comments are welcome.\n\n","author":"osha1","date":"2016-08-14","type":"article","categories":["Kotlin","Android"],"features":["highlightjs"],"description":"","filename":"","lang":"EN","enclosure":null},{"title":"Improved Pattern Matching in Kotlin","url":"https://programmingideaswithjake.wordpress.com/2016/08/27/improved-pattern-matching-in-kotlin/","body":"\nKotlin doesn’t have true pattern matching, and that’s fine. In order to make matchable classes in Scala, there is an awful lot of overhead required to make it work, and I highly respect Kotlin’s goal of _not_ adding much overhead anywhere. But that doesn’t mean we can’t try to make our own way to get something closer to pattern matching.\n\n## **Using `when`**\n\nKotlin’s `when` block is incredibly handy; It has several ways that it can work. The first way is simple equality check:\n\n```kotlin\nwhen (x) {\n    1 -> print(\"x == 1\")\n    2 -> print(\"x == 2\")\n    else -> print(\"x is neither 1 nor 2\")\n}\n```\n\nAnd cases can be combined using a comma:\n\n```kotlin\nwhen (x) {\n    0, 1 -> print(\"x == 0 or x == 1\")\n    else -> print(\"otherwise\")\n}\n```\n\nIt can also do `is` and `in` checks:\n\n```kotlin\nwhen(x) {\n    in 1..10 -> print(\"in range\")\n    is String -> print(\"I guess it's not even a number\")\n}\n```\n\nAnd with the last one, you can see that you can combine any of the previous into one `when` block. You also don’t need `else` if you’re using `when` as a statement instead of an expression. You also don’t need `else` if the expression version has all possibilities listed (as far as the compiler can tell).\n\nYou can also use `when` without a value on top, so that it simply works like a set of `if-else if` blocks:\n\n```kotlin\nwhen {\n    a == b -> doSomething()\n    b == c -> doSomethingElse()\n    else -> doThatOtherThing()\n}\n```\n\nWith all these possibilities, do you know which version we’re going to use to build our pattern matching system? Surprisingly, it’s the simplest one with equality checks.\n\nNow, I realize that you can do `sealed` classes as a sort of union type and `is` with when to match on those, but that’s has a limited set of use-cases. With the following system, I believe you can cover _all_ use cases.\n\n## **So How Do We Do It?**\n\nFirst, we realize that equality checks use `equals()` and that `equals()` is something we can override. So, we make some sort of `Pattern` type to use in the `when` block, and `equals()` checks if the object `is Pattern` and proceeds to use the `Pattern` to calculate “equality”.\n\nHere’s a glimpse at how it loosely looks:\n\n```kotlin\ninterface Pattern<in Subject> {\n    fun match(subject: Subject): Boolean\n}\n\nclass MySubject {\n    ...\n    fun equals(other: Any): Boolean {\n        if(other is Pattern<*>)\n            return other.match(this)\n        else ...\n    }\n}\n\nclass SomePattern {\n    override fun match(subject: Any): Boolean {\n        ...\n    }\n}\n```\n\nAnd it would be used as follows:\n\n```kotlin\nval x = MySubject()\n...\nwhen(x) {\n    SomePattern() -> doSomething()\n    SomeOtherPattern() -> doSomethingElse()\n}\n```\n\n## **Tweaks**\n\nThere’s quite a few things that can be done to alter this idea to make it more palatable in different situations.\n\n### **Shortcutting**\n\nFirst, you can try to make the patterns a little more accessible by shortcutting them on the subject class. If a pattern is parameterized – for example, a `List` could have a parameterized pattern that checks for a certain length, `IsLength` which would need to take in a parameter for the length – you can put a shortcut function on the `companion object` instead of directly calling the class’ constructor. If it’s not parameterized, you can cache an instance of the pattern as a value on the `companion object` of the subject class.\n\n### **Lambda Pattern**\n\nThe `Pattern` interface only has one method. You know what that means? It’s a functional interface (in Java 8 terms). That means, in Kotlin, `Pattern` doesn’t even need to exist. Instead of `equals()` checking if the object is a `Pattern`, have it check if it’s a `Function1<SubjectType, Boolean>`. You can obviously still shortcut some built-in patterns, but now you can even put in some on-the-fly lambdas into your `when` block:\n\n```kotlin\nwhen(x) {\n    {it: Subject -> it.isTheCoolest} -> doSomething()\n}\n```\n\nThis is sadly not all that useful, since type inference won’t be able to determine the type for the input parameter. You need to. At that point, you might as well use the unparameterized `when` block:\n\n```kotlin\nwhen {\n    x.isTheCoolest -> doSomething()\n}\n```\n\nThat doesn’t mean using lambdas for the pattern is a bad thing. You can still use method references, which makes quick and simple on-the-fly patterns possible (even for properties):\n\n```kotlin\nwhen(x) {\n    Subject::isTheCoolest -> doSomething()\n}\n```\n\nThat’s certainly better than the fully qualified lambda. More complex lambdas can be defined as functions or in values instead:\n\n```kotlin\nfun moreComplexCheck(subject: Subject): Boolean {\n    ...\n}\n\nval moreComplexCheck2 = {subject: Subject -> ...}\n\nwhen(x) {\n    ::moreComplexCheck -> doSomething()\n    moreComplexCheck2 -> doSomethingElse()\n}\n```\n\n## **Outro**\n\nSo, there you have it! Better pattern matching in Kotlin! What do you think? I realize it’s a misuse of `equals()`, but I think it’s worth it in some cases.\n\n","author":"Jacob Zimmerman","date":"2016-08-27","type":"article","categories":["Kotlin"],"features":["highlightjs"],"description":"","filename":"","lang":"EN","enclosure":null},{"title":"Kotlin/Native v0.2 is out","url":"https://blog.jetbrains.com/kotlin/2017/05/kotlinnative-v0-2-is-out/","body":"\nWe’re happy to announce the release of Kotlin/Native v0.2, a feature and bugfix update to Kotlin/Native Technology Preview. This update adds support for coroutines and cross-module inline functions support, along with bugfixes and improvements all over the place.\n\nThis release includes samples showing how to use [coroutines for concurrent non-blocking IO](https://github.com/JetBrains/kotlin-native/tree/master/samples/nonBlockingEchoServer), a [GUI application using GTK](https://github.com/JetBrains/kotlin-native/tree/master/samples/gtk), as well as a [TensorFlow machine learning framework ](https://github.com/JetBrains/kotlin-native/tree/master/samples/tensorflow)client contributed by Julius Kunze.\n\nFor example, code as easy as\n\n```kotlin\nvar connectionId = 0\nacceptClientsAndRun(listenFd) {\n  memScoped {\n    val bufferLength = 100L\n    val buffer = allocArray<ByteVar>(bufferLength)\n    val connectionIdString = \"#${++connectionId}: \".cstr\n    val connectionIdBytes = connectionIdString.getPointer(this)\n    try {\n      while (true) {\n        val length = read(buffer, bufferLength)\n        if (length == 0L) break\n        write(connectionIdBytes, connectionIdString.size.toLong())\n        write(buffer, length)\n      }\n    } catch (e: IOException) {\n      println(\"I/O error occurred: ${e.message}\")\n    }\n  }\n}\n```\n\ncan be used to process multiple concurrent socket IO with coroutines and serve each client individually and concurrently.\n\nAnd to create a GTK button with an event listener, just do:\n\n```kotlin\n val button = gtk_button_new_with_label(\"Click me!\")!!\n g_signal_connect(button, \"clicked\",\n   staticCFunction { _: CPointer<GtkWidget>?, _: gpointer? -> println(\"Hi from Kotlin\") }\n)\n```\n\nSo v0.2 release allows  to create fully functional small-footprint native applications written in Kotlin.\n\nBoth compilation and runtime performance were significantly improved, size of redistributable decreased.\n\nThe complete list of changes in this release can be found in the [changelog.](https://github.com/JetBrains/kotlin-native/blob/v0.2.0/CHANGELOG.md)\n\nPre-built binaries for [Linux](http://download.jetbrains.com/kotlin/native/kotlin-native-linux-0.2.tar.gz) and [MacOS](http://download.jetbrains.com/kotlin/native/kotlin-native-macos-0.2.tar.gz) hosts are available.\n\nThis entry was posted in [Releases](https://blog.jetbrains.com/kotlin/category/releases/) and tagged [native](https://blog.jetbrains.com/kotlin/tag/native/), [newsletter](https://blog.jetbrains.com/kotlin/tag/newsletter/). Bookmark the [permalink](https://blog.jetbrains.com/kotlin/2017/05/kotlinnative-v0-2-is-out/).\n","author":"Nikolay Igotti","date":"2017-05-12","type":"article","categories":["Kotlin","Kotlin Native"],"features":["highlightjs"],"description":"","filename":"","lang":"EN","enclosure":null},{"title":"Podcast Разбор Полетов: Episode 102 — Kotlin, тесты и здоровый сон.","url":"http://razbor-poletov.com/2016/02/episode-102.html","body":"\n\n## Мероприятия\n\n1. http://jbreak.ru/\n1. https://fosdem.org/2016/\n\n## Темки\n\n1. Kotlin 1.0 RC - Философия Kotlin\n1. JavaTest, TCK, JTreg и его связь с TestNG/JUnit и прочие вопросы в знатоку по этим вопросам\n1. Что нужно есть и сколько нужно спать, что бы быть белым русским мужчиной в Америке\n\n## Полезняшки\n\n1. Клиент для Redis - [Medis](https://github.com/luin/medis)\n1. http://kotlin.link/\n1. https://github.com/Originate/git-town\n1. https://libraries.io/\n\n","author":"Dmitry Jemerov, Viktor Gamov, Alexey Abashev, Anton Arphipov,  Dmitry Churbanov, Anton Arhipov","date":"2016-02-04","type":"article","categories":["Kotlin","Podcast"],"features":["highlightjs"],"description":"","filename":"","lang":"RU","enclosure":{"url":"http://traffic.libsyn.com/razborpoletov/razbor_102.mp3","size":70319173}},{"title":"JUnit 5 with Spring Boot (plus Kotlin)","url":"https://objectpartners.com/2016/07/26/junit-5-with-spring-boot-plus-kotlin/","body":"\nThis summer the JUnit team released a beta version of the next iteration, [version five](http://junit.org/junit5/). This newest version adds a ton of new features that will be a welcome relief for JVM developers who have been dealing with the limitations and idiosyncrasies of version four over the past decade. I’ve put together an [example project](https://github.com/mike-plummer/junit5-springboot-kotlin) to learn about the new feature set and tried to summarize some of my favorites in this post.\n\n# Features of JUnit 5\n\n**Backwards Compatibility:** One of the biggest concerns with any update is how it affects an existing baseline. One of the great features of version 5 is that it nicely coexists with any JUnit tests you already have. In fact, the platform supplies a special test runner that allows any version 5 test to be run as a version 4 test, albeit without some of the more advanced features. This allows a project to adopt the update and gradually migrate its test suite rather than forcing a ‘big bang’-style conversion.\n\n**Nesting:** A common complaint of JUnit 4 tests is the relative difficulty of writing behavior-driven tests in the style of Cucumber or Jasmine (in the JavaScript arena). Behavior Driven Testing (BDT) aims to test software by focusing on desired activities and features rather than the more technical focus of traditional Test Driven Development (TDD). BDT writes tests in a more verbose style, typically structuring tests in logical groups using a natural language format. In JUnit 4 this often results in dauntingly-long unit test names and large amounts of repetition. JUnit 5 resolves many of these problems by supporting Nested tests.\n\n```kotlin\n@Autowired lateinit var dataBean: DataBean\n\n@Nested\ninner class dataBean() {\n    @Nested\n    inner class whenRetrievingData() {\n        @Test\n        fun returnsCorrectData() {\n            assertEquals(dataBean.getData(), expectedData)\n        }\n    }\n}\n```\n\nNested tests allow for easier decomposition of tests into individual units that can easily share setup logic and also display in the test report in a more logical, grouped structure. For example, the code segment above will result in a test that naturally describes the expected behavior ‘dataBean, when retrieving data, returns correct data’ while allowing each segment of that behavior to be expanded with additional tests.\n\n**Dynamic Tests:** In many situations testsneed to react to generated data or are unwieldy to write manually. For this use case JUnit 4 supplied the concept of Parameterized tests and JUnit 5 replaces it with simpler Dynamic Tests.\n\n```kotlin\n@TestFactory\nfun valuesShouldIncludeAllStates(): Collection {\n    return STATES.map { state -&gt;\n        dynamicTest(state) {\n            assertTrue(values.contains(state))\n        }\n    }.toList()\n}\n```\n\nThis short block generates 50 individual tests to validate that my dataset includes the names of all 50 US states. This mechanism works particularly well for data-driven testing but has one significant drawback: dynamic tests do not support Before/After lifecycle hooks the way that legacy Parameterized tests do. This is an unfortunate limitation and can be partially worked around using Nested tests, but if multiple dynamic tests share data it cannot be reset between tests.\n\n**Extension:** Extensions replace much of the legacy ‘Runner’ construct by enabling easy enhancement and expansion of test capabilities. For example, extensions exist to automatically handle Spring and Mockito integration to help keep your tests clean and simple. By using extensions you can also neatly sidestep some of the limitations of test subclassing – multiple extensions can be applied to a single test.\n\n**Tags, Filtering, and Naming:** Sometimes you only need to run a subset of tests, for example only those dealing with a particular service or functional path. Each test or block of tests can be tagged, and at runtime a subset of tags can be included or excluded from execution. In addition, sometimes a test needs a name that doesn’t conform with method naming conventions. An optional DisplayName can be supplied for each test to print out in the test reports which can help readability.\n\n```kotlin\n@Test\n@Tag(\"LoadTests\")\n@DisplayName(\"Very long test that is disabled by default\")\nfun largeLoadTest() {\n    // TEST CONTENT\n}\n```\n\n**Dependency Injection:** Custom ParameterResolvers can be written that will be used to inject parameters into any constructors or test methods. This can help reduce boilerplate in your before/after lifecycle hooks and provides an easy way to swap out implementations when running tests against different back-ends. This is particularly useful if you’re using a Dependency Injection (DI) mechanism in your code like Guice or Java CDI as the ParameterResolver can hook into or replace many DI functions.\n\n```kotlin\n    @ExtendWith(TestTrackerResolver::class)\n    class DependencyInjectionTest {\n        @BeforeEach\n        fun setup(tracker: TestTracker) {\n            tracker.testCount++\n        }\n \n        @Test\n        fun testTracker(tracker: TestTracker) {\n            assertEquals(tracker.testCount, 1L)\n        }\n    }\n \n    /** ParameterResolver that automatically supplies a TestTracker object where requested in the tests above **/\n    class TestTrackerResolver: ParameterResolver {\n        companion object {\n            val tracker: TestTracker = TestTracker(0)\n        }\n \n        /** Whether this ParameterResolver supports the requested Parameter **/\n        override fun supports(parameterContext: ParameterContext?, extensionContext: ExtensionContext?): Boolean {\n            return parameterContext?.parameter?.type == TestTracker::class.java\n        }\n \n        /** Supply a value for the requested Parameter. **/\n        override fun resolve(parameterContext: ParameterContext?, extensionContext: ExtensionContext?): Any? {\n            return tracker\n        }\n    }\n```\n\n**Java 8:** Many test constructs have been updated to be lambda-friendly, and others like dynamic tests are a natural fit to be driven from a Stream. One of my personal favorite features is the idea of Supplier-based messages – in legacy tests a failure message was compiled and generated before the test even ran, but in the new format the Supplier will only be called in the event of a failure. This helps speed up tests ever so slightly but more importantly allows easy re-use of method references to generate detailed and standardized messages.\n\n# Use with Spring Boot\n\nEven though JUnit 5 is in beta it’s already easy to use in Spring Boot. An excellent [JUnit Extension](https://github.com/sbrannen/spring-test-junit5) supplies easy Spring integration including Autowiring. By using this extension and annotating with @SpringBootTest a test has a complete Spring context to work with. As of the time of this post that extension is not published out to a public repository, but the code can be pulled from GitHub and built manually in just a few minutes.\n\n```kotlin\n@SpringBootTest\n@ExtendWith(SpringExtension::class)\nclass DataBeanTest : ApplicationTest() {\n\n    @Autowired lateinit var dataBean: DataBean\n\n    @Test\n    fun testAutowiring() {\n        assertNotNull(dataBean)\n    }\n}\n```\n\n# Spring Boot with Kotlin\n\nMoving off the topic of JUnit, one of my favorite new languages in the JVM space is Kotlin. I’ve [written a bit about it here before](https://objectpartners.com/2016/02/23/an-introduction-to-kotlin/), and given its great feature set I wanted to see how well it worked for writing a Spring Boot application and JUnit 5 tests. Short answer: it works great once you know all the tricks.\n\n## Defining the Application\n\nAs it is in Java, creating your SpringBoot application in Kotlin is easy and concise.\n\n```kotlin\n@SpringBootApplication\n@ComponentScan(\"com.objectpartners.plummer.junit5\")\nopen class Application\n\nfun main(args: Array) {\n    SpringApplication.run(Application::class.java, *args)\n}\n```\n\n## Defining a Bean\n\nWith a quick annotation a Kotlin class becomes a Spring-managed bean.\n\n```kotlin\ninterface FibonacciService {\n    fun fibonacci(max: Long): List;\n}\n\n@Component\nopen class FibonacciServiceImpl: FibonacciService {\n    override fun fibonacci(max: Long): List {\n        Assert.isTrue(max &gt; 0)\n        return generateSequence (0L to 1L, { previous -&gt; previous.second to previous.first + previous.second})\n            .takeWhile { result -&gt; result.second  result.second}\n            .toList()\n    }\n}\n```\n\n## Using a Bean\n\nThis is the only really tricky area. Kotlin’s null-safety rules can cause problems with Dependency Injection since those fields are by definition not initialized at the time of declaration. Early versions of the language forced you to work around this by either performing a faux-initialization at declaration or by using parameter-based injection rather than field-based, but now Kotlin has the ‘lateinit’ keyword. This indicates to the compiler that the field will be initialized at some point between declaration and usage and to make assumptions based on that guarantee. If a ‘lateinit’ field is not initialized prior to use a special exception will be thrown to identify the unsatisfied assumption.\n\n```kotlin\n@Autowired lateinit var fibonacciSvc: FibonacciService\n```\n\n# Wrap Up\n\nHopefully this article has gotten you interested in checking out JUnit5 and maybe even giving Kotlin a try. JUnit may not be the most flexible or powerful testing framework out there but this newest version improves what continues to be the simplest, most-used testing platform for the JVM and is ideal for anyone who is looking to incrementally update an existing test suite or wants to write tests that are easy, familiar, and maintainable. Be sure to check out the [example project](https://github.com/mike-plummer/junit5-springboot-kotlin) to see these features in action as part of a SpringBoot Kotlin application. Happy coding!\n\n","author":"Mike Plummer","date":"2016-07-26","type":"article","categories":["Kotlin","Spring Boot"],"features":["highlightjs"],"description":"","filename":"","lang":"EN","enclosure":null},{"title":"10 Kotlin Tricks in 10(ish) Minutes","url":"https://www.youtube.com/watch?v=YKzUbeUtTak","body":"\nKotlin is a new and popular language for Android development. Its major advantages and features are immediately appealing and quick to learn, but it also has a lot of small and thoughtful parts which are harder to discover. This talk will cover 10 of my favorites with real-world examples.\n\n\n<iframe width=\"960\" height=\"480\" src=\"https://www.youtube.com/embed/YKzUbeUtTak\" frameborder=\"0\" allowfullscreen></iframe>\n\n[Slides](https://speakerdeck.com/jakewharton/10-kotlin-tricks-in-10ish-minutes-square-nyc-november-2016) [Post on Authors Site](http://jakewharton.com/10-kotlin-tricks-in-10ish-minutes/)\n\n","author":"Jake Wharton","date":"2016-11-10","type":"video","categories":["Kotlin"],"features":["highlightjs"],"description":"","filename":"","lang":"EN","enclosure":null},{"title":"The Advent of Kotlin: A Conversation with JetBrains' Andrey Breslav","url":"http://www.oracle.com/technetwork/articles/java/breslav-1932170.html","body":"\n**Learn about Kotlin, a new statically typed language for the JVM.**\n\n_Among the important Java software developments in recent years is the advent of such alternative languages for the JVM as Groovy, Jython, and JRuby—and, more recently, the rise of Scala. A new statically typed language, Kotlin, named after a Russian island off the coast of St. Petersburg, where Kotlin's Andrey Breslav and the Kotlin team reside, has recently been getting attention. A brainchild of the highly lauded Czech software development company JetBrains, maker of the Java IDE IntelliJ IDEA, Kotlin was named Language of the Month in the_ [_January 2012 issue of_ Dr. Dobb's Journal](http://www.drdobbs.com/jvm/language-of-the-month-kotlin/232600836?pgno=2).\n\n_The primary purpose of Project Kotlin is to create for developers a general-purpose language that can serve as a useful tool that is safe, concise, flexible, and 100 percent Java-compatible. Both the compiler and the IntelliJ IDEA plug-in are open source under the Apache 2 license, with source code available through [GitHub](https://github.com/JetBrains/Kotlin)._\n\n_Google software engineer Cedric Beust, creator of the Java testing framework TestNG, writing in [Javalobby](http://java.dzone.com/articles/five-reasons-why-you-should-0) in July 2011, commented that Kotlin was a cause for rejoicing because of its syntactic innovations; its strong IDE; commercial support from JetBrains, which is building the compiler and the IDEA support together; and its reified generics._\n\n_Andrey Breslav, the lead language designer for Kotlin, began his career at Borland, where he worked on language implementations for MDA support. After spending a few years as a college teacher, he joined JetBrains in 2010 to lead Project Kotlin and currently serves as a member of the Java Community Process Expert Group for JSR 335, \"Project Lambda.\" He is a frequent conference speaker at venues such as OSCON, JavaOne, Strange Loop, and Devoxx._\n\n_We met with him to see what's happening with Project Kotlin._\n\n![Andrey Breslav](http://www.oracle.com/ocom/groups/public/@otn/documents/digitalasset/1925119.jpg)\n\n**Oracle Technology Network**: You have written that your goal with Kotlin is \"to create a language that is 100 percent Java-compatible, safer than Java, more concise and flexible, and not overly complex.\" Give us some details about this.\n\n**Breslav:** Every tool comes with a driving use case. We believe that for a new programming language, this use case is gradual migration, when the new language is being introduced little by little into a large code base written in the \"old\" language. In our case, we pay a lot of attention to making mixed Kotlin/Java projects work smoothly.\n\nFor example, IntelliJ IDEA is written in Java and we are willing to use Kotlin in this project. Of course, we are not going to rewrite the whole 10-year-old code base in another language. Most likely, we will start by writing tests in Kotlin, then new features, then maybe some existing subsystems that will be migrated to Kotlin while under refactoring.\n\n> “Kotlin relies on Java libraries but makes them better, mostly through extensions but sometimes with compiler-supported techniques (collections, arrays, primitives).”\n>\n> **- Andrey Breslav** JetBrains\n\nAll of this means that Kotlin has to behave very well in the existing Java ecosystem: use Java libraries, provide Java APIs, and integrate with Java frameworks. Some other new languages adopt a different approach and aim at abandoning the JDK and building their own better platform. Although this approach involves running on the JVM and is technically Java-compatible, it is practically impossible in the use case I just described.\n\nAs for Kotlin, a good example is our collection library. The experience of Scala shows that having your own collection library—all nice and shiny—gives you significant benefits but also has drawbacks when you need to interoperate with Java code: all the data needs to be converted/wrapped, so the code does not look nice and performance is sometimes compromised significantly. This is why Kotlin adopts another strategy: we use vanilla Java collections but make them behave nicely by extracting \"virtual\" read-only interfaces and introducing declaration-site variance. This way we get both compatibility and a nice library.\n\nKotlin relies on Java libraries but makes them better, mostly through extensions but sometimes with compiler-supported techniques (collections, arrays, primitives). This gets us compatibility while keeping the language clean.\n\n## Kotlin and Scala\n\n**Oracle Technology Network:** In what ways is Kotlin simpler than Scala?\n\n**Breslav:** It depends on the definition of _simpler_. Kotlin and Scala have very different approaches: Scala aims to give library designers as much power as possible and relies heavily on a rather elaborate type system, whereas Kotlin's goal is to be a good tool for the end user, so we put a lot of effort into keeping the list of features relatively short.\n\nHere are a few things that Scala has and Kotlin does not:\n\n*   Implicit parameters and implicit conversions\n*   (Path-)dependent types\n*   Full-scale existential types\n*   View bounds, context bounds, and all other exotic bounds\n*   Macros\n\nThis list is very far from complete.\n\n> \"Kotlin provides more-flexible abstractions than Java (including Java 8).\"\n>\n> **- Andrey Breslav** JetBrains\n\n**Oracle Technology Network:** In what ways is Kotlin more concise than Java?\n\n**Breslav:** The less important part is that Kotlin generally requires less ceremony. A few examples:\n\n*   Type inference is much stronger, so you don't have to repeat yourself, specifying the same types over and over again.\n*   Class declarations are more concise, thanks to the concepts of properties and primary constructors.\n*   Delegating overloads are not needed most of the time, thanks to default values for function parameters.\n*   Static utility classes are not needed, because of top-level functions.\n\nOf greater importance, Kotlin provides more-flexible abstractions than Java (including Java 8). Here are some examples:\n\n*   Extension functions and properties in Kotlin can be added to any class/type without altering the definition of the class (as opposed to Java 8's ability to add methods to interfaces by changing their code). This enables us to beautify even existing Java libraries so that the good old JDK looks nice and shiny.\n*   Higher-order functions (passing code around as values) are a lot more convenient, because Kotlin supports proper function types (as opposed to Java 8's SAM conversions that make you create a new interface every time you need a new function signature to be passed around).\n*   Declaration-site variance, and variant collections in particular, make common data processing much more natural by eliminating the need for ubiquitous wildcards in generic types.\n\n**Oracle Technology Network:** What is the most negative feedback you have received about Kotlin?\n\n**Breslav:** \"It's not released yet.\"\n\n**Oracle Technology Network:** What is the most positive?\n\n**Breslav:** \"One language finally got everything right!\"\n\n## The Release Status of Kotlin\n\n**Oracle Technology Network:** What is the release status of Kotlin? How can developers get involved?\n\n**Breslav:** Kotlin reached the M5 milestone in early February 2013. As for big features, we are mostly stabilizing them and working on performance. Smaller features are being added, too. The project is open to contributions, and we do our best to process pull requests reasonably quickly.\n\nWe do not have a date for the 1.0 release. This is an important part of our philosophy. When the features planned for 1.0 are stable and the compiler is release-quality, we are not going to call it 1.0. It will be a beta, available to everyone to use but with no guarantee of backward compatibility for the updates. The point here is that at the \"beta\" stage, a language finally gets to be used in production (maybe other companies will refrain from doing so at first, but at least JetBrains will definitely use Kotlin), and extensive production use may reveal problems in the language design that need to be fixed.\n\nDon't get me wrong: we are making all possible efforts to make the language really good. We rely on the experience of our best engineers and on the feedback we are constantly gathering from other companies and individuals. But we know that practice always brings surprises overlooked by theory, so we embrace the need to validate the design before releasing it and committing to keeping it unchanged. This is why we do not have a date for 1.0 and do not guarantee language design stability right after the beta: it's hard to predict what changes will be necessary.\n\nWhen the design is properly validated and all the problems fixed, we will call it 1.0 and guarantee language stability from that point on.\n\n**Oracle Technology Network:** JetBrains is currently using Kotlin in the production of IntelliJ IDEA and in other projects. Tell us how Kotlin is doing with IntelliJ IDEA. What are some of the challenges?\n\n**Breslav:** First, only very brave souls are using Kotlin for production now. And the bravest among them use the less mature JavaScript back end that compiles Kotlin to run in the browser. There are very many challenges, but the result is awesome: [IntelliJ IDEA's Live Edit](http://blog.jetbrains.com/webide/2012/08/liveedit-plugin-features-in-detail/).\n\n## Enhancing Java Libraries\n\n**Oracle Technology Network:** Give us some examples of ways in which Kotlin can enhance Java libraries.\n\n**Breslav:** First, the way Kotlin treats collections: it uses standard JDK classes at runtime, but at compile time, it introduces \"virtual\" read-only interfaces that are covariant, so that a (read-only) `List<String>` can be passed where a (read-only) `List<Object>` is expected.\n\nAlso, Kotlin introduces many extension functions for collection classes. For example, the `map()` and `filter()` functions allow fluent manipulation with data:\n\n```kotlin\nusers.filter {u -> u.age >= 21}.map {u -> u.name}\n```\n\nMany other things are done through extensions: from `for`-loop support to operator overloading and tuplelike manipulations.\n\n## Other Alternative Languages\n\n**Oracle Technology Network:** Where does Kotlin fit in among the proliferated new languages for the JVM? How does it compare to Groovy, Jython, JRuby, Scala, and others? And with so many languages available to us, why do we need Kotlin?\n\n**Breslav:** Groovy, Jython, and Ruby are primarily dynamic, whereas Kotlin is statically typed, which means the ability to catch more errors at compile time (type safety), faster execution, and smarter tools.\n\nGroovy 2.0's static-compilation feature makes the generated code perform comparably to Java, and this is a great improvement for Groovy. But the type system it supports is the one Java uses, meaning that all the abstraction mechanisms are exactly the same—for example, you get Java generics with all the inconveniences of use site variance and so on.\n\nScala is a different story—it is a statically typed language—and we've learned a lot from Scala's design. Compared to Kotlin, Scala is much more powerful and much harder for people as well as machines to really understand.\n\n**Oracle Technology Network:** Tell us about IDE support in Kotlin.\n\n**Breslav:** We started an IntelliJ IDEA plug-in for Kotlin simultaneously with the compiler, and we reuse a lot of code between the two. This guarantees very accurate analysis in the IDE on the one hand and makes it possible to use IntelliJ IDEA's existing infrastructure for Java.\n\n**Oracle Technology Network**: What are the most important features of Kotlin that Java lacks?\n\n**Breslav:** Assuming that by \"Java\" you mean Java 8, and with the biggest pain of the decade, lambdas (frequently called \"closures\"), being there already: the most important features are powerful type inference, extensions, declaration-site variance, and read-only interfaces for collections.\n\nOn the library side: type-safe builders are also important.\n\n## Getting Set Up with Kotlin\n\n**Oracle Technology Network:** How can developers get set up with Kotlin? What feedback do you want?\n\n**Breslav:** Download the compiler and/or a plug-in for IntelliJ IDEA, and write your cool application. We want feedback about what people like and dislike about Kotlin, what they find hard to understand, and how they use the features the language offers.\n\n**Oracle Technology Network:** What kind of Java developer will benefit most from Kotlin?\n\n> \"We want feedback about what people like and dislike about Kotlin, what they find hard to understand, and how they use the features the language offers.\"\n>\n> **- Andrey Breslav** JetBrains\n\n\n**Breslav:** A Java developer who has reached the limits of the language (and I believe that many of us did that a long time ago) realizes the need for a new language with benefits such as cleaner abstractions, concise syntax, and type safety.\n\n**Oracle Technology Network:** In what ways is Kotlin safer than Java? What safety problems in Java does Kotlin address?\n\n**Breslav:** Kotlin promotes null safety, though nullable types. It also offers control over data modification through read-only collections and data classes and enables safer runtime checks through smart casts.\n\n**Oracle Technology Network:** What are some Java use problems that Kotlin fixes?\n\n**Breslav:** It fixes half of the issues covered in Joshua Bloch's _Java Puzzler_s books: from quirks of implicit conversions of primitives, through problems with static members and their inheritance, all the way to properly variant generics and null safety.\n\n**Oracle Technology Network:** What are the greatest misconceptions you encounter about languages for the JVM and Kotlin in particular?\n\n**Breslav:** We come across the term _functional programming_ all the time, and people often mean different things by this, if anything at all.\n\nBigger functional languages such as ML and Haskell impose a certain discipline and beauty that are highly appreciated by some people, but this is clearly not the reason why your coworker in a nearby cubicle will be talking to you about functional programming over lunch.\n\nThe main selling point of \"functional programming for the masses\" is its usefulness for concurrency that everybody is struggling with today, and the argument for this usefulness usually boils down to \"no side effects equals no problems\" or \"no shared memory equals no problems.\"\n\nBy this reasoning, all we need is immutable data or isolation (or both), but that does not necessarily bring any of the beauty and rigor of functional languages. Other things widely used in functional languages would be great to adopt in mainstream programming—this applies mostly to means of type-safe abstraction, such as higher-order functions (functions that take other functions as arguments) and parametric polymorphism (generics). But these features, again, do not define functional languages.\n\nMy point is: a good language does not need to be functional like Haskell, although it needs some features that are popular in the \"functional world.\"\n\n## See Also\n\n* [January 2012 issue of _Dr. Dobb's Journal_](http://www.drdobbs.com/jvm/language-of-the-month-kotlin/232600836?pgno=2)\n* [GitHub](https://github.com/JetBrains/Kotlin)\n* [Javalobby](http://java.dzone.com/articles/five-reasons-why-you-should-0)\n* [IntelliJ IDEA's Live Edit](http://blog.jetbrains.com/webide/2012/08/liveedit-plugin-features-in-detail/)\n* [Kotlin](http://kotlin.jetbrains.org/)\n* [JetBrains](http://www.jetbrains.com/)\n\n## About the Author\n\nJanice J. Heiss is the Java acquisitions editor at Oracle and a technology editor at _Java Magazine_.\n\n## Join the Conversation\n\nJoin the Java community conversation on [Facebook](https://www.facebook.com/ilovejava), [Twitter](https://twitter.com/#!/java), and the [Java Source Blog](https://blogs.oracle.com/java/)!\n\n","author":"Janice J. Heiss","date":"2013-04-02","type":"article","categories":["Kotlin"],"features":["highlightjs"],"description":"","filename":"","lang":"EN","enclosure":null},{"title":"You can do Better with Kotlin","url":"https://www.youtube.com/watch?v=Es32UqHNza0","body":"\nThe Kotlin programming language is gaining popularity amongst the Android developer community. It’s a modern language that gives more power in everyday routines. Kotlin code generally looks cleaner and nicer, and it’s much easier to work with when you have less verbosity or code duplication. And this is especially noticeable comparing with the soon-to-be-archaic versions of Java used on Android.\n\nBut what’s even more important, is that Kotlin is 100% compatible with all existing Java frameworks, and has good tooling in Android Studio and IntelliJ IDEA. It’s a pragmatic language with a very low learning curve, and can be quickly grasped by Java developers.\n\nIn this talk we’ll discuss the concepts of the language that provide the desired expressiveness, as well as additional goodies designed specifically for Android.\n\n<iframe width=\"960\" height=\"480\" src=\"https://www.youtube.com/embed/Es32UqHNza0\" frameborder=\"0\" allowfullscreen></iframe>\n\n","author":"Svetlana Isakova","date":"2016-05-24","type":"video","categories":["Kotlin","Android"],"features":["highlightjs"],"description":"","filename":"","lang":"EN","enclosure":null},{"title":"More Kotlin Features to Love","url":"http://blog.jimbaca.com/2016/02/22/more-kotlin-features-to-love/","body":"\nConstants are important\nOne of the things that I’ve come to appreciate more and more as a programmer are constants. Before I would have yawned and said big deal why? Now I’d say they are so important as they prevent so many needless bugs. If we are guaranteed that something is not null then we can focus simply on getting our work done instead having to null check the world.\n\nthat is gnarly\nIn Java we used the final keyword to create a constant. Unfortunately the gnarly requirement for using the final keyword is that you must either declare the value inline or set it in the constructor. I’ve run into a fair number of cases where I want something to be final, but don’t know it yet, worse is when it belongs in a class but will not be available until after that class has been constructed and had one of it’s methods executed. Fortunately Kotlin allows us to have constants declared that aren’t required to be set during the constructor. We can use the lazy keyword:\n\n```kotlin\nval myConstant : String by Lazy{\n     calculateConstant();\n}\n```\n\nThis allows us to have a constant that is instantiated the first time myConstant is used. This is perfect for two reasons:\n\n1. We don’t need to do this calculation in the constructor(which is bad anyways as it violates SOLID principles by having logic in the constructor other than variable assignment)\n2. The result of the Lazy calculation is cached, and will not be run in subsequent requests(good for expensive calculations)\n\n## Sort of Ternary Operator\n\nWhile Kotlin doesn’t have a true Ternary Operator it does have an operator that comes close that I had not noticed before:\n\n```kotlin\nprintln(listOfStrings?.size ?: \"empty\") // will first check if the strings is not null and print the size, or empty if it is null\n```\n\n## Kotlin is concise\n\nThe common theme I keep coming back to with Kotlin is that the language allows use to concisely write code. For example in Java if we wanted to execute a block of code if a null check was passed we’d do this:\n\n```kotlin\nif (object != null) {\n     // do some action with object\n}\n```\n\nbut in Kotlin we can be more concise and do the following:\n\n```kotlin\nobject?.let {\n    // if object is not null execute what is in the curly braces\n}\n```\n\nIt’s a much simpler syntax for doing the same thing\n\n![Kotlin is concise](http://i.giphy.com/UnQ68p0AVulkQ.gif)\n","author":"Jim Baca","date":"2016-02-22","type":"article","categories":["Kotlin"],"features":["highlightjs"],"description":"","filename":"","lang":"EN","enclosure":null},{"title":"Writing Gradle Build Scripts in Kotlin","url":"https://www.youtube.com/watch?v=vv4zh_oPBTw","body":"\nAs you may have heard Kotlin-based build scripting is coming in Gradle 3.0. In this talk Chris Beams and Rodrigo B. de Oliveira will cover the motivation behind providing first-class support for Kotlin-based build scripts as well as the principles and design tradeoffs that drive the effort. We’ll demonstrate a Kotlin-based Gradle build in action show you how to try it for yourself and share details about the project roadmap.\n\n<iframe width=\"960\" height=\"480\" src=\"https://www.youtube.com/embed/vv4zh_oPBTw\" frameborder=\"0\" allowfullscreen></iframe>\n\n","author":"Chris Beams & Rodrigo B. de Oliveiranp","date":"2016-08-05","type":"video","categories":["Kotlin","Gradle"],"features":["highlightjs"],"description":"","filename":"","lang":"EN","enclosure":null},{"title":"Making Android Development Easier","url":"https://medium.com/@maannajjar/progressive-android-ui-development-28d281dbe21b#.g8c7xq81a","body":"\n#### Taking Ideas From The Front-End Web\n\nIf you’ve done Android, you know how quickly your code can grow in complexity as you build out your app. Java is known for boilerplates, and UI-related code (XML & Java combined) will probably take the most of your code. In this post, I’m proposing new solution to make Android UI development much easier and less time consuming. It encourages patterns that may be new for Android, but it existed for long while in front-end development.\n\nAndroid SDK has a remarkable UI framework that allows you to build user interfaces in clear and concise way using XML. The layout system is very well thought out, you can build any kind of complex interface using it. But due to the dynamic aspects of user interfaces and the evolving UI design patterns nowadays, building UI becomes more complicated than just writing XML and it will involve a lot of Java & XML writing.\n\n#### **Front-End Web vs Android Development**\n\nWhen compared to mobile or desktop app development in general, I consider web as the easiest platform for building user interfaces. I was impressed by how the front-end community recently created impressive tools that made front-end development much easier and more disciplined. From Grunt, Gulp, Bower, Babel, ES6 to SASS, Bootstrap to React or Angular. There are also so many good patterns that existed in front-end development. Web existed for more than 20 years, so it’s only natural that they have reached this level of maturity when it comes to building UIs.\n\nThanks to the brilliant XML layouts in Android, I realized there’s a resemblance between Android and front-end web. You can think of XML as the HTML, and Java as the JavaScript. Except in Android we’re at the point of pre-jQuery, we still don’t have the frameworks that allow us to quickly build and manage UI. Android layout system is very flexible, and it provides great opportunities to create such frameworks. We have to take advantage of that and take it to the next level. The patterns used for front-end development are not exclusive to web, we can apply them on Android.\n\nJust to clarify, Android & Java community has written amazing libraries that also made Android development much easier. Just put Retrofit, RxJava, Realm and Kotlin together to create magic, you will be saving a great amount of time writing code. However there are many other challenges that are yet to be solved. This has motivated me build a UI framework inspired by the front-end web. Today, I finally published my [LatteKit](https://github.com/maannajjar/lattekit) framework and made it public in github. But before checking it out, please let me take you through the the problems the framework should solve.\n\n#### **Identifying The Problem**\n\nAs I started mulling the idea of creating UI framework, I needed to identify the problems that needed to be solved by my framework. There must be real problems to solve, I didn’t want this to be just an attempt to copy the web. I tried making a small app in Android & web app in order to help me see the things that made Android more complicated. Below are the major points I found:\n\n**1- Non-streamlined UI development**\n\nFrom design perspective, your app consists of screens that contain set of UI elements. However, it becomes very complicated when you start building the UI in Android. In Android, there are many different types of components that are directly or indirectly related to building the UI. For example, we have Activity that may contains View widgets (subclasses of android.view.View) and/or Fragments, we also have ListViews and Adapters. Each one of those component has a different way to create and manage, passing data between those components can be very different. Fragments work with Bundles, ListView (and others) require Adapters, Activities need Intents, ..etc. Those components have clear purpose and function, but at the end of the day they all play the same part in building the layout tree. All the internals should be abstracted so the components are used in uniform and streamlined way.\n\n**2- Styling UI components**\n\nStyling UI views are done via XML, but not always. Styling in XML may cause a lot of boilerplate. Sometimes you may end up creating 2–3 xml files to achieve single styling objective. Sometimes you’re forced to subclass a certain View in java. For example, if you need to create a circular ImageView, you will have to subclass it and override the drawing method. In Web those are all done in CSS using simple CSS properties.\n\n**3- View Re-usability and Separation of Concerns**\n\nMany times you will need to group views together that perform specific UI function. You can do that by either using `<include>` tag or by subclassing some ViewGroup class and inflating your xml there. Using `<include>` tag alone is not real solution because you will still have to write related Java code in the user code (e.g. in Fragment or Activity). Subclassed custom Views are difficult to manage (for example, if you want your custom view to have some certain custom attributes you will have to define those attributes in attrs.xml, then you will have to capture them in the constructor by reading AttributeSet.) They introduce more boilerplate that sometimes it’s not worth writing a whole subclass of View, you end up writing most your layout in the fragment or activity. When you decide to refactor, the code will be intermingled and hard to move out to its own class.\n\n**4- Majority of apps contain ListView/RecyclerViews/ViewPager. Writing Adapters is a waste of time**\n\nAdapter based Views are basically container views that show repeated UI elements. In web, all it takes is to write a loop which iterates through your dataset and render the UI elements. In Android (and similarly in iOS), you have to a define new Adapter class that will manually create the UI elements and bind the data. This was done for optimization purposes, Adapters help you recycle re-usable views. I understand the need to use Adapters for optimization, but there’s so much repeated pattern when writing Adapters that can be abstracted and make using ListViews (and others) easier.\n\n#### Designing The Solution\n\nI’ll present below my attempt to solve the problems above. My goal is not to create a new UI toolkit, but rather build a framework on top of Android layout system. The framework will manage views behind the scene and abstract many aspects of the underlying Android API. I established some general principles that I should follow while designing my framework\n\n**1- The framework shouldn’t introduce new complicated concepts to Android developers**\n\nIt should serve a single purpose: allow you to build the UI and get out of the way. No complicated APIs to learn. Android developer should find it very easy to adapt to the framework.\n\n**2- The framework should provide uniform and concise way to build UI**\n\nThere should be only one way to build a layout. The framework shouldn’t provide different and confusing alternatives to build certain UI elements.\n\n**3- Defining a View should only mean writing one file, and with minimum boilerplate**\n\nYou shouldn’t be jumping between xml and java files.\n\n**4- The framework should use proven patterns to build UIs**\n\nI shouldn’t be creating my own pattern to build UIs, there are tons of proven patterns that already worked and I don’t need to get too creative and invent something totally new.\n\nI started testing different frameworks used for front-end development. Two popular frameworks that caught my attention are Angular and React. I was very impressed by React and its simplicity. It doesn’t introduce new concepts and it has low learning curve. All you need to know is HTML & JavaScript and basic details about the lifecycle of React components. It introduces the concept of virtual DOM, and provides a way to bind data. You can read more about it here [https://facebook.github.io/react/](https://facebook.github.io/react/). React model also fits perfectly with my 4 principles. They do have React Native which is framework to build for mobile including Android. However, it introduces new concepts and it relies on JavaScript which is strange to Android. Also, you will have to write bridges between Java & JavaScript if you want to use Android’s API.\n\n**Plain Java Won’t Work**\n\nWhile designing my framework. I decided that I shouldn’t be using plain Java for many reasons. First, it will introduce many boilerplates that will defeat the purpose of the framework. Second, for technical reasons I needed some features that Java can’t offer.\n\nLuckily there’s Kotlin, which is becoming a rising start in Android development. Kotlin is modern JVM language that provides modern language features which are missing in Java. It heavily reduces the boilerplate code and it’s interoperable with Java. It works great with Android and it’s supported in Android Studio (Kotlin was created by JetBrains, the maker of IntelliJ IDEA).\n\n#### **And LatteKit Was Born...**\n\nThere’s so much to talk about LatteKit and how I built it. The concept should be clear though. If you know minimal Kotlin & CSS with Android knowledge, you should be able to pick up the concept quickly. I created a quick example & documentation in the github repository. There is also a full sample which shows how much lines of code you will save when using the library, it’s really a lot. Available at:\n\n[https://github.com/maannajjar/lattekit](https://github.com/maannajjar/lattekit)\n\nPlease take a look, try it out and let me know what you think. Keep in mind that this a first release, the core functionality is complete but there are many things left to do in the roadmap.\n\nBelow is a quick sample I built using the library , you can view the source code in the github repo which shows the minimal line of codes needed.\n\n![](https://d262ilb51hltx0.cloudfront.net/max/800/1*fULW0kZcUOPcPOmm5QMaBQ.png)\n\nI’ll dedicate another post about the patterns to use with LatteKit & Kotlin, which will make building Android apps very quickly and with the minimal effort. I’m happy with what I have accomplished so far, I’m also not taking full credit for the idea because it was inspired by React which proved to work really well in the web.\n","author":"Maan Najjar","date":"2016-04-11","type":"article","categories":["Android","Kotlin"],"features":["highlightjs"],"description":"","filename":"","lang":"EN","enclosure":null},{"title":"Kotlin: val does not mean immutable, it just means readonly, yeah","url":"https://artemzin.com/blog/kotlin-val-does-not-mean-immutable-it-just-means-readonly-yeah/","body":"\nHey hey, dear reader!\n\nI'm [seeing how people](https://www.toptal.com/android/kotlin-boost-android-development) (including myself some time ago) tend to think that `val` in Kotlin means **immutable**. Unfortunately, this is not true \uD83D\uDE1E\n\nObviously, `val` can not guarantee that underlying object is **immutable**, that's clear.\n\n> But can we say that `val` guarantees that underlying **reference** to the object is **immutable**?\n\nNo...\n\nKotlin allows you declare `get()` of the `val` which breaks immutability of the property and leaves only `read` permission for external \"users\".\n\nExample:\n\n```kotlin\nclass OhNo {\n\n  val yeah: Int\n    get() = Random().nextInt()\n\n}\n\n```\n\nThings are especially sad when you declare `val` in an `interface`:\n\n```kotlin\ninterface SomeService {  \n  val user: User\n}\n```\n\n**Until you check implementation** (which is not always possible) you can't be sure that value will be same each time you read it from the property.\n\nReal world example is `List.size` from Kotlin stdlib.\n\n#### How to live with that?\n\nWe have a **convention** (hopefully haha, at least I point to that in code reviews) internally in our team (100% Kotlin) to not declare properties like `val currentSomething: Something`, if value can be different each time you read it — please declare a function: `fun currentSomething()` or just `fun something()` because when it's a function then it's clear that resulting value can be different on each call. But for types that clearly represent \"volatility\" themselves, like `rx.Observable` it's ok to have them as `val`.\n\nGood thing is that in `data class` you can't define `get()` for properties declared in the constructor, but you can do it for non-constructor properties.\n\n> We've discussed that with [@abreslav](https://twitter.com/abreslav) and [@volebamor](https://twitter.com/volebamor) from Kotlin team, but looks like there is nothing Kotlin team can do about this at the moment. Would be great to have clear separation of immutable `val` and `readonly val`, but that's just dreams. Though I've opened an [issue](https://youtrack.jetbrains.com/issue/KT-13578) for highlighting that `val` has overriden `get()` in IDE.\n\nStay immutable!\n\n","author":"Artem Zinnatullin","date":"2016-08-30","type":"article","categories":["Kotlin"],"features":["highlightjs"],"description":"","filename":"","lang":"EN","enclosure":null},{"title":"Getting started with Kotlin in Android development","url":"https://datarockets.com/blog/kotlin-in-android-development","body":"\nKotlin programming language now on everyone's lips. Some people seriously considered it as a full-fledged replacement of Java in Android development. It is a modern, statically-typed language aimed at trying to make the code simpler and clearer for everyone and bring long-awaited Java features to Android developers. Let's look at the history of that language, sort out the pros and cons of the language, as well as a look at an example and how you can start using Kotlin in current projects.\n\n\n## Why Kotlin was created and by whom?\n\nCreating of language began in 2010 at Jetbrains by two talented programmers - Andrew Breslav and Dmitry Zhemerov. These guys dreamed about removing those restrictions which are imposed on developers in Java 6: no streams, no lambda functions, no try-with-resources and etc. Kotlin creators wanted to invent null-safety language that could be more flexible and friendlier than Java. They provided a solution of so-called ‘one billion problem’: null by default. Many of these features have appeared only in the latest versions of Java but were implemented by Kotlin creators.\n\n## A slight dive into Kotlin syntax\n\nStarting to develop an Android application on Kotlin is not very difficult. Let's see how the declaration of variables looks.\n\n```kotlin\nvar explicitName : String = \"Kotlin\" // Here we declare the type\n\nvar implicitName = \"Kotlin\" // In that case we declare a variable implicitly\n```\n\nKotlin also allows you to declare immutable objects with keyword ‘val’.\n\nIt's time to tell you how null-safety in Kotlin works. In Java, when we need to check variable for null, we usually write block.\n\n```kotlin\nif (name != null) {\n   name.length\n}\n```\n\nIn Kotlin, we can do the same thing in one line.\n\n```kotlin\nName?.length\n```\n\nLet’s define the variable this way:\n\n```kotlin\nval name : String = null\n```\n\nThe compiler will generate an error - there should be at least some value. Since Kotlin considers itself as null-safety language, that makes a bet on prevention of such situations during compilation.\n\nIf you're a fan of hardcore, it’s possible to compile the code, but I would not recommend to do it this way:\n\n```kotlin\nval name: String!! = null\n```\n\n## Collections\n\nIf you had an experience with developing on Java, there is nothing special in Kotlin. I would say that Kotlin simplified everything for us again. Instead of LinkedLists and ArrayLists, we have  Lists, Maps, etc.\n\nKotlin allows us to define immutable lists.\n\n```kotlin\nval list: List<String> = listOf(\"Kotlin\", \"is\", \"awesome\")\nlist.add(\"though\") // No such method, guys!\n```\n\nIf you decided to use mutable list, you can use generic MutableList<T>:\n\n```kotlin\nval mutableList: MutableList<String> = mutableListOf(\"Kotlin\", \"is\",\"awesome\")\nmutableList.add(\"though\")\n```\n\n\n## Methods\n\nLet’s write a simple method:\n\n```kotlin\nfun summarize(a: Int, b: Int) : Int {\n    return a + b\n}\n```\n\nThe first argument is the name of the parameter, and then type. After the colon, we specify the return type, if required. Do not forget that Kotlin is very, very friendly, so with this elementary function, we can write it in one line.\n\n```kotlin\nfun summarize(a: Int, b: Int) : Int = a + b\n```\n\nKotlin also provides an ability to use default parameters:\n\n```kotlin\nfun summarize(a: Int, b: Int = 20) : Int {\n    return a + b\n}\n```\n\nAnd yeah, you can write lambda-expressions.\n\n## Classes\n\nClasses and methods in Kotlin are final by default. We can construct classes in two ways: with primary and secondary constructors. The primary class constructor is a part of header. Also, it doesn’t have any code to execute. If we need to do some operations, we can use ‘init’ block.\n\n```kotlin\nclass Cat(val name: String)  {\n    init {\n        println(\"We've just initialized Cat with ${name}\")\n    }\n}\n```\n\nSecondary constructor works, like in Java, without any difference.\n\n```kotlin\nclass Dog: Animal {\n    constructor(name: String) {\n    }\n}\n```\n\nAs you can see, super method works like inheritance and it’s absolutely incredible.  \n\n```kotlin\nclass Cat : Animal {\n    constructor(name: String) : super(name) {\n    }\n}\n```\n\n## Data-classes\n\nI’m sure, during development, you’re using POJO-objects that don’t contain any specific logic. Kotlin creators decided to make developers satisfied and now you can submit your model as a data-class.\n\n```kotlin\ndata class Person(\n    val firstName: String,\n    val lastName: String\n)\n```\n\nThat’s all. All the necessary getters and setters are there by default.\n\nIf you want to use data class, just make an instance by this construction:\n\n```kotlin\nval person = Person(\"Paul\", \"Johnson\")\n```\n\nWe can also make changes based on initialized instance of data class using ‘copy’ method.\n\n```kotlin\nval newPerson = person.copy(first_name=\"Carl\")\n```\n\n## Extension functions\n\nExtension functions is an incredible replacement of many Utils classes which may have been in the separate package. Are you familiar with monkey-patching in Ruby? In Kotlin, that feature is called “extension functions” and it provides an ability to shorten your code the easiest way. Let’s see an example:\n\n```kotlin\nfun Context.showMeToast(text: String) {\n    Toast.makeText(this, text, Toast.LENGTH_SHORT).show()\n}\n```\n\nWe have just replaced this ugly boilerplate construction with an elegant and short method.\n\n## Enough of these tutorial-like snippets! Let’s get to the real code!\n\nIn March, within a few weeks, I wrote Munchkin Level Counter for use in the world-famous game. I decided to build an application with the usage of pattern proposed by Android-developer and Kotlin-lover, Antoine Leiva, who demonstrated how to build an application in the MVP architecture. It is even more reminiscent of VIPER popular architecture for developing iOS, which, in our version, deleted the letter R (Router).\n\nWe are constantly improving our application to provide the best user experience. We added dependency injection to Dagger and transferred all the code on Kotlin. We plan to use RxJava to eliminate the heaps of the implementation of interfaces that do not make the code  elegant nor beautiful for the perception of any developer.\n\nLet's see how on the presenter class Toad on Kotlin.\n\n```kotlin\npublic class DashboardPresenterImpl implements DashboardPresenter, DashboardInteractor.OnLoadPlayerListener {\n\n   private DashboardView dashboardView;\n   private DashboardInteractor interactor;\n\n   public DashboardPresenterImpl(DashboardView dashboardView, DashboardInteractor interactor) {\n       this.dashboardView = dashboardView;\n       this.interactor = interactor;\n   }\n\n   @Override\n   public void updatePlayerListItem(Player player, int position) {\n       if (dashboardView != null) {\n           interactor.updatePlayer(player, position, this);\n       }\n   }\n\n   @Override\n   public void onResume() {\n       if (dashboardView != null) {\n           interactor.loadPlayersList(this);\n       }\n   }\n\n   @Override\n   public void onFinished(ArrayList<Player> players) {\n       if (dashboardView != null) {\n           dashboardView.setItems(players);\n       }\n   }\n\n   @Override\n   public void onPlayerUpdated(Player player, int position) {\n       if (dashboardView != null) {\n           dashboardView.updatePlayerData(player, position);\n       }\n   }\n\n   @Override\n   public void onDestroy() {\n       if (dashboardView != null) {\n           dashboardView = null;\n       }\n   }\n\n   @Override\n   public void setGameFinished() {\n       if (dashboardView != null) {\n           interactor.setGameFinished();\n       }\n   }\n\n   @Override\n   public void insertStep(Player player) {\n       if (dashboardView != null) {\n           interactor.insertStep(player);\n       }\n   }\n}\n```\n\nYou can see that whenever we send the data through the presenter in the interactor, it works with business logic. If the user closes the application, and Activity is destroyed, we can be sure that the callback interactor will not appeal to DashboardView interface which will appeal to the reel to send data to the user's screen (View).\n\nWe have re-written this class in Kotlin. It can be achieved with plug-in for Android Studio, made by JetBrains, and will automatically convert the code from Java to Kotlin.\n\n```kotlin\nclass DashboardPresenterImpl : DashboardPresenter, DashboardInteractor.OnLoadPlayerListener {\n\n   private var interactor: DashboardInteractor\n   private var dashboardView: DashboardView?\n\n   constructor(dashboardView: DashboardView, interactor: DashboardInteractor) {\n       this.dashboardView = dashboardView\n       this.interactor = interactor\n   }\n\n   override fun updatePlayerListItem(player: Player, position: Int) {\n       interactor.updatePlayer(player, position, this)\n   }\n\n   override fun onResume() {\n       interactor.loadPlayersList(this)\n   }\n\n   override fun onFinished(players: ArrayList<Player>) {\n       dashboardView?.setItems(players)\n   }\n\n   override fun onPlayerUpdated(player: Player, position: Int) {\n       dashboardView?.updatePlayerData(player, position)\n   }\n\n   override fun onDestroy() {\n       dashboardView = null\n   }\n\n   override fun setGameFinished() {\n       interactor.setGameFinished()\n   }\n\n   override fun insertStep(player: Player) {\n       interactor.insertStep(player)\n   }\n}\n```\n\nWe were able to reduce the code by approximately 20 lines. We excluded checks at Null in three lines, which occupied an important place. When we turn to the interactor, we do not need to know about the status of the twist, so from this part of the code, it can be eliminated. It is much more important to know the state of the twist when we send a callback from interactor back to the presenter. We need to know the state of the twist and interface call methods that are implemented in the Activity code. As a result, the code looks cleaner, clearer and still performs its tasks.\n\nLet's look at how we can improve the code in the Activiti.\n\nWe have an activity where we load game results in three fragments that display charts and a list of players with sorting by maximum points.\n\n```kotlin\npublic class GameResultActivity extends AppCompatActivity implements GameResultView {\n\n   public static final String TAG = LogUtil.makeLogTag(GameResultActivity.class);\n\n   private GameResultPresenter presenter;\n   private Toolbar toolbar;\n   private ViewPager vpCharts;\n   private TabLayout tlChartsTitle;\n   private ChartsPagerAdapter vpChartsAdapter;\n\n   @Override\n   protected void onCreate(Bundle savedInstanceState) {\n       super.onCreate(savedInstanceState);\n       presenter = new GameResultPresenterImpl(this, this);\n       setContentView(R.layout.activity_game_result);\n       toolbar = (Toolbar) findViewById(R.id.toolbar);\n       setSupportActionBar(toolbar);\n       getSupportActionBar().setHomeButtonEnabled(true);\n       getSupportActionBar().setDisplayHomeAsUpEnabled(true);\n       presenter.onCreate();\n   }\n\n   @Override\n   public void loadChartFragments() {\n       vpCharts = (ViewPager) findViewById(R.id.vp_charts);\n       vpChartsAdapter = new ChartsPagerAdapter(getSupportFragmentManager(), this);\n       vpCharts.setAdapter(vpChartsAdapter);\n       vpCharts.setOffscreenPageLimit(3);\n       tlChartsTitle = (TabLayout) findViewById(R.id.tl_charts_title);\n       tlChartsTitle.setupWithViewPager(vpCharts);\n   }\n\n   @Override\n   protected void onResume() {\n       super.onResume();\n   }\n\n   @Override\n   public void onBackPressed() {\n       super.onBackPressed();\n       presenter.onBackPressed();\n       Intent intent = new Intent(this, PlayersListActivity.class);\n       startActivity(intent);\n       finish();\n   }\n\n   @Override\n   public boolean onOptionsItemSelected(MenuItem item) {\n       switch (item.getItemId()) {\n           case android.R.id.home:\n               onBackPressed();\n               return true;\n           default:\n               break;\n       }\n       return false;\n   }\n\n   @Override\n   protected void onStop() {\n       super.onStop();\n       presenter.onStop();\n   }\n}\n```\n\nYou can see how an activity can look in Kotlin:\n\n```kotlin\nclass GameResultActivity : AppCompatActivity(), GameResultView {\n\n   companion object {\n       val TAG = LogUtil.makeLogTag(GameResultActivity::class.java)\n   }\n\n   private val toolbar by lazy { findViewById(R.id.toolbar) as Toolbar? }\n   private val vpCharts by lazy { findViewById(R.id.vp_charts) as ViewPager? }\n   private val tlChartsTitle by lazy { findViewById(R.id.tl_charts_title) as TabLayout? }\n   private val vpChartsAdapter: ChartsPagerAdapter = ChartsPagerAdapter(supportFragmentManager, this)\n\n   private val presenter: GameResultPresenter = GameResultPresenterImpl(this, this)\n\n   override fun onCreate(savedInstanceState: Bundle?) {\n       super.onCreate(savedInstanceState)\n       setContentView(R.layout.activity_game_result)\n       setSupportActionBar(toolbar)\n       supportActionBar?.setHomeButtonEnabled(true)\n       supportActionBar?.setDisplayHomeAsUpEnabled(true)\n       presenter.onCreate()\n   }\n\n   override fun loadChartFragments() {\n       vpCharts?.adapter = vpChartsAdapter\n       vpCharts?.offscreenPageLimit = 3\n       tlChartsTitle?.setupWithViewPager(vpCharts)\n   }\n\n   override fun onBackPressed() {\n       super.onBackPressed()\n       presenter.onBackPressed()\n       val intent = Intent(this, PlayersListActivity::class.java)\n       startActivity(intent)\n       finish()\n   }\n\n   override fun onOptionsItemSelected(item: MenuItem): Boolean {\n       when (item.itemId) {\n           android.R.id.home -> {\n               onBackPressed()\n               return true\n           }\n       }\n       return false\n   }\n\n   override fun onStop() {\n       super.onStop()\n       presenter.onStop()\n   }\n}\n```\n\nLet's look what we have changed.\n\nFirst, we have transferred the entire boilerplate-code findViewById View element code of the overridden method onCreate in properties, where we presented our view-components as \"lazy\" field. What does this mean? It means initialization happens as soon as we turn to this field in the onCreate. Second, we have transferred initialization of presenter and adapter for ViewPager.\n\n## But how we can make it much better?\n\nWe can simply use Butterknife. There are no big changes in comparison with standard Android development with Java.\n\n```kotlin\nprivate val toolbar by bindView(R.id.toolbar)\nprivate val vpCharts by bindView(R.id.vp_charts)\nprivate val tlChartsTitle by bindView(R.id.tl_charts_title)\n```\n\nLooks better! Let’s see what Kotlin offers us to work with creating layouts.\n\n## Anko\n\nTypically, Android developers have to write their views in the form of the XML markup. The parsing of XML-markup spent processor resources which caused the applications to load each activity a little longer. Usage of Anko DSL with Kotlin gives an enormous advantage. We can simply turn XML markup in domain-specific language provided by Anko.\n\n## Kotlin in action\n\nKotlin already being used in production. In May, I was able to listen to the presentation of two developers from the Belarusian startup, Juno. They built its application in new language. What interesting things did uncover? What is their stack? First, their application is made in the MVVM-architecture. Second, they use Dagger2, RxKotlin, Retrofit and Gson. The developers claim that they don’t completely use for-loops because of RxKotlin. Spek helps them to unit test their code.\n\n## What’s next?\n\nThe developers of Kotlin are constantly improving their language to provide the best experience to developers. For now, we can say that the goals which have been set in the beginning of the development of Kotlin have been achieved. Kotlin makes you write a better, cleaner and safer code, provides long-awaited Java features, and lets you use Java-code along with Kotlin. These are the pros, but we have cons too: compile time is a little bit longer than in Java and some of library is not compatible with Kotlin. But it’s not a serious issue, because the most popular libraries are used by developers from all over the world. So, Kotlin is a great choice to start development for Android now.\n\n","author":"Dmitry Chyrta","date":"2016-08-30","type":"article","categories":["Kotlin","Android"],"features":["highlightjs"],"description":"","filename":"","lang":"EN","enclosure":null},{"title":"An Introduction to Kotlin","url":"https://objectpartners.com/2016/02/23/an-introduction-to-kotlin/","body":"\n[Kotlin](https://kotlinlang.org/) is a relatively new language that keeps the good parts of Java while eliminating boilerplate and encouraging better Object Oriented programming style while still allowing a Functional paradigm. Best of all, it’s 100% Java-compatible which allows you to mix it with Java, Groovy, or any other Java-bytecode language. Kotlin is similar in many ways to Groovy by handling a lot of the more mundane aspects of coding in Java but unlike Groovy, which took a Dynamic Typing approach, Kotlin doubled-down on Static typing to help eliminate many of the common annoyances in Java.\n\n## Kotlin Features\n\nWhile Kotlin’s entire feature list is far too expansive to discuss in this post I would like to point out some of my favorites coming from a Java background. If you want to dive straight into some Kotlin code there is an [example program out on GitHub](https://github.com/mike-plummer/KotlinCalendar) that demonstrates most of the features discussed below.\n\n### Null Safety and Immutability\n\nBy default all variables are enforced as non-nullable by the compiler unless explicitly defined otherwise. By enforcing nullability constraints the compiler can automatically guard you from potential NullPointerExceptions and will, in fact, generate an error if you attempt to write unsafe code.\n\n```kotlin\nval myNonNullVariable: ComplexObject = ComplexObject()  // Declare non-nullable variable\nmyNonNullVariable = null                              // Compilation error, cannot assign null to this variable\n\nval myNullableVariable: ComplexObject?                // Declare a variable as nullable\nprintln myNullableVariable.getFieldA()                // Compilation error since variable could be null here\nprintln myNullableVariable?.getFieldA()               // Use a safe call to guard against NullPointerException\n                                                      // If variable is null then safe call will return 'null'\n```\n\nThis null-checking extends throughout Kotlin syntax, even into cast operations:\n\n```kotlin\nval variable: Any = \"A string value\"\nval stringVariable = variable as String                        // Unsafe cast that will succeed - note lack of nullability on types\n\nval nullVariable: Any? = null\nval nullableStringVariable: String? = nullVariable as String?  // Unsafe cast that will succeed - note that both sides must specify nullability\nval nullableStringVariable2: String? = nullVariable as? String  // The line above can also be done using the 'safe cast' operator\nval invalidCast = stringVariable as List                       // Guaranteed to throw a ClassCastException\n```\n\nKotlin also provides multiple mechanisms for declaring variables. When using the keyword ‘val’ a variable is implicitly treated as immutable meaning the compiler will only define a getter and will generate an error if an attempt is made to reassign. Declaring using ‘var’ means the variable is mutable thus a getter and setter will be generated.\n\n```kotlin\nclass ComplexObject {\n    val fieldA: String = \"Value 1\"   // Non-nullable immutable String (just a getter will be generated)\n    var fieldB: String = \"Value 2\"   // Non-nullable but mutable (will have getter and setter generated)\n    var fieldC: String?              // Nullable, will require null checks or safe call operator ( ?. )\n    val fieldD = \"Value 4\"           // Type will be inferred if omitted but value is initialized\n}\n```\n\n### Boilerplate Reduction\n\nMuch like Groovy, Kotlin handles auto-generating much of the common logic in your programs. As previously discussed Getter and Setter methods are auto-generated but can be overridden with custom logic if desired. In addition, marking a class with the keyword ‘data’ will treat it as a Data Transfer Object and will auto-generate ‘equals’, ‘hashCode’, ‘copy’, and ‘toString’ methods.\n\n### Flexibility\n\nClasses can overload any standard operator which can aid code brevity and readability. In cases where appropriate operators don’t exist an ‘infix’ function can be declared which enables it to be used without dot notation or parentheses, making it look and behave much like a custom operator.\n\n```kotlin\n// Use infix to declare an \"operator\" function to allow somewhat cleaner code\n// This also happens to be an extension function (see below)\n// In this case, perform a subtraction and return the absolute value of the result\ninfix fun Long.absSubtract(input: Long): Long {\n    return Math.abs(this - input)\n}\n\nprintln(1L absSubtract 5L)  // prints positive 4\n```\n\nExtension functions can be added to any class at runtime which enables you to add behaviors to classes you use without forcing you to subclass them.\n\n```kotlin\n// Anywhere this function is imported all Duration objects will gain this function\nfun Duration.prettyPrint(): String {\n    return \"${toHours()}:${toMinutes() % 60}:${get(ChronoUnit.SECONDS) % 60}\"\n}\n\nDuration.ZERO.prettyPrint()  // Outputs '0:0:0'\n```\n\nFinally, Kotlin has excellent support for delegating functions and properties to member variables or extended classes. This is an alternative to gaining behaviors through extension and is a really simple way to implement several popular design patterns with minimal code.\n\n```kotlin\ninterface WakeUpProvider {\n    fun wakeUp()\n}\n\nclass AlarmClock() : WakeUpProvider {\n    override fun wakeUp() {\n        println(\"Alarm Clock woke you up!\")\n    }\n}\n\n// Make WakeUpSystem delegate to 'provider' any 'WakeUpProvider' interface functions\nclass WakeUpSystem(provider: WakeUpProvider) : WakeUpProvider by provider\n\nfun main(args: Array) {\n    val provider = AlarmClock()\n    WakeUpSystem(provider).wakeUp() // Prints 'Alarm Clock woke you up!'\n}\n```\n\n### The Kotlin Object\n\nObject is a special type in Kotlin that is very different from Java’s Object base type. Object is a versatile construct that can be used much like ad-hoc objects in JavaScript, easily build a Singleton, or add static-like capabilities to your Kotlin classes.\n\n#### Ad-hoc Objects\n\nObject can be used to generate on-the-fly structures without going through the work of defining a class. When used as part of an expression like this the Object is evaluated as the line is executed which contrasts with other uses of Object that are initialized the first time they are referenced.\n\n```kotlin\nvar adhoc = object {\n    val first = \"firstValue\"\n    val second = \"secondValue\"\n}\n\nprintln(\"${adhoc.first}, ${adhoc.second}\")    // Prints \"firstValue, secondValue\"\n```\n\n#### Singleton\n\nIf you need a Singleton you can simply write an Object declaration (contrasted with the Object expression used above) that will behave much like a class with static fields and methods in Java.\n\n```kotlin\nobject MySingleton {\n    val aSingletonValue = \"ValueA\"\n    fun aSingletonFunction() {\n        println(\"Yay for Kotlin Objects!\")\n    }\n}\n...\nprintln(MySingleton.aSingletonValue)       // Prints \"ValueA\"\nprintln(MySingleton.aSingletonFunction())  // Prints \"Yay for Kotlin Objects!\"\n```\n\n#### Companion\n\nObjects can be used as Companions in Kotlin classes to add static-like properties and functions to the class. The Companion will be constructed only once and shared amongst all instances of the containing class.\n\n```kotlin\nclass ClassWithCompanion {\n    companion object {\n        fun PrintAMessage() {\n            println(\"I'm a function in the Companion!\")\n        }\n    }\n}\nClassWithCompanion.PrintAMessage()    // Note the 'static' access. Prints \"I'm a function in the Companion!\"\n```\n\n### Java Goodness\n\nComing from a Java background? Good news! All the familiar Java concepts and libraries are still available. Interfaces, abstract/inner classes, the Java standard library, generics, enums, etc all are present and for the most part behave in exactly the same way. On top of the basics all the latest features in Java such as Lambdas and Streams are available in Kotlin.\n\nA notable exception is the lack of ‘static’ variables and methods. Often ‘static’ was misused and ended up breaking many precepts of Object Oriented design. In Kotlin this has been supplanted by Object, Companions, and package-level declarations to encourage proper encapsulation and separation of concerns while still providing the same features.\n\nFor a more complete comparison of how Kotlin compares with Java I recommend [this article](https://kotlinlang.org/docs/reference/comparison-to-java.html).\n\n#### Fixes for Common Annoyances\n\nJava’s been around long enough for everyone to find a few features they dislike. Kotlin attempts to fix a number of the most common complaints.\n\n##### Automatic Casting\n\nHow many times have you written code like this in Java?\n\n```java\nObject unknownObjectType = ...\nif (unknownObjectType instanceof String) {\n    String castString = (String) unknownObjectType;    // Have to cast in order to treat it like a String\n    castString.indexOf(\"abc\");\n}\n```\n\nNever fear, you will never have to write that in Kotlin! The Kotlin Compiler is smart enough to track the state of a variable as it executes which means it ‘knows’ everything various conditionals and other constructs tell it.\n\n```kotlin\nval unknownObjectType: Any = ...\nif (unknownObjectType is String) {\n    unknownObjectType.indexOf(\"abc\")    // Compiler knows it's a String here so it is auto-cast\n}\n```\n\n##### Destructuring\n\nAnother common annoyance is that occasionally you need to call a function that returns an object but then have to immediately pull only a subset of fields out of that object. Kotlin supports ‘destructuring’ similar to ECMAScript 2015, and supports destructuring in loop expressions.\n\n```kotlin\nval complexObjectCollection: Collection\nfor ( (fieldA, fieldB) in complexObjectCollection) {\n    // Variables fieldA and fieldB are accessible here and will be equal to fields\n    // named 'fieldA' and 'fieldB' from each item in the collection\n}\n```\n\n##### Generics\n\nIn the Java world generics are certainly a boon, but certain design decisions and limitations leave them with a number of significant gotchas. Most of these are related to the wildcard generic (?) which has been eliminated in Kotlin. Kotlin makes use of new keywords ‘in’ and ‘out’ to help further define generic bounds similar to the PECS (Producer-extend, Consumer-super) concept in Java without the same shortcomings.\n\n##### Equality\n\nTired of having to remember when it’s safe to use == and doing null-checks before calling ‘.equals(..)’? Kotlin uses == as ‘structural equality’ and === as ‘referential equality’. Put another way, == is the same as calling ‘.equals(..)’ while guarding against null in Java whereas === maps to Java’s ==.\n\n```kotlin\nval stringA: String = \"New York\"\nval stringB: String = \"New \" + \"York\"\nval stringC: String = stringA\nprintln(stringA == stringB)     // True, contents are equal\nprintln(stringA === stringB)    // False, not the exact same object\nprintln(stringA === stringC)    // True, both reference the same object\n```\n\n##### Inlining\n\nFinally, for anyone with C or C++ experience I’m sure you’re well-aware that Java doesn’t allow you to request a method be [inlined](https://en.wikipedia.org/wiki/Inline_expansion). Kotlin allows you to mark any function with the ‘inline’ keyword which makes the compiler insert that function’s code anywhere the function is called. At runtime this means fewer function calls at the expense of increasing the size of your compiled artifact. This isn’t necessary for most programs but can be a useful performance tweak especially when calling many lightweight functions in a large loop.\n\n### Exception Handling\n\nMany people have mixed feelings on this but Kotlin does not have the concept of Checked Exceptions. If a method you’re calling potentially throws an exception you are not required to catch it. This reduces the number of try-catch blocks in your code, especially in situations where you know a normally-checked exception truly can’t be thrown. Other than this, exceptions basically work the same as in Java.\n\n## Environment\n\nThere are a number of options for developing in Kotlin. Excellent IDE support is integrated into IntelliJ IDEA and a plugin is available for Eclipse. Outside of an IDE environment you can compile and run Kotlin using Gradle, Maven, Ant, or standalone command line tools.\n\nInformation and downloads for these are available at [kotlinlang.org](https://kotlinlang.org/).\n\n## Testing\n\nA new 100% Kotlin-based testing framework, Spek, is also under development. For those who have worked with Spock or Mocha it will be very familiar – tests are broken down into a series of nested “given-on-it” clauses to help semantically structure your tests and encourage targeted, readable tests.\n\n```kotlin\nclass DurationExtensionSpecs: Spek() {\n    init {\n        given(\"A zero duration\") {\n            var duration = Duration.ZERO\n            on(\"adding time values using method chaining\") {\n                duration = duration.plusHours(2).plusMinutes(5).plusSeconds(12)\n                it(\"should reflect the expected value\") {\n                    shouldEqual(duration.toHours(), 2)\n                    shouldEqual(duration.toMinutes() % 60, 5)\n                    shouldEqual(duration.get(ChronoUnit.SECONDS) % 60, 12)\n                }\n            }\n        }\n    }\n}\n```\n\nThankfully the ever-popular Hamcrest library has been ported over to Kotlin as [HamKrest](https://github.com/npryce/hamkrest) which allows you to write very powerful tests the same way you would in JUnit.\n\n## Example\n\nI’ve coded up a simple example of using Kotlin in a standalone program [out on GitHub](https://github.com/mike-plummer/KotlinCalendar). This program demonstrates much of what I’ve discussed here, including many of Kotlin’s core features and Spek tests.\n\n## Conclusion\n\nI hope I’ve shown you a few reasons to get excited about Kotlin and want to use it in your next project. Especially now that version 1.0 has dropped it’s never been a better time. Popular frameworks like Spring Boot are [adding support](https://spring.io/blog/2016/02/15/developing-spring-boot-applications-with-kotlin) which makes it downright easy to gain the power and expressiveness of Kotlin. If you have any questions leave a comment below. If you would like to see more detail on specific Kotlin features leave that below too; if there’s enough interest I will explore them in future posts. In the meantime, take a look at the [example code](https://github.com/mike-plummer/KotlinCalendar) and [Kotlin docs](https://kotlinlang.org/docs/). Happy coding!\n\n","author":"Mike Plummer","date":"2016-02-23","type":"article","categories":["Kotlin"],"features":["highlightjs"],"description":"","filename":"","lang":"EN","enclosure":null},{"title":"First glimpse of Kotlin 1.1: Coroutines, Type aliases and more","url":"https://blog.jetbrains.com/kotlin/2016/07/first-glimpse-of-kotlin-1-1-coroutines-type-aliases-and-more/","body":"\nWhile Kotlin 1.0.X releases keep delivering incremental updates and tooling features, we are working on the new language features in Kotlin 1.1. Today we are presenting the first preview version of 1.1, it’s far from Beta, but the brave and curious ones can play with new exciting things (and hopefully give us their invaluable feedback).\n\n## Compatibility\n\nThis is not a stable version of Kotlin, and **no compatibility guarantees** are given here: in the future previews of 1.1, syntax, APIs, command-line switches and anything else may be changed. If you need a stable version of Kotlin, please stay on 1.0.X until further notice.\n\n## Feedback\n\nThe upside of this temporary lack of guarantees is that we can make immediate use of all the feedback you provide us! The best way to tell us what you think is through [KEEP](https://github.com/Kotlin/KEEP): please leave your comments on the issues associated with proposals mentioned below. The implementations in Kotlin 1.1 M01 are prototypes of the functionality described in the KEEPs.\n\n## Overview\n\nThe full changelog for 1.1 M01 is available [here](https://github.com/JetBrains/kotlin/blob/1.1-M1/ChangeLog.md#11-m01-eap-1).\n\n## Coroutines\n\nWe all know that blocking is bad under a high load, that polling is a no-go, and the world is becoming more and more push-based and asynchronous. Many languages (starting with C# in 2012) support asynchronous programming through dedicated language constructs such as `async`/`await` keywords. In Kotlin, we generalized this concept so that libraries can define their own versions of such constructs, and `async` is not a keyword, but simply a function.\n\nThis design allows for integration of different asynchronous APIs: futures/promises, callback-passing, etc. It is also general enough to express lazy generators (`yield`) and cover some other use cases.\n\nSo, meet one of the bigger features of Kotlin 1.1: _coroutines_. This is a traditional CS term for “program components that generalize subroutines for nonpreemptive multitasking”, but we’ll not dive into theory here ![:)](https://i2.wp.com/blog.jetbrains.com/kotlin/wp-includes/images/smilies/simple-smile.png?zoom=1w=64&ssl=1)\n\n```kotlin\nfun main(args: Array<String>) {\n    val future = async<String> {\n        (1..5).map {\n            await(startLongAsyncOperation(it)) // suspend while the long method is running\n        }.joinToString(\"\\n\")\n    }\n\n    println(future.get())\n}\n```\n\nThe great thing about coroutines is that they can _suspend_ without blocking a thread, and yet they look like normal sequential code. Please see a [detailed description](https://github.com/Kotlin/kotlin-coroutines/blob/master/kotlin-coroutines-informal.md) and examples in a dedicated [KEEP repository](https://github.com/Kotlin/kotlin-coroutines) and comment on the [issues there](https://github.com/Kotlin/kotlin-coroutines/issues).\n\nWe are prototyping coroutine-based libraries [here](https://github.com/Kotlin/kotlinx.coroutines), to be later included with the Standard Library. This includes JDK’s `CompletableFuture`, asynchronous IO (NIO), RxJava, and off-loading tasks from the UI thread in Swing. The repo contains examples as well as the libraries themselves. To play with it, follow the instructions in the [readme file](https://github.com/Kotlin/kotlinx.coroutines/blob/master/README.md).\n\n## Type aliases\n\nIn Kotlin 1.1 we can write\n\n```kotlin\ntypealias Action<T> = (T) -> Unit\n```\n\nThis means that we can use `Action<T>` interchangeably with `(T) -> Unit`, i.e. it is a true **alias**. Type aliases are useful for abbreviating longer types that are used in multiple places in the code:\n\n* function types with complex signatures: `UserAction = (User, Context) -> ActionResponse`,\n* complex generic types: `Multimap<K, V> = Map<K, List<V>>`\n\nIn anticipation of your questions: this feature does not cover the use cases where the aliased type is not assignable to the original type (something similar to newtype in Haskell): e.g. if we try to implement units of measurement and say\n\n```kotlin\ntypealias Length = Double\ntypealias Weight = Double\n```\n\nit won’t do us much good, because `Length` can be freely assigned to `Weight` and vice versa. In fact, they can both be assigned to and from a regular `Double`. We understand the importance of such use cases, and are planning to cover them in the future, most likely through _value classes_, but that’s another story. For now we only have type aliases.\n\nRead more and comment [here](https://github.com/Kotlin/KEEP/issues/4).\n\n## Bound callable references\n\nIn Kotlin 1.0 one can obtain a reference to a function (or property) like this: `String::length`, i.e. using a name of the containing class. In 1.1 we are adding _bound references_: i.e. we’ll be able to say `mystr::length` where `mystr` is a variable (or any other expression). Such references are bound to their receiver, and thus are a special case of partial function application (that we are not supporting in the general case, at least for now).\n\nRead more and comment [here](https://github.com/Kotlin/KEEP/issues/5).\n\n## Local delegated properties & Inline properties\n\nDelegated properties have proven to be a very useful abstraction, now we allow them inside functions/code blocks too. For example, we can say:\n\n```kotlin\nfun example(foo: (Bar) -> Foo, bar: Bar) {\n    val memoizedFoo by lazy { foo(bar) }\n\n    // use memoizedFoo instead of foo to get it computed at most once\n    if (someCondition && memoizedFoo.isValid()) {\n        memoizedFoo.doSomething()\n    }\n}\n```\n\nDSLs and scripts will also benefit from this feature.\n\nRead more and comment [here](https://github.com/Kotlin/KEEP/issues/25).\n\nWe also allow [inlining property accessors](https://github.com/Kotlin/KEEP/issues/34) now.\n\n## Relaxed rules for sealed classes and data classes\n\nWe now lift some restrictions on data classes and sealed classes.\n\nData classes can now be inherited from other classes. Note that automatically generated methods may override those defined in superclasses!\n\nFor sealed classes we broaden the scope where their inheritors may be defined: before it was only inside the sealed class itself, now it’s anywhere in the same file.\n\nRead more and comment [here](https://github.com/Kotlin/KEEP/issues/29) and [here](https://github.com/Kotlin/KEEP/issues/31).\n\n## Scripting\n\nAs you’ve probably heard, we all will soon be able to write Gradle build scripts in Kotlin which will considerably improve the IDE experience for editing such scripts and make them more reliable through static type checking. This project motivated us to work more on Kotlin scripting in general: we are developing the infrastructure to enable using Kotln scripts in the context of different tools, as well as the plain command-line support.\n\nMore details in the [proposal](https://github.com/Kotlin/KEEP/issues/28).\n\n## Java 7/8 support\n\nWe are working on the improved support for Java 8: 1.1 fixes the issues with Stream APIs that we used to have (and mitigated with a support library), and adds support for generating default methods in Kotlin interfaces, so that Java clients can implement them seamlessly. Read and comment [here](https://github.com/Kotlin/KEEP/issues/30).\n\nTo enable generation of version 8 class files, supply the `-jvm-target 1.8` command line switch.\n\nWe are also adding new functions to the Standard Library, and as they rely on Java API version newer than 1.6, we introduce new artifacts: `kotlin-stdlib-jre7` and `kotlin-stdlib-jre8` that carry extra functionality such as `AutoCloseable.use()`, Regex named groups support and stream-related functions. Use these artifacts instead of `kotlin-stdlib` from your Maven/Gradle builds if you need the APIs they add.\n\nRead and discuss the proposals related to stdlib [here](https://github.com/Kotlin/KEEP/labels/stdlib).\n\n## JavaScript\n\nWe are actively working on the JavaScript back-end: all the language features available in 1.0 are covered now, and we are close to getting JavaScript (runtime) module systems integrated into the picture. Note that all this functionality is also available in Kotlin 1.0.X.\n\nFind the proposals related to JavaScript [here](https://github.com/Kotlin/KEEP/labels/JS).\n\n## Contributors\n\nWe are very grateful to GitHub users [dotlin](https://github.com/dotlin), [Valdemar0204](https://github.com/Valdemar0204), [ensirius](https://github.com/ensirius) and [geoand](https://github.com/geoand) for their contributions to this version!\n\n## How to try it\n\n**In Maven/Gradle**. Add [https://bintray.com/kotlin/kotlin-eap-1.1](https://bintray.com/kotlin/kotlin-eap-1.1) (see instructions under _“Set me up!”_) as a repository to your project. Use version 1.1-M01 for your Kotlin artifacts.\n\n**In the IDE**. If you are running [Kotlin 1.0.3](https://blog.jetbrains.com/kotlin/2016/06/kotlin-1-0-3-is-here/), go to _Tools → Kotlin → Configure Kotlin Plugin Updates_, then select “Early Access Preview 1.1” in the _Update channel_ drop-down list:\n\n![Configure-Plugin-Updates](https://i1.wp.com/blog.jetbrains.com/kotlin/files/2016/07/Configure-Plugin-Updates.png?zoom=1.5&w=400&ssl=1)\n\nPress _Check for updates_ in the same dialog, and, when the new version is show, _Install_.\n\n**On [try.kotlinlang.org](http://try.kotlinlang.org/)**. Use the drop-down list at the bottom-right corner to change the compiler version:  \n![Screen Shot 2016-07-14 at 20.23.48](https://i0.wp.com/blog.jetbrains.com/kotlin/files/2016/07/Screen-Shot-2016-07-14-at-20.23.48.png?zoom=1.5&resize=640%2C549&ssl=1)\n\n**With SDKMan**. Run `sdk install kotlin 1.1-M01`.\n\nYour feedback is very welcome, as always.\n\n### Have a nice Kotlin!\n","author":"Andrey Breslav","date":"2016-07-14","type":"article","categories":["Kotlin"],"features":["highlightjs"],"description":"","filename":"","lang":"EN","enclosure":null},{"title":"Quasar: Efficient and Elegant Fibers, Channels and Actors","url":"http://blog.jetbrains.com/kotlin/2015/09/webinar-recording-quasar-efficient-and-elegant-fibers-channels-and-actors/","body":"\nThe recording of our September 16th webinar, **Quasar: Efficient and Elegant Fibers, Channels and Actors**, is now available on [JetBrainsTV YouTube channel](https://youtu.be/Nmob2MB2Qo8).\n\nIn this webinar, Fabio Tudone shows how to use Quasar for creation of highly concurrent software. He covers basics of Kotlin syntax and shows how Quasar uses Kotlin strengths to offer concise and expressive API.\n\nDemo project is available on [GitHub](https://github.com/circlespainter/quasar-kotlin-jetbrains-webinar/releases).\n\nThe video includes the time stamps following the [agenda announced](http://blog.jetbrains.com/kotlin/2015/09/join-live-webinar-quasar-and-kotlin/):\n* `00:55` – What are Quasar and Fibers?\n* `12:22` – What are Quasar Channels?\n* `15:50` – What are and why using Quasar Fibers?\n* `21:15` – From Async to efficient Fiber-Sync with Quasar\n* `27:13` – Quasar Actors and Selective Receive\n* `37:54` – Quasar Dataflow\n* `45:19` – Pulsar: Quasar’s idiomatic API for Clojure\n* `45:19` – Comsat: existing APIs on steroids with Quasar Fibers\n* `47:07` – Comsat Web Actors for HTTP, SSE and WebSockets\n* `49:58` – Capsule: deploy Quasar and any JVM applications\n\n<iframe src=\"https://www.youtube.com/embed/Nmob2MB2Qo8\" allowfullscreen=\"\" height=\"480\" frameborder=\"0\" width=\"960\"></iframe>\n\nAbout the Presenter:\n\n[Fabio Tudone](https://twitter.com/ftudone) works on Quasar, Pulsar and Comsat at Parallel Universe. He has been writing mostly JVM software during his entire career, and before joining [Parallel Universe](http://www.paralleluniverse.co/) he led the development of a cloud-based enterprise content governance platform. His interests include Dev and DevOps practices, scalability, concurrent and functional programming as well as runtime platforms at large.\n\nThanks to all the attendees for the questions! If you still have some, please, contact Fabio or our team.\n\nYou are welcome to suggest themes for future webinars in comments.\n\n_Let’s kotlin!_\n\n","author":"Roman Belov","date":"2015-09-21","type":"webinar","categories":["Kotlin","Webinar","Fibers","Channels","Actors"],"features":["highlightjs"],"description":"","filename":"","lang":"EN","enclosure":null},{"title":"Neural Network in Kotlin","url":"http://beust.com/weblog/2016/05/27/neural-network-in-kotlin/","body":"\n![](http://beust.com/pics/neural-network.png)\n\nIt’s hard not to hear about machine learning and neural networks these days since the practice is being applied to an ever increasingly wide variety of problems. Neural networks can be intimidating and look downright magical to the untrained (ah!) eye, so I’m going to attempt to dispel these fears by demonstrating how these mysterious networks operate. And since there are already so many tutorials on the subject, I’m going to take a different approach and go from top to bottom.\n\n## Goal\n\nIn this first series of articles, I will start by running a very simple network on two simple problems, show you that they work and then walk through the network to explain what happened. Then I’ll backtrack to deconstruct the logic behind the network and why it works.\n\nThe neural network I’ll be using in this article is a simple one I wrote. No TensorFlow, no Torch, no Theano. Just some basic Kotlin code. The original version was about 230 lines but it’s a bit bigger now that I broke it up in separate classes and added comments. The [whole project can be found on github under the temporary “nnk” name](http://github.com/cbeust/nnk). In particular, [here is the source of the neural network we’ll be using](https://github.com/cbeust/nnk/blob/master/src/main/kotlin/com/beust/nnk/NeuralNetwork.kt).\n\nI will be glossing over a lot of technical terms in this introduction in order to focus on the numeric aspect but I’m hoping to be able to get into more details as we slowly peel the layers. For now, we’ll just look at the network as a black box that get fed input values and which outputs values.\n\nThe main characteristic of a neural network is that it starts completely empty but it can be taught to solve problems. We do this by feeding it values and telling it what the expected output is. We iterate over this approach many times, changing these inputs/expected parameters and as we do that, the network updates its knowledge to come up with answers that are as close to the expected answers as possible. This phase is called “training” the network. Once we think the network is trained enough, we can then feed it new values that it hasn’t seen yet and compare its answer to the one we’re expecting.\n\n## The problems\n\nLet’s start with a very simple example: `xor`.\n\nThis is a trivial and fundamental binary arithmetic operation which returns 1 if the two inputs are different and 0 if they are equal. We will train the network by feeding it all four possible combinations and telling it what the expected outcome is. With the Kotlin implementation of the Neural Network, the code looks like this:\n\n```kotlin\nwith(NeuralNetwork(inputSize = 2, hiddenSize = 2, outputSize = 1)) {\n    val trainingValues = listOf(\n        NetworkData.create(listOf(0, 0), listOf(0)),\n        NetworkData.create(listOf(0, 1), listOf(1)),\n        NetworkData.create(listOf(1, 0), listOf(1)),\n        NetworkData.create(listOf(1, 1), listOf(0)))\n \n    train(trainingValues)\n    test(trainingValues)\n}\n```\n\nLet’s ignore the parameters given to `NeuralNetwork` for now and focus on the rest. Each line of `NetworkData` contains the inputs (each combination of 0 and 1: (0,0), (0,1), (1,0), (1,1)) and the expected output. In this example, the output is just a single value (the result of the operation) so it’s a list of one value, but networks can return an arbitrary number of outputs.\n\nThe next step is to test the network. Since there are only four different inputs here and we used them all for training, let’s just use that same list of inputs but this time, we’ll display the ouput produced by the network instead of the expected one. The result of this run is as follows:\n\nRunning neural network xor()\n\n```plain\n[0.0, 0.0] -> [0.013128957]\n[0.0, 1.0] -> [0.9824073]\n[1.0, 0.0] -> [0.9822749]\n[1.0, 1.0] -> [-2.1314621E-4]\n```\n\nAs you can see, these values are pretty decent for such a simple network and such a small training data set and you might rightfully wonder: is this just luck? Or did the network cheat and memorize the values we fed it while we were training it?\n\nOne way to find out is to see if we can train our network to learn something else, so let’s do that.\n\n## A harder problem\n\nThis time, we are going to teach our network to determine whether a number is odd or even. Because the implementation of the graph is pretty naïve and this is just an example, we are going to train our network with binary numbers. Also, we are going to learn a first important lesson in neural networks which is to choose your training and testing data wisely.\n\nYou probably noticed in the example above that I used the same data to train and test the network. This is not a good practice but it was necessary for `xor` since there are so few cases. For better results, you usually want to train your network on a certain population of the data and then test it on data that your network hasn’t seen yet. This will guarantee that you are not “overfitting” your network and also that it is able to generalize what you taught it to input values that it hasn’t seen yet. Overfitting means that your network does great on the data you trained it with but poorly on new data. When this happens, you usually want to tweak your network so that it will possibly perform less well on the training data but it will return better results for new data.\n\nFor our parity test network, let’s settle on four bits (integers 0 – 15) and we’ll train our network on about ten numbers and test it on the remaining six:\n\n```kotlin\nwith(NeuralNetwork(inputSize = 4, hiddenSize = 2, outputSize = 1)) {\n    val trainingValues = listOf(\n        NetworkData.create(listOf(0, 0, 0, 0), listOf(0)),\n        NetworkData.create(listOf(0, 0, 0, 1), listOf(1)),\n        NetworkData.create(listOf(0, 0, 1, 0), listOf(0)),\n        NetworkData.create(listOf(0, 1, 1, 0), listOf(0)),\n        NetworkData.create(listOf(0, 1, 1, 1), listOf(1)),\n        NetworkData.create(listOf(1, 0, 1, 0), listOf(0)),\n        NetworkData.create(listOf(1, 0, 1, 1), listOf(1)),\n        NetworkData.create(listOf(1, 1, 0, 0), listOf(0)),\n        NetworkData.create(listOf(1, 1, 0, 1), listOf(1)),\n        NetworkData.create(listOf(1, 1, 1, 0), listOf(0)),\n        NetworkData.create(listOf(1, 1, 1, 1), listOf(1))\n    )\n    train(trainingValues)\n \n    val testValues = listOf(\n        NetworkData.create(listOf(0, 0, 1, 1), listOf(1)),\n        NetworkData.create(listOf(0, 1, 0, 0), listOf(0)),\n        NetworkData.create(listOf(0, 1, 0, 1), listOf(1)),\n        NetworkData.create(listOf(1, 0, 0, 0), listOf(0)),\n        NetworkData.create(listOf(1, 0, 0, 1), listOf(1))\n    )\n    test(testValues)\n}\n```\n\nAnd here is the output of the test:\n\n```plain\nRunning neural network isOdd()\n \n[0.0, 0.0, 1.0, 1.0] -> [0.9948013]\n[0.0, 1.0, 0.0, 0.0] -> [0.0019584869]\n[0.0, 1.0, 0.0, 1.0] -> [0.9950419]\n[1.0, 0.0, 0.0, 0.0] -> [0.0053276513]\n[1.0, 0.0, 0.0, 1.0] -> [0.9947305]\n```\n\n\nNotice that the network is now outputting correct results for numbers that it hadn’t seen before, just because of the way it adapted itself to the training data it was initially fed. This gives us good confidence that the network has configured itself to classify numbers from any input values and not just the one it was trained for.\n\n## Wrapping up\n\nI hope that this brief overview will have whetted your appetite or at least piqued your curiosity. In the [next installment](http://beust.com/weblog/2016/05/30/neural-networks-in-kotlin-part-2/), I’ll dive a bit deeper into the `NeuralNetwork` class, explain the constructor parameters and we’ll walk through the inner working of the neural network that we created to demonstrate how it works.\n\n","author":"Cédric Beust","date":"2016-05-27","type":"article","categories":["Kotlin"],"features":["highlightjs"],"description":"","filename":"","lang":"EN","enclosure":null},{"title":"Writing Concise Code With Kotlin","url":"http://petersommerhoff.com/dev/kotlin/kotlin-concise-code/","body":"\nOne of the major selling points of Kotlin is its _concise and expressive syntax_. But in how far does Kotlin actually allow you to write more concise code? Let’s look at four ways it accomplishes this.\n\n## Data Classes\n\nIn Java, you sometimes create classes which act simply as data containers without much additional functionality. This may be the case, for example, when following the [Value Object Pattern](http://martinfowler.com/bliki/ValueObject.html) proposed by Martin Fowler. Let’s look at an Address class that just stores all data associated with a specific address:\n\n```java\npublic class Address {\n     private String street;\n     private int streetNumber;\n     private String postCode;\n     private String city;\n     private Country country;\n\n     public Address(String street, int streetNumber, String postCode, String city, Country country) {\n         this.street = street;\n         this.streetNumber = streetNumber;\n         this.postCode = postCode;\n         this.city = city;\n         this.country = country;\n     }\n\n     @Override\n     public boolean equals(Object o) {\n         if (this == o) return true;\n         if (o == null || getClass() != o.getClass()) return false;\n\n         Address address = (Address) o;\n\n         if (streetNumber != address.streetNumber) return false;\n         if (!street.equals(address.street)) return false;\n         if (!postCode.equals(address.postCode)) return false;\n         if (!city.equals(address.city)) return false;\n         return country == address.country;\n\n     }\n\n     @Override\n     public int hashCode() {\n         int result = street.hashCode();\n         result = 31 * result + streetNumber;\n         result = 31 * result + postCode.hashCode();\n         result = 31 * result + city.hashCode();\n         result = 31 * result + (country != null ? country.hashCode() : 0);\n         return result;\n     }\n\n     @Override\n     public String toString() {\n         return \"Address{\" +\n                 \"street='\" + street + '\\'' +\n                 \", streetNumber=\" + streetNumber +\n                 \", postCode='\" + postCode + '\\'' +\n                 \", city='\" + city + '\\'' +\n                 \", country=\" + country +\n                 '}';\n     }\n\n     public String getStreet() {\n         return street;\n     }\n\n     public void setStreet(String street) {\n         this.street = street;\n     }\n\n     public int getStreetNumber() {\n         return streetNumber;\n     }\n\n     public void setStreetNumber(int streetNumber) {\n         this.streetNumber = streetNumber;\n     }\n\n     public String getPostCode() {\n         return postCode;\n     }\n\n     public void setPostCode(String postCode) {\n         this.postCode = postCode;\n     }\n\n     public String getCity() {\n         return city;\n     }\n\n     public void setCity(String city) {\n         this.city = city;\n     }\n\n     public Country getCountry() {\n         return country;\n     }\n\n     public void setCountry(Country country) {\n         this.country = country;\n     }\n }\n```\n\nPhew, that’s a lot of code for such a simple data class. If there was a method in there that adds any actual functionality, all the boilerplate code would greatly distract from that method. Consequently, the class is **less readable and less searchable**. For an immutable Address class, the amount of boilerplate would be a little less frustrating because it would then only contain getters but no setters.\n\nNow, you can generate this kind of boilerplate code pretty fast with a modern IDE. That’s not a problem. The major advantage of Kotlin here really is readability: Kotlin makes it much clearer on the first view what’s actually going on – and doesn’t distract you from the important parts with boring boilerplate code.\n\n**So let’s look at the equivalent class in Kotlin:**\n\n```kotlin\n data class Address(var street: String,\n                    var streetNumber: Int,\n                    var postCode: String,\n                    var city: String,\n                    var country: Country)\n```\n\nThat’s it. In most cases, a simple data class like this is a one-liner but to make it more readable, I split up the properties of the class in the above example. This simple data class declaration generates a constructor, getters & setters, hashCode(), equals(), toString(), and also adds some additional convenience methods for you.\n\nWant to create an _immutable_ data class instead? Easy, just use the val keyword instead of var:\n\n```kotlin\n data class Address(val street: String,\n                    val streetNumber: Int,\n                    val postCode: String,\n                    val city: String,\n                    val country: Country)\n```\n\nIn Kotlin, val is used to create immutable variables whereas var creates mutable variables. Above, we use the same syntax to define mutable and immutable properties for classes using var and val respectively.\n\nNow, let’s look at a language concept that doesn’t save us quite as much code but is really handy as well.\n\n## Smart Casts\n\nIn Java, you often have to cast objects in situations where the compiler could actually do this for you because it’s clear that the object can be cast. Consider the following example:\n\n```kotlin\n public class Cast {\n\n     static void printString(String str) {\n         System.out.println(str);\n     }\n\n     public static void main(String[] args) {\n         Object hello = \"Hello, World!\";\n\n         if (hello instanceof String) {\n             printString((String) hello);\n         }\n     }\n }\n```\n\nIf we tried to change printString((String) hello) to just printString(hello), the Java compiler would yell at us because hello is of type Object.\n\nNow, the compiler could actually prove that hello is a suitable actual parameter for the formal parameter str of the method printString(String str). As you may have thought, Kotlin does this for us:\n\n```kotlin\n fun printString(str: String) {\n     println(str)\n }\n\n fun main(args: Array<String>) {\n     val hello: Any = \"Hello, World!\"\n\n     if (hello is String) {\n         printString(hello)\n     }\n }\n```\n\nNote that Kotlin’s Any type is the equivalent of Java’s Object, just like “is” is the equivalent of instanceOf, and that we can create package-level functions in Kotlin (that is, they are not nested inside a class or interface).\n\nThis is called **Smart Casts** in Kotlin. Admittedly, this doesn’t safe you tons of code, but still it’s super convenient.\n\nSmart casts are by no means limited to the example above. Whenever the compiler can prove that it is safe to cast the object appropriately, it will:\n\n```kotlin\n // Smart cast #1\n if (hello !is String) return\n printString(hello)  // Smart cast\n\n // ---------------------\n // Smart cast #2\n when(hello) {\n     \"Some value\" -> println(\"Then do something\")\n     in 1..10 -> println(\"This would be printed of hello were an integer between 1 and 10.\")\n     is String -> {\n         println(\"hello is of type String, this block will be run\")\n         printString(hello)  // Smart cast\n     }\n     else -> println(\"This is the default case.\")\n }\n\n // ---------------------\n // Smart cast #3\n if (hello is String && hello.first().isLetter()) {  // Smart cast after &&\n     println(\"The string starts with a letter\")\n }\n\n // ---------------------\n // Smart cast #4\n if (hello !is String || hello.last().isDigit()) {  // Smart cast after ||\n     println(\"This will not be printed.\")\n }\n```\n\nIn smart cast #1, it’s clear that hello must be a string. Otherwise the control flow wouldn’t even reach that point due to the return statement in the preceding line.\n\nIn smart cast #2, you can see a when-expression in Kotlin. Inside this, you can not only check for specific values but also for the type of the object. In the case block associated with the condition “hello is String”, Kotlin will again use smart casts on the hello object.\n\nSmart casts #3 and #4 make use of lazy evaluation. In smart cast #3, the second part of the condition (after &&) will not be checked if the first part is already false (because then the whole condition must be false). Thus, in the second part, the hello object must be of type String because otherwise, Kotlin wouldn’t even evaluate that second part (just like Java).\n\nSimilarly, in smart cast #4, if hello were not of type String, the first part would already be true so that the second part would not be evaluated. Therefore, hello must be of type String whenver the second part is evaluated – and Kotlin knows that.\n\n## Functional Programming\n\nSimilar to Java 8 which introduced functional language elements such as lambda expressions (function literals), Kotlin comes with functional capabilities baked in. You may be used to function literals like these in Java 8:\n\n```kotlin\n public static void main(String[] args) {\n     List<String> genres = Arrays.asList(\"Action\", \"Comedy\", \"Thriller\");\n     List<String> myKindOfMovies = genres.stream().filter(s -> s.length() > 6).map(s -> s + \" Movie\").collect(Collectors.toList());\n     System.out.println(myKindOfMovies);  // Output: [Thriller Movie]\n }\n```\n\nThe Stream API introduced in Java 8 can be convenient in many cases where you have to do some quick pipe-and-filter style processing. It can often make your code much more concise because you don’t have to use explicit for-each loops all the time.\n\nKotlin makes this even easier. By convention, for lambda expressions with only one parameter, Kotlin creates an implicit parameter called “it” so that you can skip typing the parameter:\n\n```kotlin\n fun main(args: Array<String>) {\n     val genres = listOf(\"Action\", \"Comedy\", \"Thriller\")\n     val myKindOfMovies = genres.filter { it.length > 6 }.map { it + \" Movie\" }\n     println(myKindOfMovies)\n }\n```\n\nNote that there is actually another convention here. Whenever the last parameter of a method is a lambda expression, we can put it _behind_ the parentheses of the method call. In the example above, both lambda expressions are the _only_ parameters so that you can skip the parentheses altogether.\n\nAlso, we don’t have to use a collect() method at the end, the myKindOfMovies variables now stores an Iterable<String>. We can also make that explicit if we want to:\n\n```kotlin\nval myKindOfMovies: Iterable<String> = genres.filter { it.length > 6 }.map { it + \" Movie\" }\n```\n\nNext, we’ll see **how to define a singleton in Kotlin in a single line:**\n\n## Objects as Singletons\n\nThere are many ways to create a singleton, some of which are not suitable in concurrent environments or don’t hold up against serialization attacks. Let’s look at the most common way to create a singleton in Java:\n\n```kotlin\npublic class Singleton {\n     private static Singleton theInstance = new Singleton();\n\n     private Singleton() {\n     }\n\n     public static Singleton getInstance() {\n         return theInstance;\n     }\n }\n```\n\nThis creates a class with a private constructor so that we can control which instances of it are created. Since we want to have only one object of this class at any given time, we create that instance as a private attribute and allow retrieving it from the outside using getInstance(). That way, there can never be more than one instance of this object (nasty tricks using reflection or serialization aside).\n\nIn Kotlin, we can create such a singleton in a single line by using the object keyword:\n\n```kotlin\n object KotlinSingleton {}\n```\n\nPretty neat, huh? In contrast to the normal habit of defining classes, this defines a single _object,_ which is semantically the same as a singleton – a class of which there should always be only one object. Such object declarations in Kotlin are initialized lazily, just like you may do it for a singleton in Java (even though it’s not the case in the example above).\n\nIn both Kotlin and Java you can choose to make your singleton/object immutable or not.\n\nI want to mention that **there is a better way to create singletons in Java as well**: create an enum with only a single type! Joshua Bloch – one of the developers of the Java Collections Framework (amongst others) – advocates this in his very recommendable book “Effective Java”. Why? Well, enums give you all serialization machinery for free and prevent multiple instances even in the face of sophisticated serialization and reflection attacks – without you having to do anything for it. Arguably, they are also very concise:\n\n```kotlin\n enum EnumSingleton {\n     INSTANCE\n }\n```\n\nThis approach can nearly even keep up with the conciseness of Kotlin.\n\nOf course you are free to add properties and methods to Kotlin objects, just as you are free to add attributes and methods to Java enums.\n\n## Closing Words\n\nI hope this quick overview gave you some more understanding of the Kotlin programming language and how it handles some of the more annoying aspects of Java in more convenient ways. Kotlin’s syntax is generally rather concise but still perfectly expressive (“data class ...”, “object ...”, “{ it.length > 6 }”) which makes your code more readable and thus maintainable.\n\nIf you’re interested in learning more about the Kotlin programming language, you can check out my [10 tutorial videos for Kotlin](http://petersommerhoff.com/dev/kotlin/kotlin-beginner-tutorial/). They give you a gentle introduction to the language and help you with the setup to get started (don’t worry, it’s not that much). Alternatively, you can also jump ahead and [check out the full Kotlin course hosted on Udemy](https://www.udemy.com/kotlin-course/?couponCode=AMAZINGREADERS25). The link contains a 50% discount coupon for my blog readers.\n\n","author":"Peter Sommerhoff","date":"2016-04-24","type":"article","categories":["Kotlin"],"features":["highlightjs"],"description":"","filename":"","lang":"EN","enclosure":null},{"title":"Writing a RESTful backend using Kotlin and Spring Boot","url":"https://medium.com/@dime.kotevski/writing-a-restful-backend-using-kotlin-and-spring-boot-9f162c96e428#.9oucop3xg","body":"\n### Writing a RESTful backend using Kotlin and Spring Boot\n\nBeing here, I guess you already have an idea what a [RESTful](https://en.wikipedia.org/wiki/Representational_state_transfer) [backend](https://en.wikipedia.org/wiki/Front_and_back_ends) is and at least have heard of [Kotlin](https://kotlinlang.org) and [Spring [Boot]](http://projects.spring.io/spring-boot/). Beside that you will also need to know what is [Gradle](http://gradle.org) and download [IntelliJ IDEA](https://www.jetbrains.com/idea/). If not — click those few links and find out more before continuing.\n\nAt the end of this tutorial you will have a running RESTful backend packed inside a Jar together with an embedded Tomcat web server.\n\nI will start this tutorial by answering the two questions that may be on your mind:\n\n#### **_Why Kotlin?_**\n\nBecause I’m [in love with Kotlin](https://medium.com/@dime.kotevski/kotlin-love-at-first-line-7127befe240f#.ojez0fkcn). And also because Kotlin (Java) has a great ecosystem and a huge community.\n\n#### **_Why Spring Boot?_**\n\nBecause Spring is a great [web] framework and the Boot part of Spring Boot makes it even better. With Spring Boot things just work. No need to write dreadful configurations. You can, but you don’t need to (at least in our case). You just include it as a dependency, annotate a class or two and you are good to go.\n\nWe will create a very simple library management system. The system will be able to list all books available. It will allow us to add new books. For simplicity we will have all the data in memory and won’t use any databases.\n\nLet’s start by creating the project. First open your IDE (preferably IntelliJ IDEA, because it has great support for Kotlin) and create a new Gradle project. In the same window, select Kotlin as a framework.\n\n![](https://d262ilb51hltx0.cloudfront.net/max/800/1*bpAXXUEixZni9Mfy5pJwvg.png)\n_\"New project\" window_\n\nOn the next screen you need to choose an ArtifactID and GroupID for your project. Those two things are the identification of your project in the Gradle world. Most often those IDs are the Java package of your application. In this tutorial I’ll use **si.dime.kotlin.tutorials.rest.booklibrary** as the main Java package and **si.dime.kotlin.tutorials.rest** as GroupID and **booklibrary** as ArtifactID. After hitting the Finish button you should have the project opened in your IDE.\n\n**NOTE:** At the time of writing this tutorial, the IntelliJ IDEA CE 15.0.4 has a bug, which generates a broken **build.gradle** file. The content of the correct file is:\n\n```groovy\ngroup 'si.dime.kotlin.tutorials.rest'\nversion '1.0-SNAPSHOT'\n\nbuildscript {\n    ext.kotlin_version = '1.0.0'\n\n    repositories {\n        mavenCentral()\n    }\n    dependencies {\n        classpath \"org.jetbrains.kotlin:kotlin-gradle-plugin:$kotlin_version\"\n    }\n}\n\napply plugin: 'java'\napply plugin: 'kotlin'\n\nsourceCompatibility = 1.8\n\nrepositories {\n    mavenCentral()\n}\n\nsourceSets {\n    main.java.srcDirs += 'src/main/kotlin'\n}\n\ndependencies {\n    compile \"org.jetbrains.kotlin:kotlin-stdlib:$kotlin_version\"\n}\n```\n\nWe will start with the good old HelloWorld app just so you can see how incredibly simple is to get a Spring Boot application up-and-running.\n\n![](https://d262ilb51hltx0.cloudfront.net/max/600/1*wV3aghlZYkzlJEiFr-kiyw.png)\n_The project’s directory structure_\n\nFirst create the needed directory structure for your source files. Inside the project directory create the **src/main/kotlin** directories. You can do that directly from IDEA by right clicking on your project’s root directory and selecting New → Directory. After that create your base Java package by right clicking New → Package on the **kotlin** directory. Your project structure should something like the one on the left.\n\nLet’s finally write some code. Create your main Application class by right clicking on your package and selecting New → Kotlin File/Class. Name your file App and click Ok. Inside the file we’ll write the main function:\n\n```kotlin\nfun main(args: Array<String>) {\n    println(\"Hello Kotlin!\")\n}\n```\n\nWe are ready to run our HelloWorld app. Right click inside the editor and click **_Run ‘YOUR_PACKAGE_NAME’_**_._\n\n![](https://d262ilb51hltx0.cloudfront.net/max/800/1*CZaMzHFYklRk4tWWCjhiWw.png)\n\n_Running the application from IntelliJ IDEA_\n\nAfter clicking on Run, on the bottom of your screen you should get\n\n```\nHello Kotlin!\n\nProcess finished with exit code 0\n```\n\nNow the fun part begins. We have our HelloWorld application in Kotlin and it’s time to “convert” it to a Spring Boot application. It’s amazingly easy.\n\nFirst we will add the Spring Boot dependency to our project. At this point you should know that Gradle is a build system and that it has great dependency management. Adding dependencies is simple as adding a line in your **build.gradle** file. For SpringBoot we’ll need a few lines in our **build.gradle** file **(not settings.gradle)**.\n\n```kotlin\ngroup 'si.dime.kotlin.tutorials.rest'\nversion '1.0-SNAPSHOT'\n\nbuildscript {\n    ext.kotlin_version = '1.0.0'\n\n    repositories {\n        mavenCentral()\n    }\n    dependencies {\n        classpath(\"org.springframework.boot:spring-boot-gradle-plugin:1.2.6.RELEASE\")\n        classpath \"org.jetbrains.kotlin:kotlin-gradle-plugin:$kotlin_version\"\n    }\n}\n\napply plugin: 'java'\napply plugin: 'kotlin'\napply plugin: 'spring-boot'\n\nsourceCompatibility = 1.8\n\nrepositories {\n    mavenCentral()\n}\n\nsourceSets {\n    main.java.srcDirs += 'src/main/kotlin'\n}\n\ndependencies {\n    compile \"org.jetbrains.kotlin:kotlin-stdlib:$kotlin_version\"\n    compile(\"org.springframework.boot:spring-boot-starter-web:1.3.3.RELEASE\")\n}\n```\n\nAfter adding the dependency we need to refresh our Gradle configuration. To do that click on the **Refresh** button on the _Gradle tool window_. (The _Gradle tool window_ can be activated from the main menu View → Tool windows → Gradle.\n\n![](https://d262ilb51hltx0.cloudfront.net/max/800/1*K5doUTtJTNVf-nAv2MHxQA.png)\n_The Gradle Tool Window_\n\nNow we are ready to write the application’s main class. Open the **App.kt** file and define the App class. The class needs to be **open** because Spring needs its configuration classes **open (not final)**. And annotate the class with the **@SpringBootApplication** annotation\n\n```kotlin\n@SpringBootApplication\nopen class App {\n}\n```\n\nThe final thing to do is change our main method. Replace the _println()_ line with:\n\n```kotlin\nSpringApplication.run(App::class.java, *args)\n```\n\nThe line above boots Spring and starts everything (including the embedded web server). Your **App.kt** file should look like this:\n\n```kotlin\n@SpringBootApplication\nopen class App {\n}\n\nfun main(args: Array<String>) {\n    SpringApplication.run(App::class.java, *args)\n}\n```\n\nWhen you run the application, you should see a lot of output in the console at the bottom of the screen. The last line should say that the application has been successfully started.\n\n```kotlin\nStarted AppKt in 2.306 seconds (JVM running for 2.628)\n```\n\nAnd that’s it. It’s that easy to convert a simple HelloWorld application to a SpringBoot web application with an embedded web server. We already have our application running on our embedded Tomcat server. If you open your browser and type [**http://localhost:8080**](http://localhost:8080)in the address bar, you will get a _HTTP 404_ page. That’s because our application doesn’t know how to do anything.\n\nJust for fun we’ll write a simple controller that prints **_Hello SpringBoot_**_._ Create a new Kotlin class and name it **_HelloSpringBootController_**. Annotate that class with @RestController. This annotation tells Spring that this class is a REST controller and knows how to handle web requests. The next thing to do is to write the actual method that prints the **_Hello SpringBoot_** line.\n\n```kotlin\n@RequestMapping(value = \"/\")\nfun helloSpringBoot() = \"Hello SpringBoot\"\n```\n\nThe method just returns the “Hello SpringBoot” string. The **@RequestMapping** annotation registers this method as a request handler and maps it to the **“_/”_ **url. Your class should look like this:\n\n```kotlin\n@RestController\nclass HelloSpringBootController {\n\n    @RequestMapping(value = \"/\")\n    fun helloSpringBoot() = \"Hello SpringBoot\"\n}\n```\n\nAfter restarting the application and refreshing your browser, you should see “Hello SpringBoot” in your browser.\n\nAt this point you can safely remove the **HelloSpringBootController** because we won’t be using it anymore.\n\nWe’ll start coding our book library system with the class that represents a Book. Create a new Kotlin file and name it **Book**.\n\n```kotlin\nclass Book() {\n    lateinit var ISBN: String\n    lateinit var title: String\n    lateinit var author: String\n    var coverURL: String? = null\n\n    constructor(\n       ISBN: String,\n       title: String,\n       author: String,\n       coverURL: String? = null): this() {\n\n          this.ISBN = ISBN\n          this.title = title\n          this.author = @author\n          this.coverURL = coverURL\n    }\n}\n```\n\nIt’s pretty self-explanatory. It defines that every Book will have a required ISBN, a required title, a required author and an optional cover URL.\n\nBecause we’ll have all of our data in-memory, we’ll need something that’ll act like a database. For that purpose we’ll create a spring’s **component**. A **component** in Spring is an object which its lifecycle is managed by Spring. Additionally these components can be **injected/autowired** into class properties using Spring’s Dependency Injection system.\n\nWe’ll create our BooksDatabase component by creating a new Kotlin file and defining the following class:\n\n```kotlin\n@Component\nclass BooksDatabase {\n\n    // All of our books will live here\n    private val books = mutableListOf<Book>()\n}\n```\n\nBecause our data will live only in-memory, and the data won’t be persisted, we’ll need to somehow manually fill our list of books every time the application starts. Here comes in handy the **@PostConstruct** Spring annotation. This annotation tells to Spring that it needs to call this method right after it creates its instance and because our BooksDatabase component is a singleton (all of **@Component** annotated classes are singletons) we will “fill” our database just once, at application startup. So we need to write a method that fills our books list with initial data and annotates it with the **@PostConstruct** method.\n\n```kotlin\n@PostConstruct\nprivate fun init() {\n\n    // Fill our \"database\"\n    books.add(Book(\n     \"0765326353\",\n     \"The Way of Kings\",\n     \"Brandon Sanderson\",\n     coverURL = \"https://d.gr-assets.com/books/1448127430l/7235533.jpg\"))\n\n    books.add(Book(\n     \"0345391802\",\n     \"The Hitchhiker's Guide to the Galaxy\",\n     \"Douglas Adams\",\n     coverURL = \"https://d.gr-assets.com/books/1327656754l/11.jpg\"))\n\n    books.add(Book(\n     \"076531178X\",\n     \"Mistborn: The Final Empire\",\n     \"Brandon Sanderson\",\n     coverURL = \"https://d.gr-assets.com/books/1437254833l/68428.jpg\"))\n}\n```\n\nThe next thing we need to do, are the methods for accessing the data from our database. We’ll need one for retrieving the data and one for inserting new items.\n\n```kotlin\n/**\n * Returns a list of all books\n */\nfun getBooks() = books\n\n/**\n * Adds the given book only if a book with\n * the same ISBN doesn't already exist.\n *\n * @return  true - if the book was successfully added\n *          false - otherwise\n */\nfun addBook(book: Book): Boolean {\n    books.firstOrNull { it.ISBN == book.ISBN }?.let {\n        // A book with the same ISBN exist\n        return false\n    }\n\n    // If we get to this line -\n    // that means a book with the same ISBN\n    // doesn't exist.\n    books.add(book)\n    return true\n}\n```\n\nThis completes our in-memory database. We can now move on to writing the REST Controller.\n\nWe will start in the same way we did with the **HelloSpringBootController.** Create a new Kotlin Class and name it **BooksController**. After that annotate it with the **@RestController** annotation**.**\n\n```kotlin\n@RestController\nclass BooksController {\n}\n```\n\nIn this controller we will be needing the “database” we created. In order to use it, we will need to **inject/autowire** the single instance of our **BooksDatabase** class.\n\n```kotlin\n@RestController\nclass BooksController {\n\n    // Our books' database\n    @Autowired\n    private lateinit var database: BooksDatabase\n}\n```\n\nThanks to the **@Autowired** annotation and Spring’s DI, the _database_ variable will point to the single instance of our BooksDatabase class. As in our database class we will need just two methods for accessing the data. The first will return a list of all the books and the second will add a new book to our database.\n\nThe first one is really simple:\n\n```kotlin\n@RequestMapping(\"\", method = arrayOf(RequestMethod.GET))\nfun books() = database.getBooks()\n```\n\nAfter this point we are able to test our backend in a browser. After starting the application you can open [http://localhost:8080/](http://localhost:8080/) in a browser and you should get the list of books we have in our database in JSON format.\n\n```kotlin\n[\n  {\n    “title”: “The Way of Kings”,\n    “author”: “Brandon Sanderson”,\n    “coverURL”: “https://d.gr-assets.com/books/1448127430l/7235533.jpg\",\n    “isbn”: “0765326353”\n  },\n\n  {\n    “title”: “The Hitchhiker’s Guide to the Galaxy”,\n    “author”: “Douglas Adams”,\n    “coverURL”: “https://d.gr-assets.com/books/1327656754l/11.jpg\",\n    “isbn”: “0345391802”\n  },\n\n  {\n    “title”: “Mistborn: The Final Empire”,\n    “author”: “Brandon Sanderson”,\n    “coverURL”: “https://d.gr-assets.com/books/1437254833l/68428.jpg\",\n    “isbn”: “076531178X”\n  }\n]\n```\n\nAs you can see, we don’t have to worry about the format of the output. Spring is clever enough to figure out that we are returning an object (or a list of objects) from our method and serialise that to JSON.\n\nI guess you already figured it out that our application doesn’t allow duplicate books in our database. So we will need to find a way to inform the user when he tries to do that. According to the RESTfull specifications, when that happens, we will need to return the **HTTP 409 — Conflict** status back to the user. Luckily for us, Spring has a simple way of doing that.\n\nFirst we will need to define an exception with a special Spring annotation, that defines the HTTP error code and later in our **addBook** method, we will just have to throw that exception in case the user tries to insert a duplicate item.\n\nLet’s start with our exception. Create a new Kotlin class named **DuplicateItemException**:\n\n```kotlin\n@ResponseStatus(value = HttpStatus.CONFLICT, reason = \"Duplicate item.\")\nclass DuplicateItemException: RuntimeException() {}\n```\n\nNow we are ready to write our **addBook** method.\n\n```kotlin\n@RequestMapping(\"\", method = arrayOf(RequestMethod.POST))\nfun addBook(@RequestBody book: Book) =\n     if (database.addBook(book)) book\n     else throw DuplicateItemException()\n```\n\nWe have the same situation as before. Spring will automatically convert our returned Book object to JSON or in the case of a duplicate item, it will return the **409 HTTP status**. Also it will automatically convert the request body (thanks to the **@RequestBody** annotation) to an instance of our Book class.\n\nFor testing this method, I recommend you the [POSTMAN chrome app](https://chrome.google.com/webstore/detail/postman/fhbjgbiflinjbdggehcddcbncdddomop?hl=en).\n\n![](https://d262ilb51hltx0.cloudfront.net/max/800/1*iipcrRPPaBIWiajaVelBIw.png)\n\nIt’s important to set the HTTP method to **POST**, the content type to **JSON** and the body of the request. After hitting the _Send_ button you should get the same book data in your response. In case you are trying to insert a duplicate item you should get an **HTTP 409** status.\n\nIf you try to fetch the list of books after you added a new book, you should get the newly added book at the end of the list.\n\nNow that we have all to code written, we want to be able to run our server independently of our IDE. This is also a no-brainer, thanks to Gradle. Just open your terminal and cd to the project’s directory. To build our project and create a runnable JAR with an embedded web server (Tomcat in our case) we will need to fire-up Gradle:\n\n```groovy\n./gradlew clean bootRepackage\n```\n\nAfter the build has completed, our executable JAR will be located in **_build/libs_**_._ So to start our server we just need to start our JAR file:\n\n```bash\njava -jar build/libs/booklibrary-1.0-SNAPSHOT.jar\n```\n\nAfter a few seconds, you should see an output similar to:\n\n```kotlin\nStarted AppKt in 2.207 seconds (JVM running for 2.532)\n```\n\n**That’s it!** We now have a fully functional RESTfull backend. In the near future I’ll try to write a couple of more tutorials that focus on writing an Android and iOS apps that use this backend.\n\n#### Disclaimer\n\nYes, I’m a big Sanderson’s fan :)\n\n","author":"Dimitar Kotevski","date":"2016-03-22","type":"article","categories":["Spring","Kotlin"],"features":["highlightjs"],"description":"","filename":"","lang":"EN","enclosure":null},{"title":"Kotlin Month Post 3: Safety","url":"https://programmingideaswithjake.wordpress.com/2016/03/13/kotlin-month-post-3-safety/","body":"\n## **Intro**\n\nIn this third post for [Kotlin Month](https://programmingideaswithjake.wordpress.com/kotlin/#kotlinmonth), I’m going to go over some of the safety features that Kotlin comes with. Follow the link to see the previous posts.\n\n## **Null Safety**\n\nThis is one of the most touted features of Kotlin, from what I’ve seen. Personally, it has given me a little bit of grief, but some built-in property delegates, like `lazy` and `lateinit` are helpful workarounds.\n\nHere’s the safety that Koltin provides: A variable cannot contain `null` unless its type specifies that it’s nullable. You can declare a type as nullable by placing a `?` at the end of the type’s name. For example, for a variable that can hold `null` or `String`, its type would be `String?`. That’s step one of the null safety.\n\nThe next step is that you cannot directly call methods or properties from a nullable variable. In order to safely dereference a nullable object, you must place a `?` before the `.`. This operator returns `null` if the object being dereferenced is `null`, or else returns the result of the method or property use. For example, if there’s a `String?` variable called `str`, and we want to find out if it’s empty, we would call it with `str?.isEmpty()`. The result is either `null`, `true`, or `false`. With the next operator, we can use that `null` to mean `true`.\n\nThe next operator, often called the elvis operator, since it kind of looks like it’d be a pompadoured emoticon, helps us turn `null` values into default values. It works a lot like the ternary operator (which Kotlin actually doesn’t have, since its `if`/`else` block is an expression, not a statement), except the left hand side is a combination of the left and middle of the ternary operator. It either evaluates to `null` or the desired type. If it _does_ resolve as `null`, it uses the right side if the operator. So, our `String?` example above would become `str?.isEmpty() ?: true`, which returns whatever `isEmpty()` returns, or else `true` if `str` was `null`. By the way, the `?:` part was the operator.\n\nThe last piece of the puzzle is the `!!` operator. This is a way of telling the compiler one of two things. Either “I’d rather get a `NullPointerException` than have to deal with null safety”” or “”I know that the type says that it’s nullable, but I can _guarantee_ that it won’t be `null`; at least not at this point.”\n\nNow, because of Java interop, Kotlin can’t make any guarantees about the nullability of types coming from Java code. It goes the pragmatic route and lets the developer decide (and deal with the consequences, if need be) whether it can be `null` or not. Annotations can be used to tell the compiler, also. Check out their documentation on [Java interop with null safety](http://kotlinlang.org/docs/reference/java-interop.html#null-safety-and-platform-types) for more information.\n\n## **Smart Casting**\n\nSmart casting is nifty little feature that, while not coming up all that often in most cases, is really nice for cleaning up your code. Say you have code like this:\n\n```kotlin\nif(someVar instanceof SomeType) {\n   SomeType anotherVar = (SomeType)someVar;\n   ...\n}\n```\n\nThis kind of casting is such a pain. Once you’ve determined that `someVar` is of type `SomeType`, you don’t get to just use it as if it is. No, first you have to create _another_ variable (or, if you’re “lucky”, you can do it without the new variable for a single-line expression, but then you need _another_ set of parentheses for the cast – `((SomeType)someVar)...`) as well as write out the cast.\n\nIn Kotlin, you write it like this:\n\n```kotlin\nif(someVar is SomeType) {\n   ...\n}\n```\n\nFirst off, the type check operartor is shorter as `is`. The cast operator is cleaner too. If we had needed to use it in this case (which we didn’t), it would have been `var anotherVar = someVar as SomeType`. It’s not shorter, but it’s cleaner.\n\nThe reason we didn’t need to cast it is because the compiler knows that, inside the block, `someVar` is definitely a `SomeType`. So, we didn’t even need to use another variable for that because it just pretends that `someVar`‘s type is `SomeType` instead of whatever it was declared as.\n\nAn interesting note about this is that it applies to nullability, too. Since `String?` isn’t considered to be the same thing as `String`, but rather a supertype, it can be smart cast from `String?` to `String`:\n\n```kotlin\nif(someStr != null) {\n   ... as if someStr is no longer a nullable type\n}\n```\n\nThere is a limit to smart casting, though. If the variable in question could potentially be changed by another thread at any time, it will not do it. Therefore, smart casting can only be applied to `final` variables (`val`s) or local variables (those created within the function).\n\nCheck out [Kotlin’s documentation on smart casts](http://kotlinlang.org/docs/reference/typecasts.html#smart-casts) if you want to learn more.\n\n## **Generics**\n\nStraight-up, Kotlin has better generics than Java. ‘Nuff said.\n\nI’m just kidding. But seriously, Kotlin’s generics are better; they can even allow you to do things that Java won’t compile. I can’t give you an example, but I spotted a StackOverflow example once where someone tried to turn their Kotlin code into Java code, but they couldn’t because the Java code doesn’t allow generics to be used in a certain way, but luckily the byte code is forgiving and allows Kotlin to do it.\n\nMoving beyond that, Kotlin also uses declaration-site variance as a primary variance rather than Java’s use-site variance. It also follows the same syntax as C#’s variance (using `out` and `in` instead of `_ extends` or `_ super`), which is much easier to understand in most cases. Since I’m not good at explaining this stuff, I’d like to just point you to [Kotlin’s documentation on it](http://kotlinlang.org/docs/reference/generics.html).\n\n### **Inline Functions and Reified Generics**\n\nKotlin allows you to define inline functions (functions that are compiled in a way that, when called in code, it actually “copies” the code from inside the function into the place where it’s called), which can be really useful [and is only suggested to be used] when making functions that accept lambdas and method references that are called within, since _that_ can be inlined too, without actually creating a function object. Another interesting feature of inline functions is the ability to have _reified generics_ (generics without type erasure), since, in its inlined state, the compiler can actually _know_ what the actual type is (assuming it wasn’t already a generic type to begin with). There’s actually quite the swathe of things that can be done with inline functions, so you should check them out in [Kotlin’s documentation on them](http://kotlinlang.org/docs/reference/inline-functions.html).\n\n## **Outro**\n\nThus ends my list of safety features in Kotlin. You should totally just go and fall in love with Kotlin now, as I have. Even if you won’t do it now, I still have next week’s post to sway you, so look forward to that.\n\n","author":"Jacob Zimmerman","date":"2016-03-13","type":"article","categories":["Kotlin"],"features":["highlightjs"],"description":"","filename":"","lang":"EN","enclosure":null},{"title":"Use Kotlin with npm, webpack and react","url":"https://blog.jetbrains.com/kotlin/2017/04/use-kotlin-with-npm-webpack-and-react/","body":"\nWith Kotlin 1.1, targeting JavaScript in the Kotlin compiler has officially reached production-ready status. Of course, having compiler support is not enough to be able to solve real-life problems, so we continue our work on integrating Kotlin into the larger JavaScript ecosystem.\n\nToday, we’d like to present two new projects: a Gradle plugin integrating Kotlin with npm, webpack and karma, and a full-stack application sample with a Kotlin/JVM backend and a Kotlin/JS frontend built with React.\n\n## Kotlin Frontend Plugin\n\nThe [Kotlin frontend plugin](https://github.com/Kotlin/kotlin-frontend-plugin) allows you to build and deploy a Kotlin frontend application using webpack. You can use npm packages as dependencies of your application, and the plugin will take care of downloading them and bundling them into the resulting JS file. The plugin also integrates with Karma, allowing you to run the tests of your application. And for optimal workflow, the plugin supports continuous compilation and hot reload, ensuring that you always see an up-to-date version of your application in the browser.\n\nThe [README](https://github.com/Kotlin/kotlin-frontend-plugin/blob/master/README.md) file gives instructions for using the plugin, and the examples directory contains a [simple example](https://github.com/Kotlin/kotlin-frontend-plugin/tree/master/examples/frontend-only) showing how you can apply it in a real project.\n\n## Kotlin React Example\n\n[Thinkter](https://github.com/Kotlin/kotlin-fullstack-sample) is an example of a modern full-stack application built in Kotlin. The backend runs under Jetty and uses [Ktor](https://github.com/kotlin/ktor), a Kotlin Web application framework developed by the Kotlin team. The frontend uses React; a set of React wrappers for Kotlin is [provided as part of the project](https://github.com/Kotlin/kotlin-fullstack-sample/tree/master/frontend/src/org/jetbrains/react). You’re welcome to use the wrappers in your project and adapt them to your own needs. Note that we’re working on evolving the React wrappers internally, and we’re considering releasing them as a separate open-source library.\n\nTo see what Kotlin React code looks like, you can check out [one of the components](https://github.com/Kotlin/kotlin-fullstack-sample/blob/master/frontend/src/org/jetbrains/demo/thinkter/NewThoughtComponent.kt) of the application.\n\nYour feedback on these releases is very much welcome! Please file issues on GitHub, stop by the [forums](https://discuss.kotlinlang.org/), or join the #javascript channel on the [Kotlin Slack](http://slack.kotlinlang.org/).\n","author":"Dmitry Jemerov","date":"2017-04-18","type":"article","categories":["Kotlin"],"features":["highlightjs"],"description":"","filename":"","lang":"EN","enclosure":null},{"title":"Seductive Code","url":"https://publicobject.com/2016/12/19/seductive-code/","body":"","author":"Jesse Wilson","date":"2016-12-19","type":"article","categories":["Kotlin","Java"],"features":["highlightjs"],"description":"","filename":"","lang":"EN","enclosure":null},{"title":"Kotlin: Будущие изменения и текущие мифы","url":"https://www.youtube.com/watch?v=d6795d1aN3U","body":"\nKotlin очень хорошо зашёл в сообщество Android разработчиков, в то же время множество разработчиков всё так же опасаются попробовать использовать в production.\nВ этом выпуске я пригласил Яна Жуланова, из компании Jetbrains, одного из разработчиков Kotlin, а именно специализирующемся на Kotlin для Android.\nВместе мы обсудим почему вас стоит попробовать Kotlin, если вы его ещё не пробовали, обсудим популярные мифы и опасения о Kotlin и обсудим какие новости нам ожидают c Kotlin в ближайшем будущем.\n\nУпоминания:\n\n* Kotlin/anko: Pleasant Android application development – http://bit.ly/2hQvGsA\n* Scaloid makes your Android code easy to understand and maintain – http://bit.ly/2hDH8r5\n* XTend – Modernized Java – http://bit.ly/2hPCiF5\n* Используем Kotlin для написания скриптов Gradle – http://bit.ly/2ib9CFN\n* Why You Must Try Kotlin For Android Development? – http://bit.ly/2hQy8PW\n* Android Development with Kotlin — Jake Wharton – http://bit.ly/2h698mk\n* Advancing Android Development with Kotlin – Jake Wharton – http://bit.ly/2hPANa2\n* Kotlin 1.0.5 is here с улучшенной поддержкой Lint – http://bit.ly/2hPFAZj\n* Kotlin vs Java: Compilations speed – http://bit.ly/2h6eDBE\n* Kotlin 1.1: first glimpse – http://bit.ly/2gXP7LJ\n* Дмитрий Жемеров — Ой, котик побежал: Компиляция и производительность кода на Kotlin – http://bit.ly/2hPHnx8\n* Kotlin Native – http://bit.ly/2hPATOW\n* Kotlin Weekly – http://bit.ly/2hPDZ5D\n* Kotlin Slack – http://bit.ly/2hQww8I\n* Kotlin Youtrack – http://bit.ly/2hDPj6I\n* Kotlin Discussions – http://bit.ly/2h66tsU\n\n<iframe width=\"960\" height=\"480\" src=\"https://www.youtube.com/embed/d6795d1aN3U\" frameborder=\"0\" allowfullscreen></iframe>\n\n","author":"Android в Лицах","date":"2016-12-20","type":"video","categories":["Kotlin","Android"],"features":["highlightjs"],"description":"","filename":"","lang":"RU","enclosure":null},{"title":"Kotlin 1.0 Release Candidate is Out!","url":"http://blog.jetbrains.com/kotlin/2016/02/kotlin-1-0-release-candidate-is-out/","body":"\nFinally, Kotlin has graduated the Beta and we are happy to present the Release Candidate Build!\n\n**NOTE**: as we [announced earlier](http://blog.jetbrains.com/kotlin/2015/12/kotlin-1-0-beta-4-is-out/), **RC requires all code to be recompiled** to make sure no code compiled with older versions is kept around (please recompile even if you were on the EAP version!).\n\nThis blog post gives an overview of the changes made since Beta 4. Library changes are the biggest in this build. Also, some bugs have been fixed. Full list of changes is available [here](https://github.com/JetBrains/kotlin/releases/tag/build-1.0.0-rc-1036).\n\n![Kotlin 1.0 RC](http://i1.wp.com/blog.jetbrains.com/kotlin/files/2016/02/RC-Banner.png?resize=640%2C330)\n\n_See the discussions on [Hacker News](https://news.ycombinator.com/item?id=11034273) and [Reddit](https://www.reddit.com/r/programming/comments/445jih/jvm_languages_news_kotlin_10_release_candidate_is/)_.\n\n## Language\n\nFirst of all, as promised before, there has been a clean-up:\n\n*   All previously deprecated language constructs are now errors, not warnings.\n*   All deprecated declarations previously generated in the byte code (such as static fields in interfaces etc) have been removed.\n\nMost other language changes are minor tweaks and bug fixes. Some highlights are given below. See the full list [here](https://github.com/JetBrains/kotlin/releases/tag/build-1.0.0-rc-1036).\n\n### Annotations on delegate fields\n\nThe new `@delegate:` annotation target (use-site) is now supported. For example, to mark the delegate object as `@Transient`, we can say:\n\n```kotlin\nclass Example {\n    @delegate:Transient\n    val foo by Lazy { ... }\n}\n\n```\n\nIn the byte code, the field holding the delegate will be annotated.\n\n### Type checking for use-site variance\n\nWe have fixed a number of annoying bugs connected with use-site variance (type projections). As a result, the compiler may find some previously missed bugs in your code.\nFor example, in the following case:\n\n```kotlin\nval ints = mutableListOf(1, 2, 3)\nval strs = mutableListOf(\"abc\", \"def\")\nval comps: MutableList<out Comparable<*>> = ints\ncomps.addAll(strs) // ?! Adding strings to a list of ints\n```\n\nThis code was mistakenly accepted before and is rejected now on the last line with the message:\n\n```kotlin\nProjected type MutableList<out Comparable<*>> restricts the use of addAll()\n```\n\n## Java Interoperability\n\nSome improvements to synthesized properties derived from Java’s get/set pairs:\n\n*   such declarations (as well as SAM-converted methods) are now resolved on par with members;\n*   support added for Java setters that return values.\n\nSupport added for `@Nullable/@NotNull` annotations from various popular libraries such as `javax.annotations`, Android SDK, etc.\nEAP users report:\n\n> Android annotations being recognized broke a lot of my code in a good way\n\nAnd highlighted bug fixes:\n\n*   Private top-level Kotlin classes are now compiled to package-private Java classes\n*   Members of private classes can-not be accessed from non-private inline functions\n\n## Standard Library\n\n*   Library code rearranged into more granular packages (no source changes should be required)\n*   Some functions have been made inline\n*   Many inline functions (most of them one-liners) can no longer be called from Java code. This will help us reduce the size of the runtime library in the future.\n*   All old deprecations have been removed\n*   `Map.getOrElse()` and `Map.getOrPut()` now treat keys associated with `null` values as **missing**.\n*   `mutableListOf`, `mutableSetOf`, `mutableMapOf` added to construct mutable collections.\n*   `toMutableList` added instead of `toArrayList`. The latter is deprecated\n*   `associate` and `associateBy` are added to aid construction of maps (instead of `toMap`/`toMapBy`)\n*   Comparator- and comparison-related functions are moved to `kotlin.comparisons` package (not imported by default)\n\nMore changes [here](https://github.com/JetBrains/kotlin/releases/tag/build-1.0.0-rc-1036)\n\n## Tooling\n\nTo enable Android Extensions in Gradle in a more idiomatic way, we now say:\n\n```kotlin\napply plugin: 'kotlin-android-extensions'\n```\n\nin the `build.gradle` file (individually for each project).\n\nThe old way doesn’t work any more and prints fixing instructions to the output.\n\n## IDE Changes\n\n*   Intention to replace iteration over map entries with a loop using a destructuring declaration\n*   Inspection and quickfix to cleanup redundant visibility modifiers\n*   Inspection to replace ‘assert’ calls checking that a variable is not null with `!!` or `?: error(...)`\n*   Show “Kotlin not configured” notification when opening a .kt file in the IDE if the Kotlin runtime is not configured for the corresponding module\n*   Action to generate the `toString()` method\n*   Support for implementing members by primary constructor parameters\n*   Parameter info popup works for showing type parameters\n*   Completion offers name variants based on unresolved identifiers in current file\n*   Quickfix for adding missing branches to a `when` expression\n*   Support for moving nested classes to the upper level or into another top-level class\n*   `@Suppress` now works for IDE inspections\n\n## Installation Instructions\n\nFor the users of IntelliJ IDEA, automatic updates may not work in the IDE, so you’ll need to download the plugin and install it from a zip file:\n\n*   Download [here](https://plugins.jetbrains.com/plugin/download?pr=&updateId=23813)\n*   Go to _Preferences | Plugins_ and click _Install plugin from disk..._\n\nSorry for the inconvenience.\n\n## Stay tuned\n\nThe final release is approaching, meanwhile — have a nice Kotlin! ![:)](http://i2.wp.com/blog.jetbrains.com/kotlin/wp-includes/images/smilies/simple-smile.png?w=640)\n\n_P.S. See the discussions on [Hacker News](https://news.ycombinator.com/item?id=11034273) and [Reddit](https://www.reddit.com/r/programming/comments/445jih/jvm_languages_news_kotlin_10_release_candidate_is/)_.\n\n","author":"Andrey Breslav","date":"2016-02-04","type":"article","categories":["Kotlin","Release"],"features":["highlightjs"],"description":"","filename":"","lang":"EN","enclosure":null},{"title":"Kotlin 1.1 Beta Is Here!","url":"https://blog.jetbrains.com/kotlin/2017/01/kotlin-1-1-beta-is-here/","body":"\nCongratulations! Today Kotlin 1.1 has reached Beta, and this means that\n\n* it’s time to try it out,\n* there’s still time to give us your feedback (and we really need it!),\n* the release is coming fairly soon.\n\n![Kotlin 1.1 Beta](https://d3nmt5vlzunoa1.cloudfront.net/kotlin/files/2017/01/1.1-Beta-Banner-2-01.png)\n\nWe’ve seen a lot of interest in Kotlin over the past year, and would like to thank all our users, contributors and supporters. Special thanks to early adopters of new features for their bravery and feedback to our EAP builds!\n\n## An overview of what is coming in Kotlin 1.1\n\nThe biggest news of Kotlin 1.1 are\n\n* full support of compilation to **JavaScript**, and\n* **Coroutines** on the JVM, Android and JavaScript.\n\nWe’ll give some more details about these below, but they are not the only exciting news of 1.1. Many more language improvements and new features are coming (more details are available on our [What’s new](https://kotlinlang.org/docs/reference/whatsnew11.html) page):\n\n* [Type aliases](https://github.com/Kotlin/KEEP/issues/4): `typealias Action<T> = (T) -> Unit`\n* [Bound callable references](https://github.com/Kotlin/KEEP/issues/5): `expr::foo`\n* Type inference based on getters: `val myString get() = \"hi\"`\n* Compiler plugins for\n    * making classes `open` by default\n    * generating no-arg constructors by default\n    * extension lambdas in SAM conversions\n* [Inheritance for `data` classes](https://github.com/Kotlin/KEEP/issues/31)\n* [Subclasses of `sealed` classes in the same file](https://github.com/Kotlin/KEEP/issues/29)\n* [Destructuring in lambdas](https://github.com/Kotlin/KEEP/blob/master/proposals/destructuring-in-parameters.md): `map.forEach { (k, v) -> ...}`\n* [Underscore for unused parameters](https://github.com/Kotlin/KEEP/blob/master/proposals/underscore-for-unused-parameters.md)\n* [Scope control for builder-like DSL’s](https://github.com/Kotlin/KEEP/blob/master/proposals/scope-control-for-implicit-receivers.md): `@DslMarker`\n* [`provideDelegate`](https://blog.jetbrains.com/kotlin/2016/12/kotlin-1-1-m04-is-here/#provide-delegate) operator convention\n* [Local delegated properties](https://github.com/Kotlin/KEEP/issues/25)\n* [JDK 8 methods on Kotlin collections](https://github.com/Kotlin/KEEP/blob/master/proposals/jdk-dependent-built-ins.md): `list.parallelStream()`\n* [Inline properties](https://github.com/Kotlin/KEEP/blob/master/proposals/inline-properties.md)\n* `enumValues()`/`enumValueOf()` for generic access to enums\n* [Underscore in numeric literals](https://github.com/Kotlin/KEEP/blob/master/proposals/underscores-in-numeric-literals.md): `1_000_000`\n\n## Deprecation\n\nWe deprecate the unfortunate name `mod` that we used for the `%` operator, and replace it with `rem`, which is semantically correct and agrees with existing libraries such as `java.math.BigInteger`. Deprecation warnings and the tooling will guide you through the migration process.\n\n## JavaScript\n\nIt’s simple: the full Kotlin language can be now compiled to JavaScript. It doesn’t mean that we have ported all of the JDK into the browser: the language and its Standard Library are not coupled with JDK, but you can use Kotlin strings, collections, sequences, arrays and other core APIs on JS as well as JVM/Android.\n\nNumerous popular JS libraries will be available through typed headers (converted from [DefinitelyTyped](https://github.com/DefinitelyTyped/DefinitelyTyped)). We support all popular runtime module systems for JavaScript as well as [webpack](https://webpack.github.io/) and other important tools.\n\nWe’ll dedicate a lot of effort in Kotlin 1.2 and beyond to making the JavaScript tooling smooth and helpful. Our goal is to enable pleasant full-stack development with Kotlin.\n\n## Coroutines\n\nHonestly, it’s hard to over-emphasize coroutines. The future has come, and we are stuck with it: we need non-blocking asynchronous APIs to keep up with the loads of data we are processing. We’ve been through callback hell and conquered it, but we deserve better. We want to simply write the code following its natural _sequential_ logic, and let the compiler figure the asynchrony out for us. This is what coroutines are about: async/await, generate/yield, non-blocking IO, Rx and much more brought under the single unified paradigm of a _suspending function_. Such a function (or lambda) represents a computation that can be suspended (without blocking any threads) and resumed later.\n\n```kotlin\nfuture {\n    val original = asyncLoadImage(\"...original...\") // creates a Future\n    val overlay = asyncLoadImage(\"...overlay...\") // creates a Future\n    ...\n    // suspend while awaiting the loading of the images\n    // then run `applyOverlay(...)` when they are both loaded\n    return applyOverlay(original.await(), overlay.await())\n}\n```\n\nThe main benefit of coroutines is their flexibility:\n\n* The language part is minimal\n* Everything can be written as a library\n* Libraries are in total control of all aspects of suspending and resuming computations: threads, exceptions and other aspects of computation are entirely customizable.\n\nWe have written a set of libraries for interesting common use cases: [kotlinx.coroutines](https://github.com/Kotlin/kotlinx.coroutines)\n\nRead more about coroutines [here](https://github.com/Kotlin/kotlin-coroutines/blob/master/kotlin-coroutines-informal.md).\n\n**An important note**. With all the benefits that they bring, Kotlin coroutines are a fairly new design that needs extensive battle-testing before we can be sure it’s 100% right and complete. This is why we will release it under an “experimental” opt-in flag. We do not expect the language rules to change, but APIs may require some adjustments in Kotlin 1.2.\n\n* Command line: `-Xcoroutines=enabled`\n* Gradle: `kotlin.coroutines=enable` in `gradle.properties` or `local.properties`\n* Maven: `<configuration> <args> <arg>-Xcoroutines=enable</arg> </args> </configuration>`\n* IDE: Use a quick-fix (Alt+Enter) or modify the facet options (_Project Structure -> Modules -> Your Module -> Compiler -> Coroutines (experimental)_)\n\n## Standard Library, Tooling and Frameworks\n\nKotlin’s Standard Library is getting updated with [many useful utilities](https://kotlinlang.org/docs/reference/whatsnew11.html#standard-library) and extensions including those specific for JDK 7 and 8.\n\nOur collaboration with [Gradle](https://blog.gradle.org/kotlin-meets-gradle) has resulted in gradle-script-kotlin which means that you can now write type-safe build scripts for Gradle, using Kotlin scripting.\n\nWe now support JSR 223, which is utilized by [the Spring Framework](https://spring.io/blog/2017/01/04/introducing-kotlin-support-in-spring-framework-5-0) along with type-safe DSLs and other things.\n\n## How to Try It\n\nAs with other pre-release versions, we give **no backward compatibility guarantees** for Kotlin 1.1‑Beta. Moreover, when we reach final RC, all binaries produced by pre-release versions will be outlawed by the compiler: you’ll be required to recompile everything that was compiled by 1.1‑M0x and Beta (all the code from 1.0.x is perfectly fine without recompilation).\n\n**In Maven/Gradle:** Add [http://dl.bintray.com/kotlin/kotlin-eap-1.1](http://dl.bintray.com/kotlin/kotlin-eap-1.1) as a repository for the build script and your projects; use `1.1.0-beta-17` as the version number for the compiler and the standard library.\n\n**In IntelliJ IDEA:** Go to _Tools → Kotlin → Configure Kotlin Plugin Updates_, then select “Early Access Preview 1.1” in the _Update channel_ drop-down list, then press _Check for updates_.\n\nThe command-line compiler can be downloaded from the [Github release page](https://github.com/JetBrains/kotlin/releases/tag/v1.1-beta).\n\n**On [try.kotlinlang.org](http://try.kotlinlang.org/)**. Use the drop-down list at the bottom-right corner to change the compiler version to 1.1‑Beta.\n\nLet’s Kotlin!\n","author":"Andrey Breslav","date":"2017-01-19","type":"article","categories":["Kotlin"],"features":["highlightjs"],"description":"","filename":"","lang":"EN","enclosure":null},{"title":"The Adventurous Developer’s Guide to JVM languages – Kotlin","url":"http://zeroturnaround.com/rebellabs/the-adventurous-developers-guide-to-jvm-languages-kotlin/","body":"\nIn this post we will focus on [Kotlin](http://kotlin.jetbrains.org/), with a simple [HTTP Server coding example](https://github.com/sjmaple/Kotlin-HTTP-Server) to showcase the language features and coding syntax.\n\n[![](http://devnet.jetbrains.net/servlet/JiveServlet/showImage/2-5456865-25537/KotlinLogo.png)](http://devnet.jetbrains.net/servlet/JiveServlet/showImage/2-5456865-25537/KotlinLogo.png)\n\nThe Kotlin HTTP Server example we coded can be found on [github](https://github.com/sjmaple/Kotlin-HTTP-Server). Kotlin is a fairly young, statically-typed language, created by JetBrains and first announced at the JVM language summit in July 2011. The smart folks at JetBrains, creators of IntelliJ IDEA, have integrated many languages into their IDE and are pretty clued up on which requirements a modern-day developer is looking for, as well as the capabilities of the existing JVM languages.\n\nThe IDE support was the first ‘challenge’ I was faced with. As an Eclipse user, switching to the IntelliJ IDEA environment is always difficult, but it’s a necessary step if you want to code in a rich Kotlin environment. It’s fairly easy to install the Kotlin plugin, and create Kotlin artifacts, but just a shame the support isn’t also being pushed to other IDEs. Maybe we can subtly hint this to the JetBrains team? ;)\n\n![kotlin-ide](http://zeroturnaround.com/wp-content/uploads/2013/01/kotlin-ide.png)\n\n### Elegant coding\n\nCoding in Kotlin really does provide some very elegant code. It removes the need for null checks, uses primary constructors, smart casts, range expressions... the list goes on. Let’s take a look at an example.\n\nFrom my Java background I did like the combination of the `is`/`as` casting with the `when` structure. In Java terms, consider them as `instance of`, cast – `(A) obj` and `case` respectively. The `is` usage will also infer a cast if you go ahead and use the object straight away. E.g: `if (stream is Reader) stream.close()` In this example, the `stream.close()` is being called via the `Reader` interface. This would be the same as saying `if (stream is Reader) (stream as Reader).close()` but the extra code is not needed. This in combination with when allows you to switch over a variable, but not just using its value as you can get a richer involvement. Consider the following:\n\n```kotlin\nwhen (stream) {\n    is Reader -> stream.close()\n    is Writer -> stream.close()\n    is InputStream -> stream.close()\n    is OutputStream -> stream.close()\n    is Socket -> stream.close()\n    else -> System.err.println(\"Unable to close object: \" + stream)\n}\n```\n\nThis is really clean, elegant code if you consider how you might want to implement this in Java. C# interestingly has a very similar usage of `is` and `as`, and also implements nullable types.\n\nMethod calls make use of parameter naming as well as defaults. It can be such a headache when a method takes in 5 booleans as you have to call the method very carefully so you pass `true` and `false` in the right order. Parameter naming gets round the confusion by qualifying the parameter name with the parameter itself on the method invocation. Nice. Again, this has been done in the past by other languages and scripting frameworks, but it’s a welcome addition to any language, particularly with parameter defaults, which allow the method invocation to omit certain parameters if the user is happy to accept default values. Lets take a look at an example:\n\n```kotlin\nprivate fun print(out : PrintWriter, pre : String, contentType: String = \"text/html\",\n                  contentLength : Long = -1.toLong(), title : String, body : () -> Unit)\n```\n\nHere we have a method with several `String` parameters as well as a function as input. It is invoked using the following call. Notice that `contentType` and `contentLength` are both omitted from the invocation meaning the defaults in the declaration are used.\n\n```kotlin\nprint(out = out,\n      pre = \"HTTP/1.0 404 Not Found\",\n      title = \"File Not Found\",\n      body = {out.println(\"<H2>404 File Not Found: \" + file.getPath() + \"</H2>\")})\n```\n\nSo what does this mean? Well, there will be much less method overloading! Result! :D Seriously though, it’s amazing to think Java gone over 20 years without additions like this? Sometimes it does feel like you’re coding in the dark a little. Come on Java, catch up!\n\n### Kotlin will help you write safe code, unless you don’t want to!\n\nLet’s get geeky. Firstly you can say goodbye to NPEs! Kotlin uses ‘nullable types’ and ‘non-nullable types’ to differentiate between vars which could be null, and those which will never be null. Consider the following code:\n\n```kotlin\nvar a : String = \"a\"\na = null // compilation error\n```\n\nTo allow nulls, the var must be declared as nullable, in this case, written `String?`:\n\n```kotlin\nvar b : String? = \"b\"\nb = null // valid null assignment\n```\n\nNow, if you call a method on a, it’s guaranteed not to cause an NPE, so you can safely say\n\n```kotlin\nval l = a.length()\n```\n\nBut if you want to call the same method on b, that would not be safe, and the compiler reports an error:\n\n```kotlin\nval l = b.length() // error: variable 'b' can be null\n```\n\nBy knowing which vars can be null, the Kotlin compiler mandates that when you dereference a nullable type, you do so using one of the following methods:\n\nHmmm, I’m half way through writing this blog post and I’ve not mentioned anything that’s strikingly new or innovative... let’s continue and see how we go.\n\nSafe calls in Kotlin are very similar to those in Groovy, including the notation. By dereferencing a nullable type using ‘`.?`‘ like in the example below, tells the compiler to call length on object b, unless it is null, in which case do nothing.\n\n```kotlin\nb?.length()\n```\n\nThose of you who are thinking ‘What? Get rid of null? Where’s the fun in that?”, there is the `!!` operator which allows for the potential of a NPE to be thrown, if you so wish.\n\nYou can also use the `?` notation with `as` to avoid exceptions being thrown if the cast is not possible. This is called a safe cast.\n\n### Functions\n\nFunctions can be created inside (member functions) or outside of a class. A function can contain other functions (local functions) and you can use functions to extend existing classes such as the following:\n\n```kotlin\nfun Int.abs() : Int = if (this >= 0) this else -this\n```\n\nThis example extends the `Int` class to return the absolute value it contains.\n\nFunctions are very powerful and are well used on the JVM in many languages (Still not in Java, until Java 8). Kotlin also allows the use of higher order functions which means you can pass a function as an argument to a method call (function literal).\n\nAlmost at the end now, and still nothing that I would call really stand out, knee smackingly amazing. Don’t misunderstand my point, I think Kotlin is a very nice language but so far it’s been getting that way by extracting pieces of existing languages and putting a new spin on it. Maybe this is to be expected given the exposure the JetBrains team have had to all the existing languages they support, and maybe this is what they intended to produce. Do we need extra languages to please every persons development style in the development community? Maybe... Maybe not.\n\n### Documentation/Help\n\nI found that the documentation for Kotlin was all in the same place. All Google searches led back to the [community site](http://confluence.jetbrains.net/display/Kotlin/Welcome). I think this is a shame, as it would be great to go somewhere else with other examples and resources with which to play around with, but I guess it’s still quite young. It would be nice to see more code in github and the like, for others to follow.\n\n### Summary\n\nOverall I really enjoyed using Kotlin. Nothing about Kotlin is particularly groundbreaking, but what makes it great is that it cherry picks some of the best parts of other languages.\n\n**The parts I really liked about the language:**\n\n*   The use of functions really gives the developer extra options in designing code.\n*   Parameter names should be mandatory in every language as they’re so great! Kotlin uses them well with default values.\n*   Extending classes is very easy and very useful.\n*   The documentation is good and there are very interesting discussions in the comments.\n*   It’s a pretty language! The keyword and fluff to useful code ratio is much better in Kotlin using constructs such as `when`, `is` and `as`\n*   Kotlin is enjoyable to write and very easy to readand I would expect maintain, particularly because it’s a safe language.\n\n**There were a couple of pain points though:**\n\n*   The error flags in IntelliJ popping up all over the place if there is a single error, because of the knock on effect of the error. It can be hard to find the root cause.\n*   I also had a few problems with try-finally for my stream closes, which I didn’t have time to resolve. When I added the close in the finally block, it seemed to use the result as part of the return by the look of the exception received:\n\n    _Exception in thread “main” java.lang.VerifyError: (class: HttpServer, method: run signature: ()V) Register 9 contains wrong type\n    at namespace.main(HTTPServer.kt:169)_\n\nWith milestone releases every 2-3 months, Kotlin may soon be a language which many Scala beginners may turn to, although I don’t think the happy Scala users will be too bothered about it. From what I’ve read online, some look down on it, but you’d expect that from opinionated techies wouldn’t you? :) (Not to divert you, but for more on Scala, feel free to check out our super popular [Scala report](http://zeroturnaround.com/labs/scala-2013-a-pragmatic-guide-to-scala-adoption-in-your-java-organization/), featuring an in-depth interview with Martin Odersky)\n\nI’d like to look back in 6 months or a year to see how Kotlin has evolved, and with the JetBrains team driving it, we’re certain to be in for a fun ride. My initial impression is that Kotlin is going on a route quite similar to Scala, today. I wouldn’t expect anyone who is happy with Scala to migrate across to Kotlin, as the Kotlin folks have also mentioned, but for people who have been frustrated with Scala, it may be worth looking at some time in the future. I think it is sharing a busy market of developers with other languages that are too similar in features and syntax may not help them survive longer term. If you want to have a go yourself you can also play with [Kotlin in a browser](http://kotlin-demo.jetbrains.com). I’d love to hear your experiences in the comments!\n\n**Don’t forget to check out the [HTTP Server sample Kotlin code on Github](https://github.com/sjmaple/Kotlin-HTTP-Server).**\n\n_Psst! If you liked this post, [we wrote a 50-page RebelLabs report](http://zeroturnaround.com/rebellabs/devs/the-adventurous-developers-guide-to-jvm-languages/) on Java 8, Scala, Groovy, Fantom, Clojure, Ceylon, Kotlin & Xtend._\n\n","author":"Simon Maple","date":"2013-01-23","type":"article","categories":["Kotlin"],"features":["highlightjs"],"description":"","filename":"","lang":"EN","enclosure":null},{"title":"Kosent","url":"http://oneeyedmen.com/konsent.html","body":"\nI've just released [Kosent](https://github.com/dmcg/konsent), an acceptance testing library for Kotlin.\n\nThe basic idea is that you can write your tests in a nice IDE-friendly and refactorable Kotlin DSL, but they generate\nGherkin that your customer can read and approve as the spec.\n\nSo you write this\n\n```kotlin\n@RunWith(Konsent::class)\n@Preamble(\n    \"As a developer named Duncan\",\n    \"I want to know that example.com is up and running\")\nclass KonsentExampleTests : ChromeAcceptanceTest() {\n\n    val duncan = actorNamed(\"Duncan\")\n\n    @Scenario(1) fun `Example_dot_com loads`() {\n        Given(duncan).loadsThePageAt(\"http://example.com\")\n        Then(duncan) {\n            shouldSee(::`the page location`, pathContains(\"example.com\"))\n            shouldSee(::`the page title`, equalTo(\"Example Domain\"))\n            shouldSee(::`the page content`, containsALink(\"More information...\", \"http://www.iana.org/domains/example\"))\n        }\n    }\n\n    @Scenario(2, \"Following a link from example.com\") fun cant_have_dots_in_quoted_method_names() {\n        Given(duncan).loadsThePageAt(\"http://example.com\")\n        When(duncan).followsTheLink(\"More information...\", \"http://www.iana.org/domains/example\")\n        Then(duncan).shouldSee(::`the page location`, equalTo(URI(\"http://www.iana.org/domains/reserved\")))\n    }\n\n    @Scenario(3) fun `Dispensing with the given when then`() {\n        duncan.he.loadsThePageAt(\"http://example.com\")\n        duncan.he.followsTheLink(\"More information...\", \"http://www.iana.org/domains/example\")\n        duncan.shouldSee(::`the page location`, equalTo(URI(\"http://www.iana.org/domains/reserved\")))\n    }\n}\n```\n\nand they read this\n\n```gherkin\nFeature: Konsent Example Tests\n    As a developer named Duncan\n    I want to know that example.com is up and running\n\n    Scenario: Example_dot_com loads\n        Given Duncan loads the page at \"http://example.com\"\n        Then Duncan sees the page location \"location contains \"example.com\"\n        and Duncan sees the page title is equal to \"Example Domain\"\n        and Duncan sees the page content contains a link [More information...](http://www.iana.org/domains/example)\n\n    Scenario: Following a link from example.com\n        Given Duncan loads the page at \"http://example.com\"\n        When Duncan follows the link [More information...](http://www.iana.org/domains/example)\n        Then Duncan sees the page location is equal to http://www.iana.org/domains/reserved\n\n    Scenario: Dispensing with the given when then\n        Duncan loads the page at \"http://example.com\"\n        Duncan follows the link [More information...](http://www.iana.org/domains/example)\n        Duncan sees the page location is equal to http://www.iana.org/domains/reserved\n```\n\nThanks to my patrons at [Springer Nature](http://springernature.com), on whose dime this approach has been developed. We're\nhiring, so [get in touch](https://twitter.com/duncanmcg) if you're in London and this stuff interests you.\n\nStay tuned - I'm planning a post soon on how to implement a DSL like this in Kotlin.\n\n","author":"Duncan McGregor","date":"2016-05-12","type":"article","categories":["Testing","Kotlin"],"features":["highlightjs"],"description":"","filename":"","lang":"EN","enclosure":null},{"title":"Reactor Kotlin Extensions 1.0.0.M1 released","url":"https://spring.io/blog/2017/03/28/reactor-kotlin-extensions-1-0-0-m1-released","body":"\nI am excited to announce the release of the first milestone of [Reactor Kotlin Extensions](https://github.com/reactor/reactor-kotlin-extensions), which provides Kotlin extensions for Reactor API.\n\nIt provides support for Kotlin types like `KClass`, takes advantage of Kotlin [reified type parameters](http://kotlinlang.org/docs/reference/inline-functions.html#reified-type-parameters) and provide various extensions to allow more expressive code. You can see bellow a quick comparaison of Reactor with Java versus Reactor with Kotlin + extensions.\n\n| Java                                         | Kotlin with extensions                       |\n|----------------------------------------------|----------------------------------------------|\n| `Mono.just(\"foo\")`                           | `\"foo\".toMono()`                             |\n| `Flux.fromIterable(list)`                    | `list.toFlux()`                              |\n| `Mono.error(new RuntimeException())`         | `RuntimeException().toMono()`                |\n| `Flux.error(new RuntimeException())`         | `RuntimeException().toFlux()`                |\n| `flux.ofType(Foo.class)`                     | `flux.ofType()` or `flux.ofType(Foo::class)` |\n| `StepVerifier.create(flux).verifyComplete()` | `flux.test().verifyComplete()`               |\n\nTo use it in your project, add `https://repo.spring.io/milestone` repository and `io.projectreactor:reactor-kotlin-extensions:1.0.0.M1` dependency.\n\nThis is the very first milestone, so feel free to create issues and submit pull requests on [reactor-kotlin-extensions](https://github.com/reactor/reactor-kotlin-extensions) GitHub project.\n","author":"Sébastien Deleuze","date":"2017-03-28","type":"article","categories":["Kotlin","Spring"],"features":["highlightjs"],"description":"","filename":"","lang":"EN","enclosure":null},{"title":"Kotlin in Production - What works, Whats broken","url":"http://blog.dripstat.com/kotlin-in-production-the-good-the-bad-and-the-ugly-2/","body":"\nWe have been using Kotlin in the [DripStat](https://dripstat.com) backend since Kotlin's 1.0 release using the Kotlin Intellij plugin. Here is a summary of our experiences as of Kotlin 1.0.3.\n\n### The Good\n\nAt the language level, Kotlin seems to be excellent.\n\n**1 - Seamless Java interop**\n\nKotlin nails the Java interop at the language level. It is completely seamless. This was the reason why we were comfortable introducing Kotlin in our codebase in the first place.\n\n**2 - Less verbosity**\n\nKotlin code is much less verbose than Java code. This makes it more pleasing to both read and write.\n\n**3 - Null checks**\n\nKotlin enforces null checks at the language level. When you interact with Java code, it even extends that to the runtime level. This has resulted in catching some bugs pretty early and also more robust code.\n\n### What can be improved\n\n**1 - Lack of `parallelStream()`**\n\nKotlin's collection api have no equivalent to Java's `parallelStream()`. This is dearly missed.\n\n**2 - Cannot subclass Data classes**\n\nThis is something that we feel the need for more and more as our codebase grows. It seems to be planned for Kotlin 1.1 but doesnt exist as of today.\n\n**3 - Type inference on method return values**\n\nWhile type inference everywhere else results in more concise code, on method return values, it [results in an actual loss of information](http://blog.dripstat.com/type-inference-in-java-jep-286-can-be-disastrous/). You cannot tell the type of the variable unless you look at the called method's signature, and the IDE plugin currently doesn't show the type. While Kotlin does allow specifying the variable type, it results in much more verbosity than Java.\n\n### Whats Broken\n\nWe have found that the Intellij plugin for Kotlin is extremely buggy and very far behind Java.\n\n**1 - Editor crashes**\n\nThis is such a huge issue since 1.0.3 that we cannot write any more Kotlin code. The editor frequently stops doing syntax highlighting, code completion etc. The only remedy when this happens is to restart the entire IDE.\n\n[KT-13199](https://youtrack.jetbrains.com/issue/KT-13199)\n\n**2 - Inaccurate Call Hierarchy view**\n\nThe Call Hierarchy view frequently doesn't show all calls to a method if that method is used across both Java and Kotlin. This is an extremely serious bug. Entire technical decisions can be based on whether a piece of code is used in a certain location. The fact that the Call Hierarchy view shows incomplete information has a huge impact.\n\n[KT-12398](https://youtrack.jetbrains.com/issue/KT-12398)\n\n**3 - Flaky gradle integration**\n\nThe Kotlin Gradle integration has been pretty flaky in the past. It almost feels like every new release of either Gradle or Kotlin breaks it. We are almost afraid of upgrading either due to this.\n\n[KT-13179](https://youtrack.jetbrains.com/issue/KT-13179) [KT-12771](https://youtrack.jetbrains.com/issue/KT-12771)\n\n**4 - Cant see inferred variable type**\n\nFor a language that uses type inference so heavily, you would expect the IDE to have top-notch support for showing the type of variables. However, this is broken in the Kotlin Intellij plugin.\n\nIt is also surprising that Intellij forces you to press a keyboard shortcut each time to bring this up, instead of showing the variable type constantly in a fixed location like the status bar.\n\n[KT-10095](https://youtrack.jetbrains.com/issue/KT-10095)\n\n**5 - Refactorings**\n\nWhile it does have very basic move class, rename class, rename method refactorings, the vast majority of refactorings from Java are simply not present. Even the rename refactoring is extremely limited.\n\n[KT-13082](https://youtrack.jetbrains.com/issue/KT-13082) [KT-2615](https://youtrack.jetbrains.com/issue/KT-2615)\n\n**6 - No Postfix completion, Duplicate Detection**\n\nPostfix completion and Duplicate detection come to mind as some of the many features we have come to rely on and frequently use in the Java editor, that are simply not present.\n\n[KT-4710](https://youtrack.jetbrains.com/issue/KT-4710)\n\n### Conclusion\n\nKotlin seemed to promise a better Java, without compromises. It does achieve that at the language level. However, a big part of using Java is Jetbrains' own excellent Java tooling. Here the Kotlin plugin has a lot of work to do to catch up with what Jetbrains has built over 15 years for Java.\n\n","author":"DripStat","date":"2016-09-24","type":"article","categories":["Kotlin"],"features":["highlightjs"],"description":"","filename":"","lang":"EN","enclosure":null},{"title":"Code improvements with Kotlin","url":"https://blog.frankel.ch/code-improvement-kotlin","body":"\n[![](https://blog.frankel.ch/wp-content/resources/code-improvement-kotlin/icon_Kotlin.png)](https://kotlinlang.org/)This week, I tried to improve my pet Android application developed in Kotlin. As I was very new to Kotlin when I started it, most of the code just looks like Java written in Kotlin.\n\n### Starting simple\n\nHere’s one such snippet, that needs to initialize both a template message and its argument:\n\n```kotlin\nval messageTemplate: String\nval params: Array <any>when (shownCount) {\n    0 -> {\n        messageTemplate = noItem\n        params = arrayOf<any>()\n    }\n    1 -> {\n        messageTemplate = itemShowSingle\n        params = arrayOf<any>(totalCount)\n    }\n    else -> {\n        messageTemplate = itemShowCount\n        params = arrayOf(shownCount, totalCount)\n    }\n}\n```\n\n#### Pair\nKotlin versions after M3 don’t offer `Tuple` anymore, but specialized versions like `Pair` and `Triple` in the _stdlib_. Also, the `to()` extension function can create such pairs on the fly, without resorting to the constructor.\n\n#### Destructuring declarations\n\nKotlin allows to initialize multiple variables at once when the function returns a `Pair`, a `Triple` or any _data_ class for that matter.\n\nThis is the new improved code:\n\n```kotlin\nval (messageTemplate, params) = when (shownCount) {\n    0 -> noItem to arrayOf()\n    1 -> itemShowSingle to arrayOf(totalCount)\n    else -> itemShowCount to arrayOf(shownCount, totalCount)\n}\n```\n\n### _stdlib_ also known as Kotlin’s toolbelt\n\nA common task in Android is to send data to the SQLite database through `ContentValues` instances. Naive Java ports look like the following snippet:\n\n```kotlin\nval taskValues = ContentValues()\ntaskValues.put(T_NAME_COL, task.name)\ntaskValues.put(T_DESC_COL, task.description)\ntaskValues.put(T_PRIO_COL, task.priority)\ntaskValues.put(T_DONE_COL, if (task.done) 1 else 0)\ntaskValues.put(T_LIST_COL, list.id)\nif (task.imagePath != null) {\n    taskValues.put(T_IMG_COL, task.imagePath.toString())\n}\n```\n\nKotlin’s _stdlib_ provides a number of interesting functions.\n\n#### apply()\n\n`apply()` is an extension function set on `Any` type. It accepts a null-returning function as a parameter, applies it to the receiver and return the later. Note that in the scope of the lambda, `this` is the receiver.\n\n#### let()\n\n`let()` is another extension function set on `Any` type. It accepts a transforming function as a parameter and calls it with the receiver as the parameter.\n\n#### Null-safe call operator\n\nThe `.?` operator will only called the right-hand operand if the left-hand operand is not null. It’s Kotlin’s idiomatic way for null checking\n\nUsing them in combination gives the following code:\n\n```kotlin\nval taskValues = ContentValues().apply {\n    put(T_NAME_COL, task.name)\n    put(T_DESC_COL, task.description)\n    put(T_PRIO_COL, task.priority)\n    put(T_DONE_COL, if (task.done) 1 else 0)\n    put(T_LIST_COL, list.id)\n    task.imagePath?.let { put(T_IMG_COL, it.toString()) }\n}\n```\n\n### Going further\n\nAnother common Android task it to read data stored in UI components:\n\n```kotlin\nval id = nameView.tag as Long?\nif (id != null) {\n    task.id = id\n}\n```\n\n#### Safe cast\n\nCasts are handled in Kotlin with the `as` operator. However, nullable and non-nullable types don’t belong to the same hierarchy. Hence, if one casts `null` to a non-nullable type, a `ClassCastException` will be thrown at runtime. To avoid that, us the `as?` smart cast operator.\n\nUsing `let()` and the `.?` operator in conjunction with smart cast produces the next improvement:\n\n```kotlin\n(nameView.tag as? Long)?.let { task.id = it }\n```\n\n### The whole shebang\n\nThe final common snippet is related to querying SQLite databases. Basically, the usual flow is to create the object, create the cursor, iterate over it to read values and set object’s attributes from them. It looks like this:\n\n```kotlin\nfun findById(id: Long): Task {\n    val cursor = readableDatabase.rawQuery(\"SELECT A LOT FROM TABLE\", arrayOf(id.toString()))\n    cursor.moveToFirst()\n    val name = cursor.getString(1)\n    val description = cursor.getString(2)\n    val imagePath = cursor.getString(3)\n    val task = Task(name, description)\n    if (!cursor.isNull(4)) {\n        val date = cursor.getLong(4)\n        task.alarm = Date(date)\n    }\n    cursor.close()\n    task.id = id\n    if (imagePath != null) {\n        task.imagePath = Uri.parse(imagePath)\n    return task\n}\n```\n\n#### Local functions\n\nMethods in Java are about visibility and scoping. Basically, if one wants a method not reused in other classes, one sets the _private_ visibility. If this method is used only in another method, it just pollutes the class namespace. Embedded functions are a way to declare a function inside another one to avoid this pollution. Kotlin (as well as Scala) allows that.\n\n#### with()\n\nAnother useful function from _stdlib_ is with(). Available on any type, it takes 2 parameters: the first is the receiver, the second a transforming function and calls the later on the former.\n\nCombining those with some of the above features can improve the code a lot:\n\n```kotlin\nfun findById(id: Long): Task {\n\n    fun toTask(cursor: Cursor): Task {\n        with(cursor) {\n            moveToFirst()\n            val name = getString(1)\n            val description = getString(2)\n            val imagePath = getString(3)\n            return Task(name, description).apply {\n                if (!isNull(4)) {\n                    val date = getLong(4)\n                    val alarm = Date(date)\n                    this.alarm = alarm\n                }\n                this.id = id\n                imagePath?.let { this.imagePath = Uri.parse(it) }\n                close()\n            }\n        }\n     }\n\n    return readableDatabase.rawQuery(\n            \"SELECTA LOT FROM TABLE\",\n            arrayOf(id.toString())).let { toTask(it) }\n}\n```\n\n### Conclusion\n\nLearning a new programming language is easy: many books promise to do that in 21 days. The hard part is how to write idiomatic code in that new language. This is a long and arduous journey, that needs a lot of reading such idiomatic code, writing “bad” code yourself and improving it over the course of many iterations.\n\n**To go further:**\n\n* [Destructuring Declarations](https://kotlinlang.org/docs/reference/multi-declarations.html)\n* [Smart Casts](https://kotlinlang.org/docs/reference/typecasts.html#smart-casts)\n* sdtlib functions [reference](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/#functions)\n* [Safe calls](https://kotlinlang.org/docs/reference/null-safety.html#safe-calls)\n* [Local functions](https://kotlinlang.org/docs/reference/functions.html#local-functions)\n\n","author":"Nicolas Frankel","date":"2016-04-17","type":"article","categories":["Kotlin","null"],"features":["highlightjs"],"description":"","filename":"","lang":"EN","enclosure":null},{"title":"Exercises in Kotlin: Part 2 - High level syntax and Variables","url":"http://blog.dhananjaynene.com/2016/04/exercises-in-kotlin-part-2-high-level-syntax-and-variables/","body":"\nThis post first discusses the code that was written so far in the last post, [Exercises in Kotlin: Part 1 - Getting Started](http://blog.dhananjaynene.com/2016/04/exercises-in-kotlin-part-1-getting-started/). Subsequently it focuses on the basic syntax of variables, discusses a bit about packaging and also about Type Inference\n\n## A review of code so far\n\nLet us take a look at the code we wrote so far in the last blog post [first part of this series](http://blog.dhananjaynene.com/2016/04/exercises-in-kotlin-part-1-getting-started/) and glean what we can from the same.\n\n### helloworld.kt\n\n```kotlin\npackage com.example.kotlin.learning\n\nfun main(args: Array<String>) {\n    println(\"Hello World!\")\n}\nfun greetings() = \"Hello World!\"\n```\n\nSome of the things that can be noted from this program are follows\n\n*   _Similar package convention_: Kotlin follows similar package naming conventions as Java.\n*   _Standalone functions_: Yes, Kotlin has them. That means there is no requirement to have a class just in order to wrap functions, that frankly have no reasons to be part of a class.\n*   _Keyword_ `fun`: Functions are declared using the keyword `fun`.\n*   _Variable declaration order_: When declaring variables (or arguments to a function as in this case of the arguments to `main`), the order of declaration is reversed, with the type specification _following_ the variable/argument name and a colon used to separate the two.\n*   _Array is a generic type_: Arrays are not represented by `[]` but a generic type `Array<T>` instead where `T` is the type whose array is being represented. Thus at a syntactic level there is no necessity for using `[]` for arrays.\n*   There is a helper function called `println()` similar to `System.out.println()`\n*   _Semicolon as a statement terminator is optional_: A semi-colon does not seem to be mandatory\n*   _Optional function return types_: Return type of the function is not required. to be specified if the return type is a _Unit_. Which is why the function `main` does not require a return type declaration.\n*   _Alternative function representation_: As the function declaration for `greetings()` shows, function bodies can be substituted by expressions if the separator `=` is used between the function declaration and the expression. When the function body is specified as an expression, the compiler will attempt to infer the return type and in most cases no return type declaration will be required.\n\n### testgreet.kt\n\n```kotlin\npackage com.example.kotlin.learning\n\nimport org.junit.Test\nimport org.junit.Assert.assertEquals\n\nclass TestGreet() {\n    @Test\n    fun testGreetings() {\n        assertEquals(\"Greeting should be 'Hello World!'\",\n                \"Hello World!\", greetings())\n    }\n}\n```\n\nFrom this we can glean the following\n\n*   _Class declaration_: A Class declaration is similar to java in the sense it starts with the keyword `class` followed by the class name. The class body is also wrapped within `{` and `}`.\n*   _Constructor_: There is no explicit constructor that _seems_ to be required. That is not true. The parenthesis after the class name, in this case with empty content, are in fact the argument list for the primary constructor. More details about that later.\n*   _Method declarations_: Methods are also declared using the `fun` keyword.\n*   _Annotations_: Annotations can also be used just like they are used in java (in this case the `@Test` annotation.\n\nThe above gives us some sort of understanding about Kotlin syntax, Let us look at a few more examples to flesh out some of the more commonly used details. This has a main function. So you can copy this code into a file and compile and run it.\n\n## Example 1 : Comments and variables\n\n```kotlin\n/**\n* This is a comment\n*/\n\n/*\n   So is\n   this */\n\n// As is this\n\nval PI = 3.14159\n\nfun circleArea(r: Double) = PI * r * r\n\nfun main(args: Array<String>) {\n    var radius: Double = 1.0\n    val increment = 1\n    // increment = increment + 1 <-- will not compile since increment is a val\n    println(\"The radius of a circle with radius ${radius} is ${circleArea(radius)}\")\n    radius = radius + increment\n    println(\"The radius of a circle with radius ${radius} is ${circleArea(radius)}\")\n}\n\n```\n\nThe output of the above program is\n\n```kotlin\nThe radius of a circle with radius 1.0 is 3.14159\nThe radius of a circle with radius 2.0 is 12.56636\n```\n\nNote the following:\n\n#### Comments\n\n*   Kotlin follows the same syntax for comments as Java does. Enough said.\n\n#### Primitive types\n\n*   Kotlin has primitive types. Though they are not named identical to the ones in Java. They are in fact the same names with the first character capitalised viz Boolean, Byte, Int, Long, Float, Double etc. (not sure if there is an exception to that).\n*   There are member methods available for these primitives unlike Java. Thus you can call a `toString()` on an `Int`\n*   Although they seem to be like objects, their storage space is the same as primitives in Java _unless_ they are declared as _nullable_ (more about that later) or used by generic classes in which case their storage is like boxed primitives.\n\n#### Variables\n\n*   As mentioned earlier, variables can be declared at the top level (eg `PI`)\n*   Functions can also have local variables. eg. `radius` and `increment`\n*   Variables are of two types. `val` ie. read-only variables and `var` ie. read-write variables. In Java all variables by default are read-write and those that are to be treated as read-only are marked using the keyword `final`. However in Kotlin it is required to use one of the two keywords `val` or `var` explicitly. The statement `// increment = increment + 1` was commented out, because since `increment` is a `val` such a statement would not compile. `radius` on the other hand being a `var` can change its value, as is done at `radius = radius + increment`.\n*   A predominantly functional style of programming will almost always use `val`s and rarely if any `var`s. The rationale for that is beyond the scope of this post.\n*   A variable may or may not have an explicitly type declared. The compiler will attempt to infer it based on the value it is initialised to. However often that may not be feasible, and the programmer may be required to specify the type explicitly.\n\n#### Parameters\n\n*   Parameter declarations for functions are similar to a variable declaration. However they are not preceded by a `val` or a `var`. They are always `val`s. They always need an explicit type declaration.\n*   A function may return no value whatsoever (represented using the type `Unit`). The return type of the functional is optional for functions having an expression body (as in case of `circleArea`) or functions that have a block body but have a `Unit` return type. In other situatons the compiler will not attempt to infer the return type, and the programmer is required to provide it explicitly.\n\n#### String templates\n\n*   String interpolation is supported by allowing expressions to be embedded in strings using the ${`expr`} syntax as in the arguments to `println()`. This feature is called string templates in Kotlinspeak\n\n## (Optional) Some more advanced aspects about variables\n\nThere are some nuanced aspects of variables that you might use only occasionally. These are discussed here. You could chose to skip this section and instead move on to the next post since these might entangle you into learning and thinking about infrequently leveraged capabilities.\n\nConsider the following code, which is an extended version of the code we saw earlier. It is kind of a little odd, but has been deliberately constructed to talk about the advanced features.\n\n```kotlin\nconst val PI = 3.14159\n\nfun circleArea(r: Double) = PI * r * r\n\nvar defRadius = 5.0\n\nvar defaultRadius: Double\n    get() = defRadius\n    set(value) { defRadius = value }\n\nval area: Double\n    get() = circleArea(defaultRadius)\n\nfun main(args: Array<String>) {\n    var radius = 1.0\n    val increment = 1\n    println(\"The radius of a circle with radius ${radius} is ${circleArea(radius)}\")\n    radius = radius + increment\n    println(\"The radius of a circle with radius ${radius} is ${circleArea(radius)}\")\n    println(\"The radius of a circle with radius 5.0 is ${area}\")\n    defaultRadius = 6.0\n    println(\"The radius of a circle with radius 6.0 is ${area}\")\n}\n```\n\nThe output of the code above is as follows\n\n```kotlin\nThe radius of a circle with radius 1.0 is 3.14159\nThe radius of a circle with radius 2.0 is 12.56636\nThe radius of a circle with radius 5.0 is 78.53975\nThe radius of a circle with radius 6.0 is 113.09723999999999\n```\n\nThings to be noted.\n\n*   _getters_: Variables can have getter functions as shown for the variable `area` above. Frankly, not sure why they would be used for top level variables. Though I could imagine them to be used to work around variable visibility constraints by having a private var being accessible as a read-only variable function from another file by using a getter function.\n*   _setters_: We can also similarly use setters as in the case of `defaultRadius`. Again this is a bit of a contrived example, since one could have just as easily directly used `defRadius`. However do note, getters and setters to tend to be more useful when used with class member variables, a topic we will get to later.\n*   _const variables_: Variables can be prefixed with a const as in case of `PI` above. However this capability is restricted to top level variables only. In addition such variables have to be initialised to a `String` or a primitive type. and may not have a custom getter. In turn such consts can be used as parameters to annotations.\n*   _package namespaces and visibility_: Just like top level functions, you can also have top level variables/constants being declared. Also note that all the standalone functions get declared in the namespace of the package. So if you have multiple files with the same package and also same function (or top level variable) names, that will be treated as an error since one of them will end up attempting to redeclare the other. On the other hand if you declare a top level variable as private, it is not private to that package namespace, but is instead treated as private within a file\n\nWe shall be reviewing functions in the next post [Exercises in Kotlin: Part 3 - Functions](http://blog.dhananjaynene.com/2016/04/exercises-in-kotlin-part-3-functions/)\n\n","author":"Dhananjay Nene","date":"2016-04-19","type":"article","categories":["Kotlin"],"features":["highlightjs"],"description":"","filename":"","lang":"EN","enclosure":null},{"title":"Kotlin & Android: A Brass Tacks Experiment, Part 5","url":"https://medium.com/@CodingDoug/kotlin-android-a-brass-tacks-experiment-part-5-bd79eb9c85d4#.tyblv8pv8","body":"\n![Header Picture](https://cdn-images-1.medium.com/max/800/1*UN-S8ELMC2kpHf4tJKfbLQ.png)\n\n*Disclaimer: I am a Google employee, but the views expressed in this article are not those of my employer.*\n\n## Kotlin & Android: A Brass Tacks Experiment, Part 5\n\nWell, we’ve made it to part 5 in an ongoing weekly blog about my experiences using the Kotlin® language to do useful things for Android development. If you’ve landed here randomly or unexpectedly, perhaps you’d like to jump to one of the prior parts first and catch up to where we are now?\n\n[Part 1](https://medium.com/p/kotlin-android-a-brass-tacks-experiment-part-1-3e5028491bcc) (setup) | [Part 2](https://medium.com/p/kotlin-android-a-brass-tacks-experiment-part-2-c67661cfdf5f) (code starts here) | [Part 3](https://medium.com/p/kotlin-android-a-brass-tacks-experiment-part-3-84e65d567a37) | [Part 4](https://medium.com/p/kotlin-android-a-brass-tacks-experiment-part-4-4b7b501fa457)\n\nAt this point, we have a pretty good way of expressing the creation of an Android view hierarchy with fewer keystrokes than the equivalent XML resource, and *far* fewer than the equivalent written purely in the Java® language. Its syntax is declarative, the nesting of views is obvious, and we know how to use Kotlin *extension functions* to add convenient utility functions as needed.\n\nBut we left things last time with an awkward situation while trying to set a view’s left padding. Here’s what it looks like currently to set padding. Note that we have to call setPadding() with its four arguments instead of assigning to a *synthetic property* that’s derived from JavaBeans-style getters and setters:\n\n```kotlin\nv<TextView> {\n    layoutParams = LayoutParams(WRAP_CONTENT, WRAP_CONTENT)\n    setPadding(dp_i(16), 0, 0, 0)  // bleh - it's not consistent\n    text = \"Hello\"\n}\n```\n\nTo be consistent in this view builder code, we would rather specify the left padding directly by assignment instead of calling a method with four parameters. At first blush, you might consider using another extension function to attach an extension method called “setLeftPadding(int)” to the View class. You could do this, but then you wouldn’t actually be able to refer to it as “leftPadding = dp_i(16)” in the *lambda with receiver*. It turns out that member functions that look like JavaBeans-style accessors that are *defined in Kotlin* don’t get automatically converted into synthetic properties like member methods *defined in Java classes*. Bummer... but not really!\n\nInstead, Kotlin also allows you to define *extension properties*, which allow a syntax that looks just like the synthetic properties for Java class methods that we’ve been using so far. An extension property is grafted onto an existing class just like a Kotlin extension method so you can access them on instances of that class, assuming the extension property is imported into your code.\n\nSo what we can do is define extension properties to set padding values in a way that’s consistent with the other synthetic properties of view. I’ll just show a single property here for left padding; the others follow suit:\n\n```kotlin\nvar View.padLeft: Int\n    // Specify the setter behavior; value is the assigned Int\n    set(value) {\n        // Use View.setPadding to set left padding value,\n        // uses Kotlin synthetic properties for the others\n        setPadding(value, paddingTop, paddingRight, paddingBottom)\n    }\n    // Specify the getter behavior\n    get() {\n        return paddingLeft\n    }\n```\n\nUsing this “padLeft” extension property, our earlier TextView creation can now be written like this:\n\n```kotlin\nv<TextView> {\n    layoutParams = LayoutParams(WRAP_CONTENT, WRAP_CONTENT)\n    padLeft = dp_i(16)  // ahhh - much better!\n    text = \"Hello\"\n}\n```\n\nConsistency in assignment for all the properties. Excellent!\n\nThere’s a few things to note about the padLeft extension property:\n\n* It uses a syntax similar to the “class dot function” notation for extension functions, but now it’s “class dot property”.\n* The property type is given after the colon.\n* It’s declared using “var”, which is Kotlin’s way of saying a variable or property is *mutable*. This means we can assign values directly to it. (On the other hand, “val” properties are *immutable* and can only be read.)\n* An extension property that’s mutable requires us to provide both a getter and setter implementation. (Likewise, an immutable property requires only a getter).\n\nThe implementation of the padLeft *setter* is defined in terms the existing setPadding() method of View. It takes the value provided from the right hand side of the assignment expression and uses that as the first parameter to setPadding(), along with the values of synthetic properties for the other existing padding values of the TextView. Below the setter, the implementation of the padLeft *getter* is simply defined using the View’s existing “paddingLeft” synthetic property.\n\nSide note: I find it somewhat ironic that Android’s View class provides JavaBeans-style *getters* for each directional padding metric but *not setters*. Oh well, we fixed it with extension properties!\n\nIf you ever need more from a class API that you don’t control, just add what you want with Kotlin’s extension functions and properties. \uD83D\uDE03\n\n## Any other Kotlin tricks to share?\n\nThere a couple more simple tricks that can be used to tighten up the syntax even more. One trick allows you to get rid of all references to “v” in your view builder expressions, and another will make it easier to specify complicated layout parameters. So check in next time to see how these work!\n\nAs usual, you can follow me [here on Medium](https://medium.com/@CodingDoug) and also [on Twitter as CodingDoug](https://twitter.com/CodingDoug) to get notified of the next part to this series. I hope you’ve found it useful for learning Kotlin language features as well as learning some new things about Android views.\n\n","author":"Doug Stevenson","date":"2016-03-01","type":"article","categories":["Kotlin","Android"],"features":["highlightjs"],"description":"","filename":"","lang":"EN","enclosure":null},{"title":"Kotlin 1.1 is also for Android Developers","url":"https://blog.jetbrains.com/kotlin/2017/04/kotlin-1-1-is-also-for-android-developers/","body":"\n![Antonio Leiva][]\nThis is a guest blog post from [Antonio Leiva][Antonio Leiva 1] — Android engineer, trainer and author of the “Kotlin for Android Developers” book.\n\nWe’re all really excited about the release of Kotlin 1.1. The new features this release includes are extremely useful for Java developers and lead JVM development to a new world of possibilities.\n\nBut these new features, such as [coroutines][], or [type aliases][] (to put a couple of examples), look like science fiction for Android developers.\n\nWe’re still stuck in an ancient Java 6 with little improvements that forces us to develop in ways almost forgotten for most developers in any other platforms.\n\nSo a sane question would be: has the Kotlin team been able to keep compatibility to Java 6 while bringing all these new features alive? And the answer is: of course!\n\n**All the new stuff is still available for Java 6 and, as an extension, for Android developers.** And today, I want to show you some of them, and how they can make your life even easier when developing Android Apps.\n\n## Type aliases: You can make your listener much more readable ##\n\nOf course, type aliases have a lot of different applications. But the first that came to my mind was the ability to make listeners more readable while keeping the use of lambdas.\n\nIf you haven’t heard about [type aliases][type aliases 1] before, they’re basically a way to rename complex types into more readable ones.\n\nFor instance, you could have an `RecyclerViewadapter` which will receive a listener. As you may know, `RecyclerView` doesn’t have a standard way to deal with item clicks, just as `ListView` had, so we have to come out with our own.\n\nLet’s imagine we want a listener that has access to the view. Our adapter class could look like this:\n\n```kotlin\nclass MyAdapter(val items: List<Item>, val listener: (View) -> Unit) : RecyclerView.Adapter<MyAdapter.ViewHolder>() {\n    ...\n}\n```\n\nAnd your `ViewHolder` would probably need to receive that listener too, to assign it to the click listener of the view:\n\n```kotlin\nclass ViewHolder(itemView: View) : RecyclerView.ViewHolder(itemView) {\n    fun bind(item: Item, listener: (View) -> Unit) {\n        itemView.setOnClickListener(listener)\n    }\n}\n```\n\nThis is not a very complicated case, but as you can see, we need to repeat that lambda definition which, out of context, could lead to a difficult read.\n\nBut we can create a type alias that represents a click listener:\n\n`typealias ClickListener = (View) -> Unit`\n\nAnd then use it in every place we need that listener:\n\n`class MyAdapter(val items: List<Item>, val listener: ClickListener)`\n\nor\n\n`fun bind(item: Item, listener: ClickListener) { ... }`\n\n## Data classes are now more powerful ##\n\nData classes are great because the avoid a huge amount of boilerplate. But they were lacking some powers, which made them unusable in some cases.\n\nOne of the new inclusions in Kotlin 1.1 is inheritance: data classes can now inherit other classes.\nThis allows data classes to be part of sealed classes:\n\n```kotlin\nsealed class UiOp {\n    object Show : UiOp()\n    object Hide : UiOp()\n    data class Translate(val axis: Axis, val amount: Int): UiOp()\n}\n```\n\nAnd now, **as sealed classes can be defined out of the parent class**, this could also be like this:\n\n```kotlin\nsealed class UiOp\nobject Show : UiOp()\nobject Hide : UiOp()\ndata class Translate(val axis: Axis, val amount: Int)\n```\n\n## Destructuring inside lambdas ##\n\nData classes could be destructured since the first version thanks to the `componentX()` methods they generate. You could assign the content of a data class into several variables like this:\n\n```kotlin\ndata class Item(val text: String, val url: String)\n\nval (text, url) = item\n```\n\nBut a really powerful feature was missing: being able to do this on lambdas. But the wait is over! You could now do something like this:\n\n```kotlin\nfun bind(item: Item) = item.let { (text, url) ->\n    textView.text = text\n    imageView.loadUrl(url)\n}\n```\n\nThis is also really helpful for pairs or key/value sets in a map, for instance.\n\n## Local delegated properties ##\n\nDelegated properties have proven to be really useful to give extra abilities to the properties in our classes.\n\nFor instance, one of the most useful ones is the **lazy delegation**, which defers the execution of the assignment until the property is used for the first time.\n\nBut lazy would also be really helpful too on variables, and Kotlin was lacking this feature.\n\nNow, with local delegated properties, we can do it:\n\n```kotlin\nfun testLocalDelegation() {\n    val database by lazy { createDatabase() }\n    val cache by lazy { createMemoryCache() }\n\n    if (mustUseDatabase()) {\n        database.use { ... }\n    } else {\n        cache.use { ... }\n    }\n}\n```\n\nThough this example could be resolved without using lazy delegation, it helps understand the concept.\n\nWe have a couple of heavy objects that may or may not be used. By using lazy, we can delay the instantiation until we are sure we are going to use it.\n\nThe first time is used, the code inside the braces is executed, and it will be cached in case it’s used again later.\n\n## Forget about declaring unused variables on lambdas anymore ##\n\nIt was very common having to declare variables for arguments in lambdas that in the end weren’t used anywhere.\n\nThis was because in Kotlin 1.0 we didn’t have a way to discard unused parameters.\n\nAs an example, in this article where I explained how to update a RecyclerView adapter using delegation, I ended up with this code:\n\n```kotlin\nvar items: List<Content> by Delegates.observable(emptyList()) {\n    prop, old, new ->\n    autoNotify(old, new) { o, n -> o.id == n.id }\n}\n```\n\nThe prop was never used but, until now, it was necessary to declare it. You can avoid it now by using an underscore:\n\n```kotlin\nvar items: List<Content> by Delegates.observable(emptyList()) {\n    _, old, new ->\n    autoNotify(old, new) { o, n -> o.id == n.id }\n}\n```\n\nBut it was even worse the case where you didn’t use any of them. If you have more than one arguments for a lambda, you need to write them all even though you don’t use them.\n\nNow we can ignore them:\n\n```kotlin\nvar items: List<Item> by Delegates.observable(emptyList()) {\n    _, _, _ ->\n    notifyDataSetChanged()\n}\n```\n\nIt’s not only that you are defining less variables, but also that the code becomes more readable. Now you don’t need to detect whether those arguments are used or not. It’s crystal clear.\n\n## Coroutines ##\n\nCoroutines are the most exciting news in Kotlin 1.1. Though finally left as “experimental” in this release, **they are fully functional and you can start using them on your projects as of today**.\n\nCoroutines will let you write asynchronous code in a synchronous way, allowing to suspend the execution at some point and wait for a result, all while writing sequential code.\n\nOne thing you may already know about coroutines in Kotlin is that they are not a library or a specific implementation, **but a language feature that allows creating libraries over it**.\n\nSo, though the resulting code may look similar, it’s important to know what’s the “gear” that is creating those secondary threads and returning to the main thread, which is quite important in Android.\n\nLuckily, the Kotlin community moves fast and there are already **several libraries that bring the power of coroutines to Android**. Here you have some examples:\n\nThe first ones you may want to take a look are the official ones provided by Jetbrains:\n\n *  [kotlinx-coroutines-android][], which provides a coroutines implementation ready to be used on Android.\n *  [Anko][], which in its latest beta it’s including coroutines support to many framework listeners.\n\nBut there are also many other third-party libraries implementing their own versions of the coroutines:\n\nI urge you not only to use them, but also to check how they are implemented. That’s the magic of open source.\n\n## Some other cool things for Android Devs ##\n\nThere are many more improvements on this release, but I wanted to highlight some that are more focused to Android development.\n\nThe first one of them is that now you can enable the support with the Jack compiler by using: `jackOptions { true }`. Google has announced they are deprecating Jack toolchain, but if you were using it for Java 8, this may be helpful for you until the final version of Android Studio 2.4 is released.\n\nAlso, there’s **a new intention that will use** `@JvmOverloads` **to implement the constructors of a custom view**, which literally allows to implement custom view constructors in one line (well, one really long line) by using one constructor and default values for arguments:\n\n```kotlin\nclass CustomView @JvmOverloads constructor(\n        context: Context, attrs: AttributeSet? = null, defStyleAttr: Int = 0\n) : View(context, attrs, defStyleAttr) {\n    ...\n}\n```\n\n## Conclusion ##\n\nKotlin 1.1 has brought a good bunch of new awesome features that make the question of why we still use Java even more inevitable.\n\nThe power that Kotlin brings to Android developers is out of question, and you can start writing your Android apps in Kotlin from today.\n\nAnd if you want to learn Kotlin for Android from scratch while developing an App, **you might find [Kotlin for Android Developers][] book of your interest**.\n\n[Antonio Leiva]: https://avatars2.githubusercontent.com/u/2178243?v=3&s=460\n[Antonio Leiva 1]: https://antonioleiva.com/\n[coroutines]: https://github.com/Kotlin/kotlin-coroutines/blob/master/kotlin-coroutines-informal.md\n[type aliases]: https://github.com/Kotlin/KEEP/blob/master/proposals/type-aliases.md\n[type aliases 1]: https://github.com/Kotlin/KEEP/issues/4\n[kotlinx-coroutines-android]: https://github.com/Kotlin/kotlinx.coroutines/tree/master/ui/kotlinx-coroutines-android\n[Anko]: https://github.com/Kotlin/anko\n[Kotlin for Android Developers]: https://antonioleiva.com/kotlin-android-developers-book/\n","author":"Roman Belov","date":"2017-04-05","type":"article","categories":["Kotlin"],"features":["highlightjs"],"description":"","filename":"","lang":"EN","enclosure":null},{"title":"Meet the Kotlin Team at Gradle Summit","url":"https://blog.jetbrains.com/kotlin/2016/06/meet-the-kotlin-team-at-gradle-summit/","body":"\nYou’ve probably heard the news announcing that you’ll soon be able to [write your Gradle build scripts and plugins in Kotlin](https://blog.jetbrains.com/kotlin/2016/05/gradle-meets-kotlin/). At the Kotlin Night in San Francisco, Hans Dockter from Gradle demoed the first prototype of the support. After the initial announcement, we’ve continued our work together with the Gradle team to flesh out the prototype and bring it closer to the release. And next week, at the [Gradle Summit in Palo Alto](https://gradlesummit.com/), we’ll be sharing the details on our progress.\n\nIn addition to presentations by Gradle developers and users, you’ll see [the keynote by Dmitry Jemerov from the Kotlin team](https://gradlesummit.com/schedule/kotlin), talking about the DSL support features of Kotlin and their use in the Gradle build script DSL. And in the expo area, you’ll be able to chat with developers working on Kotlin, IntelliJ IDEA and TeamCity, who will help you with any questions related to the use of Gradle together with JetBrains products.\n\nThe summit will be on June 23-24th in Palo Alto, California, and [the registration is open](https://info.gradlesummit.com/conference/palo_alto/2016/06/register). Looking forward to seeing you there!\n\n","author":"Dmitry Jemerov","date":"2016-06-13","type":"article","categories":["Kotlin","Gradle"],"features":["highlightjs"],"description":"","filename":"","lang":"EN","enclosure":null},{"title":"Spring Boot and Kotlin, a match made in Heaven","url":"https://www.youtube.com/watch?v=","body":"\nDespite being very new, spring boot has seen a spectacular start as an amazing kickstarter for spring-based application. You can now start your project in a matter of minutes, not days!\n\nOn the other hand, you're still using Java, with all its ceremony regarding code... Wouldn't it be great if we could pair Spring Boot with a powerful yet simple language?\n\nIn this talk, I'll live code a Spring Boot application using Kotlin, the friendly language provided by JetBrains. Come discover how you can now cut through all the red tape and finally focus only the important stuff.\n\n<iframe width=\"960\" height=\"480\" src=\"https://www.youtube.com/embed/sEm_95BPPiA\" frameborder=\"0\" allowfullscreen></iframe>\n\n","author":"Nicolas Frankel","date":"2016-10-23","type":"video","categories":["Kotlin"],"features":["highlightjs"],"description":"","filename":"","lang":"EN","enclosure":null},{"title":"Using the Kotlin Language with Apache Spark","url":"http://tomstechnicalblog.blogspot.com.by/2016/11/using-kotlin-language-with-spark.html","body":"\nAbout a month ago I [posted an article](http://tomstechnicalblog.blogspot.com/2016/10/kotlin-for-data-science.html) proposing [Kotlin](http://kotlinlang.org/) as another programming language for data science. It is a pragmatic, readable language created by [JetBrains](https://www.jetbrains.com/), the creator of [Intellij IDEA](https://www.jetbrains.com/idea/) and [PyCharm](https://www.jetbrains.com/pycharm/). It has received growing popularity on Android and focuses on industrial use rather than experimental functionality. Just like Java and Scala, Kotlin compiles to bytecode and runs on the Java Virtual Machine. It also works with Java libraries out-of-the-box with no hiccups, and in this article I’m going to show how to use it with [Apache Spark](https://spark.apache.org/).  \n\nOfficially, you can use Apache Spark with [Scala](http://www.scala-lang.org/), [Java](https://java.com/en/), [Python](https://spark.apache.org/docs/0.9.0/python-programming-guide.html), and [R](https://spark.apache.org/docs/latest/sparkr.html). If you are happy using any of these languages with Spark, you likely will not need Kotlin. But if you tried to learn Scala or Java and found it was not for you, you might want to give Kotlin a look. It is a legitimate fifth option that works out-of-the-box with Spark.  \n\nI recommend using [Intellij IDEA](https://www.jetbrains.com/idea/) as it natively includes Kotlin support. It is an excellent IDE that you can also use with Java and Scala. I also recommend using [Gradle](https://gradle.org/) for your build automation.  \n\n> Kotlin is replacing Groovy as the official scripting language for Gradle builds. You can read more about it in the article _[Kotlin Meets Gradle](https://blog.gradle.org/kotlin-meets-gradle)_.\n\n## Setting Up\n\nTo get started, make sure to install the following:  \n\n*   [Java JDK](http://www.oracle.com/technetwork/java/javase/downloads/index.html) - Java JDK\n*   [Intellij IDEA](https://www.jetbrains.com/idea/) - IDE for Java, Kotlin, Scala, and other JVM projects\n*   [Gradle](https://gradle.org/gradle-download/) - Build automation system, download _Binary Only distribtion_ and unzip it to a location of your choice\n\nYou will need to configure Intellij IDEA to use your Gradle location. Launch Intellij IDEA and set this up in _Settings -> Build, Execution, and Deployment -> Gradle_. If you have trouble there should be plenty of walkthroughs online.  \n\nLet’s create our Kotlin project. Using your operating system, create a folder with the following structure:  \n\n```kotlin\nkotlin_spark_project\n   |\n   └────src\n         |\n         └────main\n               |\n               └────kotlin\n```\n\nYour project folder needs to have a folder structure inside of it containing `/src/main/kotlin/`. This is important so Gradle will recognize this as a Kotlin project.  \nNext, create a text file named `build.gradle` and use a text editor to put in the following contents. This is the script that will configure your project as a Kotlin project. You can read more about Kotlin Gradle configurations [here](https://kotlinlang.org/docs/reference/using-gradle.html).  \n\n```gradle\nbuildscript {\n    ext.kotlin_version = '1.0.5'\n    repositories {\n        mavenCentral()\n    }\n    dependencies {\n        classpath \"org.jetbrains.kotlin:kotlin-gradle-plugin:$kotlin_version\"\n    }\n}\n\napply plugin: \"kotlin\"\n\nrepositories {\n    mavenCentral()\n}\n\ndependencies {\n    compile \"org.jetbrains.kotlin:kotlin-stdlib:$kotlin_version\"\n\n    //Apache Spark\n    compile 'org.apache.spark:spark-core_2.10:1.6.1'\n}\n\n```\n\nFinally, launch Intellij IDEA and click _Import Project_ and navigate to the location of your Kotlin project folder you just created. In the wizard, check _Import project from external model_ with the _Gradle_ option. Click _Next_, then select _Use Local Gradle Distribution_ with the Gradle copy you downloaded. Then click _Finish_.  \n\nYour workspace should now be set up with a Kotlin project as shown below. If you do not see the project explorer on the left press ALT + 1. Then double-click on the project folder and navigate down to the `kotlin` folder.  \n\n![](https://i.imgur.com/YzcYoLW.png)  \n\nRight click the `kotlin` folder and select _New -> Kotlin File/Class_.  \n\n![](https://i.imgur.com/ocw0WNx.png)  \n\nName the file “SparkApp” and press _OK_. You will now see a `SparkApp.kt` file added to your `kotlin` folder. An editor will open on the right.  \n\n## Using Spark with Kotlin\n\nLet’s put our Spark usage in the `SparkApp.kt` file. Spark was written with Scala. While Kotlin does not work directly with Scala, it does have 100% interoperability with Java. Thankfully, `Spark` has a Java API by providing a `JavaSparkContext`. We can leverage this to use Spark out-of-the-box with Kotlin.  \nCreate a `main()` function below which will be the entry point for our Kotlin application. Be sure to import the needed Spark dependencies as well. In your `main()` function, configure your `SparkConf` and create a new `JavaSparkContext` off of it.  \n\n```kotlin\nimport org.apache.spark.SparkConf\nimport org.apache.spark.api.java.JavaSparkContext\n\nfun main(args: Array<String>) {\n\n    val conf = SparkConf()\n            .setMaster(\"local\")\n            .setAppName(\"Kotlin Spark Test\")\n\n    val sc = JavaSparkContext(conf)\n}\n```\n\nThe `JavaSparkContext` provides a Java API to create Spark streams. Thankfully, we can use the excellent [Kotlin lambda syntax](https://kotlinlang.org/docs/reference/lambdas.html#lambda-expression-syntax) which the Kotlin compiler will translate into the needed Java functional types.  \nLet’s turn a `List` of Strings containing alphanumeric text values separated by `/` characters. Let’s break these alphanumeric values up, filter only for numbers, and then find their sum.  \n\n```kotlin\nimport org.apache.spark.SparkConf\nimport org.apache.spark.api.java.JavaSparkContext\nimport kotlin.reflect.KClass\n\nfun main(args: Array<String>) {\n\n    val conf = SparkConf()\n            .setMaster(\"local\")\n            .setAppName(\"Kotlin Spark Test\")\n\n    val sc = JavaSparkContext(conf)\n\n    val items = listOf(\"123/643/7563/2134/ALPHA\", \"2343/6356/BETA/2342/12\", \"23423/656/343\")\n\n    val input = sc.parallelize(items)\n\n    val sumOfNumbers = input.flatMap { it.split(\"/\") }\n            .filter { it.matches(Regex(\"[0-9]+\")) }\n            .map { it.toInt() }\n            .reduce {total,next -> total + next }\n\n    println(sumOfNumbers)\n}\n```\n\nIf you click the Kotlin logo right next to your `main()` function in the gutter, you can run this Spark application.  \n\n![](https://i.imgur.com/TSlEJT2.png)  \n\nA console should pop up below and start logging Spark’s events. I did not turn off logging so it will be a bit noisy. But ultimately you should see the value of `sumOfNumbers` printed.  \n\n![](https://i.imgur.com/nqhIM7u.png)  \n\n## Conclusion\n\nI will show a few more examples in the coming weeks on how to use Kotlin with Spark (you can also check out my [GitHub project](https://github.com/thomasnield/kotlin-spark-test)). Kotlin is a pragmatic, readable language that I believe has potential for adoption in Spark. It just needs more documentation for this purpose. But If you want to learn more about Kotlin, you can read the [Kotlin Reference](https://kotlinlang.org/docs/reference/) as well as check out [a few books](https://www.manning.com/books/kotlin-in-action) that are out there. I heard great things about the [O’Reilly video series on Kotlin](http://shop.oreilly.com/product/0636920052982.do) which I understand is helpful for folks who do not have knowledge on Java, Scala, or other JVM languages.  \n\nIf you learn Kotlin you can likely translate existing books and documentation on Spark into Kotlin usage. I’ll do my best to share my discoveries and any nuances I may encounter. For now, I do recommend giving it a look if you are not satisfied with your current languages.\n\n","author":"Thomas Nield","date":"2016-11-30","type":"article","categories":["Kotlin"],"features":["highlightjs"],"description":"","filename":"","lang":"EN","enclosure":null},{"title":"Kotlin Night in San Francisco Recordings","url":"https://blog.jetbrains.com/kotlin/2016/06/kotlin-night-recordings/","body":"\nOn May 17th we held an evening event at San Francisco in cooperation with Realm and Netflix. Thanks to everyone who joined us this evening! There were great talks and important announcements, and the good news is that all of them were recorded:\n\n## Talk #1: Andrey Breslav. **Where We Stand and What’s Next**\n\nKotlin project lead Andrey Breslav gave an overview of what Kotlin is today and took a peek into the near future: what the Kotlin team is planning for the next release.\n\n<iframe src=\"https://www.youtube.com/embed/POZmfjRHdfE\" allowfullscreen=\"\" frameborder=\"0\" height=\"480\" width=\"960\"></iframe>\n\n<iframe webkitallowfullscreen=\"true\" mozallowfullscreen=\"true\" allowfullscreen=\"true\" src=\"//speakerdeck.com/player/f1dea41f659a4c70a6e8fb20291b871b?\" style=\"border: 0px none; background: transparent none repeat scroll 0% 0%; margin: 0px; padding: 0px; border-radius: 5px; width: 960px; height: 480px;\" class=\"speakerdeck-iframe\" frameborder=\"0\"></iframe>\n\n## Bonus Talk by Hans Dockter. **Gradle goes Kotlin**\n\nHans Dockter, CEO of Gradle demoed the first milestone of writing a Gradle build script using Kotlin.\n\n<iframe src=\"https://www.youtube.com/embed/4gmanjWNZ8E\" allowfullscreen=\"\" frameborder=\"0\" height=\"480\" width=\"960\"></iframe>\n\n## Talk #2: Jake Wharton. **Instrumentation Testing Robots**\n\nLibraries like Espresso allow UI tests to have stable interactions with your app, but without discipline these tests can become hard to manage and require frequent updating. In this talk Jake covered how the so-called robot pattern allows you to create stable, readable, and maintainable tests with the aid of Kotlin’s language features.\n\nSee the full recording along with transcribing on [realm.io](https://realm.io/news/kau-jake-wharton-testing-robots/)\n\n## Talk #3: Laura Kogler & Rob Fletcher. **Kotlin Testing**\n\nSpek framework contributor Laura and Spock maintainer Rob demonstrated the current state of Kotlin testing frameworks and discussed expected further advancements in testing support.\n\nPart1:\n\n<iframe src=\"https://www.youtube.com/embed/pCg3P7AOtHo\" allowfullscreen=\"\" frameborder=\"0\" height=\"480\" width=\"960\"></iframe>\n\n<iframe webkitallowfullscreen=\"true\" mozallowfullscreen=\"true\" allowfullscreen=\"true\" src=\"//speakerdeck.com/player/4bfe84ca3f6f45979f2bd1d67fb2d12b?\" style=\"border: 0px none; background: transparent none repeat scroll 0% 0%; margin: 0px; padding: 0px; border-radius: 5px; width: 960px; height: 480px;\" class=\"speakerdeck-iframe\" frameborder=\"0\"></iframe>\n\nPart2:\n\n<iframe src=\"https://www.youtube.com/embed/y5U8uiI2S0I\" allowfullscreen=\"\" frameborder=\"0\" height=\"480\" width=\"960\"></iframe>\n\n<iframe src=\"//www.slideshare.net/slideshow/embed_code/key/9ZqOCfx8zmnOXZ\" marginwidth=\"0\" marginheight=\"0\" scrolling=\"no\" style=\"border:1px solid #CCC; border-width:1px; margin-bottom:5px; max-width: 100%;\" allowfullscreen=\"\" frameborder=\"0\" height=\"480\" width=\"960\"></iframe>\n\nThanks all participants and speakers for great atmosphere and engaging discussions. Here are several photos from the event:\n![Swag](https://i2.wp.com/blog.jetbrains.com/kotlin/files/2016/06/IMG_0109-1.jpg?zoom=1.5&resize=370%2C278&ssl=1)\n![Community](https://i2.wp.com/blog.jetbrains.com/kotlin/files/2016/06/IMG_0114-1.jpg?zoom=1.5&resize=370%2C278&ssl=1)\n![Hans](https://i1.wp.com/blog.jetbrains.com/kotlin/files/2016/06/IMG_0129-1.jpg?zoom=1.5&resize=370%2C278&ssl=1)\n![Kotlin&Gradle](https://i1.wp.com/blog.jetbrains.com/kotlin/files/2016/06/IMG_0150-1.jpg?zoom=1.5&resize=370%2C278&ssl=1)\n\n**See you on next K•NIGHT!**  \n\n","author":"Roman Belov","date":"2016-06-14","type":"article","categories":["Kotlin","K.Night"],"features":["highlightjs"],"description":"","filename":"","lang":"EN","enclosure":null},{"title":"Kotlin 1.0.7 is out","url":"https://blog.jetbrains.com/kotlin/2017/03/kotlin-1-0-7-is-out/","body":"\nWe’re happy to announce that Kotlin 1.0.7, the last update in the Kotlin 1.0.x series, is out. The main focus of this update is to backport the fixes related to Gradle and annotation processing so that they become available to those who can’t upgrade to version 1.1 at this time. The complete list of fixes is available in the [changelog](https://github.com/JetBrains/kotlin/blob/1.0.7/ChangeLog.md).\n\nTo use the new version in your Maven or Gradle builds, simply change the Kotlin version number in your build scripts. The command-line compiler can be downloaded from the [Github release page](https://github.com/JetBrains/kotlin/releases/tag/v1.0.7).\n\nIn IntelliJ IDEA and Android Studio, we recommend to use the 1.1 version of the plugin, and to switch the language version to 1.0 if you’re using Kotlin 1.0.7 to build your project. If you do want to install the version 1.0.7 of the plugin, you can do so by downloading the version for your IDE from the [Kotlin plugin Web site](https://plugins.jetbrains.com/plugin/6954-kotlin) and using the “Install plugin from disk…” button.\n\nAs usual, if you run into any problems with the new release, you’re welcome to ask for help on the [forums](https://discuss.kotlinlang.org/), on Slack (get an invite [here](http://kotlinslackin.herokuapp.com/)), or to report issues in the [issue tracker](https://youtrack.jetbrains.com/issues/KT).\n\nLet’s Kotlin!\n","author":"Dmitry Jemerov","date":"2017-03-15","type":"article","categories":["Kotlin"],"features":["highlightjs"],"description":"","filename":"","lang":"EN","enclosure":null},{"title":"An in-depth look at Kotlin’s initializers","url":"https://medium.com/keepsafe-engineering/an-in-depth-look-at-kotlins-initializers-a0420fcbf546#.bf7j3he2b","body":"\nYesterday I had a co-worker come to me with an interesting bug in a Kotlin class he was writing. He had a read-only property with an inline initializerlike this:\n\n```kotlin\nclass MyProgressBar(context: Context) : ProgressBar(context) {  \n    val bounds = Rect()</pre>\n\n<pre name=\"dc70\" id=\"dc70\" class=\"graf graf--pre graf-after--pre\">    override fun setProgress(progress: Int) {  \n        super.setProgress(progress)  \n        with(bounds) {  \n            val right = left + ((progress.toFloat() / max) * width)  \n            set(left, top, right.toInt(), bottom)  \n        }  \n    }  \n}\n```\n\nEven though there were no IDE or lint warnings, when he tried to create an instance of that class, it would crash with a _NullPointerException_ when trying to read the _bounds_ property.\n\n“How can a non-null, read-only property with an initializer ever be causing a _NullPointerException_?” you might ask. The answer to that question lies in the order that Kotlin runs constructors and initializers.\n\n### Constructors vs Initializers\n\nOne aspect of class creation in Kotlin that might surprise people coming from other languages is that, when writing a class, there a few places that you can define code that will be executed when you create an instance of the class:\n\n#### Property initializers\n\nWhen you declare a property, you can immediately assign it a value like this:\n\n```kotlin\nval count: Int = 0\n```\n\nYou’ll frequently use constant values as initializers, but you can also call a function or use a property delegate in order to run arbitrary code.\n\n#### **Initializer blocks**\n\nIf you want more complex code, you can also use an initializer block, defined with the _init_ keyword:\n\n```kotlin\ninit {  \n    /* do some setup here */  \n}\n```\n\nYou can define those blocks anywhere at the top level of a class declaration, and they will be executed as part of class construction. You can even define more than one initializer block if you want, and they will all be executed.\n\n#### Constructors\n\nKotlin also has [constructors](https://kotlinlang.org/docs/reference/classes.html#constructors), which can be defined in the class header or in the body of the class definition. You can define multiple secondary constructors, but only one will be called when you create a class instance unless the constructor explicitly calls another one. Constructors can also have default argument values which are evaluated each time the constructor is called. Like property initializers, these can be function calls or other expressions that will run arbitrary code.\n\n### Execution order\n\nAll of those features are great, but it can be easy to overlook how they all interact, especially when inheritance is involved. So what order will code run if you define a class with all of them?\n\nFirst, default constructor arguments are evaluated, starting with argument to the constructor you call directly, followed by arguments to any delegated constructors. Next, initializers (property initializers and _init_ blocks) are executed in the order that they are defined in the class, top-to-bottom. Finally, constructors are executed, starting with the primary constructor and moving outward through delegated constructors until the constructor that you called is executed. The constructor order is probably the most surprising, since no matter where in the class the constructor is defined, it is always executed after _all_ initializers have run.\n\nThat’s a lot of rules, so let’s create an small program to help us visualize all of this:\n\n```kotlin\nopen class Parent {\n    private val a = println(\"Parent.a\")\n\n    constructor(arg: Unit=println(\"Parent primary constructor default argument\")) {\n        println(\"Parent primary constructor\")\n    }\n\n    init {\n        println(\"Parent.init\")\n    }\n\n    private val b = println(\"Parent.b\")\n}\n\nclass Child : Parent {\n    val a = println(\"Child.a\")\n\n    init {\n        println(\"Child.init 1\")\n    }\n\n    constructor(arg: Unit=println(\"Child primary constructor default argument\")) : super() {\n        println(\"Child primary constructor\")\n    }\n\n    val b = println(\"Child.b\")\n\n    constructor(arg: Int, arg2:Unit= println(\"Child secondary constructor default argument\")): this() {\n        println(\"Child secondary constructor\")\n    }\n\n    init {\n        println(\"Child.init 2\")\n    }\n}\n```\n\nIf we construct an instance of _Child_ by calling its secondary constructor with _Child(1)_, what will be printed to the console?\n\nHere’s the output:\n\n```kotlin\nChild secondary constructor default argument  \nChild primary constructor default argument  \nParent primary constructor default argument  \nParent.a  \nParent.init  \nParent.b  \nParent primary constructor  \nChild.a  \nChild.init 1  \nChild.b  \nChild.init 2  \nChild primary constructor  \nChild secondary constructor\n```\nn\nAs you can see, initializers are run top to bottom at the beginning of a class’ primary constructor. If you call a secondary constructor, the constructor that gets delegated to will be run before the secondary constructor. And most importantly, superclasses will be fully constructed before any subclass constructors will be run.\n\n### Conclusion\n\nThe crash I talked about at the beginning of the article was due to the fact that the parent constructor was calling a method that was overridden in the child class. That overridden method tried to access a property it had defined with an initializer. But since subclass initializers don’t run until the superclass constructor finishes, the property hadn’t been initialized yet.\n\nSo there you have it: Kotlin’s execution order for constructors and initializers is straight forward, but there are a lot of pieces that come in to play. Since it’s not documented very explicitly, it’s easy to get tripped up.\n\n","author":"AJ Alt","date":"2016-09-23","type":"article","categories":["Kotlin"],"features":["highlightjs"],"description":"","filename":"","lang":"EN","enclosure":null},{"title":"Why I don't want to use Kotlin for Android Development yet","url":"http://artemzin.com/blog/why-i-dont-want-to-use-kotlin-for-android-development-yet/","body":"\nEven though Kotlin is better than Java in many points it still has significant (in my opinion) drawbacks.\n\n> Please treat it as personal opinion & comment if you have solutions for problems listed below.\n\n###### 1) Slow compilation\n\nSmall project (~100 classes in total, mostly in Kotlin) takes ~1 minute to assemble. This is simply unacceptable. [https://youtrack.jetbrains.com/issue/KT-6246](https://youtrack.jetbrains.com/issue/KT-6246)\n\n###### 2) Performance of Kotlin plugin for IDEA\n\nSyntax analysis and highlighting of Kotlin in IDEA (Android Studio) pretty often freezes development machine during typing, unacceptable.\n\n###### 3) Problems with annotation processing\n\nSometimes it gives random errors and you have to do `clean`. Almost every day I see complaints about that on different resources. I'm not alone.\n\n###### 4) Mocking Kotlin classes with Mockito is painful\n\nAlmost everything is `final` in Kotlin by default: classes, methods, etc. And I really like it because it forces immutability -> less bugs. But at the same time, it makes mocking via `Mockito` (which is kind of gold standard in JVM world) painful and goes contrary with language design.\n\nYes, PowerMock is possible solution, but it interferes with tools like Robolectric and generally it was always a good rule that you should not mock final classes and final method.\n\nI understand that in Java we have that problem of everything non-final by design, but at the same time **I don't want to change code just for testing.**\n\n###### 5) No static analyzers for Kotlin yet\n\nYes, `kotlinc` adds more safety to the code than `javac`, but if you want to achieve good performance of the compiler you don't want to turn it into static analyzer.\n\nStatic code analysis is good for CI, but probably you don't want to run it every time you click on `run` button in IDE during local development.\n\nJava has: FindBugs, PMD, Checkstyle, Sonarqube, Error Prone, FB infer.\n\nKotlin has: `kotlinc`.\n\n> Points above were objective, I hope. Points below are more subjective and personal.\n\n###### 6) `==` does `equals()` instead of reference comparison\n\nIf Kotlin is \"better\" Java or \"Java on steroids\" then it should be _better_, but not _breaking_.\n\nImagine you're in the process of rewriting Java project to Kotlin, you will have Java and Kotlin code at the same time.\n\nYou'll have to read and write _same_ code that works differently from language to language. This is one of the reasons why I don't like Groovy.\n\n###### 7) In bad hands operators overloading may lead to bad results\n\nStatement 1: you will need to deal with old codebase written in Kotlin in future.\nStatement 2: you can add operators overloading to **existing** java classes via extension functions.\n\nNow imagine you see something like `val person3 = person1 + person2` in already written code you need to deal with.\n\nEvery project you'll work on may have its own meaning of operators for same classes \uD83D\uDE3F\n\nOperators overloading is controversial, these links may help you decide (not all of them end with same conclusion):\n\n* [Operator Overloading Considered Harmful](http://cafe.elharo.com/programming/operator-overloading-considered-harmful/)\n* [Operator Overloading Ad Absurdum](http://james-iry.blogspot.ru/2009/03/operator-overloading-ad-absurdum.html)\n* [Why Everyone Hates Operator Overloading](http://blog.jooq.org/2014/02/10/why-everyone-hates-operator-overloading/)\n\n***\n\n[@artem_zin](https://twitter.com/artem_zin)\n\n","author":"Artem Zinnatullin","date":"2016-03-11","type":"article","categories":["Android","Kotlin"],"features":["highlightjs"],"description":"","filename":"","lang":"EN","enclosure":null},{"title":"Kotlin Month Post 4: Properties","url":"https://programmingideaswithjake.wordpress.com/2016/03/19/kotlin-month-post-4-properties/","body":"\n## **Intro**\n\nIn this, the fourth and final post in the Kotlin Month series, we take a look at a widely overarching feature of Kotlin that is tightly coupled with a few other features: Properties. Besides the obvious benefits of properties that they provide in all languages, Kotlin has reusable properties via Delegated Properties as well as really clean syntax for distinguishing between read-only and full properties.\n\n## **`var` and `val` and Type Inference**\n\nKotlin makes it very easy to create clean, expressive properties. `var` and `val` make it so we don’t have to _remember_ to mark our fields as `final`. Depending on circumstances, the type might be able to be omitted as well.\n\n### **More Concise Than Most Other Property Syntaxes**\n\nKotlin’s properties are supremely concise in comparison to any other syntax that I’ve seen. Here’s why:\n\n* In Kotlin, we never need to declare the backing fields for a property, although we can use a backing _property_ for more complicated implementations when needed. If you ever need access to the backing field in the getter and setter methods, you simply refer to it as `field`.\n* In Kotlin, unless we’re actually defining an alternative implementation of `get` and `set`, we don’t need to type them; `var` and `val` are used to determine whether it’s read-only or read-write.\n* If the property is being initialized directly from the primary constructor without checks or changes, it can simply be declared in the parameter list of the primary constructor. See the [official documentation on Kotlin’s constructors](https://kotlinlang.org/docs/reference/classes.html#constructors) for more information.\n* As mentioned earlier, we don’t even need to specify the type for the property if we’re assigning a value to it right away (this only applies to properties declared in the body of the class, as opposed to those declared in the primary constructor).\n* [Delegated properties](https://kotlinlang.org/docs/reference/delegated-properties.html). If we end up using the same code for multiple properties’ getters and setters, we can extract that code into a delegated property, which is just a class that defines the `getValue(...)` operator function and, optionally, the `setValue(...)`] operator function. These work a lot like descriptors in Python, except there’s one per instance, rather than one per class. To use them, we use our normal in-body property definition, followed by `by` and an instance of the delegated property class. Some built-in delegated property types in Kotlin include `lazy`, which allows us to lazily instantiate the value in the property; `observable`, which makes the property observable; and using `Map`s via some extension functions.\n\n### **The Not-So-Great Parts**\n\nThere are some not-so-great things about properties in Kotlin, though. The first of which is the fact that the class definition line can become unhelpfully long. This is because this one line contains `class`, the name of the class, any type parameters (generics), the primary constructor argument list, and any inheritance. Now, even when these are simple, the line can easily clear 80 characters if there are more than two properties in the constructor, especially if there’s some inheritance. It’s gets even longer if a visibility modifier needs to be applied to anything; to the class, to the constructor (which not only requires the visibility modifier, but also the `constructor` keyword to show that the modifier is applying to that), or to the properties – which are already longer than typical parameters because of the `val` or `var` keyword. Luckily, Kotlin has forgone the `extends` and `implements` keywords in favor of `:`. If we still used those keywords, those lines would be unbearably long.\n\nBreaking up the class definition line into multiple lines helps, but it’s always a little awkward to have the inheritance stuff near the end. I’d kind of like to have it right after the class name and type parameters if we want. Oh well.\n\nThe other problem comes from the fact that there can potentially be two different places to define properties: in the primary constructor or in the class body. This can make it more difficult to find properties sometimes. I think a convention needs to be put out there that states that, if you have any (public?) properties that are defined in the class body, all properties should be defined there. It ends up with more typing (but still less than Java or C#, since you can set a property equal to a parameter in the primary constructor), but clarifies the code by having only one place to look for properties. None in the constructor? They must all be in the body, then. This also keeps private properties from lengthening the class definition line with the visibility modifier.\n\n## **Kotlin Month Summary**\n\nWe’ve looked at a lot of my favorite features of Kotlin, but there’s so much more to see, so if you’re not familiar with Kotlin, check out their documentation. It’s great, and is able to stay short by letting you assume that anything else they haven’t explained is just like in Java. I’ve read through the whole thing a couple times, actually; it’s really well written;\n\nIf there were only 4 things I could take from Kotlin and put into Java, they would be, in order of “importance”:\n\n1.  Extension Methods\n2.  First-Class Delegation\n3.  Properties\n4.  Simple Primary Constructor (It would probably be done a bit differently than in Kotlin, just to work better with Java’s existing syntax and to hopefully avoid the really long class declaration line)\n\n## **Outro**\n\nSo, this is the end of this post as well as the Kotlin Month! series. But this definitely isn’t the end of me praising Kotlin. In fact, I’ve submitted an abstract to do a talk on Kotlin at [That Conference](https://www.thatconference.com/). It’s a talk that does an introduction to Kotlin before (unless I decide to do it _while_) showing the steps involved in migrating Java code to Kotlin.\n\nFor those too lazy to click the link, That Conference is a dev conference from August 8 – 10 in Wisconsin Dells (a bit south of central Wisconsin). At an indoor themepark/waterpark. How cool is that. I hope to meet some of you guys there!\n\n","author":"Jacob Zimmerman","date":"2016-03-19","type":"article","categories":["Kotlin"],"features":["highlightjs"],"description":"","filename":"","lang":"EN","enclosure":null},{"title":"Kotlin, dragging java into the modern world","url":"http://optimalbi.com/blog/2016/05/20/kotlin-dragging-java-into-the-modern-world/","body":"\n![kotlin_800x320](http://35gd0g2fpmpc2rmy8u1ld360.wpengine.netdna-cdn.com/wp-content/uploads/2016/05/kotlin_800x320.png)\n\nEven though we love our coffee here at OptimalBI, we have never had a place in our hearts for Java. Even so Java has a lot to offer for the modern cloud-driven world, but writing good, maintainable and human readable code has never been part of a Java developers life.\nThis is where [Kotlin ](https://kotlinlang.org/) comes into things. Kotlin is a statically typed language that runs on the JVM (Java Virtual Machine) which is designed to write better and safer Java-like applications that also have a certain level of human readability.\n\n## Why do we need Java anyway?\n\nAt OptimalBI we do stuff in the cloud. This means that we have a large toolbox we can reach into to help us with a bunch of different tasks. As you might have seen from [Optimal Spyglass](https://github.com/OptimalBI/optimal-spyglass-open-source) Java was one of the tools we have used to create a reliable cross-platform GUI, using the always helpful AWS SDK. Java was chosen here so that support for all platforms could be offered easily without maintaining multiple versions[![Campagnolo_Tool_Kit_Super_Record_Wooden_Box_Nr._16](http://35gd0g2fpmpc2rmy8u1ld360.wpengine.netdna-cdn.com/wp-content/uploads/2016/05/Campagnolo_Tool_Kit_Super_Record_Wooden_Box_Nr._16-300x225.jpg)](http://35gd0g2fpmpc2rmy8u1ld360.wpengine.netdna-cdn.com/wp-content/uploads/2016/05/Campagnolo_Tool_Kit_Super_Record_Wooden_Box_Nr._16.jpg) of the same application. The issue here is that most of the code in Optimal Spyglass tend towards making Java’s life easier to run rather than developer’s lives easier to add features.\nBeing in the cloud sometimes means that we have a need for long-running jobs; Monitoring system health, SQL execution systems, etc. There is a strange Java shaped hole in our toolbox for these types of jobs, but despite fitting in the toolbox, Java never fitted in our hearts. We just never felt like battling the language to do what we wanted it to do. So up until recently we have jammed Python or NodeJS into the Java shaped hole and hoped that they would be quiet and help us out until we have a better fitting solution.\n\n## What about the other traditional big chunky languages?\n\n![Prog-languages](http://35gd0g2fpmpc2rmy8u1ld360.wpengine.netdna-cdn.com/wp-content/uploads/2016/05/Prog-languages-300x125.png)\n\nJava is not the only language that can run long jobs without creaking, but all of these languages have some drawbacks, big or small.\n\n**C#** is one of our favorite languages; it talks well to SQL Server, is has one of the easiest to read syntax for your traditional developer types, it compiles to a proper executable, it has a proper GC, it is easy to make services that run on windows, it has the best desktop/mobile GUI system ... and much more. All of that aside, C# has one big problem, Windows. When you run in the cloud you want your OS to quietly get on with managing the system and stay out of the way of your nicely performance tweaked code. Windows likes to poke his head in the door a little too much and then charges you license fees for the privilege. We like our code to run on Linux and C# doesn’t [(yet... reliably...)](https://dotnet.github.io/).\n\n**C++** makes it too hard to produce a good system in the time-frames we have available to us. When you always have in the back of your mind that if you have a bad day in the office you could accidentally fill 64 GB of RAM with an array of Integers that you forgot to clear, it’s really hard to make good code quickly. Or at least for your average non-superhero based programmer. (Where is C++ man when I need him?)\n\n[**Node.js**](https://nodejs.org) was the industry favorite child recently, but the JavaScript world is full of terrible code that no one _wants_ to pay to maintain. That being said with a proper development team Node.js is a very powerful tool. ([TypeScript](https://www.typescriptlang.org) anyone?)\n\nThere are many, more than this, but this blog is long as it is\n\nThere are many choices but from a functional point of view, Java still manages to keep its head above the ocean of programming languages.\n\n## So what does this Kotlin thing do for us anyway?\n\n> _“Kotlin is designed to be an industrial-strength object-oriented language, and to be a better language than Java but still be fully interoperable with Java code, allowing companies to make a gradual migration from Java to Kotlin.”_ – Andrey Breslav, Development Lead for Kotlin.\n\nKotlin is a statically typed language just like Java, that ends up as Java byte code that then can be run on the JVM. This means the outputs are .jar files as we would expect for a Java application.\n\nOne of Kotlin’s main selling points is that they are 100% interoperable with Java. This means that if you want a JSON serializer for your Kotlin application that you can just grab and run the rather useful Google GSON library and Kotlin will have no issues using it.\n\nAnother thing that Kotlin likes to brag about is its safety or mainly it’s system of avoiding NullPointerExceptions. Types in Kotlin have no ability to hold nulls (unless you ask really really nicely) which mean that there is no chance of accidentally asking for a null to split itself on “,”.\n\nFor us though the main thing Kotlin does is clean up the mess that is working with Java. Take the simple job of writing a line to the terminal for example. System.out.println(“Man this is annoying to do all the time”); becomes println(“Java don’t hurt me, no more!”);. This is easier to type, but also easier to read, makes developers happier. And a happy developer is a good developer.\n\nThere are many examples of why Kotlin helps us with writing modern cloud-based applications with Java level reliability (another blog post someday perhaps), all we know for now is we have found a better fit for that hole in our toolkit. Will it stick around? We will have to wait and see.\n\n##### _Coffee to Code – Tim Gray_\n\n##### _Tim blogs about the sharp end of code and the languages we write in._\n\n","author":"Tim Gray","date":"2016-05-20","type":"article","categories":["Kotlin"],"features":["highlightjs"],"description":"","filename":"","lang":"EN","enclosure":null},{"title":"Building APIs on the JVM Using Kotlin and Spark – Part 1","url":"http://nordicapis.com/building-apis-on-the-jvm-using-kotlin-and-spark-part-1/","body":"\n![Building-APIs-JVM-kotlin-spark-java-nordic-apis-pt-1](http://nordicapis.com/wp-content/uploads/Building-APIs-JVM-kotlin-spark-java-nordic-apis-pt-1.png)\n\nWhen you start a new API project, one of the first questions to answer is what programming language to use. Picking the right one can make all the difference. Some languages help solve certain problems while others inhibit solutions. Even after a language is chosen and tens-of-thousands of lines of code have been written, there is the possibility of reducing complexity by using new languages on the same **runtime**.\n\nIn this two-part blog series, we’ll explain why the **JVM** provides a strong basis on which to run your APIs, and how to simplify their construction using a framework called **Spark** and a new programming language called **Kotlin**. In this first part, we will introduce you to the JVM and how it can execute code written in many programming languages, including Kotlin. We’ll discuss a number of Kotlin’s features and show them in the context of APIs.\n\nIn our [second post](http://nordicapis.com/building-apis-on-the-jvm-using-kotlin-and-spark-part-2/), we explore the Spark framework in detail, and how to complement this toolkit with additional components like Inversion of Control (IoC). During the series, we’ll develop a boilerplate that you can use to **create robust APIs with Kotlin and Spark**. The code can be [found on Github](https://github.com/travisspencer/kotlin-spark-demo/), so refer to it there as you read through the snippets below.\n\nWatch Travis Spencer present on this topic at the Stockholm Java Meetup <iframe src=\"https://www.youtube.com/embed/eDHUabQMRb4\" allowfullscreen=\"allowfullscreen\" height=\"315\" frameborder=\"0\" width=\"560\"></iframe>\n\n## Introducing the JVM\n\nThe **Java Virtual Machine (JVM)** is a runtime that offers a range of language choices. Adoption of Clojure, Groovy, Scala, Jython, and other JVM-based languages are widespread. Aside from the broad range of language choices, another uncommon aspect of the JVM is its openness. You can get an implementation of the JVM not just from Oracle but also from an [expansive list of other providers](https://en.wikipedia.org/wiki/List_of_Java_virtual_machines). Many distributions of Linux come preloaded with [OpenJDK](https://en.wikipedia.org/wiki/OpenJDK), which is the reference implementation of Java, allowing API developers to host their service with very little cost and hassle.\n\nOne of the core tenants of Java is that each new version is **backward compatible** with previous ones. This has caused the Java programming language to evolve more slowly than others like C#, where major changes in the language come with massive upgrade efforts. ![](http://combineoverwiki.net/images/thumb/d/dc/Lambda_logo.svg/365px-Lambda_logo.svg.png)This has improved a lot over the years, and [Java 8](http://www.oracle.com/technetwork/java/javase/overview/java8-2100321.html) has removed a lot of cruft in the language with the introduction of **lambdas**. Regardless of the pace of Java’s evolution, this commitment to backward compatibility has resulted in a **very stable base**.\n\nThe openness and ongoing compatibility of the JVM offers a number of very compelling reason to build APIs on this platform:\n\n* **Return on Investment (ROI)**: Code that continues to run can continue to produce a return on the investment made to write it.\n* **Knowledge remains relevant**: Since old code continues to run, all the knowledge gained to write that code continues to be useful. With new versions of the JVM, you can keep writing old-style code. You don’t have to retrain yourself when the runtime’s vendor upgrades the platform.\n* **Ecosystem**: These factors have caused a very large ecosystem to flourish around the JVM. This system includes massive corporations and some of the biggest open source communities that will work hard to ensure its longevity.\n\nProbably one of the biggest drawbacks of selecting Java to code up your API is that it is _**so**_ verbose. Who would use it if they didn’t have to?! ROI is often enough of a reason for companies to select it even for greenfield work, putting programmers through the pains of its verbosity even with the advent of alternatives like Node.js and [Golang](http://nordicapis.com/writing-microservices-in-go/).\n\nBut what if you had the most sugary syntax you could ever dream of without having to change anything else? What if you could retain your build system, packaging, dependencies, existing code and performance, _and_ get the language you’ve been longing for?\n\n# Enter Kotlin\n\n**![](https://upload.wikimedia.org/wikipedia/en/b/b5/Kotlin-logo.png)Kotlin** is a new programming language from Jetbrains, the makers of some of the best programming tools in the business, including [Intellij IDEA](https://www.jetbrains.com/idea/), an IDE for Java and other languages. As a leader in the Java community, Jetbrains understands the pains of Java and the many benefits of the JVM. Not wanting to throw the baby out with the bathwater, Jetbrains designed Kotlin to run on the JVM to get the best out of that platform.\n\nThey didn’t constrain it to this runtime, however — developers can also compile their Kotlin code into **JavaScript**, allowing it to be used in environments like **Node.js**. To work with untyped and typed environments like these, Kotlin is statically typed by default, but allows developers to define dynamic types as well. This balance provides great power and many opportunities.\n\n## Why Kotlin?\n\n[Mike Hearn](https://twitter.com/OctSkyward) does a spectacular job explaining [why you should consider using Kotlin](https://medium.com/@octskyward/why-kotlin-is-my-next-programming-language-c25c001e26e3). In his article, he lists the following reasons:\n\n* Kotlin compiles to JVM bytecode and JavaScript\n* Kotlin comes from industry, not academia\n* Kotlin is open source and costs nothing to adopt\n* Kotlin programs can use existing Java or JavaScript frameworks\n* The learning curve is very low\n* Kotlin doesn’t require any particular style of programming (OO or functional)\n* Kotlin can be used in Android development in addition to others where Java and JavaScript work\n* There is already excellent IDE support (Intellij and Eclipse)\n* Kotlin is highly suitable for enterprise Java shops\n* It has the strong commercial support of an established software company\n\nRead through [Mike’s article](https://medium.com/@octskyward/why-kotlin-is-my-next-programming-language-c25c001e26e3) for more on the rationale for using Kotlin. Hopefully though, this list is enough to convince you to seriously consider Kotlin for your next API. To see how easy this can be, we’ll explain how to use Kotlin with a [micro-services framework called Spark](http://www.sparkjava.com/). We’ll delve deep into Spark in the next part of this series, but now we’ll explain some of the great Kotlin language features with some [sample code](https://github.com/travisspencer/kotlin-spark-demo/commit/3ebce75345c6a4ac08710578de42bbc7a5a1d297#diff-600376dffeb79835ede4a0b285078036).\n\n# Examples of Kotlin’s Syntax\n\nTo see how Kotlin can be used to [create killer APIs](http://nordicapis.com/top-5-development-tips-for-a-killer-api/), we’ll walk through a sample that demonstrates many of the language’s features in the context of APIs. You can find the [entire code on Github](https://github.com/travisspencer/kotlin-spark-demo/), and it’s all open source.\n\nTo start, here’s the API’s entry point:\n\n```kotlin\nfun main(args: Array) = api(composer = ContainerComposer()) {\n    route(path(\"/login\", to = LoginController::class, renderWith = \"login.vm\"),\n          path(\"/authorize\", to = AuthorizeController::class, renderWith = \"authorize.vm\"),\n          path(\"/token\", to = TokenController::class))\n}\n```\n\nNote that what we have is very readable even with zero knowledge of Kotlin. **This snippet starts an API that exposes various paths that are routed to controllers, some of which are rendered by a template and others that are not.** Easy. Kotlin lends itself to creating fluent APIs like this one, making for very readable code and approachable frameworks.\n\n## Functions and Constructors\n\nTo create our Domain Specific Language ([DSL](https://en.wikipedia.org/wiki/Domain-specific_language)) for hosting APIs, we’re using several of Kotlin’s syntactic novelties and language features. Firstly:\n\n* **Constructors**: In Kotlin, you do not use the `new` keyword to instantiate objects; instead, you use the class name together with parenthesis, as if you were invoking the class as a function (a la Python). In the above snippet, a new `ContainerComposer` object is being created by invoking its [default constructor](http://kotlinlang.org/docs/reference/classes.html#constructors).\n* **Functions**: [Functions](http://kotlinlang.org/docs/reference/functions.html#function-declarations), which begin with the `fun` keyword, can be defined in a class or outside of one (like we did above). This syntax means that we can write Object Oriented (OO) code or not. This will give you more options and potentially remove lots of boilerplate classes.\n* **Single expression functions**: The fluent API allows us to wire up all our routes in a single expression. When a [function consists of a single expression](http://kotlinlang.org/docs/reference/functions.html#single-expression-functions) like this, we can drop the curly braces and specify the body of our function after an equals symbol.\n* **Omitting the return type**: When a function does not return a value (i.e., when it’s “void”), the return type is `Unit`. In Kotlin, [you do not have to specify this](http://kotlinlang.org/docs/reference/functions.html#unit-returning-functions); it’s implied.\n\nIf we weren’t to use these last two features, the slightly more verbose version of our main function would be this:\n\n```kotlin\nfun main(args: Array) : Unit {\n    // ...\n}\n```\n\nThe difference is only a few characters, but the result is less noisy.\n\n## Named Arguments and Passing Function Literals\n\nThe next part of this main method is the call to the `api` function. This function uses a few other interesting features:\n\n* **Named arguments**: When calling the `path` function, we’re [specifying certain arguments by name](http://kotlinlang.org/docs/reference/functions.html#named-arguments) (e.g., `to` and `renderWith`). Doing so makes the code more fluid.\n* **Passing function literals outside the argument list**: When a function, like our `api` function, expects an argument that is itself a function, you can pass it after closing the argument list. This cleans up the code a lot. To see what we mean by this, observe the `api` function definition:\n\n  ```kotlin\n  fun api(composer: Composable, routes: () -> List<Controllable>) {\n      // ...\n  }\n  ```\n\nThis function takes two arguments:\n\n1.  The composer (more on that in the next part of this series)\n2.  The routes as a function that takes no arguments and produces a list\n\nThe second argument is the interesting one. It is a [lambda expression](http://kotlinlang.org/docs/reference/lambdas.html). In Kotlin, **lambdas** are written as `() -> T` where the parentheses contain the possibly-empty list of arguments and their types, an arrow symbol (i.e., `->` or “produces”), and the return type. Our `api` function uses this syntax to define it’s last argument. In Kotlin, when the last argument of a function is also a function, we can pass the lambda expression _outside_ of the call. Without this capability, calling the `api` method would look like this:\n\n```kotlin\napi(ContainerComposer(), {\n    // ...\n})\n```\n\nSee the difference? If you’re a jQuery programmer, you’re probably numb to it. Have a look at this contrived example that shows the difference more clearly:\n\n```kotlin\na({\n    b({\n        c({\n        })\n    })\n})\n```\n\nSee it now? When a method takes a function literal as an argument, you end of with a grotesque interchange of parentheses and braces. Instead, Kotlin allows us to pass the body of the function literal after the method call. JQuery programmers unite! This is your way out of the flip-flopping trap of delimiters you’ve found yourself in! Instead, Kotlin allows you write this sort of oscillation like this:\n\n```kotlin\na() {\n    b() {\n        c()\n    }\n}\n```\n\nSo clear. So easy to understand. This convention is what we’re using in the call to the `api` function. Our routes are defined in a lambda that returns a list of [data objects](http://kotlinlang.org/docs/reference/data-classes.html) (which we’ll explain shortly). The result is [half a dozen lines of code](https://github.com/travisspencer/kotlin-spark-demo/blob/master/src/main/kotlin/com/nordicapis/kotlin_spark_sample/main.kt) that start a Web server which hosts our API, sets up three routes, maps them to controllers, and associates templates to certain endpoints. That’s the powerful triad we mentioned early — **language, runtime, and JVM-based frameworks** — that allow us to quickly start serving up APIs!\n\n## Generics\n\nAs you saw in the definition of the of the `api` function, Kotlin has support for **generics** (i.e., function templates). In Kotlin, generics aren’t confusing like they are in Java. The thing that makes Java’s generics so tricky is [wildcard parameterized types](http://www.angelikalanger.com/GenericsFAQ/FAQSections/ParameterizedTypes.html#WIldcard%20Instantiations). These were needed to ensure backward compatibility with older Java code. Kotlin doesn’t have wildcards, making it much easier to use generics in this new language. In fact, generics are so easy for Java and C# developers that there’s very little to say.\n\nOne aspect of Kotlin’s generics that may be unclear at first is the use of the `out` annotation on some template parameters. This is seen in the definition of the `RouteData` class [included in the sample code](https://github.com/travisspencer/kotlin-spark-demo/commit/3ebce75345c6a4ac08710578de42bbc7a5a1d297#diff-600376dffeb79835ede4a0b285078036):\n\n```kotlin\ndata class RouteData(\n    val path: String,\n    val controllerClass: Class,\n    val template: String? = null)\n```\n\nThis class is parameterized along with the constructor argument; `controllerClass`. Both have this extra modifier on `T` though. What does this mean? It means that the output type `T` will not be passed in as input; instead, the `RouteData` class will only produce objects of type `T` as output. This is what is referred to as [declaration-site variance](http://kotlinlang.org/docs/reference/generics.html#declaration-site-variance). Because the `RouteData` class does not consume any values of type `T` but only produces them as return values, the compiler knows that it is safe for any class that extends `Controllable` to be used as a parameter value, since they can always safely be upcast at runtime to the `Controllable` interface.\n\nIf `T` were not an output-only type, a potentially unsafe downcast would be required at run-time. By providing this extra bit of info to the compiler, we can avoid wildcards (i.e., something like `RouteData<? extends Controllable>` in Java) and end up with safer, more easy-to-use generics.\n\n## Data Classes\n\n[The `data` annotation](http://kotlinlang.org/docs/reference/data-classes.html) is another interesting feature of Kotlin that we’re using in the `RouteData` class. This modifier tells the compiler that objects of this type will only hold data. This allows it to synthesize a bunch of boilerplate code for us. Specifically, the compiler will implement the following methods for us:\n\n* `equals`\n* `hashCode`\n* `toString`\n* `copy`; and\n* Getters and setters for each constructor parameter that is marked with `val` (i.e., read-only variables).\n\nAfter we define a data class we can also use it to [declare and set the values of multiple variables simultaneously](http://kotlinlang.org/docs/reference/data-classes.html#data-classes-and-multi-declarations) like this:\n\n```kotlin\nval (path, controllerClass, template) = routeData\n```\n\nGiven a data object of type `RouteData`, we can sort of pull it apart into constituent parts, where each property of the class is assigned to respective variables. This can help you write self-documenting code, and can also be used to return more than one value from a function.\n\n### Multiple Return Values from Functions\n\nOne attractive language feature of [Golang](http://nordicapis.com/writing-microservices-in-go/) is its syntax that allows developers to define multiple return values for a function. In Go, you can write very descriptive code like this:\n\n```kotlin\nfunc (file *File) Write(b []byte) (n int, err error) {\n    // ...\n}\n```\n\nThis says that the function `Write` returns two values: an integer called `n` and `err`, an `error` object. This unique language construct obviates the need to pass references to objects that the function will modify when an additional return value is also needed. This is what one has to do in Java, which you can see in a [Java-based version of our `Controllable` type](https://github.com/travisspencer/stockholm-java-meetup-java-spark-demo/blob/master/src/main/java/java_meetup_spark_demo/Example08/Controllable.java):\n\n```kotlin\ninterface Controllable {\n    default boolean get(Request request, Response response,\n        final Map<String, Object> model) { return true; }\n\n    default boolean post(Request request, Response response,\n        final Map<String, Object> model) { return true; }\n\n    default boolean put(Request request, Response response,\n        final Map<String, Object> model) { return true; }\n\n// ...\n}\n```\n\nWe want to return two things from `get`, `post`, `put`, etc. — a Boolean flag that will be used to abort routing if `false`, and the model that contains the template values (if templating is used by the view). Here the Java language is actually working against us, forcing us to write unclear code. Google Go would help us write this more clearly, and so does Kotlin.\n\nIn Kotlin, our `Controllable` type is defined like this:\n\n```kotlin\nabstract class Controllable {\n    public open fun get(request: Request, response: Response):\n        ControllerResult = ControllerResult()\n\n    public open fun post(request: Request, response: Response):\n        ControllerResult = ControllerResult()\n\n    public open fun put(request: Request, response: Response):\n        ControllerResult = ControllerResult()\n\n    // ...\n}\n```\n\nKotlin allows us to say that our controller’s methods return a `ControllerResult` type. Like `RouteData` described above, `ControllerResult` is a data class:\n\n```kotlin\ndata class ControllerResult(\n        val continueProcessing: Boolean = true,\n        val model: Map<String, Any> = emptyMap())\n```\n\nWith this one line, we can easily define a result type that we can use in the `Router` to control the flow of processing requests and provide views with model data.\n\nBig deal, you may say. Create a class in Java and do the same. Sure. With Java though, our `ControllerResult` class becomes 50 annoying lines of code after we implement `equals`, `toString`, `hashCode`, a copy constructor, getters, and setters. As we described above, data classes include all these in **one line of code**. Take that in like a cool refreshing drink after a long day’s work in the hot summer sun!\n\nUsing data classes, our controllers can override methods in the `Controllable` class like this:\n\n```kotlin\npublic override fun get(request: Request, response: Response): ControllerResult =\n    ControllerResult(model = mapOf(\n        \"user\" to request.session(false).attribute(\"username\"),\n        \"data\" to mapOf(\n                \"e1\" to \"e1 value\",\n                \"e2\" to \"e2 value\",\n                \"e3\" to \"e3 value\")))\n```\n\nUsing the `to` keyword and a read-only map produced by the standard Kotlin library’s `mapOf` function, we end up with a very succinct yet readable implementation of this method. Refer to the Kotlin docs for more info about [creating maps with the `to` keyword](http://kotlinlang.org/docs/reference/idioms.html#read-only-map), [the `mapOf` function](http://kotlinlang.org/api/latest/jvm/stdlib/kotlin/map-of.html), and [overriding methods defined in a base class](http://kotlinlang.org/docs/reference/classes.html#overriding-members). For now though, let’s see how we can use the `ControllerResult` objects in a safe and intuitive manner using one of the coolest Kotlin language features.\n\n## Smart Casts\n\nAs we’ll discuss more in the next part of this blog series, the methods of our Controllers are invoked dynamically depending on the HTTP method used by the client. This is done in [the `Router` class](https://github.com/travisspencer/kotlin-spark-demo/blob/master/src/main/kotlin/com/nordicapis/kotlin_spark_sample/Router.kt) like this:\n\n```kotlin\nval httpMethod = request.requestMethod().toLowerCase()\nval method = controllerClass.getMethod(httpMethod, javaClass(), javaClass())\nval result = method.invoke(controller, request, response)\n\nif (result is ControllerResult && result.continueProcessing) {\n   controller.after(request, response)\n\n   model = result.model\n}\n```\n\nIn the first three lines, we are using reflection to invoke a method on the controller that has the same name as the HTTP method specified by our API consumer. `Invoke` is defined in the Java runtime to return an `Object` which Kotlin represents as `Any`. This is helpful because two of our `Controllable`’s methods, `before` and `after`, do not return `ControllerResult` objects while the bulk of them do. Using [Kotlin’s smart casting language feature](http://kotlinlang.org/docs/reference/typecasts.html#smart-casts), we can write **very clear and safe code** to handle this discrepancy.\n\nIn the snippet above, we check at run time to see if the `Any` object is of type `ControllerResult`. This is done using [Kotlin’s is operator](http://kotlinlang.org/docs/reference/typecasts.html#smart-casts) in the if statement. If it is, we also check to see if the data object’s `continueProcessing` property returns `true`. We do this _without_ casting it. On the right side of the logical `&&` operator, Kotlin treats the `result` object not as type `Any` but as type `ControllerResult`. Without having to write code to perform the cast, we can access the object’s `ContinueProcessing` property. Without smart casting and without properties, we’d have to write this conditional statement verbosely in Java like this:\n\n```java\nif (result instanceof ControllerResult) {\n    ControllerResult controllerResult = (ControllerResult)result;\n\n    if (controllerResult.getContinueProcessing()) {\n        // ...\n    }\n}\n```\n\nEven with C#’s `as` operator, we end up with code that isn’t as clear as Kotlin’s. In C#, we’d have to write this:\n\n```kotlin\nControllerResult controllerResult = result as ControllerResult\n\nif (controllerResult != null && controllerResult.continueProcessing) {\n    // ...\n}\n```\n\nKotlin lets us avoid all this confusing, verbose code. This will ensure that our intent is more clear, and help us find and fix bugs in our APIs more quickly.\n\n[![Java Meetup Medium CTA-01](http://nordicapis.com/wp-content/uploads/Java-Meetup-Medium-CTA-01.png)](http://www.meetup.com/Stockholm-Java-User-Group/events/224295980/)\n\n# Using Kotlin\n\nBecause of its interoperability with other tools in the Java ecosystem, it is very easy to start using Kotlin. You can leverage all of the same tools and knowledge that you are using today in your Java development. Building with Ant or Maven? Those work with Kotlin. Writing code in Intellij IDEA, Eclipse, or Sublime? Keep using them!\n\nTo get started using your favorite tools with Kotlin, here’s some helpful links:\n\n* [Intellij IDEA](http://kotlinlang.org/docs/tutorials/getting-started.html)\n* [Kotlin Sublime Text 2 Package](https://github.com/vkostyukov/kotlin-sublime-package)\n* [Eclipse](http://kotlinlang.org/docs/tutorials/getting-started-eclipse.html)\n* [Maven usage guide](http://kotlinlang.org/docs/reference/using-maven.html)\n* [Using Gradle with Kotlin](http://kotlinlang.org/docs/reference/using-gradle.html)\n* [Ant integration](http://kotlinlang.org/docs/reference/using-ant.html)\n\n## Converting Existing Code\n\nWhen you start using Kotlin, it can help to convert an existing Java project to this new language. Then, you can see how familiar code looks using Kotlin. To convert existing code, you have to use [Intellij](http://kotlinlang.org/docs/tutorials/getting-started.html), [Eclipse](http://kotlinlang.org/docs/tutorials/getting-started-eclipse.html), or (if you only have a snippet) the [Kotlin on-line console](http://try.kotlinlang.org/). In the end, you will probably rewrite a lot of the converted code to use more idioms and Kotlinic styles, but converting existing code is a great starting point.\n\n## Compiling Kotlin\n\nWhether you convert your code or write it from scratch, you are going to need to compile it. The IDE plug-ins make this easy while you’re working. In order to use this language in larger projects, however, you are going to need to automate those builds. This will require integration with Maven, Ant, or Gradle. Jetbrains and the Kotlin community provides these out of the box, and usage is as you would expect. For an existing Java-based project using one of these, switching to Kotlin can be done by replacing just a few lines in your build script. For instance, the sample project accompanying this series was converted to compile Kotlin code instead of Java [with just a few dozen lines](https://github.com/travisspencer/kotlin-spark-demo/commit/3ebce75345c6a4ac08710578de42bbc7a5a1d297#diff-600376dffeb79835ede4a0b285078036).\n\n## Debugging\n\nCompiling code isn’t necessarily working code. To make your software functional, you can use one of the many JVM-based logging frameworks to print out debug statements. You can see this in the sample project that uses SLF4J and Log4j to print statements about API requests and responses. Here’s an indicative sample from the `AuthorizationController`:\n\n```kotlin\npublic class AuthorizeController : Controllable() {\n    private val _logger = LoggerFactory.getLogger(javaClass())\n\n    public override fun before(request: Request, response: Response): Boolean {\n        _logger.trace(\"before on Authorize controller invoked\")\n\n        if (request.session(false) == null) {\n            _logger.debug(\"No session exists. Redirecting to login\")\n\n            response.redirect(\"/login\")\n\n            // Return false to abort any further processing\n            return false\n        }\n\n        _logger.debug(\"Session exists\")\n\n        return true\n    }\n\n    // ...\n}\n```\n\nA few things to note about that snippet before we move on:\n\n* It’s normal SLF4J stuff, so there’s no learning curve for Java devs.\n* The SLF4J `LoggerFactory` requires a static class to initialize it. This is a Java class, so we use Kotlin’s `::class` syntax to get [a `KClass` object](http://kotlinlang.org/api/latest/jvm/stdlib/kotlin.reflect/-k-class/) and then call its `java` extension property. Voila! Java interop :)\n\nBasic instrumentation will only take you so far; sometimes you need to roll up your sleeves and dive into the running code though. You can do this _easily_ in Intellij and Eclipse using those tools’ debuggers just as you would with your Java code. In these environments, you have all the same tools you have come to rely on when debugging other JVM-based code. For instance, the **call stack**, list of **running threads**, **expression evaluation**, and of course **breakpoints**, are all available to you! Here’s a screenshot of the above code running in Intellij with the debugger attached:\n\n![debugging](http://nordicapis.com/wp-content/uploads/debugging.png)\n\nFinding bugs will be <del>easy</del> _easier_ with that. This is a _very_ compelling example of why Kotlin is a better choice for creating large-scale APIs than some other languages (e.g., Go). ([Golang can be debugged using GDB](http://golang.org/doc/gdb), but that tool is not nearly as user-friendly as Intellij’s and Eclipse’s debuggers.)\n\n# Conclusion\n\nUnlike other programming environments, the JVM gives you both language and vendor choices that can help you create incredible API. On the JVM you can choose between **dynamic** languages like Groovy, **functional** ones like Scala and Clojure, and now another rival — [Kotlin](http://kotlinlang.org/). We talked through a number of reasons to use this language, and showed some of the features this new JVM upstart delivers.\n\nAll this is great, you may be saying, but what’s the catch? There are [some drawbacks](https://medium.com/@octskyward/why-kotlin-is-my-next-programming-language-c25c001e26e3#5cef), but they are minor. The strongest argument against Kotlin is its immaturity — it isn’t at v1 yet. This is a problem that will inevitably be fixed with a bit more time. Even now at milestone 12, the compiler gives you warnings about the use of deprecated language features that will not be included in the initial release. This makes it easy to pivot and prepare.\n\n[![battlehack](http://nordicapis.com/wp-content/uploads/battlehack.png)](https://2015.battlehack.org/stockholm)In [part 2](http://nordicapis.com/building-apis-on-the-jvm-using-kotlin-and-spark-part-2/) of this series, we delve deeper into [Spark](http://www.sparkjava.com/) and explain it more using the [sample Kotlin code](https://github.com/travisspencer/kotlin-spark-demo/) we started developing in this post. In the meantime, be sure to [register for our upcoming event in Stockholm](http://www.meetup.com/Stockholm-Java-User-Group/events/224295980/) where we’ll be discussing Kotlin, Clojure, Groovy, and building APIs on the JVM. Learning more about Kotlin could also give you the edge you’ll need if you plan to participate in PayPal’s upcoming hackathon, [BattleHack](https://2015.battlehack.org/stockholm), which is happening on November 14th and 15th in Stockholm.\n\nContinue to Part 2: [Building APIs on the JVM Using Kotlin and Spark – Part 2](http://nordicapis.com/building-apis-on-the-jvm-using-kotlin-and-spark-part-2/)\n\n## Kotlin Resources\n\nIf you aren’t going to be in Stockholm this month for the meetup, you can also learn more about this new language from these resources:\n\n* [Kotlin language reference](http://kotlinlang.org/docs/reference/) (start here)\n* [Kotlin programming language cheat sheet](https://gist.github.com/dodyg/5823184)\n* [Designing DSLs in Kotlin](http://blog.jetbrains.com/kotlin/2011/10/dsls-in-kotlin-part-1-whats-in-the-toolbox-builders/)\n* [RE: Why Kotlin is my next programming language – SubReddit discussion](https://www.reddit.com/r/programming/comments/3chgp3/why_kotlin_is_my_next_programming_language/?submit_url=https%3A%2F%2Fmedium.com%2F%40octskyward%2Fwhy-kotlin-is-my-next-programming-language-c25c001e26e3&already_submitted=true&submit_title=%22Why+Kotlin+is+my+next+programming+language%22+by+Mike+Hearn)\n* [Sample Web API project using Kotlin and Spark](https://github.com/travisspencer/kotlin-spark-demo/commit/3ebce75345c6a4ac08710578de42bbc7a5a1d297#diff-600376dffeb79835ede4a0b285078036)\n* [Getting the most from the JVM using Java, Clojure, Kotlin & Groovy meetup in Stockholm](http://www.meetup.com/Stockholm-Java-User-Group/events/224295980/)\n* [Building APIs on the JVM Using Kotlin and Spark – Part 2](http://nordicapis.com/building-apis-on-the-jvm-using-kotlin-and-spark-part-2/)\n\n_[Disclosure: PayPal is a sponsor of the Java Stockholm meetup being produced by Nordic APIs]_\n\n\n\n\n","author":"Travis Spencer","date":"2015-08-06","type":"article","categories":["Kotlin"],"features":["highlightjs"],"description":"","filename":"","lang":"EN","enclosure":null},{"title":"Setting animation scale for Android UI tests","url":"http://www.thedroidsonroids.com/blog/setting-animation-scale-for-android-ui-tests/","body":"","author":"Karol Wrótniak","date":"2016-12-11","type":"article","categories":["Kotlin","Android"],"features":["highlightjs"],"description":"","filename":"","lang":"EN","enclosure":null},{"title":"Experimental: Kotlin and mutation testing","url":"https://blog.frankel.ch/experimental-kotlin-mutation-testing","body":"\n[![](https://blog.frankel.ch/wp-content/resources/experimental-kotlin-mutation-testing/icon_Kotlin.png)](https://kotlinlang.org/)Since about a year and a half, I do a [lot](https://player.vimeo.com/video/105758362) [of](https://youtu.be/uC_8l69ArXs) [presentations](https://youtu.be/biLyXaJwO3c) on [Mutation Testing](https://en.wikipedia.org/wiki/Mutation_testing). In those, my point is to show that [Code Coverage](https://en.wikipedia.org/wiki/Code_coverage)‘s only benefit is that it’s easy to compute but that it’s meaningless – hence Mutation Testing.\n\nSince some time, I’ve been interested in [Kotlin](http://kotlinlang.org), a language from JetBrains that runs on the JVM. It’s only natural that I wanted to check how Mutation Testing could be applied to the Kotlin language. As Kotlin is too young to have its own dedicated mutation testing tool, I used [Pit](http://pitest.org), a Java dedicated tool. I didn’t expected much, here are my findings.\n\nI started with a [Kotlin-port](https://github.com/nfrankel/mutationtesting-kotlin) of my demo project. It has two simple classes and an associated test for each. In the first one, assertion is missing and in the second, the boundary condition of the < operator is not tested. This is the perfect use-case for Mutation Testing. It’s a Maven project, so the command is quite straightforward:\n\n```bash\nmvn org.pitest:pitest-maven:mutationCoverage\n```\n\nInterestingly enough, this works perfectly well, in terms of mutation coverage execution, but also regarding referencing the lines that are the source of the problem.\n\n![](https://blog.frankel.ch/wp-content/resources/experimental-kotlin-mutation-testing/duplicatemath.png)\n![](https://blog.frankel.ch/wp-content/resources/experimental-kotlin-mutation-testing/lowpredicate.png)\n\nI wanted to go further, to use a _real_ project. The Kotlin folks were kind enough to redirect me to [KTor](https://github.com/Kotlin/ktor), a Kotlin-based web framework. I tried the same command, but limited on a single module – ktor-features/ktor-server-sessions (I have no clue what it does, that is not relevant anyway). Aye, there’s the rub.\n\nFirst, Pit cannot correctly parse the generated bytecode at some places:\n\n```\nPIT >> WARNING : Found more than one mutation similar on same line in a finally block. Can't correct for inlining.\n```\n\nWorse, there are a lot of timeout errors. Since there’s some threading involved, that’s not really a blocker.\n\n```\nPIT >> WARNING : Slave exited abnormally due to TIMED_OUT\n```\n\nFor this project, reports are really long, but some errors are really similar to what you’d expect from Java code, for example:\n\n```\nremoved call to kotlin/jvm/internal/Intrinsics::checkParameterIsNotNull → NO_COVERAGE\n```\n\nHere’s a sample of the report:\n\n![](https://blog.frankel.ch/wp-content/resources/experimental-kotlin-mutation-testing/pullablelinkedlist.png)\n\nAgain, Pit is able to bind the real lines to the problems found. Isn’t life good? If you stop at this point, it probably is. But running Pit on another project – say, ktor-features/ktor-locations fails miserably.\n\n```\nThe class org.jetbrains.ktor.locations.Locations$WhenMappings does not contain a source debug information. All classes must be compiled with source and line number debug information\n```\n\nIt seems using the `when` construct in Kotlin generates an inner class that doesn’t contain debug information, which Pit need to works its magic. Let’s exclude the offending class and its inner mappings class:\n\n```\nmvn org.pitest:pitest-maven:mutationCoverage -DexcludedClasses=org.jetbrains.ktor.locations.Locations*\n```\n\nIt works again and produces expected results:\n\n![](https://blog.frankel.ch/wp-content/resources/experimental-kotlin-mutation-testing/conversionservice.png)\n\nThere are no mutation testing tools for Kotlin (yet), and considering Java ecosystem’s history, there might never be one. However, mutation testing is an invaluable tool to assert the real quality of your tests. Even if Pit is not a perfect match for Kotlin, it would be foolish to discard it.\n\n","author":"Nicolas Frankel","date":"2016-04-03","type":"article","categories":["Testing","Mutation Testing","Kotlin"],"features":["highlightjs"],"description":"","filename":"","lang":"EN","enclosure":null},{"title":"Android And Kotlin","url":"https://stxnext.com/blog/android-and-kotlin/","body":"\n\n**Kotlin** – one of the popular programming languages built on top of Java that runs on JVM. Thanks to JetBrains support and excellent IDE integration, it’s an ideal choice for Android development. 100% Java compatibility, interoperability and no runtime overhead is just the beginning of a long list of strengths. Kotlin is supposed to be a subset of SCALA, has clear benefits for developers on one hand and keeps short compile times on the other.\n\nAs a **mobile team** we got interested in Kotlin a few months before its final release which gave us time to test it thoroughly before production use. The language has some clear advantages for an **Android programmer** – it enables migration from Java projects that have been under development for some time already. Java & Kotlin **coexistence** simplifies Kotlin introduction as only new functionality is written in JetBrain’s new language leaving all the legacy code untouched.\n\nTransitioning gives the developer an opportunity to use lambdas, new syntax for data objects, extension functions to easily expand Android SDK’s classes functionality and infix notation to write DSL-like structures. Almost all the libraries you use today will work with Kotlin thanks to 100% Java compatibility. The same is true for Android SDK classes – all of them will seamlessly work with the new programming language. Kotlin gives you more choice when it comes to reflection, creating documentation and being null-pointer safe. Android works great with it out of the box so you won’t need to change your development habits.\n\nOur production project in Kotlin turned out to be a success after 4 months of development. We had **0 bugs related to Kotlin as a programming language**. Our code footprint is almost **30%** smaller thanks to JetBrain’s, we benefit from nullpointer safety, closures, translated enums, data objects and use infix notation for logging and displaying Snackbars.\n\n## Kotlin Developer Starter in Android projects\n\n<iframe src=\"https://www.slideshare.net/slideshow/embed_code/key/2IrMDNtY8cRKrJ\" width=\"427\" height=\"356\" frameborder=\"0\" marginwidth=\"0\" marginheight=\"0\" scrolling=\"no\" style=\"border:1px solid #CCC; border-width:1px; margin-bottom:5px; max-width: 100%;\" allowfullscreen=\"\"></iframe>\n\n**[Kotlin Developer Starter in Android projects](https://www.slideshare.net/BartoszKosarzycki/kotlin-developer-starter-in-android-projects \"Kotlin Developer Starter in Android projects\")** from **[Bartosz Kosarzycki](http://www.slideshare.net/BartoszKosarzycki)**\n\nThis presentation is a Developer Starter – a set of hand-picked information allowing a person with no knowledge of Kotlin to start writing basic Android activities and set up a kotlin-based Android project. It starts with language background, reasons for its creation and advantages. Then presents basic use cases, syntax, structures and patterns. Later on Kotlin is presented in Android context. Simple project structure, imports and Kotlin usage with Android SDK is explained. In the end cost of Kotlin compilation is presented and the language is compared to SCALA and SWIFT.\n\n## Kotlin advanced – language reference for android developers\n\n<iframe src=\"https://www.slideshare.net/slideshow/embed_code/key/fPQ0XeGdMBpMqK\" width=\"427\" height=\"356\" frameborder=\"0\" marginwidth=\"0\" marginheight=\"0\" scrolling=\"no\" style=\"border:1px solid #CCC; border-width:1px; margin-bottom:5px; max-width: 100%;\" allowfullscreen=\"\"></iframe>\n\n**[Kotlin advanced – language reference for android developers](https://www.slideshare.net/BartoszKosarzycki/kotlin-advanced-language-reference-for-android-developers \"Kotlin advanced - language reference for android developers\")** from **[Bartosz Kosarzycki](http://www.slideshare.net/BartoszKosarzycki)**\n\nSecond talk on Kotlin language we had at STXNext. We try go deeper into language specifics and look at the positive impact new syntax can have on boilerplate removal and readability improvement.\n\nKotlin really shines in Android development when one looks at “Enum translation”, “Extension functions”, “SAM conversions”, “Infix notation”, “Closures” and “Fluent interfaces” applied to lists. The talk, however, compares language-specifics of Java & Kotlin in terms of “Type Variance”, “Generics” and “IDE tools” as well.\n\n\n![](https://stxnext.com/wp-content/uploads/2016/03/bartosz-kosarzycki-author.jpg)\n\n### Bartosz Kosarzycki\n\nSenior developer focused on new technologies and particularly interested in mobile development. Has 3 years experience in Android platform. Bartosz enjoys problem solving, is a huge fan of Agile methodologies and functional programming. For some time already is vividly interested in JVM-based languages like Scala & Kotlin.\n\n","author":"Bartosz Kosarzycki","date":"2016-04-07","type":"article","categories":["Android","Kotlin"],"features":["highlightjs"],"description":"","filename":"","lang":"EN","enclosure":null},{"title":"Kotlin 1.0. Задай вопрос команде.","url":"https://habrahabr.ru/company/JetBrains/blog/277573/","body":"\n## Kotlin 1.0. Задай вопрос команде\n\nНа этой неделе случилось важное для нас событие — [вышла первая версия](http://blog.jetbrains.com/kotlin/2016/02/kotlin-1-0-released-pragmatic-language-for-jvm-and-android/) языка программирования [Kotlin](http://kotlinlang.org/)! Так как почти вся разработка Kotlin велась в Питерском офисе компании JetBrains, многие хабровчане уже знают, что такое Kotlin и пробовали его на практике, поэтому этот пост больше для комментариев: задавайте любые вопросы и команда Kotlin ответит. Мы онлайн!\n\n![Kotlin](https://habrastorage.org/getpro/habr/post_images/2f8/f4e/685/2f8f4e6857445ecef579ae6e96e80c60.png)\n\n\nДля тех, кто слышит о Kotlin впервые, а так же для затравки разговора, несколько фактов о Kotlin:\n\n* Kotlin — это “прагматичный” язык для JVM и Android, который мы в JetBrains написали, для того чтобы нам было на чем программировать ;)\n*Kotlin имеет ту же облаcть применимости, что и Javа, и совместим со всеми современными технологиями и инструментами:\n    * [IntelliJ IDEA](http://kotlinlang.org/docs/tutorials/getting-started.html), [Android Studio](http://kotlinlang.org/docs/tutorials/kotlin-android.html), [Eclipse](http://kotlinlang.org/docs/tutorials/getting-started-eclipse.html)\n    * [Maven](http://kotlinlang.org/docs/reference/using-maven.html), [Gradle](http://kotlinlang.org/docs/reference/using-gradle.html), [Ant](http://kotlinlang.org/docs/reference/using-ant.html)\n    * [Spring Boot](https://spring.io/blog/2016/02/15/developing-spring-boot-applications-with-kotlin)\n* Kotlin полностью [совместим с Java](http://kotlinlang.org/docs/reference/java-interop.html). В смешанных проектах код на Kotlin может легко вызывать код на Java и наоборот. Соответственно, все существующие Java-библиотеки доступны из Kotlin.\n* В Kotlin нелегко получить Null Pointer Exception, потому что система типов исключает это.\n* Kotlin позволяет [создавать функции-расширения](http://kotlinlang.org/docs/reference/extensions.html) для существующих классов. Поэтому стандартная библиотека не определяет свои классы коллекций, но предоставляет кучу удобных функций для работы с JDK коллекциями\n* Начиная с версии 1.0 мы гарантируем бинарную совместимость. Так что теперь можно ;)\n* Нас много! За январь Kotlin использовало больше 11 тысяч человек, из них 5 тысяч за последнюю неделю. Почти 2 тысячи человек общаются в нашем Slack-канале и помогают друг другу. Сейчас в команде Kotlin больше двадцати человек. В JetBrains написано около 500К строчек кода на Kotlin, более чем в десяти проектах, а в открытых репозиториях на GitHub (исключая наши) число строчек растет экспоненциально, и на момент релиза их уже больше двух миллионов: ![Kotlin GitHub](https://habrastorage.org/getpro/habr/post_images/75e/087/333/75e087333d725b9f69ec3d009abf17fe.gif)\n* Мы планируем вскоре зарелизить поддержку JavaScript и Java 8\n* У нас есть своя онлайн-песочница: [http://try.kotl.in](http://try.kotl.in/) В ней есть серия задачек [Kotlin Koans](http://try.kotl.in/koans), которые помогают освоиться с языком буквально за несколько часов. Действительно за несколько часов! Также у нас отличная документация на [официальном сайте](http://kotlinlang.org/docs/reference/).\n* Мы открыты! Kotlin [разрабатывается на GitHub](https://github.com/JetBrains/kotlin), под лицензией Apache 2.0. Но самое главное, мы всегда внимательно прислушиваемся ко всему входящему фидбеку, так что теперь слово вам:\n\n","author":"Роман Белов","date":"2016-02-19","type":"article","categories":["JetBrains","Kotlin"],"features":["highlightjs"],"description":"","filename":"","lang":"RU","enclosure":null},{"title":"Kotlin census: call to action","url":"https://blog.jetbrains.com/kotlin/2016/09/kotlin-census-call-to-action/","body":"\nMany times we’re asked by people working with or planning to work with Kotlin, what our adoption rate is and who’s using Kotlin and what for.\n\nWhile we do accept [pull requests](https://github.com/JetBrains/kotlin-web-site/blob/master/_data/companies-using-kotlin.yml) and run into an occasional _tweet_ we would really like to know first-hand from you, whether you’re using Kotlin in production and if so, how, and what issues you have faced. This not only helps us answer the question when someone asks about our adoption, but learn more about our community. With close to 4000 people on our [Kotlin Slack](http://kotlinslackin.herokuapp.com/) alone, it’s hard to keep track of every piece of feedback!\n\nAs such, we’re asking you if you could kindly give us two minutes of your time and fill out the following survey. Please note that by providing us your details, you are not automatically giving us consent to use your name, application or company name. We would ask for written confirmation from you before doing so.\n\nThank you!\n\n### [Fill Out Survey](https://blog.jetbrains.com/kotlin/2016/09/kotlin-census-call-to-action/)\n\n","author":"Roman Belov","date":"2016-09-01","type":"article","categories":["Kotlin"],"features":["highlightjs"],"description":"","filename":"","lang":"EN","enclosure":null},{"title":"Building a Kotlin project 2/2","url":"http://cirorizzo.net/2016/03/04/building-a-kotlin-project-2/","body":"\n###### _Part 2_\n\nIn the previous [post](http://www.cirorizzo.net/building-a-kotlin-project/) we started a new project from scratch, and adjusted the `build.gradle` for the Kitten App purpose.\n\nThe next steps are going to be the programming of the elements of the app.\n\n#### Data Model\n\nOne of the main features of the app is to retrieve data through Internet via the `http://thecatapi.com/`\n\n> _The complete API call will be i.e. `http://thecatapi.com/api/images/get?format=xml&results_per_page=10`_\n\nThe API sends back an `XML` file like this one\n\n![XML-API](http://cirorizzo.net/content/images/2016/03/xxmlAPI.png.pagespeed.ic.CABTBWB1Ch.png)\n\nIt needs to deserialize in order to get the `url` property containing the location of the Kitten image.\n\nKotlin has a very useful class called `data class` that is perfect for the purpose.\n\nLet's starting to create a new class file in the `model.cats` package using right click on it and `New->Kotlin File/Class` and call it `Cats` and choose `Class` as kind.\n\nIn order to structure the class as the `XML` file received the `Cats.kt` will be as the following\n\n```kotlin\ndata class Cats(var data: Data? = null)\n\ndata class Data(var images: ArrayList<Image>? = null)\n\ndata class Image(var url: String? = \"\", var id: String? = \"\", var source_url: String? = \"\")\n```\n\nSo far very simple...\nThe same class in Java is much longer!\n\nThe Kotlin Data Class has several benefits, some of them are that the compiler generates `getter()`, `setter()` and `toString()` methods, and many more like `equals()` `hashCode()` and `copy()`. So it's the perfect class to use to deserialize data\n\n#### API Call\n\nThere are many ways to retrieve data through the network, and different libraries to handle it. One of these libraries is the [Retrofit2](http://square.github.io/retrofit/) library from Square.\nThis is a very powerful `HTTPClient` and easy to set up.\n\nLet's start with the `interface` and create it under the `network` package.\nCall it `CatAPI` as shown\n\n```kotlin\ninterface CatAPI {\n    @GET(\"/api/images/get?format=xml&results_per_page=\" + BuildConfig.MAX_IMAGES_PER_REQUEST)\n    fun getCatImageURLs(): Observable<Cats>\n}\n```\n\nThe `interface` will manage the `Get` request to the API Endpoint `/api/images/get?format=xml&results_per_page=`.\nIn this case the param `results_per_page` retrieve its numerical value from the constant defined in the `build.gradle` called `MAX_IMAGES_PER_REQUEST` that will have different values depending on the `buildTypes` used.\n\n```kotlin\nbuildTypes {\n    debug {\n        buildConfigField(\"int\", \"MAX_IMAGES_PER_REQUEST\", \"10\")\n        ...\n```\n\n> This method is very useful to have different value of constants in case we're using `debug` type or `release` one i.e. _especially in case you need to access to the debug API instead of the production one_\n\nAbout the `interface CatAPI` is very interesting the function called to manage the callback from the API `fun getCatImageURLs(): Observable<Cats>`\n\nSo the next step is its implementation.\nLet's create a new class under the same package (`network`) and call it `CatAPINetwork` as this\n\n```kotlin\nclass CatAPINetwork {\n    fun getExec(): Observable<Cats> {\n        val retrofit = Retrofit.Builder()\n            .baseUrl(\"http://thecatapi.com\")\n            .addConverterFactory(SimpleXmlConverterFactory.create())\n            .addCallAdapterFactory(RxJavaCallAdapterFactory.create())\n            .build()\n\n        val catAPI: CatAPI = retrofit.create(CatAPI::class.java)\n\n        return catAPI.getCatImageURLs().\n            subscribeOn(Schedulers.io()).\n            observeOn(AndroidSchedulers.mainThread())\n    }\n}\n```\n\nThe `fun getExec(): Observable<Cats>` is implicitly `public` so that means available to be called by outside this class.\n\nThe line `.addConverterFactory(SimpleXmlConverterFactory.create())` indicates to use the `XML` converter to deserialize the result form the API call.\n\nThen the `.addCallAdapterFactory(RxJavaCallAdapterFactory.create())` is the call adapter to use on the API Callback\n\nThe `return` lines referring to the `RxJava` `Observable`\n\n```kotlin\nreturn catAPI.getCatImageURLs().\n            subscribeOn(Schedulers.io()).\n            observeOn(AndroidSchedulers.mainThread())\n```\n\n#### Presenter\n\nThe `Presenter` modules are in charge of managing the logic of the app and to bind data between the `View` and the `Model`.\n\nIn our case it will implement the method called by the `View` to retrieve the API data and send them to the `Adapter` in charge to show up.\n\nIn order to communicate with the `View` we're starting to create its `interface` called `MasterPresenter` under the package `presenter` as the followed\n\n```kotlin\ninterface MasterPresenter {\n    fun connect(imagesAdapter: ImagesAdapter)\n    fun getMasterRequest()\n}\n```\nThe first function `fun connect(imagesAdapter: ImagesAdapter)` will be used to connect the `Adapter interface` to show data, and the `fun getMasterRequest()` will be the one to start the API request.\n\nLet's the implementations in a new class under the same `presenter` package and call it `MasterPresenterImpl`\n\n```kotlin\nclass MasterPresenterImpl : MasterPresenter {\n    lateinit private var imagesAdapter: ImagesAdapter\n\n    override fun connect(imagesAdapter: ImagesAdapter) {\n        this.imagesAdapter = imagesAdapter\n    }\n\n    override fun getMasterRequest() {\n        imagesAdapter.setObservable(getObservableMasterRequest(CatAPINetwork()))\n    }\n\n    private fun getObservableMasterRequest(catAPINetwork: CatAPINetwork): Observable<Cats> {\n        return catAPINetwork.getExec()\n    }\n}\n```\n\nInteresting line at `lateinit private var imagesAdapter: ImagesAdapter` where Kotlin give us the chance to declare a Non-Nullable mutable object without initialization thanks to `lateinit` keyword. So it will be initialize at the first time it will be used at runtime; in our case on calling the `fun connect(imagesAdapter: ImagesAdapter)`.\n\nThe function `fun getMasterRequest()` is in charge of starting the API call, just set the `Observable` in order to be subscribed by the `Adapter` (i.e. `imagesAdapter`) after starts the `catAPINetwork.getExec()` that executes the API call\n\n#### View section\n\nIn the `view` package are collected the classes to manage the UI.\nBasically are the `View` and the `Adapter` ones; in our case `MainActivity` and `ImagesAdapter`.\n\n###### Layouts\n\nBefore starting with their implementation, let's go through the `Layout` designing.\n\n![Kitten App](http://cirorizzo.net/content/images/2016/03/xkittenApp-1.png.pagespeed.ic.ulo4yWl6Cg.png) To design it we need basically of two elements the <mark>main container</mark> and the <mark>item container</mark>.\n\nThe <mark>main container</mark> is the element containing the list of the item and we're going to place it in the `activity_main.xml` contained in the `res->layout` folder of the project; this one has been automatically created during the initial phase of [Project Creation](http://www.cirorizzo.net/building-a-kotlin-project/).\n\nFor our app we need to inject in a `RecyclerView` component (a very powerful and optimized component for listing views).\n\nThe `activity_main.xml` will be like shown\n\n```xml\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<RelativeLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    xmlns:tools=\"http://schemas.android.com/tools\"\n    android:layout_width=\"wrap_content\"\n    android:layout_height=\"wrap_content\"\n    tools:context=\".view.MainActivity\"\n    android:gravity=\"center\">\n\n    <android.support.v7.widget.RecyclerView\n        android:id=\"@+id/containerRecyclerView\"\n        android:layout_width=\"wrap_content\"\n        android:layout_height=\"wrap_content\"\n        android:scrollbars=\"vertical\"\n        android:layout_centerInParent=\"true\" />\n</RelativeLayout>\n```\n\nThe component `containerRecyclerView` represents the <mark>main container</mark> of the list of item\n\nThe `row_card_view.xml` is the <mark>item container</mark> of our list and basically it appears like this\n\n```xml\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<android.support.v7.widget.CardView\n    xmlns:card_view=\"http://schemas.android.com/apk/res-auto\"\n    xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    android:id=\"@+id/card_view\"\n    android:layout_gravity=\"center\"\n    android:layout_width=\"wrap_content\"\n    android:layout_height=\"wrap_content\"\n    card_view:cardCornerRadius=\"4dp\"\n    android:layout_margin=\"16dp\"\n    android:background=\"@android:color/transparent\"\n    android:layout_centerInParent=\"true\"\n    android:elevation=\"4dp\">\n\n    <RelativeLayout\n        android:layout_width=\"wrap_content\"\n        android:layout_height=\"wrap_content\"\n        android:layout_centerInParent=\"true\"\n        android:gravity=\"center\"\n        android:foregroundGravity=\"center\">\n\n        <ImageView\n            android:layout_width=\"wrap_content\"\n            android:layout_height=\"wrap_content\"\n            android:id=\"@+id/imgVw_cat\"\n            android:padding=\"4dp\"\n            android:layout_centerInParent=\"true\"\n            android:scaleType=\"fitCenter\"\n            android:contentDescription=\"@string/cat_image\" />\n    </RelativeLayout>\n</android.support.v7.widget.CardView>\n```\n\nAs you can see the item container is the `card_view` that basically is composed by a `RelativeLayout` containing an `ImageView` (`imgVw_cat`)\n\n###### Adapter\n\nNow we've got basic elements of the `Layout`, so let's move on implementing the `MainActivity` and the `Adapter`.\n\nStarting on `Adapter` the first thing to create is its `interface` in order to be invoked by the previous `MasterPresenterImpl` so let's create a new file in the `view` package and called it `ImagesAdapter` and write it down like this\n\n```kotlin\ninterface ImagesAdapter {\n    fun setObservable(observableCats: Observable<Cats>)\n    fun unsubscribe()\n}\n```\n\nThe function `setObservable(observableCats: Observable<Cats>)` is called by `MasterPresenterImpl` to set the `Observable` and give the `Adapter` to subscribe to it.\n\nThe `unsubscribe()` function will be invoked by the `MainActivity` to unsubscribe the `Adapter` from the `Observable` when the activity is destroyed.\n\nNow let's implement them in a new class under the same package called `ImagesAdapterImpl` that appears like that\n\n```kotlin\nclass ImagesAdapterImpl : RecyclerView.Adapter<ImagesAdapterImpl.ImagesURLsDataHolder>(), ImagesAdapter {\n    private val TAG = ImagesAdapterImpl::class.java.simpleName\n\n    private var cats: Cats? = null\n    private val subscriber: Subscriber<Cats> by lazy { getSubscribe() }\n\n    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): ImagesURLsDataHolder {\n        return ImagesURLsDataHolder(\n                LayoutInflater.from(parent.context).inflate(R.layout.row_card_view, parent, false))\n    }\n\n    override fun getItemCount(): Int {\n        return cats?.data?.images?.size ?: 0\n    }\n\n    override fun onBindViewHolder(holder: ImagesURLsDataHolder, position: Int) {\n        holder.bindImages(cats?.data?.images?.get(position)?.url ?: \"\")\n    }\n\n    private fun setData(cats: Cats?) {\n        this.cats = cats\n    }\n\n    override fun setObservable(observableCats: Observable<Cats>) {\n        observableCats.subscribe(subscriber)\n    }\n\n    override fun unsubscribe() {\n        if (!subscriber.isUnsubscribed) {\n            subscriber.unsubscribe()\n        }\n    }\n\n    private fun getSubscribe(): Subscriber<Cats> {\n        return object : Subscriber<Cats>() {\n            override fun onCompleted() {\n                Log.d(TAG, \"onCompleted\")\n                notifyDataSetChanged()\n            }\n\n            override fun onNext(cats: Cats) {\n                Log.d(TAG, \"onNextNew\")\n                setData(cats)\n            }\n\n            override fun onError(e: Throwable) {\n                //TODO : Handle error here\n                Log.d(TAG, \"\" + e.message)\n            }\n        }\n    }\n\n    class ImagesURLsDataHolder(view: View) : RecyclerView.ViewHolder(view) {\n\n        fun bindImages(imgURL: String) {\n            Glide.with(itemView.context).\n                    load(imgURL).\n                    placeholder(R.mipmap.document_image_cancel).\n                    diskCacheStrategy(DiskCacheStrategy.ALL).\n                    centerCrop().\n                    into(itemView.imgVw_cat)\n        }\n    }\n}\n```\n\nThis is the class inflate the `row_card_view.xml`, basically the <mark>item container</mark> as you can see at function `onCreateViewHolder`\n\nThe function `getSubscribe()` provide to subscribe the `Adapter` to the `Observable` used at line `private val subscriber: Subscriber<Cats> by lazy { getSubscribe() }` where you can notice the `lazy` initialization, this is a way to declare an unmutable object (i.e. `subscriber`) and it'll be created through the function enclosed in the braces (i.e. `getSubscribe()`) at the first invocation at runtime.\n\n> _The Subscriber and Observable concepts comes from [RxJava](https://github.com/ReactiveX/RxJava); We can dig deeper in some next posts_\n\nAt the end, a very interesting piece of code is the inner class called `ImagesURLsDataHolder` used to fill up the `imgVw_cat` using the `Glide` library, that helps to retrieve the image from the passed `URL` extracted by the API call. This part is wrapped in the function `bindImages(imgURL: String)` and invoked by the method `onBindViewHolder` in the same file.\n\n###### Activity\n\nLast but not least the the `Activity` (i.e. `MainActivity`)\n\n```kotlin\nclass MainActivity : AppCompatActivity() {\n    private val imagesAdapterImpl: ImagesAdapterImpl by lazy { ImagesAdapterImpl() }\n\n    private val masterPresenterImpl: MasterPresenterImpl\n            by lazy {\n                MasterPresenterImpl()\n            }\n\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        setContentView(R.layout.activity_main)\n\n        initRecyclerView()\n        connectingToMasterPresenter()\n        getURLs()\n    }\n\n    override fun onDestroy() {\n        imagesAdapterImpl.unsubscribe()\n        super.onDestroy()\n    }\n\n    private fun initRecyclerView() {\n        containerRecyclerView.layoutManager = GridLayoutManager(this, 1)\n        containerRecyclerView.adapter = imagesAdapterImpl\n    }\n\n    private fun connectingToMasterPresenter() {\n        masterPresenterImpl.connect(imagesAdapterImpl)\n    }\n\n    private fun getURLs() {\n        masterPresenterImpl.getMasterRequest()\n    }\n}\n```\n\nNotice the functions\n\n* `initRecyclerView()`\n* `connectingToMasterPresenter()`\n* `getURLs()`\n\nRespectively used to\n\n* initialize the <mark>main container</mark> (i.e. `RecyclerView`)\n* connecting the `MainActivity` to the `MasterPresenterImpl` and pass to it the `interface` of the `ImagesAdapterImpl` (aka `Adapter`)\n* `getURLs()` starts the API request to retrieve the `XML` data, and so executing the followed tasks (deserialize data, retrieving images through `Adapter`).\n\nThe Kitten App is now ready to run.\nIn any case you can find the entire project on my Github Repository of the [KShow](https://github.com/cirorizzo/KShows) project.\nThe same project has been written in Java as well [JShows](https://github.com/cirorizzo/JShows) so you can comparing them\n\n###### _Translations_\n\nThis post is also available in Chinese on [gold.xitu.io](https://goo.gl/3YpGoR)\nA special thanks for the translation to the **gold.xitu.io** Team\n\n","author":"Ciro Rizzo","date":"2016-03-04","type":"article","categories":["Android","Kotlin"],"features":["highlightjs"],"description":"","filename":"","lang":"EN","enclosure":null},{"title":"Living (Android) without Kotlin","url":"https://hackernoon.com/living-android-without-kotlin-db7391a2b170#.kme29gfhg","body":"","author":"Piotr Ślesarew","date":"2016-12-21","type":"article","categories":["Kotlin","Android"],"features":["highlightjs"],"description":"","filename":"","lang":"EN","enclosure":null},{"title":"Kotlin recipes for Android (I): OnGlobalLayoutListener","url":"http://antonioleiva.com/kotlin-ongloballayoutlistener/","body":"\n<div class=\"et_post_meta_wrapper\">\n\n# Kotlin recipes for Android (I): OnGlobalLayoutListener\n\n![Kotlin recipes for Android (I): OnGlobalLayoutListener](http://i2.wp.com/antonioleiva.com/wp-content/uploads/2016/03/kotlin_logo_new.png?resize=800%2C320)</div>\n\nToday a mate asked me how he could do an `OnGlobalLayoutListener` properly without incurring in the need of too much boilerplate. This was a tricky question because of a couple of things, let’s see it a little more deeply.\n\n## What is OnGlobalLayoutListener for?\n\nThis listener is available for any view’s `ViewTreeObserver` and it’s quite often used to get a callback when the view is inflated and measured, and we already have a width and height available to do any kind of calculations, animations, etc.\n\nThanks to the awesome Java interoperability that Kotlin provides, we can do this on a very clean way using its simulated properties and lambdas for single-method interfaces:\n\n```kotlin\nrecycler.viewTreeObserver.addOnGlobalLayoutListener {\n    // do whatever\n}\n```\n\nWhat’s the issue here? To prevent leaks, a recommended practice is to remove the listener once you’ve finished using it. But we don’t have a reference to the object because we used a lambda, and a lambda is not exactly the same as an object.\n\nWe could still use the old-fashioned style, but a kitten dies every time we use an anonymous object directly in Kotlin. We are not changing to a nicer language if we still need to do things like this:\n\n```kotlin\nrecycler.viewTreeObserver.addOnGlobalLayoutListener(\n        object : ViewTreeObserver.OnGlobalLayoutListener {\n            override fun onGlobalLayout() {\n                recycler.viewTreeObserver.removeOnGlobalLayoutListener(this);\n                // do whatever\n            }\n        });\n```\n\n## Finding a better alternative\n\nOk, we know we don’t want that. But what can we do to make it better? We are forced to use the not-so-good-looking way, but a good alternative would be to hide this behind an extension function.\n\nWe will then create a new function for views that receives another function and creates and removes the listener by itself. Something like:\n\n```kotlin\ninline fun View.waitForLayout(crossinline f: () -> Unit) = with(viewTreeObserver) {\n    addOnGlobalLayoutListener(object : ViewTreeObserver.OnGlobalLayoutListener {\n        override fun onGlobalLayout() {\n            removeOnGlobalLayoutListener(this)\n            f()\n        }\n    })\n}\n```\n\nYou can now just call the function and be sure that the listener is added and removed by itself. Besides, you’ll never forget about removing it anymore:\n\n```kotlin\nrecycler.waitForLayout {\n    // do whatever\n}\n```\n\nIf you prefer, you could apply the extension function to the `ViewTreeObserver` instead of directly to the `View`. That’s up to you.\n\n## But we can improve it\n\nThis layout listener is usually used to do something after a view is measured, so you typically would need to wait until width and height are greater than 0. And we probably want to do something with the view that called it, so why don’t we **convert the parameter function into an extension function** too?\n\nI also **generified the function** so that it can be used by any object that extends View and also be able to access to all its specific functions and properties from the function we’ll write.\n\n```kotlin\ninline fun <T: View> T.afterMeasured(crossinline f: T.() -> Unit) {\n    viewTreeObserver.addOnGlobalLayoutListener(object : ViewTreeObserver.OnGlobalLayoutListener {\n        override fun onGlobalLayout() {\n            if (measuredWidth > 0 && measuredHeight > 0) {\n                viewTreeObserver.removeOnGlobalLayoutListener(this)\n                f()\n            }\n        }\n    })\n}\n```\n\nThis `afterMeasured` function is very similar to the previous one, but you can use the properties and public methods of the view directly inside the lambda. We can, for instance, get the width of the recycler and set a layout with a dynamic number of columns depending on it.\n\n```kotlin\nrecycler.afterMeasured {\n    val columnCount = width / columnWidth\n    layoutManager = GridLayoutManager(context, columnCount)\n}\n```\n\n## Conclusion\n\nIt’s true that there are still some things that don’t look nice when working with Android, even moving to Kotlin, but we can always find an alternative that improves readability and avoids boilerplate, by hiding this boilerplate behind other structures. At least you’ll have to only write it once and the rest of the code will look awesome!\n\n","author":"Antonio Leiva","date":"2016-03-16","type":"article","categories":["Android","Kotlin"],"features":["highlightjs"],"description":"","filename":"","lang":"EN","enclosure":null},{"title":"Never say final: mocking Kotlin classes in unit tests","url":"https://medium.com/@dpreussler/never-say-final-mocking-kotlin-classes-in-unit-tests-314d275b82b1#.9oldk16f5","body":"\n[Test doubles](http://www.martinfowler.com/bliki/TestDouble.html) are one of the most essential part of unit testing. A test double replaces a class that we need in our test but that is not the focus of our test. We remove that dependency by using a “fake” object. This way our test becomes more robust due to a reduced dependency on other classes. Such a double could be a stub, a dummy or a mock. All of these need the ability to replace an object with something artificial that looks and behaves like the object we need. In Java, the common approach for test doubles is using interfaces: one implementation of the class is the “real” one, and the other one is used for testing.\n\nWriting a lot of unit tests means that all your classes need interfaces. This creates a lot of boilerplate. Therefore it became a common rule for many developers that if you have only one implementation for your interface the interface is useless and can be dropped.\n\nThis rule can easily be applied for testing also. As long as we only test the “public contract” of a class we can still replace this by a double. This can be done via extension and overriding or via a mocking framework like [Mockito](https://github.com/mockito/mockito). Mocking classes not only interfaces became pretty common and are a powerful feature. In other languages, like ObjectiveC, where developers do not focus on interfaces as much as in Java, this is the default approach.\n\n### The Kotlin problem\n\nEverything seemed fine, until [Kotlin](https://kotlinlang.org/) came around, a great modern language. Given how well Kotlin and Java work together, the Android developer community was hooked almost from the beginning.\nBut Kotlin brought a new concept: everything is _final_ by default. The rule: “closed for modifications, open for extension” is baked into the language. Every class is _final_ by default, every method is _final_ by default! Inheritance was widely overused in the last decades and Kotlin tries to make this a bit better.\n\nFrom a testing perspective this is a problem: if you can not extend a class you can not replace it with any kind of double, not even a generated mock:\n\n```kotlin\norg.mockito.exceptions.base.MockitoException:\nCannot mock/spy class com.mypackage.MyKotlinClass\nMockito cannot mock/spy following:\n — final classes\n — anonymous classes\n — primitive types\n```\n\nAnd if the class would not be _final_ you still have all the _final_ methods. But as _final_ methods can not be overridden, real code will suddenly run in your mock. This is something you want to avoid.\nThe problem itself is not new, especially APIs or different third party code were sealed with _finals_. The developers from [Jayway](https://www.jayway.com/sharing-knowledge/blog/) solved this solution a long time ago by creating [PowerMock](https://github.com/jayway/powermock/).\nPowerMock allows to mock _finals_ and even _statics_. The question for us Kotlin developers is: is there a better way, easier way? Using PowerMock is like using a sledge hammer to crack a nut.\n\nWhat else could we do? Going back to interfaces? This would lead us to the situation described above.\nWe could open all the classes we need. As we (hopefully) test all the classes, could this lead to opening all our classes!? And would this mean modifying our code just for testing? This sounds wrong! The main feature of the language would be broken.\n\n### An idea to solve it\n\nIn an ideal world we would just have something like:\n\n```kotlin\ncontroller = mockFinal()\n```\n\nwhich would be an extension of normal _mock()_ method. Everything this call would need to do, is removing the _final_ modifier from the class and all its public methods.\n\nWith Java reflection is very easy to remove the _final_ modifier of a field.\nFor example:\n\n```kotlin\nField modifiersField = Field.class.getDeclaredField(“modifiers”); modifiersField.setAccessible(true);\nmodifiersField.setInt(field, field.getModifiers() & ~Modifier.FINAL);\n```\n\nBut for classes and methods things tend to be a bit trickier. You can not achieve this with pure Java reflection API.\n\nBut thanks to frameworks like [_javassist_](http://jboss-javassist.github.io/javassist/) there is a way. Javassist is a large toolkit around byte code. It allows the manipulation and even creation of Java classes at runtime. And it also includes a way to change the class and method modifiers:\n\n```kotlin\nCtClass clazz = ...\nint notFinalModifier = Modifier.clear(clazz.getModifiers(), Modifier.FINAL);\nclazz.setModifiers(notFinalModifier);\nreturn clazz.toClass();  // returns new non final class\n```\n\nWith this, a new non-final class can be easily created. But this leads to the next problem: _javassist_ creates a new class but we can not load the new class into the current test. Because the class is already loaded by the class loader. Two version of it are not allowed:\n\n```kotlin\njavassist.CannotCompileException: by java.lang.LinkageError: loader (instance of  sun/misc/Launcher$AppClassLoader): attempted  duplicate class definition for name: \"com/myPackage/MyKotlinClass\"\n```\n\nSo we just need a different class loader right?\nThe problem: an assignment like\n\n```kotlin\ncontroller = mockFinal()\n```\n\nwould not work if two different class loaders would be used. So even if we could get passed that Linker error for duplicate class from above we would get a ClassCastException! This is because for the JVM classes are identified by _name, package_ and _class loade_r. So even without modification, instances of two identical classes cannot be assigned to each other if the class loader differs.\n\nThis means we need to aim a bit larger than the initial idea: there must be only one class loader for our full test class.\nGood news! With JUnit there is way to achieve this. We can change the TestRunner that is used for our class.\n\n```kotlin\npublic class MyTestRunner extends BlockJUnit4ClassRunner {\n\n    public MyTestRunner(Class<?> clazz) throws InitializationError {\n        super(getFromMyClassloader(clazz));\n    }\n\n    private static Class<?> getFromMyClassloader(Class<?> clazz) ...\n```\n\nthen we would write our own _ClassLoader_ and override:\n\n```kotlin\n@Override\npublic Class<?> loadClass(String name) throws ClassNotFoundException { ...\n```\n\nHere you can remove the _final_ modifier with _javassist_ as shown above and return the new “better” class.\n\nHave a look on how all of these look when put together:\n[_https://github.com/dpreussler/kotlin-testrunner_](https://github.com/dpreussler/kotlin-testrunner)\n\nIf you want to use it, all you need to do is to add **_@RunWith(KotlinTestRunner.class)_ **for Java tests\nor\n**_@RunWith(KotlinTestRunner::class)_ **for Kotlin tests\n\n```kotlin\n@RunWith(KotlinTestRunner::class)\nclass MyKotlinTestclass {\n   @Test\n   fun test() {\n   ...\n   }\n}\n```\n\nWith this you will never have to care about if your Kotlin class is _final_ or _open_. Simply mock them, it will work :-)\n\n### Wrap up\n\nFor now it seems there is no way around without changing the Testrunner. PowerMock uses the same approach but requires more configuration. So for what we wanted to achieve this is a reasonable solution. Give it a try and let me know how it works for you.\n\nAnd of course the Runner is not limited to Kotlin. It can also be used for any Java test where a _final_ method or class needs to be mocked.\n","author":"Danny Preussler","date":"2016-07-06","type":"article","categories":["Testing","Kotlin"],"features":["highlightjs"],"description":"","filename":"","lang":"EN","enclosure":null},{"title":"Taking Kotlin to production, Seriously","url":"https://www.youtube.com/watch?v=qSFch-3ULAw","body":"\nNext Insurance was founded in the beginning of 2016 and first lines of our production code started accumulating in May 2016. In the beginning I have started writing in Java and experimenting with Kotlin, which saw its 1.0 release two months earlier. 6 months later, the development of our backend services has totally shifted to Kotlin. We still keep a few classes in Java just to make sure that the integration remains seamless but the vast majority of our codebase is written in Kotlin. In this talk I will cover the language features and why I think it is awesome, from null safety to smart casts and data classes. We will also look into the future with 1.1 async/await feature and more.\n\nHaim Yadid is leading backend development in Next insurance. Developing in Java in the last 13 years most of the time focusing on performance optimization and GC tuning.\n\n<iframe width=\"960\" height=\"480\" src=\"https://www.youtube.com/embed/qSFch-3ULAw\" frameborder=\"0\" allowfullscreen></iframe>\n","author":"Haim Yadid","date":"2016-12-09","type":"video","categories":["Kotlin"],"features":["highlightjs"],"description":"","filename":"","lang":"HE","enclosure":null},{"title":"Building a Kotlin project 1/2","url":"http://cirorizzo.net/2016/03/04/building-a-kotlin-project/","body":"\n### Part 1\nThe best way to learn a new language is to use it in a real use case.\nThat's way this new series of posts are focused on building a proper Android project using Kotlin.\n\n## Scenario\nTo cover as many scenarios as possible the project will require:\n\n* Accessing to the network\n* Retrieving data through out a REST API call\n* Deserialize data\n* Showing Images in a list\n\nFor this purpose why not have an app showing kittens? ;)\nUsing the [http://thecatapi.com/](http://thecatapi.com/) API we can retrieve several funny cat images\n\n![Example](http://cirorizzo.net/content/images/2016/03/xkittenApp.png.pagespeed.ic.ulo4yWl6Cg.png)\n\n## Dependencies\nIt looks like a very good chance to try out some very cool libraries like\n\n* [Retrofit2](http://square.github.io/retrofit/) for the network access, REST API calls and deserializing data\n* [Glide](https://github.com/bumptech/glide) for showing images\n* [RxJava](https://github.com/ReactiveX/RxJava) to bind data\n* [RecyclerView CardView](http://developer.android.com/training/material/lists-cards.html) as UI\n* Everything wrapped in a [MVP](https://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93presenter) pattern\n\n## Set Up the Project\n\nUsing [Android Studio](http://developer.android.com/sdk/index.html) is extremely simple create a new project from scratch\n\n### Start a new Android Project\n\n![Start a new Android Project](http://cirorizzo.net/content/images/2016/03/xAndroidStudio_NewProject.png.pagespeed.ic.7fDR0qSTJd.png)\n\n### Create a new project\n\n![Create a new project](http://cirorizzo.net/content/images/2016/03/xAndroidStudio_NewProject_Create_NEW-1.png.pagespeed.ic.rtJ-FIVYiG.png)\n\n### Select Target Android Device\n\n![Select Target Android Device](http://cirorizzo.net/content/images/2016/03/xAndroidStudio_NewProject_Target.png.pagespeed.ic.bXlb6fWH62.png)\n\n### Add an activity\n\n![Add an activity](http://cirorizzo.net/content/images/2016/03/xAndroidStudio_NewProject_Empty.png.pagespeed.ic.VYxIdhZ3Xk.png)\n\n### Customize the Activity\n\n![Customize the Activity](http://cirorizzo.net/content/images/2016/03/xAndroidStudio_NewProject_Activity.png.pagespeed.ic.3g2X5Gs9Bn.png)\n\nPress on Finish, the new project from the chosen template will be created.\n\n![Done](http://cirorizzo.net/content/images/2016/03/xAndroidStudio_Basic_Template.png.pagespeed.ic.3iX8nv51PP.png)\n\n\nThis is the starting point of our Kitten App!\nHowever the code is still in Java, later we’re going to see how to convert it.\n\n## Defining Gradle Build Tool\n\nThe next step is to adjust the Build Tool and defining which libraries we're going to use for the project.\n\n> Before starting with this phase, have a look at what you need for an Android Kotlin project on this [post](http://www.cirorizzo.net/kotlin-code/)\n\nOpen the Module App `build.gradle` (highlighted with a red rectangle in the picture)\n\n![Gradle](http://cirorizzo.net/content/images/2016/03/xAndroidStudio_Basic_Gradle_High.png.pagespeed.ic.0SHrJn4YZc.png)\n\nIt's a very good practice collecting all the libraries' version and Android properties in separate scripts and accessing to them through the `ext` property object provided by Gradle.\n\nThe easiest way is to add at the beginning of the `build.gradle` file the following snippet\n\n```groovy\nbuildscript {\n  ext.compileSdkVersion_ver = 23\n  ext.buildToolsVersion_ver = '23.0.2'\n\n  ext.minSdkVersion_ver = 21\n  ext.targetSdkVersion_ver = 23\n  ext.versionCode_ver = 1\n  ext.versionName_ver = '1.0'\n\n  ext.support_ver = '23.1.1'\n\n  ext.kotlin_ver = '1.0.0'\n  ext.anko_ver = '0.8.2'\n\n  ext.glide_ver = '3.7.0'\n  ext.retrofit_ver = '2.0.0-beta4'\n  ext.rxjava_ver = '1.1.1'\n  ext.rxandroid_ver = '1.1.0'\n\n  ext.junit_ver = '4.12'\n\n  repositories {\n      mavenCentral()\n  }\n\n  dependencies {\n      classpath \"org.jetbrains.kotlin:kotlin-gradle-plugin:$kotlin_ver\"\n  }\n}\n```\n\nThen adding the Kotlin plugins as shown\n\n```groovy\napply plugin: 'com.android.application'\napply plugin: 'kotlin-android'\napply plugin: 'kotlin-android-extensions'\n```\n\nBefore adding the dependencies for the libraries we're going to use in the project starting to change all the version numbers of the script with the `ext` properties added early at the beginning of the file\n\n```groovy\nandroid {\n  compileSdkVersion \"$compileSdkVersion_ver\".toInteger()\n  buildToolsVersion \"$buildToolsVersion_ver\"\n\n  defaultConfig {\n    applicationId \"com.github.cirorizzo.kshows\"\n    minSdkVersion \"$minSdkVersion_ver\".toInteger()\n    targetSdkVersion \"$targetSdkVersion_ver\".toInteger()\n    versionCode \"$versionCode_ver\".toInteger()\n    versionName \"$versionName_ver\"\n}\n...\n```\n\nOne more change to the `builTypes` section\n\n```groovy\nbuildTypes {\n    debug {\n        buildConfigField(\"int\", \"MAX_IMAGES_PER_REQUEST\", \"10\")\n        debuggable true\n        minifyEnabled false\n        proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'\n    }\n\n    release {\n        buildConfigField(\"int\", \"MAX_IMAGES_PER_REQUEST\", \"500\")\n        debuggable false\n        minifyEnabled true\n        shrinkResources true\n        proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'\n    }\n}\nsourceSets {\n    main.java.srcDirs += 'src/main/kotlin'\n}\n```\n\nNext step is to declare the Libraries used in the project\n\n```groovy\ndependencies {\n  compile fileTree(dir: 'libs', include: ['*.jar'])\n  testCompile \"junit:junit:$junit_ver\"\n\n  compile \"com.android.support:appcompat-v7:$support_ver\"\n  compile \"com.android.support:cardview-v7:$support_ver\"\n  compile \"com.android.support:recyclerview-v7:$support_ver\"\n  compile \"com.github.bumptech.glide:glide:$glide_ver\"\n\n  compile \"com.squareup.retrofit2:retrofit:$retrofit_ver\"\n  compile (\"com.squareup.retrofit2:converter-simplexml:$retrofit_ver\") {\n    exclude module: 'xpp3'\n    exclude group: 'stax'\n}\n\n  compile \"io.reactivex:rxjava:$rxjava_ver\"\n  compile \"io.reactivex:rxandroid:$rxandroid_ver\"\n  compile \"com.squareup.retrofit2:adapter-rxjava:$retrofit_ver\"\n\n  compile \"org.jetbrains.kotlin:kotlin-stdlib:$kotlin_ver\"\n  compile \"org.jetbrains.anko:anko-common:$anko_ver\"\n}\n```\n\nFinally the `build.gradle` is ready to work with the project.\n\nJust one more thing is to add the `uses-permission` to access to Internet, so add the following line to the `AndroidManifest.xml`\n\n```xml\n<uses-permission android:name=\"android.permission.INTERNET\" />\n```\n\nAnd now we are ready to go to the next step\n\n## Designing Project Structure\n\nAnother good practice is to structure the project having different packages and folders for different group of Classes composing our project so we can structure our project as shown below.\n\n![Structure](data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAARIAAAB1CAMAAAC1b55HAAAABGdBTUEAALGPC/xhBQAAAm1QTFRFPT9BPUBBPUBCPkBBPkFDQEJDQEJEQENFQkRFQkRGQkVHQ0ZHQ0ZIREdJRUhJRkhKRklLR0pLSEpMSEtNSUxNSUxOSk1OS05PS05QTE5QTVBRTlBSTlFTTl1mT1JTT11nUFJUUVJUUVRVUVRWUlRWUlVXU1VXU1ZXVFZYVFdZVVdZVVhZV1laV1lbV1pbWFpcWVtcWVtdWlxeWl1eW11eW11fW3ODXF5gXF9gXV9gXV9hX2BiX2FiX2FjYGJjYGJkYWNkYmRlYmRmY2VmY2VnZGZnZGZoZWdoZWdpZmhpZmhqZ2lqZ2lraGpraWtsaWttamxta21ta21ua21vbG5vbW9xbnBxb3FycHFycHJzcXN0cnR1c3R2c3V2c5y3dHV2dJ23dJ24dXd4dnh5d3l6eHl6eXp7emtUenx9eqfEe3x9e31+fH5/fX5/fX+Afn+Af4GCgIGCgYODgYOEgoOEg4WGhIWGhYaHhoeIh4iJiImKiYqLiouLiouMi4yNjI2NjI2OjY2OjY6Pjo+Pjo+QjpCQj5CRkJGSkZKSkZKTkpOTkpOUk5SUk5SVlJWVlJWWlZaWlpaXlpeXlpeYl5iYmJmZmJmamZqampubmpucm5ycnJ2dnJ2enZ2enZ6enp6fnp+gn6CgoKChoKGhoKGioaKioqKjoqOjo6Ojo6SkpKSkpKSlpKWlpaWlpaampqanpqenp6enp6ioqKipqampqaqqqqqrq6urrKysrKytra2tra6urq6vr6+vr7CwsLCxsbGxsrKzs7OztLS0tLS1tbW1tra2tra3t7e3uJZouLi4uLi5urq6urq7u7u7y01+uQAAB/NJREFUeNrtnftDU2Ucxr8sLnIZzKGZYWqGXUArb4kXRFspRuIyFcEsnFZeUiyVMs2sjCysKEDxklg6l5cojwR2ajEnYiHtb+q9nss2tiOM6c7e54dzOOf77gt7xjm8+/CcHQAhISGh+Gkr0XPCiGBLhCehljDhPV9sSaKn/4tMdSmiJdmjksiSMmbJAp0lwV/X1wBsueA9YIFPXwawXUijGybVSeJIG0S0BB84lQ/bfM/A+mMA6w+zDZPqUWLJxOiWIJ2ogfw7o8FdyjbMqs+RI59AdEsqGpp8yIW2msl/WfiGSZV1Xe7Oim7JU/8UwHHkwpozdbuVDbOqTt4B0S1Z7M0o7HwTwNrfM1XZMKtSW1MNzEvSz/rddb5igKaLoG4k71TtRCVa5ALkKWN0G8mn+p0+m5jT6zRzlVWYICQkJCQUJ/1L9LYwItiSoXmyacrgW8PuN/x2w7SEyeCDJId2pd8ZcU/4fWFrkQbGTuHg45AsyU2D05XRLUHDwMi+e2hJOPiotYF+Pb7J37MOxrf6pQqAlhcafbvsbd4NdMTE9huHjlZAS8mOfu+1VGlFQ089wNkigLZZIK1u9h9hNIL2aCmBloq2BqUX/rqlxHYNy8pWvMhcWHQ8E5b85N+PNmhzWv52PmR0OCDlXCYtxk5h4COy4ZHa2kdUS1KunCrMHWu5eMC2/HYxSF3lswJnS5f708mItv3WuTeq0M+ec7naDpJcPa1/CvhmAnQtAqlj6cLuKjKM9sBPUepaZld7LUOPcaTY7fZjJyxsxYvUkgneIrD8Pi/tIWDNWfn9PVB6Zx/M+IEVY6cw8BHZULt1a61qSVFgHloWB9A3PlUP0hqAW89DVmAcHpDdPx7g9Fr8XD34wHEBXHYqlqDX+t0vSSPag1hSrelVzY8Hl0zebuIVL5LxK6+uQqvOvfj/BrQ5KzuuwN76q7DLxYoxVCh8pJZsVC1Z+l8GXt7E75SPkmfQOx1GUUsW4r0aS1DRrVqCtl7tII1oD2KJQ9+LLObefhqXyYoXyXh3N/5lLJb+LOXNWTm73/arvXd0x0RWjKFC4SOyYdLG1yeplkwLTEfLZwPodWzeF2SJfcAOKZepJU7VkjmQ/je1ZNeHpBHtwS3R9sKLsT3k8KIrXiTjV3g+I+xrc18ma87L7Zt/hO83SbwYS4XAx5DTa6p0xJaany67LJNvLtZa8kY5wM9fOxq8xJLGOsWScxtyDt5Bluyx5F14CfA42oNbou2FFmnnPsLfjK14EXeXHPnydkgrhDF9Vtacl3f4t4HLv5sXRxQ+hv4Rfvxan28bzPiju+8d0FrScRCgsPnki54VeG9Zj4dbsrLXV4UPnIOS/xv0AuJxtAezRNsLLRYGfF6vt4CteBE/Cg2Y2ltplbs6XYrfrDw7UIROO7OBFeM+VbOTPy/5qWEfYBt4kqzTVR45isw1cixpueow2oNrkF6DFPMsEcp599k/Iw/s3ykdEe+CtJpQXl0iXBASEhISEvDxnsPHmun3ARYcAbU/NmT4iN4Tx5eBxUmyfNg6MpZgFpmglsjdb0V5d6zljQwMFrTfOORBlhScudmYpVhCASONRRIWGWsuGC9LZPm3BRHho4Y3cjB47IPsMn8VQKsrt3U1t4QBRhqLxCwy5lwwfpbI8muR4KOGNzLyl9E3jhw4ObeemLD9Y24JA4xAY5EYvMWcC8bNks5XIMSSjVpLFGzCyN88Pz2XLOo/f/58A7eEAUYWi8SWxJwLxsmS6+89EHwu0cNHjSWM/E0ZyAY4sxamDYzRnF4pYOSxSMwiY88F42LJdw9CtNOragknf15X+tq+Kki9Wp8JVjJAAYw8FtlYNxJcMA66NMfAvETDGxn5W9ffV49+S6Dwir+zmQxQACOPRZb1eOLBBeM5ex1sXkLJX2YO27TpDgwCGFksErPIPNNepCAkJCQkJCQUv3mJAI2hU7W798QkuHEYoDFEJsGNQwCNgxJE01hiBDQuIfFCShUxQWxSIobauCKLJJrAEgOgkWYXKVXEBFGNGOrjijiSaA5LooJGEi/kVNFTCUrEUB9XpJFEU1hiBDS6nZwqIkuUiKE+rkgjiSawxBhodDs5VcQEkUcM9XFFFklMeEsMgka3k1NFnGbkEcOguCKOJCa8DINGt5NTRZxm5BHDoLgijiSaePYabl5CqWK67urqiHFFISEhISEhIaHhz0sEaAydqiWtJ7EEjSbRMBKNoTpdaQ5LjIDGcnpZNMGJLMRIw4psg5JIEmLke/DQhLXEAGhkl0UTnEhxIwsr8kQjIZHkgmq+Bw9NYEuigkZ2WTTGiRw3krCikmikV1F7KtU91Yl84BgDjfiyaLzmuJGEFbWJRjexRJ9xTFRLjIFGfFk0XnPcSMKK2kQjtsQZlHFMUEuMgEZ2WTR+ngw30rCiJtGILWms02YcE1XGQONX9LJo8jwpbmRhRTXRiC3BCFKzx3SzVx171V4WzXAjCyvqEo0EQdoywfwy10seE83PFx4ICQkJCY3UvESAxtCpmgCNkWavyTVhuwvQGOnzFc1lSXTQyO4U01LCuKL6kYlmtSQqaGR3ikEHDqWISp4RzGtJFNDI7hQjORhFVD8y0byWRAON9E4xkoNRRPUjE81qSXTQSO4UgyzhFFH9yERzWmIANJI7xSBLOEXkeUZzyhBoJHeKwadXRhGVPGOSzV7D/wM0KSiikJCQkJCQQf0P6Bh9nhVvE5IAAAAASUVORK5CYII=)\n\n> Right Click on the Root Package `com.github.cirorizzo.kshows` and then `New -> Package`\n\n## Coding\nThe next [post](http://www.cirorizzo.net/2016/03/04/building-a-kotlin-project-2/) is on how to code the elements of the Kitten app\n\n## Translations\nThis post is also available in Chinese on [gold.xitu.io](https://goo.gl/tBIMn7)\nA special thanks for the translation to the gold.xitu.io Team\n\n\n\n\n","author":"Ciro Rizzo","date":"2016-03-04","type":"article","categories":["Android","Kotlin"],"features":["highlightjs"],"description":"","filename":"","lang":"EN","enclosure":null},{"title":"Kotlin Month Post 1: Assorted Features","url":"https://programmingideaswithjake.wordpress.com/2016/02/27/kotlin-month-post-1-assorted-features/","body":"\nTo open up Kotlin Month, we’ll look at a small assortment of Kotlin’s features that aren’t big enough to merit their own post and don’t fit into a grouping for the upcoming posts, starting with operator overloading.\n\n## Operator Overloading\n\nBecause of the mess it made in C++, Java decided to not include [operator overloading](https://kotlinlang.org/docs/reference/operator-overloading.html), and it has unfortunately stuck to that decision, presumably because people haven’t made a big enough stink about it. This makes sense if a majority of Java programmers haven’t had much/any experience with a language that does, which I think may be the case at this point.\n\nMy opinion is that it isn’t specifically operator overloading that was the problem in C++; the problem was the free reign to invent whatever operators you wanted. This is still technically possible in Kotlin (see the next feature), but it’s still harder to abuse in its case. And obviously, operators can still be abused and used in ways they’re not meant to be, but that applies for just about anything in programming.\n\nAnyway, I really enjoy the increased readability and conciseness of properly used operators over functions, so it’s nice to have.\n\n## Infix “Operator” Methods\n\nUsing the [infix notation](https://kotlinlang.org/docs/reference/functions.html#infix-notation) for functions allows Kotlin to allow extending the list of available “operators” without falling into the same deep pit that C++ did by limiting them to legal method names. By doing so, they kept coders from using symbols that had no inherent meaning, making it much more likely that people will be able to decipher the meaning of the operator, assuming it’s named well.\n\nOne pointer I would give to those considering infixing one of their functions is that you shouldn’t use them in the case where they’re meant to be chained in a fluent interface. It can become very difficult to distinguish between objects and operators, since they’re all just a bunch of identifiers. A potential exception to this rule is an internal DSL that is meant to be used in a configuration-like file.\n\nFor the most part, I don’t think this feature will be used a whole lot, but I can definitely see enough use cases to make it a valuable part of Kotlin.\n\n## Streaming\n\nOf all the features of all the languages out there, being able to filter, map, and reduce over a collection declaratively is probably my all-time favorite. Kotlin does not disappoint, to this end. Being required to compile to Java 6, they didn’t automatically have access to the new Stream API, so they made their own essentially, called [Sequence](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.sequences/-sequence/index.html). It is largely the same idea, but doesn’t support doing the work in parallel. Luckily, it makes up for it by having an even larger set of methods to use. Not only that, but the collections themselves (and even Iterators) have the same set (or at least similar set) of methods as a Sequence, making it so you don’t have to make the Stream or Sequence instance to do a simple filter or map. Unfortunately, doing the calls from a collection or iterator is eager and creates (usually) a List right away. That’s what Sequence is for: to make it lazy.\n\nI really like that they 1) made Iterators be iterable (meaning you can put Iterators directly into a for loop, just like in Python; the iterator() method simply returns “this”) and 2) the streaming methods can be called from iterators, too, so you don’t need an eagerly created collection to start with.\n\nAlso, [Ranges](https://kotlinlang.org/docs/reference/ranges.html) allow for the quick creation of numbers to iterate over as well as checking if a value is within it.\n\nAnd Strings are iterable!\n\n## Data Classes\n\n[Data classes](https://kotlinlang.org/docs/reference/data-classes.html) are a quick, easy way to make bean-like classes in Kotlin. By annotating a class with “data”, it will use all the properties defined in the primary constructor to define toString(), hashCode(), equals(), and the [component functions](https://kotlinlang.org/docs/reference/multi-declarations.html). It also creates a [copy() method](https://kotlinlang.org/docs/reference/data-classes.html#copying) that is pretty awesome.\n\nIn an older article, I tried to recreate this for Python, then someone commented that it pretty much already existed as named tuples :P\n\n## Outro\n\nI could on and on, as everything that Kotlin does differently from Java is generally pretty good, but then I’d be digging a bit too deep into the minutia of it all and bore you. If you want to learn more about it, check out [my other Kotlin articles](https://programmingideaswithjake.wordpress.com/kotlin/) or look at [Kotlin’s awesome reference page](https://kotlinlang.org/docs/reference/).\n\nNext week, I’ll be shouting my praises of Kotlin’s decisions about inheritance, its special cases, and defaults.\n\n","author":"Jacob Zimmerman","date":"2016-02-27","type":"article","categories":["Kotlin"],"features":["highlightjs"],"description":"","filename":"","lang":"EN","enclosure":null},{"title":"Kotlin 1.1-M02 is here!","url":"https://blog.jetbrains.com/kotlin/2016/10/kotlin-1-1-m02-is-here/","body":"\nWe’re happy to announce the second milestone release of Kotlin 1.1. This release brings one long-awaited new language feature, **destructuring in lambdas**, as well as many improvements to features introduced in 1.1-M1, including type aliases, coroutines and bound references. The new release also includes all tooling features introduced in Kotlin 1.0.4 and 1.0.5-eap-66, and is fully compatible with IntelliJ IDEA 2016.3 EAP and Android Studio 2.2.\n\nAs with Kotlin 1.1-M01, we give **no backward compatibility guarantees** for new language and library features. Anything introduced in milestone releases of 1.1 is **subject to change** before the final 1.1 release.\n\nAnd once again: please do share your feedback regarding the new language features or any problems that you may run into with this release, via [YouTrack](https://youtrack.jetbrains.com/issues/KT), [forums](http://discuss.kotlinlang.org) and [Slack](https://kotlinlang.slack.com).\n\nThe full changelog for 1.1-M02 is available [here](https://github.com/JetBrains/kotlin/blob/1.1-M2/ChangeLog.md).\n\n## Destructuring in Lambdas\n\nKotlin 1.0 supports [destructuring declarations](https://kotlinlang.org/docs/reference/multi-declarations.html) – a feature that allows you to “unpack” a composite value (such as a data class) and assign its components to several distinct variables. Kotlin 1.1 extends this to **lambda parameters**, letting you unpack a composite variable passed to a lambda and access its components under distinct names. For example, you can use this to iterate over a list of pairs:\n\n```kotlin\nlistOfPairs.map {\n    (a, b) -> a + b\n}\n```\n\nYou can find more details in the [KEEP](https://github.com/Kotlin/KEEP/blob/master/proposals/destructuring-in-parameters.md). Note that the feature is currently supported only for the JVM backend. Nested destructuring, as well as destructuring of arguments passed to regular functions and constructors, is currently unsupported.\n\n## Standard Library\n\nKotlin 1.1-M02 adds several new APIs to the standard library:\n\n*   distinct `AbstractCollection` and `AbstractMutableCollection` hierarchies to use as base classes for implementing new Kotlin collection classes ([KEEP-53](https://github.com/Kotlin/KEEP/blob/master/proposals/stdlib/abstract-collections.md));\n*   `Map.toMap()` and `Map.toMutableMap()` extension functions for copying maps ([KEEP-13](https://github.com/Kotlin/KEEP/blob/master/proposals/stdlib/map-copying.md))\n\n## Reflection\n\nThe reflection library has gained a substantial amount of new features. You can now obtain more useful information out of a KType instance and create custom KType instances, introspect modifiers on declarations, get superclasses or check subtyping, etc. To see what’s new you can scan down [the following commit](https://github.com/JetBrains/kotlin/commit/ed1490dbc43f88696f82e5307df43269ecbb32b1).\n\n## IDE\n\nThe IntelliJ IDEA plugin has been extended to support the new 1.1 language features, with new refactorings “Introduce type alias” and “Inline type alias”, an intention action to create a type alias from usage, as well as quickfixes to apply destructuring in lambdas automatically.\n\n## Scripting\n\nStarting with this release, Kotlin supports JSR-223 (the `javax.script` API), allowing you to easily run Kotlin scripts from your application and to use Kotlin as an embeddes scripting language. It also continues the work required to support Kotlin scripting in Gradle build files.\n\n## JavaScript\n\nJavaScript support in 1.1-M02 has been extended to support **type aliases** and **class literals** (`Foo::class`).\n\nIn addition to that, we’re working to make more of the Kotlin API available in multiplatform projects. To that end, we’ve defined all the standard exception classes in the `kotlin` package. When targeting the JVM, the Kotlin exceptions are defined as type aliases for the corresponding Java exceptions, and the JS backend provides their full-fledged implementations. We’ve also provided a full Kotlin implementation for the standard collection classes, which is now used in JS projects. (Kotlin on the JVM still uses standard Java collection classes.)\n\n## How to Try It\n\n**In Maven/Gradle:** Add `http://dl.bintray.com/kotlin/kotlin-eap-1.1` as a repository for the build script and your projects; use 1.1-M02 as the version number for the compiler and the standard library.\n\n**In IntelliJ IDEA:** Go to _Tools → Kotlin → Configure Kotlin Plugin Updates_, then select “Early Access Preview 1.1” in the _Update channel_ drop-down list, then press _Check for updates_.\n\n**On [try.kotlinlang.org](http://try.kotlinlang.org/)**. Use the drop-down list at the bottom-right corner to change the compiler version to 1.1-M02.\n\n**With SDKMan**. Run `sdk install kotlin 1.1-M02`.\n\nIf you are using [kotlinx.coroutines](https://github.com/Kotlin/kotlinx.coroutines) library please use updated version 0.1-alpha-2, it’s almost the same, but it’s recompiled with 1.1-M02 compiler. You can follow the updates in the [readme file](https://github.com/Kotlin/kotlinx.coroutines/blob/master/README.md).\n\nHave a nice Kotlin!\n\n","author":"Denis Zharkov","date":"2016-10-20","type":"article","categories":["Kotlin"],"features":["highlightjs"],"description":"","filename":"","lang":"EN","enclosure":null},{"title":"Ad-hoc polymorphism in Kotlin","url":"http://beust.com/weblog/2016/06/20/ad-hoc-polymorphism-in-kotlin/","body":"\nEven though Kotlin doesn’t natively support ad-hoc polymorphism today, it’s actually pretty straightforward to use it with little effort. Doing so is not as straightforward as it is in Haskell, obviously, but it’s been simple enough that I haven’t really encountered situations in Kotlin where the lack of native support in the language was a showstopper. In this article, I present two techniques you can use to leverage ad-hoc polymorphism in Kotlin.\n\n## Extending for “fun” and some profit\n\nHere is what the [Haskell wiki](https://wiki.haskell.org/Polymorphism) has to say about ad-hoc polymorphism:\n\n> Despite the similarity of the name, Haskell’s type classes are quite different from the classes of most object-oriented languages. They have more in common with interfaces, in that they specify a series of methods or values by their type signature, to be implemented by an instance declaration.\n\nBefore we get into details, let’s define exactly what we are trying to do and why we’re trying to do it. One intuitive way of looking at ad-hoc polymorphism is that it enables us to retroactively make values conform to a certain type. This is a bit abstract but I’m pretty sure you have encountered this problem many times before even if you never realized it. Let’s look at a simple example.\n\nA library typically defines types and then offers functions that take parameters and returns values of that type. The only way to make use of that library is to find a way to bring your objects into that library’s object world, or in other words, be able to convert your objects to objects that this library expects and vice versa. You will find many examples of type classes if you do a simple search: values that behave like a Number, Functor, Applicative, Monad, Monoid, Equality, Comparability, etc... In order not to repeat what’s already out there and in an effort to remain focused on concrete problems, I’m going to pick a different field: JSON.\n\nThe need to parse JSON and also convert your objects to JSON is pretty much universal, so in all likeliness, you are already using a JSON library in your code. And at some point, you have had to ask yourself a very simple question: “How do I convert my current objects to JSON so I can use this library”. The library probably defines some kind of `JsonObject` type and most of its API is defined in terms of this type, either with functions accepting parameters of that type or returning such values:\n\n```kotlin\ninterface JsonObject {\n    fun toJson() : String\n}\n```\n\nIn order to leverage this library, converting your objects so they conform to this interface is very important, and once you have converted your objects, you gain full access to all the functionalities that this library offers, such as pretty printing in JSON, doing search/replaces in JSON, reshaping JSON object from one form to another, etc...\n\nIf you own (i.e. you are the author of) these classes, doing so is very easy. For example, you can modify your class to implement that interface:\n\n```kotlin\nclass Account : JsonObject {\n    fun override toJson() : String { ... }\n}\n```\n\nThe advantage of this approach is that you can now pass all your `Account` values directly to functions of the JSON libraries that accept a `JsonObject`. This is very useful, but the downside is that you have now polluted your class with a concern that make your design more bloated. If you are going to extend this approach to other types, very soon, your `Account` class will extend multiple interfaces filling various functionalities, and you have now tied your business logic to a lot of dependencies (i.e. you now need this JSON library in order to compile your `Account`...).\n\nAnother approach is simply to write a function that converts your business objects to `JsonObjects`:\n\n```kotlin\nfun Account.toJson() : JsonObject { ... }\n```\n\nThis defines an extension function that adds the method `toJson()` directly on the `Account` class, where it belongs. The extension function buys us two very important benefits:\n\n* Since it’s an extension function, its implementation runs on the `Account` instance itself (in other word, `this` is of type `Account`).\n* This function is defined without making any modification to the `Account` class itself. Not only does it leave your class untouched and unpolluted with unrelated concerns, you can also apply this approach to classes that you don’t own. This is extremely important and a critical step toward ad-hoc polymorphism.\n\nWith this approach, we have won separation of concerns and a great amount of flexibility but we have lost some typing power: we can no longer pass an instance of `Account` to a function accepting a `JsonObject` parameter, we need to call `toJson()` on that instance first.\n\nThis is how far we can go with Kotlin today and this fits in Kotlin’s general design principle to stay away from implicit conversions, a decision I’ve come to respect greatly after several years writing Kotlin code.\n\n## Escaping the tyranny of nominal typing\n\nLet’s look at another approach to implement ad hoc polymorphism. Consider the following simple function that saves an object to a database:\n\n```kotlin\nfun persist(person: Person) {\n    db.save(person.id, person)\n}\n```\n\nThe object is saved to the database and associated to its `id`. A little later, I want to persist an `Account` object, and in the spirit of proper software engineering, I’d rather abstract my existing code rather than writing a second `persist()` function. So I make my function more generic and in the process, I discover that in order to be persisted, my `Account` instance needs to be able to give me its `id`. After refactoring, my code now looks like this:\n\n```kotlin\ninterface Id {\n    val id : String\n}\n\nclass Person : Id {\n    override val id: String get() = \"1\"\n}\n\nfun persist(id: Id) { ... }\n```\n\nBut now, I find myself having to make `Account` implement `Id`, which is exactly what I am trying to avoid with ad hoc polymorphism (either because I think it’s bad design or more simply because the class `Account` is not mine, so I can’t modify it). The realization here is that these type names get in the way of my goal and I’d rather keep all these concepts separate.\n\nWhat if, instead, the `persist()` method accepted an additional parameter (a function) that allows me to obtain an `Id` from its parameter?\n\n```kotlin\nfun <T> persist(o: T, toId: (T) -> String)\n\n// Persist a Person: easy since Person extends Id\npersist(person, { person -> person.id })\n\n// Persist an Account: need to get an id some other way\npersist(account, { account -> getAnIdForAccountSomehow(account) }\n```\n\nThis new approach has a few interesting characteristics:\n\n1.  Notice how completely generic the `persist()` method has become: it doesn’t reference `Person`, `Account` and not even `Id`, even though it needs some sort of id in order to operate. This function is literally applicable “for all” types (I am intentionally using double quotes here, some of you will probably immediately understand what “for all” means in this context).\n2.  We have detached the ability to provide an id from our types. You still have the option to implement this functionality into your types (like `Person` does) but it’s now entirely optional (like `Account` shows). This gives you a lot of flexibility since you are now longer forced to use the id supplied by the class and you can also be more creative in your testing (e.g. trying to save two different objects but force them to have the same `id` in order to test for collision error cases).\n\nThis approach makes a drastic step toward a more functional solution to the problem of ad hoc polymorphism: we depend less on types and more on functions. As you can see, this approach provides some interesting benefits.\n\n## An ad-hoc polymorphism proposal for Kotlin\n\nWhen I reflected about this problem a while ago, it occurred to me that ad-hoc polymorphism has a lot in common with Kotlin’s extension functions: an extension function adds a function to a type outside of the definition of that type and ad-hoc polymorphism makes a type extend another type outside of the definition of that type. I came up with the concent of “Extension types” and I gave a quick overview of this idea [in this article](https://discuss.kotlinlang.org/t/extension-types-for-kotlin/1390). Extension types would allow us to make types retroactively implement other types with this made up syntax:\n\n```kotlin\n// Not legal Kotlin\noverride class String: Monoid<String>\n```\n\nThe rest of the interface would be implemented with extension functions, as demonstrated in the link above. The downside of this proposal is that it adds some form of implicit conversion, something that is at odds with Kotlin’s current design, so it’s probably unlikely this proposal will go past the stage of strawman but I thought it would be interesting to draw a parallel between extension functions and extension types.\n\n## Does Kotlin really need ad-hoc polymorphism?\n\nThe more I think about it, the more convinced I am that the value offered by ad-hoc polymorphism is very closely tied to the language you’re using it in. In other words, it’s not a universal tool but one that’s heavily dependent on how well supported it is in your language. Ad-hoc polymorphism is obviously a critical component of Haskell and it has given rise to high amounts of reuse and elegant abstractions in that language but I’m not sure Kotlin would benefit as much from it.\n\nAnother important aspect of deciding how useful ad-hoc polymorphism would be in a language is whether that language supports higher kinds (type families). Without higher kinds, your ability to abstract is limited, which lessens the value of ad-hoc polymorphism significantly. And since Kotlin doesn’t support higher kinds as of this writing, the importance of native support for ad-hoc polymorphism is questionable, or at least, certainly not as high a priority as other features.\n\nAt any rate, I have used the two techniques described above in my own code bases with reasonable benefit, so I hope they will be useful to others as well.\n\n","author":"Cédric Beust","date":"2016-06-20","type":"article","categories":["Kotlin"],"features":["highlightjs"],"description":"","filename":"","lang":"EN","enclosure":null},{"title":"Data Driven Testing with Spek ","url":"http://engineering.pivotal.io/post/spek-data-driven-tests/","body":"\nSeveral days ago, when we were developing a parser in Kotlin, we found ourselves copying and pasting series of tests with slight adjustments. This has become really annoying, especially when we thought of all the tests we would need to change every time the behaviour of our parser is going to change. As we have used Spock on previous projects, we wanted to replicate Spock's [Data Driven Testing](https://spockframework.github.io/spock/docs/1.0/data_driven_testing.html) approach in [Spek](https://jetbrains.github.io/spek/).\n\n## Spock Example\nBefore diving into the Kotlin exploration, let's quickly review the Spock interface for data driven testing. Spock provides means for defining easily readable tests, and even supports inclusion of test data into the test name using the `@Unroll` annotation:\n\n```groovy\n    @Unroll\n    def \"maximum of #a and #b is #c\"(int a, int b, int c) {\n        expect:\n            Math.max(a, b) == c\n\n        where:\n            a | b | c\n            1 | 3 | 3\n            7 | 4 | 4\n            0 | 0 | 0\n    }\n```\n\nThe definition above will yield three tests in the report:\n\n    maximum of 1 and 3 is 3 [PASS]\n    maximum of 7 and 4 is 4 [FAIL]\n    maximum of 0 and 0 is 0 [PASS]\n\nWhen the set of data is more complicated, a label can be included as part of the test data parameters:\n\n```groovy\n    @Unroll\n    def \"maximum of two numbers when #testLabel\"(String testLabel, int a, int b, int c) {\n        expect:\n            Math.max(a, b) == c\n\n        where:\n            testLabel                 | a | b | c\n            \"first number is bigger\"  | 4 | 1 | 4\n            \"second number is bigger\" | 0 | 5 | 5\n            \"numbers are equal\"       | 3 | 3 | 3\n    }\n```\n\n## Spek approach\nOriginally we would like to replicate the features of Spock interface as close as possible.\n\nIn Spek, as of version 1.0, all tests are defined within a lambda that is supplied as a constructor argument. This provides flexibility needed to replicate the RSpec DSL, but imposes limitations such as preventing the use of annotations.\n\n### Trusting your heroes\nFor the sake of this article, let's assume that we are writing a game in Kotlin, and we need to test the query methods in our `Hero` class that depend on the state our `Hero` is in. The state change can be triggered by calling an appropriate method, as per the skeleton defined below:\n\n```kotlin\nclass Hero() {\n    val isRunning: Boolean get() = false\n    val isStanding: Boolean get() = true\n    val isJumping: Boolean get() = false\n\n    fun run() {}\n    fun stand() {}\n    fun jump() {}\n}\n```\n\nIn contrast to the Spock example above, we need to run a series of tests for every state of the object. For every one of the four states (initial, running, standing and jumping), we would need to verify all three query methods. With Spock we would have to put the three assertions into a single test method.\n\n### First attempt\nOur first approach was to use lists of arbitrary objects to emulate the Spock `when` table. Then all our test blocks can be dynamically defined while iterating over those lists:\n\n```kotlin\nclass HeroTests: Spek({\n    describe(\"query methods\") {\n        listOf(\n            listOf(\"initial state\", false, false, true, Hero()),\n            listOf(\"when running\", false, false, true, Hero().apply { run() }),\n            listOf(\"when jumping\", false, false, true, Hero().apply { jump() }),\n            listOf(\"when standing\", false, false, true, Hero().apply { stand() })\n        ).forEach { test ->\n            describe(test.first) {\n                fun testLabel(flag: Boolean, action: String): String = \"${if (flag) \"should\" else \"shouldn't\"} be $action\"\n\n                it(testLabel(test[1], \"running\")) {\n                    expect(test[1]) { test[4].isRunning }\n                }\n\n                it(testLabel(test[2], \"walking\")) {\n                    expect(test[2]) { test[4].isWalking }\n                }\n\n                it(testLabel(test[3], \"jumping\")) {\n                    expect(test[3]) { test[4].isJumping }\n                }\n            }\n        }\n    }\n})\n```\n\nWhen running these tests, we can get a very nicely organized output:\n\n![HeroTests report](https://dl.dropboxusercontent.com/u/364765/hero-tests-report.png)\n\n> **Please note**\n>\n> Only the platform test runner should be used in IDEA to get meaningful test reports for Spek tests. At the time of writing, Gradle test runner output was pretty confusing and rather useless. For the test case above it reported 48 tests named \"classMethod\", and even though the stack trace for failed tests would indicate the point of failure, it is absolutely meaningless without knowledge of the failed iteration.\n\nWe now have a fine-grained output, and adding a new set of tests straight away is fairly simple and straightforward. However, it is difficult to keep track of the value types and meanings. And maintaining these tests could become difficult over time, especially when you need to restructure the test data.\n\n### Moving test data to a DTO\nIn order to improve clarity and maintainability, we can replace the list of arbitrary objects with a DTO. Additionally, we can move some test reporting helpers, such as test and test group name generators, into that DTO as well:\n\n```kotlin\ndata class HeroQueryTest(val state: String, val subject: Hero, val isRunning: Boolean, val isJumping: Boolean, val isStanding: Boolean) {\n    val runningTestLabel = testLabel(isRunning, \"running\")\n    val standingTestLabel = testLabel(isStanding, \"standing\")\n    val jumpingTestLabel = testLabel(isJumping, \"jumping\")\n    val testGroupLabel = \"when $state\"\n\n    private fun testLabel(condition: Boolean, action: String) = if (condition) \"should be $action\" else \"shouldn't be $action\"\n}\n```\n\nIn the code above, we could have used [introspection](https://kotlinlang.org/docs/reference/reflection.html) to derive the action string from the property name, but that would require to drag in the heavy `kotlin-reflect.jar`, which might not be needed otherwise. But just in case you were wondering, this is how it might look like:\n\n```kotlin\nimport kotlin.reflect.KProperty\n\ndata class HeroQueryTest(val state: String, val subject: Hero, val isRunning: Boolean, val isJumping: Boolean, val isStanding: Boolean) {\n    val runningTestLabel = HeroQueryTest::isRunning.testLabel(this)\n    val standingTestLabel = HeroQueryTest::isStanding.testLabel(this)\n    val jumpingTestLabel = HeroQueryTest::isJumping.testLabel(this)\n    val testGroupLabel = \"when $state\"\n\n    private val KProperty<Boolean>.action: String get() = this.name.substring(2).toLowerCase()\n    private fun KProperty<Boolean>.testLabel(owner: Any): String = if (this.getter.call(owner)) \"should be ${this.action}\" else \"shouldn't be ${this.action}\"\n}\n```\n\nRegardless of the internal implementation, we transform our test case, utilizing the newly defined DTO:\n\n```kotlin\nclass HeroTests : Spek({\n    describe(\"query methods\") {\n        listOf(\n                HeroQueryTest(\"created\", isRunning = false, isJumping = false, isStanding = true, subject = Hero()),\n                HeroQueryTest(\"running\", isRunning = true, isJumping = false, isStanding = false, subject = Hero().apply { run() }),\n                HeroQueryTest(\"jumping\", isRunning = false, isJumping = true, isStanding = false, subject = Hero().apply { jump() }),\n                HeroQueryTest(\"standing\", isRunning = false, isJumping = false, isStanding = true, subject = Hero().apply { stand() })\n        ).forEach { test ->\n            describe(test.testGroupLabel) {\n                it(test.runningTestLabel) {\n                    expect(test.isRunning) { test.subject.isRunning }\n                }\n\n                it(test.jumpingTestLabel) {\n                    expect(test.isJumping) { test.subject.isJumping }\n                }\n\n                it(test.standingTestLabel) {\n                    expect(test.isStanding) { test.subject.isStanding }\n                }\n            }\n        }\n    }\n})\n```\n\nThis looks much nicer - named arguments can be used to rearrange constructor arguments in a way that would make the \"table\" more readable. At the same time, named arguments are also used to avoid any confusion regarding the meaning of the test data. Not to mention that all of our actual test definitions became clearer and are much easier to follow.\n\n### Using a factory to configure the test subject\nIn real projects, configuring the subject may be much more complicated. In those cases, a factory object can be used to isolate that complexity, and to provide a readable name for the configured object:\n\n```kotlin\nobject HeroFactory {\n    val default: Hero get() = Hero()\n    val running: Hero get() = Hero().apply { run() }\n    val standing: Hero get() = Hero().apply { stand() }\n    val jumping: Hero get() = Hero().apply { jump() }\n}\n```\n\nrendering our test \"table\" even more readable:\n\n```\n    HeroQueryTest(\"created\", isRunning = false, isJumping = false, isStanding = true, subject = HeroFactory.default),\n    HeroQueryTest(\"running\", isRunning = true, isJumping = false, isStanding = false, subject = HeroFactory.running),\n    HeroQueryTest(\"jumping\", isRunning = false, isJumping = true, isStanding = false, subject = HeroFactory.jumping),\n    HeroQueryTest(\"standing\", isRunning = false, isJumping = false, isStanding = true, subject = HeroFactory.standing)\n```\n\n### Improving the factory\nWe can go even a bit further, and combine the state label with the configured subject in the factory, returning an instance of a DTO holding both the state label and the subject. This approach is, of course, specific to the particular use case:\n\n```kotlin\ndata class ConfiguredHero(val subject: Hero, val stateLabel: String)\n\nobject HeroFactory {\n    val default: ConfiguredHero get() = ConfiguredHero(Hero(), \"created\")\n    val running: ConfiguredHero get() = ConfiguredHero(Hero().apply { run() }, \"running\")\n    val standing: ConfiguredHero get() = ConfiguredHero(Hero().apply { stand() }, \"standing\")\n    val jumping: ConfiguredHero get() = ConfiguredHero(Hero().apply { jump() }, \"jumping\")\n}\n\ndata class HeroQueryTest(val configuration: ConfiguredHero, val isRunning: Boolean, val isJumping: Boolean, val isStanding: Boolean) {\n    val state = configuration.stateLabel\n    val subject = configuration.subject\n    // the remaining implementation remains untouched\n}\n```\n\nUsing this configuration makes our test definitions tidier than ever, while retaining the granularity of feedback we had on our first iteration:\n\n```\n    HeroQueryTest(HeroFactory.default, isRunning = false, isJumping = false, isStanding = true),\n    HeroQueryTest(HeroFactory.running, isRunning = true, isJumping = false, isStanding = false),\n    HeroQueryTest(HeroFactory.jumping, isRunning = false, isJumping = true, isStanding = false),\n    HeroQueryTest(HeroFactory.standing, isRunning = false, isJumping = false, isStanding = true)\n```\n\n## Spock test revisited\nLet's define the Spock example from the beginning of this article using our approach:\n\n```kotlin\nclass MathTests : Spek({\n    data class MaxTest(val a: Int, val b: Int, val c: Int)\n    describe(\"max\") {\n        listOf(\n                MaxTest(a = 1, b = 3, c = 3),\n                MaxTest(a = 7, b = 4, c = 4),\n                MaxTest(a = 0, b = 0, c = 0)\n        ).forEach { test ->\n            it(\"calculates maximum of ${test.a} and ${test.b} as ${test.c}\") {\n                expect(test.c) { Math.max(test.a, test.b) }\n            }\n        }\n    }\n})\n```\n\nThis test case is only one line longer than the original, readable and maintainable, but feels more cluttered.\n\nLet's see if we can implement an approximation of the pipe syntax. Since | is unavailable as a function name, we can use the uppercase `I` instead:\n\n```kotlin\n    infix fun Int.I(other: Int): List<Int> = listOf(this, other)\n    infix fun List<Int>.I(other: Int): List<Int> = this + listOf(other)\n```\n\nThis way we could define our data table by listing numbers separated by `I`s. The resulting list should be fed into a factory to produce our DTO:\n\n```kotlin\n        fun maxTest(values: List<Int>): MaxTest = MaxTest(values[0], values[1], values[2])\n```\n\non the result of which we can call `apply` to get rid of all of the `test.` prefixes. This is the final form of the test case:\n\n```kotlin\nclass MathTests : Spek({\n    class MaxTest(val a: Int, val b: Int, val c: Int)\n    fun maxTest(values: List<Any>): MaxTest = MaxTest(values[0] as Int, values[1] as Int, values[2] as Int)\n    infix fun Any.I(other: Any): List<Any> = listOf(this, other)\n    infix fun List<Any>.I(other: Any): List<Any> = this + listOf(other)\n\n    describe(\"max\") {\n        listOf(\n                1 I 3 I 3,\n                7 I 4 I 4,\n                0 I 0 I 0\n        ).forEach { data ->\n            maxTest(data).apply {\n                it(\"calculates maximum of $a and $b as $c\") {\n                    expect(c) { Math.max(a, b) }\n                }\n            }\n        }\n    }\n})\n```\n\nAlthough the data table now looks cleaner, and has become generic, it has lost it's labels, and the indentation won't be maintained by the IDE, as is the case with Spock. The latter means that in reality this table will become an unreadable mess, meaning that we'd be better off with the DTO constructor using labelled arguments.\n\n# Conclusion\nAlthough we were unable to fully replicate the simplicity of Spock's data tables, the end result became more flexible and powerful. We have discovered a way to create clean and maintainable data-driven tests with Spek, and even made one row in our data \"table\" generate several named assertions.\n\nThe shortest implementation can be made by using lists of arbitrary objects to hold the test data, but it would be hard to maintain. By introducing a few DTOs and a factory object, we have been able to increase both usability and maintainability of the test suite. And although the DTOs are tightly coupled to the test, the factory could be easily reused elsewhere in the test suite. Even so, the size of the whole test case is still kept under 50 lines of code, as opposed to a hundred lines of duplicated unmaintainable test code for the regular, non-data-driven approach.\n\n\n","author":"Konstantin Semenov","date":"2016-07-03","type":"article","categories":["Kotlin","Testing"],"features":["highlightjs"],"description":"","filename":"","lang":"EN","enclosure":null},{"title":"Gradle Elevates the Build to First-Class Programming With Kotlin Language","url":"http://www.businesswire.com/news/home/20160517006230/en/Gradle-Elevates-Build-First-Class-Programming-Kotlin-Language","body":"\n## Alliance between Gradle Inc. and JetBrains makes the Build a first-class citizen in Software Development\n\nSAN FRANCISCO--([BUSINESS WIRE](http://www.businesswire.com/))--Gradle Inc. today announced an alliance with JetBrains to provide a Kotlin-based Build Programming Language for Gradle, the popular open source build automation software.\n\n> Build programming is advanced engineering— @Gradle @JetBrains alliance promotes @Kotlin-based builds #ElevateBuilds\n\nWhy is this important? Historically, build automation has relied on simplistic shell scripts or inflexible XML files. This no longer works. In the age of Continuous Delivery and DevOps, builds have become a full-fledged engineering discipline. Today, a product’s build is mission-critical; it automates and assembles, connects, tests, packages and—in many cases—deploys or ships that product. As such, the design, implementation and maintainability of build code demands first-class treatment. Today, Gradle is taking the next step in elevating the discipline of build automation by supporting writing Gradle builds in Kotlin—a modern, pragmatic, and statically-typed language developed by JetBrains. The result for Gradle users will be best-in-class usability and performance, and deep IDE support in IntelliJ IDEA and Eclipse—including refactoring, symbol navigation, code completion and content assist.\nWhy is this important? Historically, build automation has relied on simplistic shell scripts or inflexible XML files. This no longer works. In the age of Continuous Delivery and DevOps, builds have become a full-fledged engineering discipline. Today, a product’s build is mission-critical; it automates and assembles, connects, tests, packages and—in many cases—deploys or ships that product. As such, the design, implementation and maintainability of build code demands first-class treatment. Today, Gradle is taking the next step in elevating the discipline of build automation by supporting writing Gradle builds in Kotlin—a modern, pragmatic, and statically-typed language developed by JetBrains. The result for Gradle users will be best-in-class usability and performance, and deep IDE support in IntelliJ IDEA and Eclipse—including refactoring, symbol navigation, code completion and content assist.\n\n“JetBrains is widely respected for their excellent products.” said Hans Dockter, CEO and founder of Gradle Inc. “This alliance is based on mutual technical admiration and a common goal to place the most effective tools in the hands of developers.”\n\nBuild programming is an advanced engineering discipline— @Gradle @JetBrains alliance promotes @Kotlin-based builds #ElevateBuilds\n\n**Modern Build Infrastructure, Largest Community**\n\nA majority of enterprises are already using Gradle to build and deliver mission-critical software written in dozens of programming languages and platforms including Java, Android, C, C++, Python, Kotlin, Groovy, Scala, Hadoop and many more. Gradle is the new market leader for build automation, with 10.4 million direct downloads in 2015, and is growing fast with nearly 2 million new direct downloads per month in 2016. Because Gradle is a core part of Google’s Android Studio IDE (based on JetBrains’ IntelliJ IDEA), virtually every Android developer also uses Gradle. The fact that Google chose both JetBrains and Gradle Inc. for Android tooling further validates IntelliJ IDEA and Gradle as world-class technologies.\n\n“The ultimate goal of Kotlin is to make developers' lives easier, and we’re excited to partner with a great product like Gradle on this mission.” said Andrey Breslav, Kotlin team lead at JetBrains. “Together we’ll create a unique experience to the benefit of Gradle’s many users.”\n\n**Advanced Customers Lead the Way**\n\nMobile, SaaS, IoT and Container technologies along with modern DevOps practices have transformed the requirements for modern build systems. With the DevOps and Continuous Delivery age producing more and more complex automation requirements on the build, there is an increased need to see build code as first-class, performance optimized software—an enterprise asset as opposed to a collection of scattered, convenience scripts.\n\n“We are building the future of software delivery for all enterprises by working closely and at a large scale with some of the best software teams in the world.” said Adam Murdoch, CTO and co-founder of Gradle Inc. “We see these teams increasing their investment in scaling up their automation pipeline to improve their ability to deliver software.”\n\nWith organizations running tens of thousands of builds a day, having a fast, maintainable, extensible build is required to be successful. Since build code has become a first-class citizen in software, the need for a statically-typed, elegant, high-performing build language with deep IDE integration led Gradle to embrace Kotlin.\n\n**Learn More at Gradle Summit 2016**\n\nLearn more about this development and much more at the Continuous Delivery conference of the year, Gradle Summit 2016 in Palo Alto CA June 23-24th. You can win a free ticket at [http://gradle.org](http://cts.businesswire.com/ct/CT?id=smartlink&url=http%3A%2F%2Fgradle.org&esheet=51343942&newsitemid=20160517006230&lan=en-US&anchor=http%3A%2F%2Fgradle.org&index=1&md5=0a36f28ca4ba005bd64f525e4c278adf).\n\n**About Gradle**\n\nGradle Inc. is a Silicon Valley startup whose mission is to transform how software is built and shipped. Gradle Inc. develops, distributes and supports the Gradle Platform—consisting of the popular Gradle open source build tool and Gradle.com commercial SaaS service. With approximately 2 million downloads per month, Gradle is the most popular build automation system world-wide. Powered by a unique Build Programming Language, Gradle also boasts an ecosystem with over eight hundred plugins supporting all facets of software development and deployment. Gradle is at the heart of the Continuous Delivery pipelines of some of the most advanced software companies in the world including LinkedIn, Netflix, Unity Technologies and many more. Gradle helps enterprises ship software faster, with fewer defects, and more continuously by unifying and automating build processes. Gradle Inc. also provides training, consulting and support for its customers. Our motto is “Build Happiness”. Learn more at [gradle.org](http://cts.businesswire.com/ct/CT?id=smartlink&url=http%3A%2F%2Fgradle.org&esheet=51343942&newsitemid=20160517006230&lan=en-US&anchor=gradle.org&index=2&md5=3e96189fc8c662c318c35dfc5645b553) and follow us on Twitter at [@Gradle](http://cts.businesswire.com/ct/CT?id=smartlink&url=http%3A%2F%2Ftwitter.com%2Fgradle&esheet=51343942&newsitemid=20160517006230&lan=en-US&anchor=%40Gradle&index=3&md5=83692a7d6b9a8e7968410ff7e19a8df2).\n\n**About JetBrains**\n\nJetBrains s.r.o. is a technology-leading software development firm specializing in the creation of intelligent, productivity-enhancing software. It maintains its headquarters in Prague, Czech Republic, with its R&D labs located in St. Petersburg, Moscow, Munich and Boston. JetBrains employs over 600 people and is organically grown. Its product catalogue includes award-winning tools such as IntelliJ IDEA and ReSharper, and its IntelliJ Platform has been chosen by variety of companies to build their own tooling on, including Google's Android Studio. For more information, see [www.jetbrains.com](http://cts.businesswire.com/ct/CT?id=smartlink&url=https%3A%2F%2Fwww.jetbrains.com%2F&esheet=51343942&newsitemid=20160517006230&lan=en-US&anchor=www.jetbrains.com&index=4&md5=b00800605a6efcea3b36eed88b76c699).\n\n","author":"BusinessWire","date":"2016-05-17","type":"article","categories":["Kotlin","Gradle"],"features":["highlightjs"],"description":"","filename":"","lang":"EN","enclosure":null},{"title":" Experimental status of coroutines in 1.1 and related compatibility concerns","url":"https://discuss.kotlinlang.org/t/experimental-status-of-coroutines-in-1-1-and-related-compatibility-concerns/2236","body":"\nAs [you know](https://blog.jetbrains.com/kotlin/2017/01/kotlin-1-1-beta-is-here/), Kotlin 1.1 will be shipping with [coroutines](https://github.com/Kotlin/kotlin-coroutines/blob/master/kotlin-coroutines-informal.md) as an experimental feature, and will require an opt-in compiler switch to enable them.\n\nThis post seeks to do the following:\n\n* Explain our motivation to not release coroutines unconditionally;\n* Explain our plans regarding compatibility of coroutines in future versions of Kotlin;\n* Ask your opinion about the overall approach and some particular aspects of it (scroll to the bottom if you only want to share your opinion ;)).\n\n## Why coroutines are experimental in Kotlin 1.1\n\nWe believe that it is a very important feature, because it opens a door on a whole new style of programming: asynchronous, non-blocking code with straightforward structure. And we believe that we have a very good design there: few built-in things, a lot of flexibility, clear mental model, good performance where it matters.\n\nNevertheless we are not too eager to say that this design is _final_. We understand that the whole area of asynchronous programming is relatively new (to the main stream at least), and the experience that other languages got before us (from Scheme and Go to C# and Dart) is not necessarily applicable to Kotlin, because of many subtle and not-so-subtle differences. Overall, it's largely unknown how people might use coroutines, what turns out to be most important and even what use cases that we didn't think of are out there. Of course, one can't expect to know all use cases upfront, so it's a matter of intuition/expert opinion as for when we have enough. We collected as much information as we could, did some extensive prototyping, wrote [different libraries](https://github.com/Kotlin/kotlinx.coroutines), and we feel it's more of a terra incognita at the moment.\n\nSo, coroutines are experimental in 1.1, because we expect the design to change.\n\nNote that it's not the implementation bugs we worry about: there will be bugs, and we'll fix them as usual, but overall we think that coroutines are in a good shape implementation-wise.\n\n## Why release coroutines at all\n\nNormally, when a feature is not ready, we don't release it at all. We keep it in our language design back yard until we're reasonably sure it's good enough to get into the language. So, why include an experimental feature in 1.1?\n\nThe reason is: it's too big for our back yard :) This is to say: we did all we could do internally, but the feature is too multifaceted in its possible applications to be released without an extensive battle-testing outside our team.\n\nSo, we need your feedback and we need it as diverse as possible. This is why we make coroutines available to anyone, but give a fair warning that the design may change. (An opt-in switch `-Xcoroutines=enable` will remove the warning.) We want people to use them and communicate their use cases, issues and ideas back to us. The more coroutine-based code is written out there, the sooner we can adjust the design and get to the final version of it.\n\nAnd, honestly, it's also a bit too good to be kept in the back yard :) Very many people can benefit from coroutine-based APIs and libraries today, an this aligns nicely with what's said above: the more you benefit, the more we can learn about your use cases and needs. We expect that very many of you will find their use cases already covered just fine in 1.1, but those who don't will give us valuable feedback.\n\n## What may change in future versions\n\nI, personally, think that everyone should grab and use coroutines as soon as 1.1 comes out, and the readers of this forum should probably start as soon as yesterday :) But some of us may be concerned with the possible changes coming in future versions of Kotlin that may pose some migration difficulties. Here, I'll try to give an honest account of what we expect to change and below I explain how we are going to mitigate the possible compatibility issues. (If it's too scary for your setting, you may want to keep the coroutines out of your project until they graduate the experimental status.)\n\nWhen it comes to compatibility, there are two large groups of concerns: source compatibility and binary compatibility.\n\nSource compatibility is somewhat less of a concern, because if you have the source that used to compile in version X, but fails to compile in version Y, then all you need to do is fix it, and we have a very positive experience in providing you with tools that do that automatically (or almost automatically). So, what may break in our source code? We do not expect the language syntax to change, it's too little syntax, after all. But we think that **the core APIs may change**.\n\nBinary compatibility is usually harder: when you have a binary, you often do not control the source (or it's too costly for you to fix the source and build a new binary). So, what may change in our binaries? Well, the same **core APIs affect the binaries** as well as source, plus we may need to change **something in the ABI**, i.e. how we represent coroutines in the byte code.\n\n## How we plan to make it relatively easy to upgrade to the final design\n\nActually, I think, we have a pretty good plan for how to both extensively use coroutines now and avoid much pain later:\n\n1. On the source/API level we will simply use the usual _deprecate-migrate-remove cycle_, which has proven pretty smooth with the help of our `ReplaceWith` functionality in the IDE\n2. Also, the newer compilers will keep supporting the experimental design for a while\n    a. For a while they will understand binaries produced by 1.1 and generate correct calls to them\n    b. With a compiler switch `-language-version=1.1` they will emit code as 1.1 does\n3. On the binary level we are going to simply _keep the experimental APIs in a separate package_. This is the way that, for example, JUnit and Rx used when rolling out radically new APIs.\n\nSo, all the APIs related to coroutines in `kotlin-stdlib` will ship in a package named `kotlin.coroutines.experimental` (or maybe we find some better name, see below). When the final design is ready, we'll publish it under `kotlin.coroutines`, and keep the old binaries compatible and working. We can remove the experimental package later on (after waiting a considerable time to give everybody a change to migrate), or rather move it to a separate artifact so that everyone can use it at any time if they have to.\n\n**An important thing is**: _every library that uses coroutines in its public API should do the same_. I.e. if you are writing a library that it here to stay, so you care about the users of your future versions, you will also need to name your package something like `org.my.library.experimental`. And when the final design of coroutines comes, drop the “experimental” suffix from the main API, but keep the old package around for those of your users who might need it for binary compatibility.\n\nWe realize that there are some settings under which nothing is acceptable but 100% backward compatibility, no bargaining allowed, but we expect these to be a minority of our users.\n\n**So, the big question to you**: does this plan sound reasonable? Do you think we can improve on it?\n\n## Some bikeshedding questions\n\nNow, let the [bikeshedding](https://en.wikipedia.org/wiki/bikeshedding) begin :) We are not running a democratic procedure here, but your opinions and arguments will help us a lot.\n\n**Question number one**: what suffix should be used for those experimental packages?\n\n* `experimental` is very clear, but looks a bit long, so do `incubation` and `tentative`.\n    * Consider: `kotlin.coroutines.experimental`, `org.my.library.experimental.async`\n* Among shorter options, we are looking at `probe` and `pilot`. How do you feel about these?\n    * Consider: `kotlin.coroutines.pilot`, `org.my.library.pilot.async`\n\nA note about another option: we considered using something like “v0” as a suffix: `kotlin.coroutines.v0`, but there are two downsides:\n\n* it sort of suggests that there will be v1, v2, etc, which we are not planning to have;\n* it may look weird in your library whose version is, e.g. 1.5.\n\n**Question number two**: would it be better to put the experimental API in a separate JAR file?\n\nCurrently we are planning to ship the experimental package in the `kotlin-stdlib.jar` (`kotlin-runtime.jar` in the compiler distribution), and it will be possible to move it to another JAR later. We are on the fence on this, so your opinions are welcome.\n\n_Thanks for your time. Your input is very welcome!_\n","author":"Andrey Breslav","date":"2017-01-20","type":"article","categories":["Kotlin"],"features":["highlightjs"],"description":"","filename":"","lang":"EN","enclosure":null},{"title":"Early Impressions of Kotlin","url":"http://natpryce.com/articles/000815.html","body":"\nWe’ve been using the [Kotlin](https://kotlinlang.org) programming language for a few weeks on our latest project to perform technical experiments, explore the problem space, and write a few HTTP services. I’ve also ported [Hamcrest](https://github.com/hamcrest/JavaHamcrest) to Kotlin, as [HamKrest](https://github.com/npryce/hamkrest), to help us write tests, and written a small library for [type safe configuration](https://github.com/npryce/konfig) of our services.\n\n## Why Kotlin?\n\nThe organisation I’m working with has mature infrastructure for deploying JVM services in their internal [PaaS](https://en.wikipedia.org/wiki/Platform_as_a_service) cloud. They use a mix of Java and Scala but have found Scala builds too slow. Watching my colleague struggle to use Java 8 streams to write what should have been basic functional map-and-fold code, I decided to have a look at some other “post-Java” JVM languages.\n\nWe wanted a typed language. We wanted [language aware editing](http://c2.com/cgi/wiki?LanguageAwareEditor). And we wanted a language that had an organisation behind its development and enough people using it that we could get questions answered, even the stupid ones we’d be likely to ask while learning.\n\nThat eliminated dynamically typed languages ([Groovy](http://www.groovy-lang.org/), [JavaScript](http://openjdk.java.net/projects/nashorn/), [Clojure](http://clojure.org/)) and languages that are less popular or have small, informal development teams behind them ([Xtend](http://www.eclipse.org/xtend/index.html), [Gosu](https://gosu-lang.github.io/), [Fantom](http://fantom.org/), [Frege](https://github.com/Frege/frege), etc.). In the end it came down to Red Hat’s [Ceylon](http://ceylon-lang.org/) and JetBrains’ [Kotlin](https://kotlinlang.org). Of the two, Ceylon is the most innovative, and therefore (to me, anyway) the most interesting, but Kotlin met more of our criteria. Kotlin has a more active community, is being used for commercial development by JetBrains and a number of other companies[<sup>1</sup>](#fn1), has good editing support within [IntelliJ](http://www.intellij.com), has an active community on social media, and promises easy interop with existing Java libraries.\n\n## Good points\n\nKotlin was very quick to learn. Kotlin is a conservative increment to Java that smooths off a lot of Java’s rough edges. Kotlin is small and regular, with few special cases and gotchas to learn. In many ways it feels a bit like a compiled, typed Python with curly brace syntax.\n\nThe type system is a breath of fresh air compared to Java. Type inferencing makes code less cluttered. There is no distinction between primitive & reference types. Generics and subtyping work together far better than Java: the type system uses [declaration site variance](https://kotlinlang.org/docs/reference/generics.html#declaration-site-variance), not [use site variance](https://docs.oracle.com/javase/tutorial/java/generics/bounded.html), and variance does not usually have to be specified at all for functions. You never have unavoidable compiler warnings, as you do with Java’s type system.\n\nFunctional programming is more convenient in Kotlin than Java. You can define free-standing functions and constants at the top level of a module, instead of having to define them in a [“Utils” class](https://en.wikipedia.org/wiki/Utility_class). Function definitions can be nested. There is language support for immutable value types (aka “[data classes](https://kotlinlang.org/docs/reference/data-classes.html)”) and algebraic data types (“[sealed classes](https://kotlinlang.org/docs/reference/classes.html#sealed-classes)”). Null safety is enforced by the type system and variables and fields are non-nullable by default. The language defines standard function types and a lambda syntax for anonymous functions.\n\nYou can define [extension methods](https://kotlinlang.org/docs/reference/extensions.html) on existing types. They are only syntactic sugar for free-standing functions, but nevertheless can lead to more concise, expressive code. The Kotlin standard library defines a number of useful extension methods, especially on the Iterable and String types.\n\nKotlin supports, and carefully controls, [operator overloading](https://kotlinlang.org/docs/reference/operator-overloading.html). You can overload operators that act as functions (e.g. arithmetic, comparison, function call) but not those that perform flow control (e.g. short-cut logical operators). You cannot define your own operators, which will stop me going down the rabbit hole of “ascii-art programming”, which I found hard to resist when writing Scala.\n\n[Class definitions](https://kotlinlang.org/docs/reference/classes.html) require a lot less boilerplate than in Java. Using old fashioned getter-and-setter style Java code is made more convenient by [language support for bean properties](https://kotlinlang.org/docs/reference/properties.html).\n\n[Anonymous extension methods](https://kotlinlang.org/docs/reference/lambdas.html#function-literals-with-receiver) (borrowed from Groovy, I believe) make [domain specific embedded languages](https://kotlinlang.org/docs/reference/type-safe-builders.html) easier to write. Method chaining builder APIs are unnecessary in Kotlin and more awkward than using the [apply](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/apply.html) function to set properties of an object.\n\nKotlin has a philosophy of preferring behaviour to be explicitly specified. For example, there is no automatic coercion between numeric types, even from low to high precision. That means you have to explicitly convert from Int to Long, for example. I like that, but I expect some people will find it annoying.\n\n## Surprises\n\n### I didn’t miss destructuring pattern match\n\nKotlin doesn’t have destructuring pattern match & language support for tuples. [A limited form of destructuring](https://kotlinlang.org/docs/reference/multi-declarations.html) can be used in for loops and assignments. The [when expression](https://kotlinlang.org/docs/reference/control-flow.html#when-expression) is an alternative conditional expression that doesn’t do destructuring.\n\nI was surprised to find that I didn’t really miss destructuring. Without tuples you have to use data classes with named fields. The flow-sensitive typing then works rather well where destructuring would be necessary in a language where the type system is not flow-sensitive. For example:\n\n```kotlin\nsealed class Result<out T> {\n   class Success<T>(val value: T) : Result<T>()\n   class Failure(val exception: Throwable): Result<Any>()\n}\n\n...\n\nval e : Result<String> = doSomething()\nif (e is Result.Success<String>) {\n    // e is known to be a Result.Success<String> and\n    // can be used as such without a downcast\n    println(e.value)\n}\n```\n\n### Sealed classes cannot be data classes\n\nAn algebraic data type cannot be be a data class, so you have to write equals, hashCode, etc. yourself. This is a surprising omission, since I always want an algebraic data type to be a value type. The Kotlin developers say that this will be fixed after version 1.0 is released.\n\n### Functions are not quite first-class objects\n\nThere’s a difference between f1 and f2 below:\n\n```kotlin\nval f1 = {i:Int -> i+1}\nfun f2(i:Int) = i + 1\n```\n\nCode can refer to the value of `f1` directly, but must use the “::” operator to obtain a reference to `f2`:\n\n```kotlin\nval f = ::f2\n```\n\n### Null safe operators push me to write more extension functions\n\nThe null safe operators (`?.` and `?:`) only help when dereferencing a nullable reference. When you have a nullable reference and want to pass a value (if it exists) to a function as a parameter, you have to use the awkward construct:\n\n```kotlin\nnullableThing?.let{ thing -> fn(thing, other, parameters) }\n```\n\nI find myself refactoring my functions to extension functions to reduce the syntactic noise, letting me rewrite the code above as:\n\n```kotlin\nnullableThing?.fn(other, parameters)\n```\n\nIs that a good thing? I’m not sure. Sometimes it feels a little forced.\n\n### Companion objects\n\nKotlin borrows the concept of [companion objects](#companion-objects) from Scala. Why can’t classes be objects? Perhaps it’s a limitation of the JVM but compared to, say, Python, it feels clunky.\n\n## Frustrations\n\nI only have a couple of frustrations with Kotlin.\n\n### Lack of polymorphism\n\nOperators and the for loop are syntactic sugar that desugar to method calls. The methods are invoked statically and structurally — the target does not need to implement an interface that defines the method.\n\nFor example, `a + b` desugars to `a.add(b)`. However, there’s no way to write a generic function that sums its parameters, because `add` is not defined on an interface that can be used as an upper bound.\n\nThere’s no way to define the following function for any type that has an add operator method.\n\n```kotlin\nfun <T> sum(T first, T second) : T = first + second\n```\n\nYou would have to define overloads for different types, but then wouldn’t be able to call `sum` within a generic function.\n\n```kotlin\nfun sum(first: Int, second: Int) = first + second\nfun sum(first: Long, second: Long) = first + second\nfun sum(first: Double, second: Double)= first + second\nfun sub(first: Matrix<Double>, second: Matrix<Double>)= first + second\nfun sum(first: Money, second: Money)= first + second\n...\n```\n\nThat kind of duplication is what generics are meant to avoid!\n\nExtension methods are also statically bound. That means you cannot write a generic function that calls an extension method on the value of a type parameter.\n\nFor example, the standard library defines the same extension methods on unrelated types — `forEach`, `map`, `flatMap`, `fold`, etc. But there is no concept of, for example, “mappable” or “foldable”. Nor is there a way of defining such a concept and applying it to existing types to allow you to write generic functions over unrelated types. Kotlin doesn’t have [higher kinded types](https://en.wikipedia.org/wiki/Kind_(type_theory)) that would let you express this kind of generic function or [type classes](https://en.wikipedia.org/wiki/Type_class) that would let you add polymorphism without modifying existing type definitions.\n\nCompared to [Rust’s traits](https://doc.rust-lang.org/book/traits.html), which support extension methods, operator overloading, type classes for parametric polymorphism, _and_ interfaces for subtype polymorphism, Kotlin’s monomorphic extension methods and operator overloading are quite limited and do not help refactor duplicated logic.\n\nHowever, for typical monomorphic, procedural Java code this is probably not an issue.\n\n### Optionality is a Special Case\n\nKotlin’s support for nullable types is implemented by a special case in the type system and special case operators that only apply to nullable references. The operators do not desugar to methods that can be implemented for other types. For example, `optionalThing?.foo` can be considered a map of the function `{thing -> thing.foo}` over the option `optionalThing`. If `foo` itself is nullable, then it can be considered a flatMap. But the expressions do not desugar to `map` and `flatMap` And if you want to map or flatMap a function, you have to use a different syntax: `optionalThing?.let(theFunction)`.\n\nFor typical Java code, which is monomorphic and uses null references with wild abandon, language support for nullability is invaluable. But I would find it more convenient if it could be used polymorphically, or if Kotlin used a common naming convention for optional and other functor types.\n\nNull safety is not enforced when you interop with Java code. And you do that a lot. Kotlin doesn’t have many libraries or much of a runtime and makes it easy to call existing Java libraries directly. Kotlin expects you to know what you’re doing with respect to null references when calling Java code, and doesn’t force you to treat every value returned from Java as nullable. As a result, null safety is a bit of an illusion in a lot of our Kotlin code and it has come back to bite us.\n\n## Conclusion\n\nThe code we’ve been writing has been a mix of coordinating and piping data between existing Java libraries – Apache HTTP client, Undertow HTTP server, JDBC, Sesame, JSON and XML parsers, and so on – and algorithmic code that analyses human readable text. For that kind of work, Kotlin has been very useful. The Kotlin code is far more concise than the equivalent Java. In our domain models and algorithmic code, Kotlin’s type safety and especially null safety, has been a big help.\n\nExactly how happy we’ve been with Kotlin has depended on the design style of the code we’re writing:\n\nFor functional programming, Kotlin has occasionally been frustrating, because we cannot use parametric polymorphism to factor out duplicated logic as much as we’d like.\n\nFor object-oriented programming, Kotlin’s concise syntax for class definitions and [language support for delegation](https://kotlinlang.org/docs/reference/delegation.html) avoids a lot of Java’s boilerplate.\n\nHowever, most Java out there is monomorphic, procedural code moving data between “[NOJOs](http://puttingtheteaintoteam.blogspot.co.uk/2008/10/is-that-pojo-or-nojo.html)” and APIs that expect objects to have “bean” getters and setters. Kotlin has made working with that kind of API much easier and far more concise than doing so in Java.\n\n1.  As far as I can tell, RedHat sponsor development of Ceylon but do not actually use it to develop their own products. If I’m wrong, please let me know in the comments.[↩](#fnref1)\n","author":"Nat Pryce","date":"2015-12-30","type":"article","categories":["Kotlin"],"features":["highlightjs"],"description":"","filename":"","lang":"EN","enclosure":null},{"title":"Kotlin 1.1 Event in Your City","url":"https://blog.jetbrains.com/kotlin/2017/03/kotlin-1-1-event-in-your-city-2/","body":"\nWe are holding the [Kotlin 1.1 event on March 23][]. Tune in to the live stream [at JetBrains TV][] and see **Andrey Breslav’s demo presentation** about the key features of Kotlin 1.1, including coroutines, JavaScript back-end and more.\n\nStart tweeting your questions today and get answers during the **Q&A session live stream** on March 23. Use the hashtag \\#kotlinqa.\n\nWe hold 2 live streams to accommodate different time zones. See **the detailed schedule and guidelines** [in the blogpost][Kotlin 1.1 event on March 23].\n\nCheck if there is a **Kotlin 1.1 event in your city**. If you don’t find a local community event, join the live stream individually.\n\n[![Kotlin 1.1 event map](https://i1.wp.com/blog.jetbrains.com/kotlin/files/2017/03/Kotlin_1_1event_map.png?resize=640%2C451&ssl=1)](http://kotlinlang.org/community/talks.html?time=kotlin)\n\nPlease note that the time of the live stream for the US has been changed to PDT time. The first live stream will start at 9 am PDT and the second at 11 am PDT.\n\n[Kotlin 1.1 event on March 23]: https://blog.jetbrains.com/kotlin/2017/03/kotlin-1-1-event-2/#more-4726\n[at JetBrains TV]: http://jb.gg/kotlinevent1_1\n","author":"Alina Dolgikh","date":"2017-03-21","type":"article","categories":["Kotlin"],"features":["highlightjs"],"description":"","filename":"","lang":"EN","enclosure":null},{"title":"The Journey of a Spring Boot application from Java 8 to Kotlin, part 3: Data Classes","url":"http://engineering.pivotal.io/post/spring-boot-kotlin-data-classes/","body":"\nWelcome to the third installment of our Java 8 -> Kotlin conversion for a Spring Boot application. [Last time](/post/spring-boot-configuration-in-kotlin/) we saw how converting a configuration class to Kotlin helped clean up some of the boilerplate code required in Java.\n\nIn this third installment, we are going to continue our theme of \"write less code with Kotlin\" and look at how [Kotlin data classes](https://kotlinlang.org/docs/reference/data-classes.html) help us clean up our POJOs data classes.\n\nOur [starting point](https://github.com/mikegehard/user-management-evolution-kotlin/blob/83883fee6dac3cb06e10bd6a510403cbe3e1ef62/components/email/src/main/java/com/example/email/EmailMessage.java) is a plain old Java object (POJO) to hold some data to be sent via RabbitMQ:\n\n```kotlin\npackage com.example.email;\n\nimport java.io.Serializable;\n\npublic class EmailMessage implements Serializable {\n\n    private final String toAddress;\n    private final String subject;\n    private final String body;\n\n    public EmailMessage(String toAddress, String subject, String body) {\n        this.toAddress = toAddress;\n        this.subject = subject;\n        this.body = body;\n    }\n\n    public String getToAddress() {\n        return toAddress;\n    }\n\n    public String getSubject() {\n        return subject;\n    }\n\n    public String getBody() {\n        return body;\n    }\n}\n\n```\n\nHere is the [same class](https://github.com/mikegehard/user-management-evolution-kotlin/blob/f137c5ec25a2a575c30113a3260f55af6d0285ed/components/email/src/main/kotlin/com/example/email/EmailMessage.kt) implemented as a [Kotlin data class](https://kotlinlang.org/docs/reference/data-classes.html):\n\n```kotlin\npackage com.example.email\n\nimport java.io.Serializable\n\ndata class EmailMessage(val toAddress: String, val subject: String, val body: String) : Serializable\n\n```\n\nNot only is this code much shorter than it's Java counterpart, it also has more functionality. As a Kotlin data class, this tiny amount of code gets:\n\n* generated implementations for a `equals()/hashCode()` pair\n* a default `toString()` method\n* a `copy()` method that allows for easy altering of individual attributes of the object\n* the ability to [destructure](https://kotlinlang.org/docs/reference/data-classes.html#data-classes-and-destructuring-declarations) the object in an assignment statement.\n\nOther places this feature will come in handy is with [JSON deserialization](https://spring.io/blog/2016/02/15/developing-spring-boot-applications-with-kotlin#jackson-kotlin-module) and [Spring Data JPA classes](https://spring.io/blog/2016/02/15/developing-spring-boot-applications-with-kotlin#jackson-kotlin-module).\n\nAs someone evaluating a switch from Java to Kotlin, these data classes are a major reasons for adopting Kotlin in your Spring Boot application. They help you write, and thus maintain, less code and the less code we have to maintain the better in my mind.\n\n","author":"Mike Gehard","date":"2016-02-29","type":"article","categories":["Spring Boot","Kotlin"],"features":["highlightjs"],"description":"","filename":"","lang":"EN","enclosure":null},{"title":"Kotlin : Retrofit + RxAndroid + Realm","url":"https://medium.com/@ahmedrizwan/kotlin-retrofit-rxandroid-realm-39d7be5dc9dc#.w7ufbebxh","body":"\n### Kotlin : Retrofit + RxAndroid + Realm\n\nIn this article I thought I should cover some of the libraries (that I use regularly), like Retrofit and Realm in the context of Kotlin and Rx.\n\nIf you’re new to Retrofit... Then I suggest you visit this [article](https://medium.com/@ahmedrizwan/rxandroid-and-retrofit-2-0-66dc52725fff#.51syz2rr5) — and things will (hopefully) be crystal clear! And if you’re new to Rx & Kotlin — go [here](https://medium.com/@ahmedrizwan/rxandroid-and-kotlin-part-1-f0382dc26ed8#.i0smhvwlm)!\n\n#### So let’s begin : Kotlin + Rx + Retrofit + Realm\n\nIf you’re anything like me, then you absolutely hate writing unnecessary code. *cough Java 6 cough*. And in my Android development experience, I’ve come across many situations where I was like — “But... Why?!”\n\nIn the context of Languages, I think Kotlin is definitely a life-saver. And libraries like Retrofit, Realm and RxAndroid also significantly reduce the amount of unnecessary code.\n\nHorror story: I once came across a project, which had around **12** model classes aka POJOs. Then there were **12** Database (ORM) Table classes and there were also **12** Model-to-Database-Mapping classes. If you’re good at counting, you’ll notice... Those are **36** classes right there! And not only that, a change to the a single class meant, changing all 3 classes.\n\n![](https://d262ilb51hltx0.cloudfront.net/max/800/1*j31fbds0p0D_WwDim60TEQ.jpeg)\n\n_Yeah, that was me..._\n\nI suppose, even if we don’t use any ORMs, we still would be writing code for mapping the Models to the Database! And that’s no good!\n\nSo, what was the solution... Well... For me **Realm** + **Retrofit** was it... I added in **RxAndroid** to the mix later on, because Rx makes almost everything better and more delicious! And of course **Kotlin**, because...\n\n> Kotlin is love... Kotlin is life...\n\nWith the combination of these, those 36 classes would be represented in just 12 (as they should be). And not just that, code will be more concise and expressive because of Kotlin!\n\n### Simple Example: Getting data from Github API\n\nImagine an app which gets data from an API, stores/persists that data to the database and also displays it. A pretty common scenario, right?\n\nThis is what I’d be making... An extremely simple example... Which should hopefully cover the basics!\n\n![](https://d262ilb51hltx0.cloudfront.net/max/800/1*CLjgK7p_Cdro4oh0gu4_Qg.png)\n\n_Nothing fancy — Just plain old me and my github info!_\n\nLet me walk you through on how I would go about creating this app...\n\n#### Creating the Project and Enabling Kotlin\n\nThe first thing we do is enable Kotlin in the project — Just make sure the Kotlin Plugin is installed in your Android Studio.\n\nI created an Empty project with a single MainActivity — Went straight into the build.gradle file and... Triggered the action...\n\n![](https://d262ilb51hltx0.cloudfront.net/max/800/1*pI9K9b0ww9jAduIrjZ10eg.png)\n\n_Trigger Action and search for Configure Kotlin_\n\n![](https://d262ilb51hltx0.cloudfront.net/max/800/1*jMre8FWu_02iHJRnNLaj0w.png)\n\n_Select the modules and click OK_\n\n![](https://d262ilb51hltx0.cloudfront.net/max/800/1*w-WHqk_EDQm8uu09fTyTXg.png)\n\n_After clicking OK — this gets added to the build file — *Sync Changes*_\n\nCool! Now we can write code in Kotlin!\n\n![](https://d262ilb51hltx0.cloudfront.net/max/800/1*gUTF_1dfhJLGJbQZxiJ-nA.png)\n\n_MainActivity.java at the moment — Pretty standard stuff_\n\nWe can (magically) convert the existing java code to Kotlin... By doing the following...\n\n![](https://d262ilb51hltx0.cloudfront.net/max/800/1*8p7TdBtxViZlM50nBGBdww.png)\n\n_Action: Convert Java File to Kotlin File_\n\nNow the MainActivity becomes...\n\n![](https://d262ilb51hltx0.cloudfront.net/max/800/1*jtzRyBq1Parb6TYzdsgwVw.png)\n\n_Holy mother of Kotlin!_\n\n#### Adding Rx — Retrofit — Realm Dependencies\n\nTime to add some dependencies!\n\n![](https://d262ilb51hltx0.cloudfront.net/max/800/1*CAdkhnWaF0MeqwYHpqKo1Q.png)\n\n_I also use Databinding! Because cool people use Databinding!_\n\nNow you might be thinking what the hell is **kapt**? Well it’s an annotation processor built for Kotlin.\n\n![](https://d262ilb51hltx0.cloudfront.net/max/600/1*6MHRyDAF7oqrxhlf2LHwcg.png)\n\n_sudo add this to build.gradle_\n\nIn our project we’ll also have to enable **generateStubs** as well for kapt, in order for it to generate code.\n\nSo... Now we have everything we need! Time to start coding!\n\n#### The Model\n\nThe endpoint we’re dealing with...\n\n`https://api.github.com/users/ahmedrizwan`\n\nAnd the response...\n\n```json\n{\n  \"login\": \"ahmedrizwan\",\n  \"id\": 4357275,\n  \"avatar_url\": \"https://avatars.githubusercontent.com/u/4357275?v=3\",\n  \"gravatar_id\": \"\",\n  \"url\": \"https://api.github.com/users/ahmedrizwan\",\n  \"html_url\": \"https://github.com/ahmedrizwan\",\n  \"followers_url\": \"https://api.github.com/users/ahmedrizwan/followers\",\n  \"following_url\": \"https://api.github.com/users/ahmedrizwan/following{/other_user}\",\n  \"gists_url\": \"https://api.github.com/users/ahmedrizwan/gists{/gist_id}\",\n  \"starred_url\": \"https://api.github.com/users/ahmedrizwan/starred{/owner}{/repo}\",\n  \"subscriptions_url\": \"https://api.github.com/users/ahmedrizwan/subscriptions\",\n  \"organizations_url\": \"https://api.github.com/users/ahmedrizwan/orgs\",\n  \"repos_url\": \"https://api.github.com/users/ahmedrizwan/repos\",\n  \"events_url\": \"https://api.github.com/users/ahmedrizwan/events{/privacy}\",\n  \"received_events_url\": \"https://api.github.com/users/ahmedrizwan/received_events\",\n  \"type\": \"User\",\n  \"site_admin\": false,\n  \"name\": \"ahmed\",\n  \"company\": null,\n  \"blog\": null,\n  \"location\": \"Rawalpindi, Pakistan\",\n  \"email\": null,\n  \"hireable\": null,\n  \"bio\": null,\n  \"public_repos\": 9,\n  \"public_gists\": 0,\n  \"followers\": 5,\n  \"following\": 9,\n  \"created_at\": \"2013-05-06T18:32:59Z\",\n  \"updated_at\": \"2015-08-29T18:17:58Z\"\n}\n```\n\nOk for this example, I just want to extract _id_, _name_, _avatar_url_ and _public_repos_ from the response. So my model class (which is also a realm class btw), would look something like\n\n![](https://d262ilb51hltx0.cloudfront.net/max/800/1*XkIxB1PtetctYpuPBMDM3Q.png)\n\n_\\*\\_\\*_\n\n\n> Note: If you want to extract everything from the JSON response, then I suggest visiting to this awesome [website](http://www.jsonschema2pojo.org), and generate a POJO. Then convert the Java code to Kotlin as described earlier.\n\nOk, lots of things to cover here... Starting off from the _RealmClass_ annotation... For Realm, this annotation is necessary for Realm’s code generation in Kotlin... _PrimaryKey_ annotation is also a Realm annotation, representing the Primary Key field (duh!)... Rest of the annotations are for Gson...\n\nNow the **open** keyword! In kotlin it’s the opposite of **final** in Java. By default, Kotlin classes are final — that means if you want a class to be inherrited — we explicitly have to declare it as **open**. Same is the case with properties. Like in our model, _name_ is a property, with an actual getter and a setter (thanks to Kotlin). And in order for the getter/setter to be overridable (which Realm requires them to be), we put the keyword **open** along with the declaration of the property. Which makes sense (to me at least).\n\n#### Retrofit Interface\n\nAgain the endpoint url is\n\n`https://api.github.com/users/[some_user]`\n\nSo the interface would look something like :-\n\n![](https://d262ilb51hltx0.cloudfront.net/max/800/1*D8ABvZYNBRsw_Ffe5ilS0g.png)\n\n_Simplicity of Retrofit :’)_\n\nNotice how I’m returning Observable of a Github. This is possible because Retrofit allows Rx integration. And that’s super-super-cool!\n\n#### Retrofit Builder\n\n![](https://d262ilb51hltx0.cloudfront.net/max/800/1*RAPCtfF_ztT6qB_wHoxLjw.png)\n\n_Yay... Now I can make API calls... ^_^_\n\nBecause of Realm we use a special Gson instance, which basically adds an exclusion strategy for skipping Realm generated fields. Otherwise Gson doesn’t work with the model.\n\nNext we create an instance of Retrofit with RxJavaCallAdapter factory which allows Rx integration and we also add the Gson converter using the Gson instance we created before.\n\n#### Rx Magic\n\n![](https://d262ilb51hltx0.cloudfront.net/max/800/1*_fSWqpcqhzNfoJNKc8PMig.png)\n\n_Lambdaaaaaaas! :’) Btw binding is my Databinding object!_\n\n\nNow all I do is get the observable, subscribe to it and get our Github object. Once we have the object, it’s easy to persist the user to Realm database.\n\n#### Caching\n\nCaching is also (sort of) possible, because we can first fetch data from Realm Database (if it has already been saved)... Like this...\n\n![](https://d262ilb51hltx0.cloudfront.net/max/800/1*_31bgwIcMTmcCTJHKv03UQ.png)\n\n_Dayum!_\n\nAnd... That’s it! Now if you run the app...\n\n![](https://d262ilb51hltx0.cloudfront.net/max/800/1*CLjgK7p_Cdro4oh0gu4_Qg.png)\n\n_*slow clap*_\n\nYou can find the full code example [here](https://github.com/ahmedrizwan/RxRealmRetroKotlin/tree/master). Hope the article was somewhat useful!\n\nHappy coding!\n\n\n","author":"Ahmed Rizwan","date":"2016-03-15","type":"article","categories":["Retrofit","Realm","RxAndroid","Kotlin"],"features":["highlightjs"],"description":"","filename":"","lang":"EN","enclosure":null},{"title":"Building microservices with Kotlin and Spring Boot","url":"http://www.thedevpiece.com/building-microservices-with-kotlin-and-springboot/","body":"\n![Kotlin and Spring-Boot Logo.](http://www.thedevpiece.com/content/images/2016/12/kotlin-springboot.png)\n\nIt's been a while since Kotlin arrived. Kotlin is a JVM language created by JetBrains developed to be interoperate with Java libraries and apis.  \n\nWhat draws attention about Kotlin is its simplicity. If you find Java too verbose, you also will be interested in Kotlin because it is possible to transit between both languages easily.\n\nOkay then, this post is supposed to be very short, so, let's begin.\n\nWe are going to build a simple crud app using Spring Boot, specifically Spring Boot Data Rest and use Kotlin (of course) as our programming language.\n\nFirst of all, our **build.gradle**:\n\n```gradle\nbuildscript {  \n    ext.kotlin_version = '1.0.5'\n\n    repositories {\n        jcenter()\n    }\n\n    dependencies {\n        classpath \"org.springframework.boot:spring-boot-gradle-plugin:1.4.2.RELEASE\"\n        classpath \"org.jetbrains.kotlin:kotlin-gradle-plugin:$kotlin_version\"\n    }\n}\n\napply plugin: 'kotlin'  \napply plugin: 'java'  \napply plugin: 'eclipse'  \napply plugin: 'idea'  \napply plugin: 'org.springframework.boot'\n\nrepositories {  \n    jcenter()\n}\n\nsourceSets {  \n    main.java.srcDirs += 'src/main/kotlin'\n}\n\ndependencies {  \n    compile \"org.jetbrains.kotlin:kotlin-stdlib:$kotlin_version\"\n\n    compile 'org.slf4j:slf4j-api:1.7.14'\n\n    compile(\"org.springframework.boot:spring-boot-starter-data-rest\")\n    compile(\"org.springframework.boot:spring-boot-starter-data-jpa\")\n    compile(\"com.h2database:h2\")\n\n    testCompile(\"org.springframework.boot:spring-boot-starter-test\")\n    testCompile 'junit:junit:4.12'\n    testCompile 'io.kotlintest:kotlintest:1.3.5'\n}\n```\n\nAnd that's all you need if you want to set up Kotlin in with Gradle. Also, you can see that we are using two Spring Boot libraries: **data rest and data jpa.**\n\nSo, now we are going to create our entity and our rest repository in a file named **PersonApp.kt**:\n\n```kotlin\npackage package com.thedevpiece.kotlin.spring.boot\n\nimport com.fasterxml.jackson.annotation.JsonInclude  \nimport org.springframework.data.repository.PagingAndSortingRepository  \nimport org.springframework.data.rest.core.annotation.RepositoryRestResource as Resource  \nimport javax.persistence.Entity  \nimport javax.persistence.Table  \nimport org.springframework.boot.autoconfigure.SpringBootApplication  \nimport org.springframework.boot.SpringApplication  \nimport javax.persistence.GeneratedValue  \nimport javax.persistence.Id\n\n/**\n * @author Gabriel Francisco <gabfssilva@gmail.com>\n */\n@JsonInclude(JsonInclude.Include.NON_NULL)\n@Entity\n@Table(name = \"people\")\ndata class Person(@Id @GeneratedValue val id: Long? = null, val name: String? = null, val age: Int? = null)\n\n@Resource(collectionResourceRel = \"people\", path = \"people\")\ninterface PersonRepository : PagingAndSortingRepository\n\n@SpringBootApplication\nopen class Application\n\nfun main(args: Array) {  \n    SpringApplication.run(Application::class.java, *args)\n}\n```\n\nSince this is an example and our classes are incredibly simple, our app will have only this file.\n\nKnowing that it is very easy to create tests using Kotlin, we are also going to create a simple feature test to assure that the get by id service is working as expected. By the way, our test lib is called **KotlinTest** and was inspired by [ScalaTest](http://www.scalatest.org/):\n\n```kotlin\npackage com.thedevpiece.rapidoid.microservices.endpoints\n\nimport io.kotlintest.specs.FeatureSpec  \nimport org.springframework.beans.factory.annotation.Autowired  \nimport org.springframework.boot.test.context.SpringBootTest  \nimport org.springframework.boot.test.web.client.TestRestTemplate  \nimport org.springframework.test.annotation.DirtiesContext  \nimport org.springframework.test.context.ActiveProfiles  \nimport org.springframework.test.context.TestContextManager\n\n/**\n * @author Gabriel Francisco <gabfssilva@gmail.com>\n */\n@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)\n@ActiveProfiles(value = \"test\")\n@DirtiesContext\nclass PersonEndpointTest : FeatureSpec() {  \n    @Autowired\n    val restTemplate: TestRestTemplate? = null\n\n    @Autowired\n    val repository: PersonRepository? = null\n\n    override fun beforeAll() {\n        TestContextManager(this.javaClass).prepareTestInstance(this)\n    }\n\n    init {\n        feature(\"People endpoint\") {\n            scenario(\"Asserting getting a person is working\") {\n                repository?.save(Person(name = \"Gabriel\", age = 23))\n                val entity = restTemplate?.getForEntity(\"/people/1\", Person::class.java)\n                entity?.statusCodeValue shouldBe 200\n            }\n        }\n    }\n}\n```\n\nAnd I guess that's all. As you can see, Kotlin is a interesting language, very pragmatic and focused on high productivity.\n\nThank you and, any questions, please, leave a comment.\n\n[]'s\n\n","author":"Gabriel Francisco","date":"2016-12-15","type":"article","categories":["Kotlin"],"features":["highlightjs"],"description":"","filename":"","lang":"EN","enclosure":null},{"title":"Как себе выстрелить в ногу в Kotlin","url":"https://habrahabr.ru/post/278169/","body":"\n> Пост-наброс\n\n## Как себе выстрелить в ногу в Kotlin\n\nСовсем недавно вышел [релиз](http://blog.jetbrains.com/kotlin/2016/02/kotlin-1-0-released-pragmatic-language-for-jvm-and-android/) Kotlin, а его команда разработчиков предлагала [задавать вопросы](https://habrahabr.ru/company/JetBrains/blog/277573/) про язык. Он сейчас на слуху и, возможно, многим хочется его попробовать.\n\nПару недель назад тимлид сделал для компании презентацию о том, что в Котлине хорошо. Одним из самых интересных вопросов был «А как в Котлине выстрелить себе в ногу?» Так получилось, что ответил на этот вопрос я.\n\nDisclaimer:\nНе стоит воспринимать эту статью как «Kotlin — отстой». Хотя я отношусь скорее к категории тех, кому и со Scala хорошо, я считаю, что язык неплохой.\nВсе пункты спорные, но раз в год и палка стреляет. Когда-то вы себе прострелите заодно и башку, а когда-то у вас получится выстрелить только в полночь полнолуния, если вы предварительно совершите черный ритуал создания плохого кода.\n\nНаша команда недавно закончила большой проект на Scala, сейчас делаем проект помельче на Kotlin, поэтому в спойлерах будет сравнение со Scala. Я буду считать, что Nullable в Kotlin — это эквивалент Option, хотя это совсем не так, но, скорее всего, большинство из тех, кто работал с Option, будут вместо него использовать Nullable.\n\n#### 1. Пост-инкремент и преинкремент как выражения\n\nЦитирую вопрошавшего: «Фу, это ж баян, скучно». Столько копий сломано, миллион вопросов на собеседованиях C++... Если есть привычка, то можно было его оставить инструкцией (statement'ом). Справедливости ради, другие операторы, вроде +=, являются инструкциями.\n[Цитирую](https://habrahabr.ru/company/JetBrains/blog/277573/#comment_8784811) одного из разработчиков, [abreslav](https://habrahabr.ru/users/abreslav/):\n\n> Смотрели на юзкейсы, увидели, что поломается, решили оставить.\n>\n> Замечу, что у нас тут не С++, и на собеседовании про инкремент спросить особо нечего. Разве что разницу между префиксным и постфиксным.\n\nНа нет и суда нет. Разумеется, в здравом уме никто так делать не будет, но случайно — может быть.\n\n```kotlin\nvar i = 5\ni = i++ + i++\nprintln(i)\n```\n\n> **Никакого undefined behaviour, результат, очевидно, 12**\n>\n> 11\n\n```kotlin\nvar a = 5\na = ++a + ++a\nprintln(a)\n```\n\n> **Тут все проще, конечно, 14**\n>\n> 13\n\n> **Больше примеров**\n>\n> ```kotlin\n> var b = 5\n> b = ++b + b++\n> println(b)\n> ```\n>\n> > **Банальная логика говорит, что ответ должен быть между 11 и 13**\n> >\n> > да, 12\n> >\n> > ```kotlin\n> > var c = 5\n> > c = c++ + ++c\n> > println(c)\n> > ```\n>\n> > **От перестановки мест слагаемых сумма не меняется**\n> >\n> > разумеется, 12\n>\n> ```kotlin\n> var d = 5\n> d = d + d++ + ++d + ++d\n> println(d)\n>\n> var e = 5\n> e = ++e + ++e + e++ + e\n> println(e)\n> ```\n>\n> > **От перестановки мест слагаемых сумма не меняется!**\n> >\n> > Разумеется:\n> > 25\n> > 28\n\n> **Чё там в Scala?**\n>\n> Ничего интересного, в Scala инкрементов нет. Компилятор скажет, что нет метода ++ для Int. Но если очень захотеть, его, конечно, можно определить.\n\n#### 2. Одобренный способ\n\n```kotlin\nval foo: Int? = null\nval bar = foo!! + 5\n```\n\n> **Что хотели, то и получили**\n>\n> Exception in thread «main» kotlin.KotlinNullPointerException\n\nВ документации говорится, что так делать стоит только если вы очень хотите получить NullPointerException. Это хороший метод выстрелить себе в ногу: !! режет глаз и при первом взгляде на код все понятно. Разумеется, использование !! предполагается тогда, когда до этого вы проверили значение на null и smart cast по какой-нибудь причине не сработал. Или когда вы почему-то уверены, что там не может быть null.\n\n> **Чё там в Scala?**\n>\n> ```scala\n> val foo: Option[Int] = None\n> val bar = foo.get + 5\n> ```\n>\n> > **Что хотели, то и получили**\n> >\n> > Exception in thread «main» java.util.NoSuchElementException: None.get\n\n#### 3. Переопределение invoke()\n\nНачнем с простого: что делает этот кусок кода и какой тип у a?\n\n```kotlin\nclass A(){...}\nval a = A()\n```\n\n> **На глупый вопрос - глупый ответ**\n>\n> Правильно, создает новый объект типа A, вызывая конструктор по умолчанию.\n\nА здесь что будет?\n\n```kotlin\nclass В private constructor(){...}\nval b = B()\n```\n\n> **Ну, наверно, ошибка компиляции будет...**\n>\n> А вот и нет!\n>\n> ```kotlin\n> class B private constructor(){\n>     var param = 6\n>\n>     constructor(a: Int): this(){\n>         param = a\n>     }\n>\n>     companion object{\n>         operator fun invoke() = B(7)\n>     }\n> }\n> ```\n>\n> Для класса может быть определена фабрика. А если бы она была в классе A, то там все равно вызывался бы конструктор.\n\nТеперь вы ко всему готовы:\n\n```kotlin\nclass С private constructor(){...}\nval c = C()\n```\n\n> **Тут создается объект класса С через фабрику, определенную в объекте-компаньоне класса С.**\n>\n> Конечно же нет!\n>\n> ```kotlin\n>     class C private constructor(){\n>         ...\n>         companion object{\n>             operator fun invoke() = A(9)\n>         }\n>     }\n> ```\n>\n> У переменной c будет тип A. Заметьте, что A и С не связаны родственными узами.\n\n**Полный код**\n\n> ```kotlin\n> class A(){\n>     var param = 5\n>\n>     constructor(a: Int): this(){\n>         param = a\n>     }\n>\n>     companion object{\n>         operator fun invoke()= A(10)\n>     }\n> }\n>\n> class B private constructor(){\n>     var param = 6\n>\n>     constructor(a: Int): this(){\n>         param = a\n>     }\n>\n>     companion object{\n>         operator fun invoke() = B(7)\n>     }\n> }\n>\n> class C private constructor(){\n>     var param = 8\n>\n>     constructor(a: Int): this(){\n>         param = a\n>     }\n>\n>     companion object{\n>         operator fun invoke() = A(9)\n>     }\n> }\n>\n> class D(){\n>     var param = 10\n>\n>     private constructor(a: Int): this(){\n>         param = a\n>     }\n>\n>     companion object{\n>         operator fun invoke(a: Int = 25) = D(a)\n>     }\n> }\n>\n> fun main(args: Array<String>) {\n>     val a = A()\n>     val b = B()\n>     val c = C()\n>     val d = D()\n>     println(\"${a.javaClass}, ${a.param}\")\n>     println(\"${b.javaClass}, ${b.param}\")\n>     println(\"${c.javaClass}, ${c.param}\")\n>     println(\"${d.javaClass}, ${d.param}\")\n> }\n> ```\n>\n> Результат выполнения:\n>\n> class A, 5\n> class B, 7\n> class A, 9\n> class D, 10\n\nК сожалению, придумать короткий пример, где у вас реально все поломается, я не смог. Но пофантазировать немного можно. Если вы вернете левый класс, как в примере с классом C, то скорее всего, компилятор вас остановит. Но если вы никуда не передаете объект, то можно сымитировать утиную типизацию, как в примере. Ничего криминального, но человек, читающий код, может сойти с ума и застрелиться, если у него не будет исходника класса.\n\nЕсли у вас есть наследование и функции для работы с базовым классом (Animal), а invoke() от одного наследника (Dog) вернет вам другого наследника (Duck), то тогда при проверке типов (Animal as Dog) вы можете накрякать себе беду.\n\n> **Чё там в Scala?**\n>\n> В Scala проще — есть new, который всегда вызывает конструктор. Если не будет new, то всегда вызывается метод apply у компаньона (который тоже может вернуть левый тип). Разумеется, если что-то вам не доступно из-за private, то компилятор ругнется. Все то же самое, только очевиднее.\n\n#### 4. lateinit\n\n```kotlin\nclass SlowPoke(){\n    lateinit var value: String\n\n    fun test(){\n        if (value == null){ //компилятор здесь говорит, что проверка не нужна (и правильно делает)\n            println(\"null\")\n            return\n        }\n        if (value == \"ololo\")\n            println(\"ololo!\")\n        else\n            println(\"alala!\")\n    }\n}\nSlowPoke().test()\n```\n\n> **Результат предсказуем**\n>\n> Exception in thread «main» kotlin.UninitializedPropertyAccessException: lateinit property value has not been initialized\n\n> **А как правильно?**\n>\n> ```kotlin\n> class SlowBro(){\n>     val value: String? = null\n>\n>     fun test(){\n>         if (value == null) {\n>             println(\"null\")\n>             return\n>         }\n>         if (value == \"ololo\")\n>             println(\"ololo!\")\n>         else\n>             println(\"alala!\")\n>     }\n> }\n> SlowBro().test()\n> ```\n>\n> **Результат**\n>\n> null\n\nЯ бы сказал, что это тоже одобренный способ, но при чтении кода это неочевидно, в отличие от !!. В документации немного завуалированно говорится, что, мол, проверять не надо, если что, мы кинем тебе Exception. По идее, этот модификатор используется тогда, когда вы точно уверены, что поле будет инициализированно кем-то другим. То есть никогда. По моему опыту, все поля, которые были lateinit, рано или поздно стали Nullable. Неплохо это поле вписалось в контроллер JavaFX приложения, где Gui грузится из FXML, но даже это «железобетонное» решение было свергнуто после того, как появился альтернативный вариант без пары кнопок. Один раз так получилось, что в SceneBuilder изменил fx:id, а в коде забыл. В первые дни кодинга на Kotlin немного взбесило, что нельзя сделать lateinit Int. Я могу придумать, почему так сделали, но сомневаюсь, что совсем нет способа обойти эти причины (читай: сделать костыль).\n\n> **Чё там в Scala?**\n>\n> А там аналога lateinit как такового и нет. По крайней мере, я не обнаружил.\n\n#### 5. Конструктор\n\n> ```kotlin\n> class IAmInHurry(){\n>     val param = initSecondParam()\n>     /*tons of code*/\n>     val twentySecondParam = 10\n>     /*tons of code*/\n>     fun initSecondParam(): Int{\n>         println(\"Initializing by default with $twentySecondParam\")\n>         return twentySecondParam\n>     }\n>\n> }\n> class IAmInHurryWithStrings(){\n>     val param = initSecondParam()\n>     /*tons of code*/\n>     val twentySecondParam = \"Default value of param\"\n>     /*tons of code*/\n>     fun initSecondParam(): String{\n>         println(\"Initializing by default with $twentySecondParam\")\n>         return twentySecondParam\n>     }\n> }\n> fun main(args: Array<String>){\n>     IAmInHurry()\n>     IAmInHurryWithStrings()\n> }\n> ```\n\n> **Результат**\n>\n> Initializing by default with 0\n> Initializing by default with null\n\nВсе просто — к полю идет обращение до того, как оно было инициализировано. Видимо, тут стоит немного доработать компилятор. По идее, если вы пишете код хорошо, такая проблема у вас не должна возникнуть, но всякое бывает, не с потолка же я взял этот пример (коллега себе так выстрелил в ногу, случайно через цепочку методов в редко срабатывающем коде вызвал поле, которое было не инициализировано).\n\n> **Чё там в Scala?**\n>\n> Все то же самое.\n>\n> object Initializer extends App{\n>   class IAmInHurry(){\n>     val param = initSecondParam()\n>     /*tons of code*/\n>     val twentySecondParam = 10\n>     /*tons of code*/\n>     def initSecondParam(): Int = {\n>       println(s\"Initializing by default with $twentySecondParam\")\n>       twentySecondParam\n>     }\n>\n>   }\n>\n>   class IAmInHurryWithStrings(){\n>     val param = initSecondParam()\n>     /*tons of code*/\n>     val twentySecondParam = \"Default value of param\"\n>     /*tons of code*/\n>     def initSecondParam(): String = {\n>       println(s\"Initializing by default with $twentySecondParam\")\n>       twentySecondParam\n>     }\n>\n>   }\n>\n>   override def main(args: Array[String]){\n>     new IAmInHurry()\n>     new IAmInHurryWithStrings()\n>   }\n> }\n>\n> **Результат**\n>\n> Initializing by default with 0\n> Initializing by default with null\n\n#### 6. Взаимодействие с Java\n\nДля выстрела тут простор достаточно большой. Очевидное решение — считать все, что пришло из Java, Nullable. Но тут есть долгая и поучительная [история](http://blog.jetbrains.com/kotlin/2015/04/upcoming-change-more-null-safety-for-java/). Как я понял, она связана в основном с шаблонами, наследованием, и цепочкой Java-Kotlin-Java. И при таких сценариях приходилось делать много костылей, чтобы заработало. Поэтому решили от идеи «все Nullable» отказаться.\nНо вроде как один из основных сценариев — свой код пишем на Kotlin, библиотели берем Java (как видится мне, простому крестьянину-кодеру). И при таком раскладе, лучше безопасность в большей части кода и явные костыли в небольшой части кода, которые видно, чем «красиво и удобно» + внезапные грабли в рантайме (или яма с кольями, как повезет). Но у разработчиков другое [мнение](https://habrahabr.ru/company/JetBrains/blog/277573/#comment_8784731):\n\n> Одна из основных причин была в том, что писать на таком языке было неудобно, а читать его — неприятно. Повсюду вопросительные и восклицательные знаки, которые не очень-то помогают из-за того, что расставляются в основном, чтобы удовлетворить компилятор, а не чтобы корректно обработать случаи, когда выражение вычисляется в null. Особенно больно в случае дженериков: например, Map<String?, String?>?..\n\nСделаем небольшой класс на Java:\n\n```java\npublic class JavaCopy {\n    private String a = null;\n\n    public JavaCopy(){};\n\n    public JavaCopy(String s){\n        a = s;\n    }\n\n    public String get(){\n        return a;\n    }\n}\n```\n\nИ попробуем его вызвать из Kotlin:\n\n```kotlin\nfun printString(s: String) {\n    println(s)\n}\n\nval j1 = JavaCopy()\nval j1Got = j1.get()\nprintString(j1Got)\n```\n\n> **Результат**\n>\n> Exception in thread «main» java.lang.IllegalStateException: j1Got must not be null\n\nТип у j1 — String! и исключение мы получим только тогда, когда вызовем printString. Ок, давайте явно зададим тип:\n\n```kotlin\nval j2 = JavaCopy(\"Test\")\nval j3 = JavaCopy(null)\n\nval j2Got: String = j2.get()\nval j3Got: String = j3.get()\n\nprintString(j2Got)\nprintString(j3Got)\n```\n\n> **Результат**\n>\n> Exception in thread «main» java.lang.IllegalStateException: j3.get() must not be null\n\nВсе логично. Когда мы явно указываем, что нам нужен NotNullable, тогда и ловим исключение. Казалось бы, указывай у всех переменных Nullable, и все будет хорошо. Но если делать так:\n\n```kotlin\nprintString(j2.get())\n```\n\nто ошибку вы можете обнаружить нескоро.\n\n> **Чё там в Scala?**\n>\n> Никаких гарантий, NPE словить можно элементарно. Решение — оборачивать все в Option, у которого, напомню, есть хорошее свойство, что Option(null) = None. С другой стороны, тут нет иллюзий, что java interop безопасен.\n\n#### 7. infix нотация и лямбды\n\nСделаем цепочку из методов и вызовем ее:\n\n```kotlin\n    fun<R> first(func: () -> R): R{\n        println(\"calling first\")\n        return func()\n    }\n\n    infix fun<R, T> R.second(func: (R) -> T): T{\n        println(\"calling second\")\n        return func(this)\n    }\n\n    first {\n        println(\"calling first body\")\n    }\n    second {\n        println(\"calling second body\")\n    }\n```\n\n**Результат**\n\n```kotlin\ncalling first\ncalling first body\nOops!\ncalling second body\n```\n\nПодождите-ка... тут какая-то подстава! И правда, «забыл» один метод вставить:\n\n```kotlin\nfun<T> second(func: () -> T): T{\n    println(\"Oops!\")\n    return func()\n}\n```\n\nИ чтобы заработало «как надо», нужно было написать так:\n\n```kotlin\nfirst {\n    println(\"calling first body\")\n} second {\n    println(\"calling second body\")\n}\n```\n\n> **Результат**\n>\n> calling first\n> calling first body\n> calling second\n> calling second body\n\nВсего один перенос строки, который легко при переформатировании удалить/добавить переключает поведение. Основано на реальных событиях: была цепочка методов «сделай в background» и «потом сделай в ui треде». И был метод «сделай в ui» с таким же именем.\n\n> **Чё там в Scala?**\n>\n> Синтаксис немного отличается, поэтому так просто тут себе не выстрелишь:\n>\n> ```scala\n> object Infix extends App{\n>   def first[R](func: () => R): R = {\n>     println(\"calling first\")\n>     func()\n>   }\n>\n>   implicit class Second[R](val value: R) extends AnyVal{\n>     def second[T](func: (R) => T): T = {\n>       println(\"calling second\")\n>       func(value)\n>     }\n>   }\n>\n>   def second[T](func: () => T): T = {\n>     println(\"Oops!\")\n>     func()\n>   }\n>\n>   override def main(args: Array[String]) {\n>     first { () =>\n>       println(\"calling first body\")\n>     } second { () => //<--------type mismach\n>       println(\"calling second body\")\n>     }\n>   }\n> }\n> ```\n>\n> Зато, пытаясь подогнать скаловский код хотя бы для неочевидности засчет implicit/underscore, я взорвал все вокруг.\n>\n> > **Осторожно! Кровь, кишки и расчлененка...**\n> >\n> >\n> >\n> >     object Infix2 extends App{\n> >       def first(func: (Unit) => Unit): Unit = {\n> >         println(\"calling first\")\n> >         func()\n> >       }\n> >\n> >       implicit class Second(val value: Unit) extends AnyVal{\n> >         def second(func: (Unit) => Unit): Unit = {\n> >           println(\"calling second\")\n> >           func(value)\n> >         }\n> >       }\n> >\n> >       def second(func: (Unit) => Unit): Unit = {\n> >         println(\"Oops!\")\n> >         func()\n> >       }\n> >\n> >       override def main(args: Array[String]) {\n> >         first { _ =>\n> >           println(\"calling first body\")\n> >         } second { _ =>\n> >           println(\"calling second body\")\n> >         }\n> >       }\n> >     }\n> >\n> > И результат:\n> >\n> > ```scala\n> > Exception in thread \"main\" java.lang.VerifyError: Operand stack underflow\n> > Exception Details:\n> >   Location:\n> >     Infix2$Second$.equals$extension(Lscala/runtime/BoxedUnit;Ljava/lang/Object;)Z @40: pop\n> >   Reason:\n> >     Attempt to pop empty stack.\n> >   Current Frame:\n> >     bci: @40\n> >     flags: { }\n> >     locals: { 'Infix2$Second/pre>, 'scala/runtime/BoxedUnit', 'java/lang/Object', 'java/lang/Object', integer }\n> >     stack: { }\n> >   Bytecode:\n> >     0000000: 2c4e 2dc1 0033 9900 0904 3604 a700 0603\n> >     0000010: 3604 1504 9900 4d2c c700 0901 5701 a700\n> >     0000020: 102c c000 33b6 0036 57bb 0038 59bf 3a05\n> >     0000030: b200 1f57 b200 1fb2 001f 57b2 001f 3a06\n> >     0000040: 59c7 000c 5719 06c6 000e a700 0f19 06b6\n> >     0000050: 003c 9900 0704 a700 0403 9900 0704 a700\n> >     0000060: 0403 ac\n> >   Stackmap Table:\n> >     append_frame(@15,Object[#4])\n> >     append_frame(@18,Integer)\n> >     same_frame(@33)\n> >     same_locals_1_stack_item_frame(@46,Null)\n> >     full_frame(@77,{Object[#2],Object[#27],Object[#4],Object[#4],Integer,Null,Object[#27]},{Object[#27]})\n> >     same_frame(@85)\n> >     same_frame(@89)\n> >     same_locals_1_stack_item_frame(@90,Integer)\n> >     chop_frame(@97,2)\n> >     same_locals_1_stack_item_frame(@98,Integer)\n> >\n> >     at Infix2$.main(Infix.scala)\n> > ```\n\n#### 8. Перегрузка методов и it\n\nЭто, скорее, метод подгадить другим. Представьте, что вы пишите библиотеку, и в ней есть функция\n\n```kotlin\nfun applier(x: String, func: (String) -> Unit){\n    func(x)\n}\n```\n\nРазумеется, народ ее использует довольно прозрачным способом:\n\n```kotlin\napplier (\"arg\") {\n    println(it)\n}\napplier (\"no arg\") {\n    println(\"ololo\")\n}\n```\n\nКод компилируется, работает, все довольны. А потом вы добавляете метод\n\n```kotlin\nfun applier(x: String, func: () -> Unit){\n    println(\"not applying $x\")\n    func()\n}\n```\n\nИ чтобы компилятор не ругался, пользователям придется везде отказаться от it (читай: переписать кучу кода):\n\n```kotlin\napplier (\"arg\") { it -> //FIXED\n    println(it)\n}\napplier (\"no arg\") { -> //yes, explicit!\n    println(\"ololo\")\n}\n```\n\nХотя, теоретически, компилятор мог бы и угадать, что если есть it, то это лямбда с 1 входным аргументом. Думаю, что с развитием языка и компилятор поумнеет, и этот пункт — временный.\n\n> **Чё там в Scala?**\n>\n> Без аргументов придется явно указать, что это лямбда. А при добавлении нового метода поведение не изменится.\n>\n> ```scala\n> object Its extends App{\n>   def applier(x: String, func: (String) => Unit){\n>     func(x)\n>   }\n>\n>   def applier(x: String, func: () => Unit){\n>     println(\"not applying $x\")\n>     func()\n>   }\n>\n>   override def main(args: Array[String]) {\n>     applier(\"arg\", println(_))\n>     applier(\"no arg\", _ => println(\"ololo\"))\n>   }\n> }\n> ```\n\n#### 9. Почему не стоит думать о Nullable как об Option\n\nПусть у нас есть обертка для кэша:\n\n```kotlin\nclass Cache<T>(){\n    val elements: MutableMap<String, T> = HashMap()\n\n    fun put(key: String, elem: T) = elements.put(key, elem)\n\n    fun get(key: String) = elements[key]\n}\n```\n\nИ простой сценарий использования:\n\n```kotlin\nval cache = Cache<String>()\ncache.put(\"foo\", \"bar\")\n\nfun getter(key: String) {\n    cache.get(key)?.let {\n        println(\"Got $key from cache: $it\")\n    } ?: println(\"$key is not in cache!\")\n}\n\ngetter(\"foo\")\ngetter(\"baz\")\n```\n\n> **Результат довольно предсказуем**\n>\n> Got foo from cache: bar\n> baz is not in cache!\n\nНо если мы вдруг захотим к кэше хранить Nullable...\n\n```kotlin\nval cache = Cache<String?>()\ncache.put(\"foo\", \"bar\")\n\nfun getter(key: String) {\n    cache.get(key)?.let {\n        println(\"Got $key from cache: $it\")\n    } ?: println(\"$key is not in cache!\")\n}\n\ngetter(\"foo\")\ngetter(\"baz\")\n\ncache.put(\"IAmNull\", null)\ngetter(\"IAmNull\")\n```\n\n> **То получится не очень хорошо**\n>\n> Got foo from cache: bar\n> baz is not in cache!\n> IAmNull is not in cache!\n\nЗачем хранить null? Например, чтобы показать, что результат не вычислим. Конечно, тут было бы правильнее использовать Option или Either, но, к сожалению, ни того, ни другого в стандартной библиотеке нет (но есть, например, в [funKTionale](https://github.com/MarioAriasC/funKTionale/wiki)). Более того, как раз при реализации Either, я наступил на грабли этого пункта и предыдущего. Решить эту проблему с «двойным Nullable» можно, например, возвратом Pair или специального data class.\n\n> **Чё там в Scala?**\n>\n> Никто не запретит сделать Option от Option. Надеюсь, понятно, что так все будет хорошо. Да и с null тоже:\n>\n> ```scala\n> object doubleNull extends App{\n>   class Cache[T]{\n>     val elements =  mutable.Map.empty[String, T]\n>\n>     def put(key: String, elem: T) = elements.put(key, elem)\n>\n>     def get(key: String) = elements.get(key)\n>   }\n>\n>   override def main(args: Array[String]) {\n>     val cache = new Cache[String]()\n>     cache.put(\"foo\", \"bar\")\n>\n>     def getter(key: String) {\n>       cache.get(key) match {\n>         case Some(value) => println(s\"Got $key from cache: $value\")\n>         case None => println(s\"$key is not in cache!\")\n>       }\n>     }\n>\n>     getter(\"foo\")\n>     getter(\"baz\")\n>\n>     cache.put(\"IAmNull\", null)\n>     getter(\"IAmNull\")\n>   }\n> ```\n>\n>\n> > **Все хорошо**\n> >\n> > Got foo from cache: bar\n> > baz is not in cache!\n> > Got IAmNull from cache: null\n\n#### 10. Объявление методов\n\nБонус для тех, кто раньше писал на Scala. Спонсор данного пункта — [lgorSL](https://habrahabr.ru/users/lgorsl/).\n[Цитирую:](https://habrahabr.ru/post/277479/#comment_8779645)\n\n> ...\n> Или, например, синтаксис объявления метода:\n> В scala: def methodName(...) = {...}\n> В kotlin возможны два варианта — как в scala (со знаком =) и как в java (без него), но эти два способа объявления неэквивалентны друг другу и работают немного по-разному, я однажды кучу времени потратил на поиск такой «особенности» в коде.\n> ...\n\n> Я подразумевал следующее:\n>\n> fun test(){ println(«it works») }\n> fun test2() = println(«it works too»)\n> fun test3() = {println(«surprise!»)}\n>\n> Чтобы вывести «surprise», придётся написать test3()(). Вариант вызова test3() тоже нормально компилируется, только сработает не так, как ожидалось — добавление «лишних» скобочек кардинально меняет логику программы.\n>\n> Из-за этих граблей переход со скалы на котлин оказался немного болезненным — иногда «по привычке» в объявлении какого-нибудь метода пишу знак равенства, а потом приходится искать ошибки.\n\n#### Заключение\n\nНа этом список наверняка не исчерпывается, поэтому делитесь в комментариях, как вы шли дорогой приключений, но потом что-то пошло не так...\nУ языка много положительных черт, о которых вы можете прочитать на [официальном сайте](http://kotlinlang.org/), в [статьях](https://habrahabr.ru/post/277479/) [на](https://habrahabr.ru/post/268463/) [хабре](https://habrahabr.ru/post/274997/) и еще много где. Но лично я не согласен с некоторыми архитектурными решениями (классы final by default, java interop) и иногда чувствуется, что языку нехватает единообразия, консистентности. Кроме примера с lateinit Int приведу еще два. Внутри блоков let используем it, внутри with — this, а внутри run, [который является комбинацией let и this](http://beust.com/weblog/2015/10/30/exploring-the-kotlin-standard-library/) что надо использовать? А у класса String! можно вызвать методы isBlank(), isNotBlank(), isNullOrBlank(), а «дополняющего» метода вроде isNotNullOrBlank нет:( После Scala нехватает некоторых вещей — Option, Either, matching, каррирования. Но в целом язык оставляет приятное впечатление, надеюсь, что он продолжит достойно развиваться.\n\nP.S. Хабровская подсветка Kotlin хромает, надеюсь, что администрация [habrahabr](https://habrahabr.ru/users/habrahabr/) это когда-нибудь поправит...\n\n#### UPD: Выстрелы от комментаторов (буду обновлять)\n\n[Неочевидный приоритет оператора elvis](https://habrahabr.ru/post/278169/#comment_8786835). Автор — [senia](https://habrahabr.ru/users/senia/).\n\n","author":"@ov7a","date":"2016-02-29","type":"article","categories":["Puzzlers","Kotlin"],"features":["highlightjs"],"description":"","filename":"","lang":"RU","enclosure":null},{"title":"Leveraging TornadoFX to the fullest","url":"https://edvin.town/leveraging-tornadofx-to-the-fullest/","body":"\nCarl Walker recently wrote an insightful post on [TableView Binding in Kotlin](http://courses.bekwam.net/public_tutorials/bkcourse_tableselectapp_kotlin.html) where he uses [TornadoFX](https://github.com/edvin/tornadofx) to create a nice looking TableView with a couple of buttons that are disabled depending on the state of the currently selected item.\n\n![](http://courses.bekwam.net/public_tutorials/images/bkcourse_tableselectapp_kt_nontax.png)\n\nHe also wrote the [same program in plain Java](https://fxdocs.github.io/docs/index.html#_tableview) and the post illustrates how TornadoFX can greatly reduce boiler plate code.\n\nComing from a strong JavaFX background, Carl's approach is very reasonable, but I'd like to show you that we can improve upon it even more by leveraging some more TornadoFX features.\n\nTornadoFX is all about reducing boiler plate, while increasing readability and maintainability.\n\nFirst I'll post the complete application as Carl created it, then I'll walk through each element I feel we can improve upon and finally post the full source for the modified app.\n\nHere is the initial application without imports:\n\n```kotlin\ndata class Item(val sku : String, val descr : String, val price : Float, val taxable : Boolean)\n\nclass TableSelectView : View(\"TableSelectApp\") {\n\n    private val items = FXCollections.observableArrayList(\n        Item(\"KBD-0455892\", \"Mechanical Keyboard\", 100.0f, true),\n        Item(\"145256\", \"Product Docs\", 0.0f, false),\n        Item(\"OR-198975\", \"O-Ring (100)\", 10.0f, true)\n    )\n\n    var tblItems : TableView<Item> by singleAssign()\n    var btnInventory : Button by singleAssign()\n    var btnCalcTax : Button by singleAssign()\n\n    override val root = vbox {\n        tblItems = tableview(items) {\n\n            column(\"SKU\", Item::sku)\n            column(\"Item\", Item::descr)\n            column(\"Price\", Item::price)\n            column(\"Taxable\", Item::taxable)\n\n            prefWidth = 667.0\n            prefHeight = 376.0\n\n            columnResizePolicy = CONSTRAINED_RESIZE_POLICY\n\n            vboxConstraints {\n                vGrow = Priority.ALWAYS\n            }\n        }\n        hbox {\n            btnInventory = button(\"Inventory\")\n            btnCalcTax = button(\"Tax\")\n\n            spacing = 8.0\n        }\n\n        padding = Insets(10.0)\n        spacing = 10.0\n    }\n\n    init {\n\n        btnInventory.disableProperty().bind( tblItems.selectionModel.selectedItemProperty().isNull )\n\n        btnCalcTax.disableProperty().bind(\n                tblItems.selectionModel.selectedItemProperty().isNull().or(\n                    Bindings.select<Boolean>(\n                            tblItems.selectionModel.selectedItemProperty(),\n                            \"taxable\"\n                    ).isEqualTo( false )\n                )\n        )\n    }\n}\n\nclass TableSelectApp : App(TableSelectView::class)\n```\n\n## Syntactic Sugar\n\nWe'll start with something simple and probably insignificant, but we want to attack every piece of boiler plate, so I'll mention it anyway.\n\nIn JavaFX, you're used to setting properties on objects as you create them. A typical example is the `spacing` property on `VBox` and `HBox` containers. The original sample does:\n\n```kotlin\nvbox {\n    spacing = 8.0\n}\n```\n\nThe box builders take spacing as a parameter, so you can write `vbox(8.0)` or `vbox(spacing = 8.0)` if you prefer. OK, that was low hanging fruit, but bear with me.\n\nNext up is actually a feature we added to TornadoFX, but that also has a shorthand alternative. Configuring the constraints inside a `VBox` can be done inside a `vboxConstraints` block, but when you only configure a single constraint you're better off just using this shorthand:\n\n```kotlin\nvgrow = Priority.ALWAYS\n```\n\nLet's tackle the last minor issue before we move on to bigger fish. Setting preferred width and height can be done in a single statement:\n\n```kotlin\nsetPrefSize(667.0, 376.0)\n```\n\n## Builder Encapsulation\n\nI have a golden rule I always try to follow: _Whenever possible, avoid references to other ui elements_. This reduces coupling, but more importantly it means that you will configure a single ui element in just one place. It's almost always less code as well. The original sample uses the `singleAssign` delegate that makes sure we only assign a value to the variable once. This is the original code:\n\n```kotlin\nvar tblItems : TableView<Item> by singleAssign()\nvar btnInventory : Button by singleAssign()\nvar btnCalcTax : Button by singleAssign()\n```\n\nWhen these objects are created inside the builders, they are assigned to these variables:\n\n```kotlin\ntblItems = tableview(items)\nbtnInventory = button(\"Inventory\")\nbtnCalcTax = button(\"Tax\")\n```\n\nLater, in the `init` block of the class, these variables are configured further. The buttons gets their `disabledProperty` bound, and the `tblItems` is references from these bindings. This is the major issue with this code IMO.\n\nThe items are declared in one place, instantiated another and configured a third place in the code. That's three different places to look for how each of these elements are treated. We can actually change all this so everything is done in one place - inside the builder expression that created them. We can get rid of those `singleAssign` variable declarations, and make the binding expression much more concise in the process.\n\nThe reason this is needed in the original sample, is that the binding expressions work on the selectedItem of the TableView. We want to avoid that alltogether, so before we can clean up these variables, let's create a ViewModel.\n\n## ViewModel\n\nAn `ItemViewModel` can wrap an instance of your domain object and gives you properties you can bind against which will stay valid even when the item it represents is changed. We want the view model to solve two issues for us:\n\n* It should indicate which `Item` is currently selected in the table\n* It should have a property for the `taxable` state of that item\n\nThe latter is used in the button bindings, so we need to expose that as a property we can bind to, and we need that binding to be the same even when the item changes.\n\nThe ItemViewModel can be defined like this:\n\n```kotlin\nclass MyItemViewModel : ItemViewModel<Item>() {\n    val taxable: BooleanProperty = bind { SimpleBooleanProperty(item?.taxable ?: false) }\n}\n```\n\nThe `MyItemViewModel` can contain an item of type `Item` in our case, and it has a `BooleanProperty` called `taxable`. This property will always reflect the state of the selected item, or null if false. Now this might look a bit verbose. That's because our domain object `Item` doesn't contain JavaFX properties. That's another thing I would probably change if I wrote this app from scratch, but we'll keep it, so you see how to bind against POJO properties. If `Item` contained JavaFX properties it would be much simpler:\n\n```kotlin\nval taxable = bind { item?.taxableProperty }\n```\n\nSince TornadoFX makes it so easy to create JavaFX properties, you should always do that when your domain objects are exposed to JavaFX Nodes. Now that we have our view model, we can inject it into the view:\n\n```kotlin\nval mySelectedItem: MyItemViewModel by inject()\n```\n\nNext, we can get rid of all the `singleAssign` statements, the variable assignments (`tblItems =` etc) and that whole `init` block at the bottom. Instead we will define the bindings directly inside the builders.\n\nInside the TableView builder we bind the selected state of the tableview to our view model:\n\n```kotlin\nbindSelected(mySelectedItem)\n```\n\nNow whenever the selection changes, the item inside our view model is updated, and the `taxable` property will reflect the state of the selected item. This gives us a chance to clean up the bindings.\n\n## View Model Usage\n\nThe inventory button should be disabled when there is no selection in the table view. Now we can define everything in one place, and also leverage the `empty` property you get for free with the `ItemViewModel`:\n\n```kotlin\nbutton(\"Inventory\") {\n    disableProperty().bind(mySelectedItem.empty)\n}\n```\n\nIt's much easier to reason about the intent of this code, as you can almost read it as an English expression, and it's defined in one place, not three.\n\nWe do the same for the tax button, but here something magical happens:\n\n```kotlin\nbutton(\"Tax\") {\n    disableProperty().bind(mySelectedItem.empty.or(mySelectedItem.taxable.not()))\n}\n```\n\nWhoa?! Remember how this used to look? All though it makes my skin crawl, I'll recite it for you:\n\n```kotlin\nbtnCalcTax.disableProperty().bind(\n    tblItems.selectionModel.selectedItemProperty().isNull().or(\n        Bindings.select<Boolean>(\n            tblItems.selectionModel.selectedItemProperty(),\n            \"taxable\"\n        ).isEqualTo( false )\n    )\n)\n```\n\nIt's almost hard to believe that these two pieces of code actually have the same effect. The first one \"reads\" something like \"Selected item is empty or selected item is not taxable\". This you can infer in a two second glance. I don't think you can say the same for the `Bindings.select` expression we had originally.\n\nThe real power here comes from binding the `ItemViewModel` to the TableView, and I'm sure you agree now that it was most definitely worth it.\n\n## Tying it all together\n\nBelow you'll find the modified code, as I feel it should be written using TornadoFX 1.5.9\\. I would probably make two other adjustments, but I wanted it to be as close to the original sample as possible. I would rename `Item` to `Product` or something similar to avoid the unfortunate name clash with `ItemViewModel`, which is a TornadoFX construct, but more importantly I would create the properties as real JavaFX properties, utilizing the property delegates of TornadoFX. That would clean up that swearing inside the ItemViewModel as I demonstrated.\n\nHere is the modified code:\n\n```kotlin\ndata class Item(val sku: String, val descr: String, val price: Float, val taxable: Boolean)\n\nclass MyItemViewModel : ItemViewModel<Item>() {\n    val taxable: BooleanProperty = bind { SimpleBooleanProperty(item?.taxable ?: false) }\n}\n\nclass TableSelectView : View(\"TableSelectApp\") {\n\n    private val items = FXCollections.observableArrayList(\n            Item(\"KBD-0455892\", \"Mechanical Keyboard\", 100.0f, true),\n            Item(\"145256\", \"Product Docs\", 0.0f, false),\n            Item(\"OR-198975\", \"O-Ring (100)\", 10.0f, true)\n    )\n\n    val mySelectedItem = MyItemViewModel()\n\n    override val root = vbox(10.0) {\n        tableview(items) {\n            column(\"SKU\", Item::sku)\n            column(\"Item\", Item::descr)\n            column(\"Price\", Item::price)\n            column(\"Taxable\", Item::taxable)\n            bindSelected(mySelectedItem)\n            setPrefSize(667.0, 376.0)\n            columnResizePolicy = CONSTRAINED_RESIZE_POLICY\n            vgrow = Priority.ALWAYS\n        }\n        hbox(8.0) {\n            button(\"Inventory\") {\n                disableProperty().bind(mySelectedItem.empty)\n            }\n            button(\"Tax\") {\n                disableProperty().bind(mySelectedItem.empty.or(mySelectedItem.taxable.not()))\n            }\n        }\n\n        padding = Insets(10.0)\n    }\n\n}\n```\n\n## Conclusion\n\nTornadoFX has a lot of features to simplify your UI code. You most certainly don't need to use them all, just use whatever portion you feel comfortable with, but know that if you ever write boiler plate in a TornadoFX app, you're probably not following best practices or we're missing something in the framework \uD83D\uDE42\n\nAs the syntax and features have progressed so much during 2016, we have a lot dated samples out there. We'll try to clean up as many as possible over the coming weeks, but the [TornadoFX Guide](https://edvin.gitbooks.io/tornadofx-guide/content/) is in pretty good shape already, and is one of the best resources to help you get started.\n\n","author":"Edvin Town","date":"2017-01-02","type":"article","categories":["Kotlin"],"features":["highlightjs"],"description":"","filename":"","lang":"EN","enclosure":null},{"title":"Functional Programming in Kotlin with funKTionale","url":"https://speakerdeck.com/marioariasc/functional-programming-in-kotlin-with-funktionale-1","body":"\n\n_v1_\n\n[Slides on SpeakerDeck](https://speakerdeck.com/marioariasc/functional-programming-in-kotlin-with-funktionale-1)\n\n_v2_\n\n[Slides on SpeakerDeck](https://speakerdeck.com/marioariasc/functional-programming-in-kotlin-with-funktionale-2)\n\n","author":"Mario Arias","date":"2016-09-29","type":"slides","categories":["Kotlin","Functional Programming"],"features":["highlightjs"],"description":"","filename":"","lang":"EN","enclosure":null},{"title":"Exploring the Kotlin Standard Library - Part 1","url":"http://jamie.mccrindle.org/2013/01/exploring-kotlin-standard-library-part-1.html","body":"\nExploring the API docs and source code for a language's standard library is usually illuminating and Kotlin is no different. In this series, I thought I'd look at some of the highlights of the Kotlin stdlib. In Part 1, I'll be going over the default Kotlin namespace.\n\nBoth the [API docs](http://jetbrains.github.com/kotlin/versions/snapshot/apidocs/index.html) and the [source code](https://github.com/JetBrains/kotlin/tree/master/libraries/stdlib) for the stdlib are available on github.\n\nFirst up, the iterate method creates an iterator from a stateful function that returns either a value if it has more data or a null if not. For infinite iterators, just never return null. The following code will create an infinite iterator over the integers 0, 1, 2, 3...:\n\n```kotlin\nvar i = 0;\nvar iterator = iterate { i++ }\n```\n\nTo do something useful with the iterator, we can use some of the other methods from the standard library e.g. filter, take, forEach etc. The following code will print all the integers between 0 and 100 that are divisible by 3 and 5.\n\n```kotlin\nvar i = 0;\niterate { i++ } filter { it % 3 == 0 || it % 5 == 0} take 100 forEach { println(it) }\n```\n\nNext up, the stdlib makes it easy to construct read only collections as follows:\n\n```kotlin\nlistOf(1, 2, 3, 4) // constructs a read only list of Int's\nmapOf(1 to \"A\", 2 to \"B\") // constructs a read only map of Int to String\nsetOf(\"Hello\", \"World\") // constructs a read only map of Int to String\n```\n\nOr more specific / mutable collections like this:\n\n```kotlin\narrayListOf(\"Hello\", \"World\") // constructs an array list of Strings\nlinkedListOf(\"Hello\", \"World\") // constructs a linked list of Strings\nhashMapOf(1 to \"A\", 2 to \"B\") // constructs a hash map of Ints to Strings\nlinkedMapOf(1 to \"A\", 2 to \"B\") // constructs a linked map\nsortedMapOf(1 to \"A\", 2 to \"B\") // constructs a sorted map\nsortedSetOf(1, 2, 3) // constructs a sorted set\n```\n\nAll of the arrays, collections, lists and iterators share a similar set of methods: all, any, appendString, contains, count, drop, dropWhile, dropWhileTo, filter, filterNot, filterNotNull, filterNotNullTo, filterNotTo, filterTo, find, flatMap, flatMapTo, fold, foldRight, forEach, groupBy, groupByTo, makeString, map, mapTo, partition, plus, reduce, reduceRight, requireNoNulls, reverse, sort, sortBy, take, takeWhile, takeWhileTo, toArray, toCollection, toLinkedList, toList, toSet, toSortedList, toSortedSet.\nHere are examples of using most of the above methods:\n\n```kotlin\n// all\n//\n// check that all values from 0 to 100 are positive\nassertTrue((1..100).all{ it > 0 })\n\n// any\n//\n// check that any of the words hello and world contain the letter h\nassertTrue(array(\"hello\", \"world\").any{ it.contains(\"h\") })\n\n// contains\n//\n// check that the list of hello and world contains world\nassertTrue(listOf(\"hello\", \"world\").contains(\"world\"))\n\n// count\n//\n// check that the number of values between 1 and 100 inclusive is 100\nassertTrue((1..100).count() == 100)\n\n// drop\n//\n// check that dropping the first string results in only the second\nassertEquals(listOf(\"world\"), listOf(\"hello\", \"world\").drop(1))\n\n// dropWhile\n//\n// check that dropping values from the range 1 to 100 while\n// the value is less than 90 results in the values 90 to 100\n// remaining\nassertEquals((90..100).toList(), (1..100).dropWhile{ it < 90 })\n\n// dropWhileTo\n//\n// check that dropping values from the range 1 to 100 while\n// the value is less than 90 results in the values 90 to 100\n// remaining, using an existing, mutable list\nval dropWhileToList = arrayListOf<Int>()\nassertEquals((90..100).toList(), (1..100).dropWhileTo(dropWhileToList) { it < 90 })\n\n// filter\n//\n// filter the values 0 to 10 to a list containing only even numbers\nassertEquals(listOf(0, 2, 4, 6, 8, 10), (0..10).filter { it % 2 == 0 })\n\n// filterTo\n//\n// filter the values 0 to 10 to a list containing only even numbers\nval filterToList = arrayListOf<Int>()\nassertEquals(listOf(0, 2, 4, 6, 8, 10), (0..10).filterTo(filterToList) { it % 2 == 0 })\n\n// filterNot\n//\n// filter the values 0 to 10 to a list containing only odd numbers\nassertEquals(listOf(1, 3, 5, 7, 9), (0..10).filterNot { it % 2 == 0 })\n\n// filterNot\n//\n// filter the values 0 to 10 to a list containing only odd numbers\nval filterNotToList = arrayListOf<Int>()\nassertEquals(listOf(1, 3, 5, 7, 9), (0..10).filterNotTo(filterNotToList) { it % 2 == 0 })\n\n// filterNotNull\n//\n// filter out null values\nassertEquals(listOf(\"hello\", \"world\"), array(null, \"hello\", null, \"world\").filterNotNull())\n\n// filterNotNullTo\n//\n// filter out null values\nval filterNotNullTo = arrayListOf<String>()\nassertEquals(listOf(\"hello\", \"world\"), array(null, \"hello\", null, \"world\").filterNotNullTo(filterNotNullTo))\n\n// find\n//\n// find the first element in hello world that starts with \"h\"\nassertEquals(\"hello\", array(\"hello\", \"world\").find{ it.startsWith(\"h\") })\n\n// first\n//\n// get the first element of hello and world\nassertEquals(\"hello\", listOf(\"hello\", \"world\").first())\n\n// flatMap\n//\n// map over the values 1, 2 and 3, creating a list of lists of it and it + 1\n// for each element and then flatten them into a single list\nassertEquals(listOf(1, 2, 2, 3, 3, 4), listOf(1, 2, 3).flatMap{ listOf(it, it + 1) })\n\n// flatMapTo\n//\n// map over the values 1, 2 and 3, creating a list of lists of it and it + 1\n// for each element and then flatten them into a single list\nval flatMapToList = arrayListOf<Int>()\nassertEquals(listOf(1, 2, 3).flatMapTo(flatMapToList) { listOf(it, it + 1) }, listOf(1, 2, 2, 3, 3, 4))\n\n// fold\n//\n// take the numbers 1 to 4. start with 0 and add each number to a running total and\n// return the result\nassertEquals(1 + 2 + 3 + 4, listOf(1, 2, 3, 4).fold(0) { total, next -> total + next })\n\n// foldRight\n//\n// take the numbers 1 to 4. add each of them together in turn from the right\nassertEquals(1 + 2 + 3 + 4, listOf(1, 2, 3, 4).foldRight(0) { a, b -> a + b })\n\n// forEach\n//\n// for each of the values in the range 1..10, print out the value on a new line\n(1..10) forEach { println(it) }\n\n// groupBy\n//\n// take the values 0, 1 and 2 and turn them into a map of the characters to lists of integers\n// where A = 0, B = 1, C = 3 etc.\nassertEquals(mapOf('A' to listOf(0), 'B' to listOf(1), 'C' to listOf(2)),\n        array(0, 1, 2).groupBy{ (it + 'A'.toInt()).toChar() })\n\n// groupByTo\n//\n// take the values 0, 1 and 2 and turn them into a map of the characters to lists of integers\n// where A = 0, B = 1, C = 3 etc.\nval groupByToMap = hashMapOf<Char, MutableList<Int>>()\nassertEquals(mapOf('A' to listOf(0), 'B' to listOf(1), 'C' to listOf(2)),\n        array(0, 1, 2).groupByTo(groupByToMap) { (it + 'A'.toInt()).toChar() })\n\n// last\n//\n// get the last element of hello and world\nassertEquals(\"world\", listOf(\"hello\", \"world\").last())\n\n// makeString\n//\n// turn a list into a string using a space as a separator\nassertEquals(\"hello world\", listOf(\"hello\", \"world\").makeString(separator = \" \"))\n\n// map\n//\n// go through the range of integers from 1 to 5 and multiply each one by 2\nassertEquals(listOf(2, 4, 6, 8, 10), (1..5).map{ it * 2 })\n\n// mapTo\n//\n// go through the range of integers from 1 to 5 and multiply each one by 2\nval mapToList = arrayListOf<Int>()\nassertEquals(listOf(2, 4, 6, 8, 10), (1..5).mapTo(mapToList) { it * 2 })\n\n// partition\n//\n// partition the values 1 to 10 into a pair of lists of even and odd numbers\nassertEquals(Pair(listOf(2, 4, 6, 8, 10), listOf(1, 3, 5, 7, 9)), (1..10).partition{ it % 2 == 0 })\n\n// plus\n//\n// add 4 onto the end of an array\nassertEquals(listOf(1, 2, 3, 4), array(1, 2, 3).plus(4))\n\n// reduce\n//\n// take the values 1 to 4 and add them together using a running total\nassertEquals(1 + 2 + 3 + 4, (1..4) reduce { total, next -> total + next })\n\n// reduceRight\n//\n// take the values 1 to 4 and add them together using a running total\nassertEquals(1 + 2 + 3 + 4, (1..4) reduceRight { a, b -> a + b })\n\n// requireNoNulls\n//\n// require that a collection doesn't contain nulls\narray<String?>(\"one\", \"two\", \"three\").requireNoNulls()\n\n// reverse\n//\n// reverse a collection\nassertEquals(array(4, 3, 2, 1), (1..4).reverse())\n\n// sort\n//\n// sort a mutable collection\nassertEquals(array(1, 2, 3, 4), linkedListOf(4, 2, 3, 1).sort())\n\n// sortBy\n//\n// sort a mutable collection in reverse\nassertEquals(array(4, 3, 2, 1), linkedListOf(4, 2, 3, 1).sortBy{ -it })\n\n// take\n//\n// take 5 numbers from the front of a range of 1 to a 100\nassertEquals(listOf(1, 2, 3, 4, 5), (1..100) take 5)\n\n// takeWhile\n//\n// take numbers while they're less then 5 from a range of 1 to a 100\nassertEquals(listOf(1, 2, 3, 4, 5), (1..100) takeWhile { it <= 5 })\n\n// takeWhileTo\n//\n// take numbers while they're less then 5 from a range of 1 to a 100\nval takeWhileToList = arrayListOf<Int>()\nassertEquals(listOf(1, 2, 3, 4, 5), (1..100).takeWhileTo(takeWhileToList) { it <= 5 })\n```\n","author":"Jamie McCrindle","date":"2013-01-22","type":"article","categories":["Kotlin"],"features":["highlightjs"],"description":"","filename":"","lang":"EN","enclosure":null},{"title":"Kotlin & Android: A Brass Tacks Experiment Wrap-Up","url":"https://medium.com/@CodingDoug/kotlin-android-a-brass-tacks-experiment-wrap-up-2b37e3ac8957#.nf83hy78g","body":"\n![](https://d262ilb51hltx0.cloudfront.net/max/1600/1*UN-S8ELMC2kpHf4tJKfbLQ.png)\n\n_Disclaimer: I am a Google employee, but the views expressed in this article are not those of my employer._\n\n### Kotlin & Android: A Brass Tacks Experiment Wrap-Up\n\nIt’s been fun exploring Kotlin® language features for use with Android development! If you’ve landed here without that context and want to explore this 7-part blog series from the beginning, you can [jump back to the beginning](https://medium.com/p/kotlin-android-a-brass-tacks-experiment-part-1-3e5028491bcc), but there’s no need for that to understand this article.\n\nIf you have been following along with the prior 6 parts, you know that, at this point in the experiment, we have a nice domain specific language for expressing the creation of an Android view hierarchy in Kotlin. We made use of the type-safe builder pattern, along with extension functions and properties, to provide ourselves with some handy tools to make this super easy.\n\nA question you might have at this point in the journey is this: _Should I even try to use this technique to build views in my app?_ Up until now, I’ve only ever talked about how it can be easy and convenient to do so, but I haven’t really compared it to anything other than the same task in the Java® programming language. On that point, I definitely find that using Kotlin’s type-safe builder pattern for building views far more agreeable than the equivalent practice in Java. However, specifying views in XML resources is the standard for Android apps, so let’s break down some categories for comparison between the classic XML layouts and the Kotlin type-safe builder approach.\n\n![](https://d262ilb51hltx0.cloudfront.net/max/800/1*LEibB6uJbdo3gZ4dNcydaQ.png)\n\n**How well does the approach work with Activity configuration changes?**\n\nWith Android, a device may change configuration at any time. The most common type of configuration change is orientation. There are many other types, [as documented here](http://developer.android.com/guide/topics/manifest/activity-element.html) (see android:configChanges within). Changes in orientation are especially important for Android views, because it is common practice to have a different layout for both landscape and portrait.\n\nWhen dealing with XML layouts, it’s trivial to handle configuration changes that result in different UI. You simply define your layout twice — once for landscape under res/layout-land and once for portrait under res/layout-port. When you give the XML files the same name in these different spaces, that lets Android know to find and inflate the correct version of the layout for each circumstance. Generally speaking, you write no extra code to handle this change.\n\nWhen dealing with layouts generated from code, you don’t get this configuration switching behavior for free. If you want to change layouts for different configurations, you have to write conditional logic to decide which views to create. And, if you do this a lot, it becomes cumbersome.\n\nSo, for handling a possible matrix of configuration settings with different UI, XML layouts are more convenient.\n\n![](https://d262ilb51hltx0.cloudfront.net/max/800/1*PrbCkbWf1z_dznNsRNpbXQ.png)\n\n**How well does the approach work for complex layouts such as RelativeLayout?**\n\nRelativeLayout is a tool that allows for a very flexible way of positioning views relative to other views. You can easily say that one view should be above, below, to the left, or to the right of another “anchor” view. This requires assigning IDs to the anchor views, while also calling out those IDs in the views to be positioned relative to its anchors. View IDs are also used to locate views within view hierarchies to make modifications to them in code.\n\nIn Android, it’s a best practice to let the compiler assign the integer values for view IDs. You shouldn’t just make up values of your own. This means that you have to use the Android tools to specify these IDs so they can be used later.\n\nWhen dealing with XML layouts, it’s trivial to create a new ID. You simply call out a new value where it’s needed, usually in the view’s android:id property, like this:\n\n```xml\n<TextView android:id=\"@+id/tv\" ... />\n```\n\nThe +@id notation tells the Android toolchain to define a new ID called tv, or reuse an existing ID with the same name. Couldn’t be easier.\n\nHowever, when dealing with layouts generated from code, it’s not possible to create a new ID in the middle of code. To create a new ID, you have to define a new ID as a resource in XML. Then you can reference it from the compiled R class that contains all the IDs used in the app. So, working with views programmatically involves dealing with another file, and Android will not automatically remove IDs for you when no longer referenced.\n\nConsidering all this, it’s easier to work with view IDs with XML layouts because of the tooling support for automatic ID management.\n\n**How well does the approach work when doing calculations to assign to attributes of views?**\n\nIt’s not uncommon to want to calculate some value for an attribute of a view, such as its display text, or a background color, or its dimensions.\n\nThe Android XML layout language is purely declarative. You can’t do any computations in the strings used for assigning attributes. This means that attributes must be assigned in code later after the view has been inflated. This creates a disconnect between the definition in the layout file and its corresponding inflation code. Android programmers are not strangers to this practice!\n\nHowever when building view programmatically, you can simply assign the result of a computation directly to the view property. You can also assign values to be equal to some other property on the view. How many times have you assigned the exact same value to marginLeft and marginBegin?\n\nGiven that you (of course) have all the flexibility of code when creating views programmatically, it’s definitely more convenient in this case to use programmatic view creation, especially with Kotlin type-safe builders.\n\n![](https://d262ilb51hltx0.cloudfront.net/max/800/1*Z38Ypb3iB2_Vw_OOHOXwOg.png)\n\n**How easily can you experiment with tweaks to your layouts?**\n\nUnless you’re really good at visualizing Android layout as you write them, you’ve probably used Android Studio to preview an XML layout without having to build and deploy to a device to see the result.\n\nWhen you code layouts programmatically, you don’t have a quick preview method like this. When Android Studio 2.0 with Instant Run is fully released, this situation will improve greatly. But for now, the most convenient way to experiment with layout changes is usually through the Android Studio preview pane.\n\n**What’s the performance like with each approach?**\n\nThis is a matter of benchmarking inflation of a view hierarchy against equivalent code that constructs the views directly. When I first started experimenting with this, I found that building a simple layout was up to twice as fast inflation! But as I started layering in more Kotlin features and doing more complicated things with views, the difference wasn’t so stark. On my Nexus 6P, I found that building takes roughly 75% of the time it takes to inflate. Presumably, this is because inflation has the overhead of processing the layout resource as it builds the views.\n\nIt should be noted that, in either case, it takes less than 1 millisecond to end up with a view hierarchy with 5 views total, so unless you’re making a whole lot of views, performance is not a huge problem to address.\n\nIf you want to perform the benchmarks yourself, the source code to a sample project can be found [in my GitHub](https://github.com/CodingDoug/kotlin-view-builder).\n\n**What’s the size overhead of using Kotlin?**\n\nThere was a dangling question from part 1 about the size requirements of using Kotlin in Android. There is a runtime and standard library for Kotlin that you declare as a compile dependency. Any time you add a dependency to an Android app, you should definitely be considering its size, especially if you’re not able to multidex your app.\n\nWith Kotlin version 1.0.0, the runtime + stdlib jars weigh in at 210KB + 636K = **846KB**, which is fairly hefty for a library. Counting all the methods using [dex-method-counts](https://github.com/mihaip/dex-method-counts) reveals a total of **6584 methods** under the kotlin package, not including the methods in the Java runtime it also references. This is at least a full 10% of your method count budget for a single dex! But, after applying ProGuard on my test project, that number drops to just **42 methods**. The final number will, of course, expand in relation to the other parts of Kotlin that the app makes use of. The bottom line is that use of ProGuard on apps that include Kotlin is crucial to keeping it under control for serious use.\n\n**Summing it all up:**\n\nKotlin is a pleasure to use in general and can be directly applicable to Android development. For building views, it’s not a silver bullet, since there are many advantages to using XML layouts as is normally recommended. But there are definitely times when programmatic view building is preferable, and Kotlin can provide some handy shortcuts to getting that done with style.\n\nYou may also wonder what other hidden costs there are to using Kotlin. This is a valid question, and was recently addressed in [a discussion on Reddit](https://www.reddit.com/r/androiddev/comments/47613n/can_we_talk_about_the_downsides_of_using_kotlin/). I add my two cents to that discussion, so head over there if you want to see what some people think about that.\n\nIf you want to see my test project and compare XML layouts with views built by Kotlin, clone [my kotlin-view-builder repo](https://github.com/CodingDoug/kotlin-view-builder) to easily try it out yourself.\n\nI hope you enjoyed reading about my experiences with Kotlin for Android as much as I enjoyed learning about it myself!\n\nI work extensively with Android, so be sure to follow me on [Medium](https://medium.com/@CodingDoug) and [Twitter](https://twitter.com/CodingDoug) to get my upcoming blogs.\n\n","author":"Doug Stevenson","date":"2016-03-14","type":"article","categories":["Android","Kotlin"],"features":["highlightjs"],"description":"","filename":"","lang":"EN","enclosure":null},{"title":"KillerTask, the solution to AsyncTask implementation","url":"http://inaka.net/blog/2016/01/25/killertask-the-solution-to-asynctask-implementation/","body":"\n\n## Introduction\n[KillerTask](https://github.com/inaka/KillerTask) is an Android library to create asynchronous background tasks.\n\nDeveloped in [Kotlin](https://kotlinlang.org/) and inspired by [TinyTask](https://github.com/inaka/TinyTask), this is more beautiful and easy to use for Kotlin Android developments.\n\n### Wait... Kotlin?\n\nTo learn what Kotlin is, how to use it in Android and their characteristics, you can take a look at: [\"Android development with Kotlin\"](http://inaka.net/blog/2016/01/15/android-development-with-kotlin/).\n\n### So, is this the same as TinyTask? :/\n\nWell, both are just wrappers around AsyncTask, with a funny looking API. But no, is not exactly the same.\n\nThe main difference between KillerTask and TinyTask is that this library is written in Kotlin language, very different from Java. If you use Kotlin for develop your Android apps, you will find this much more clear and reliable.\n\nIn addition, KillerTask has a better management of threads compared to TinyTask's actual last version (1.0.1).\n\n## Include it in your project\n\nAdd the following to your `app/build.gradle` file:\n\n```groovy\nrepositories {\n  maven {\n    url \"https://jitpack.io\"\n  }\n}\n\ndependencies {\n  // ...\n  compile 'com.github.inaka:killertask:v1.2'\n  // ...\n}\n```\n\n## How it works\n\nCreate a new KillerTask\n\n```kotlin\nvar killerTask = KillerTask(doWork, onSuccess, onFailed)\n```\n\nHaving for example:\n\n```kotlin\n// task function\nval doWork: () -> String = {\n  var connection: URLConnection? = null;\n\n  try {\n      var url = URL(\"https://api.github.com/gists\")\n      connection = url.openConnection();\n  } catch (e: Exception) {\n      e.printStackTrace()\n  }\n\n  var httpConn = connection as HttpURLConnection;\n  httpConn.connectTimeout = 3000;\n  httpConn.readTimeout = 5000;\n\n  // implicit return\n  httpConn.responseCode.toString() + \" \" + httpConn.responseMessage\n}\n\n// onSuccess function\nval onSuccess: (String) -> Unit = {\n  result: String ->\n  Log.wtf(\"success result\", result)\n}\n\n// onFailed function\nval onFailed: (Exception?) -> Unit = {\n  e: Exception? ->\n  Log.wtf(\"error result\", e.toString())\n  e?.printStackTrace()\n}\n```\n\nTo execute it:\n\n```kotlin\nkillerTask.go()\n```\n\nTo cancel it:\n\n```kotlin\nkillerTask.cancel()\n```\n\n### All together\n\nYou can write it all together, for example:\n\n```kotlin\nKillerTask(\n    { \"test\" }, // main task returning \"test\"\n    {result: String -> Log.wtf(\"result\", result)}, // onSuccess actions\n    {e: Exception? -> Log.wtf(\"result\", e.toString())} // onFailed actions\n  ).go()\n```\n\n### Variable parameters\n\nActually, the only strongly necessary parameter is the first one (the main task).\n\n* Example without onSuccess and onFailed actions:\n\n```kotlin\nKillerTask(\n    { Log.wtf(\"LOG\", \"KillerTask is awesome\") }, // main task\n    { Log.wtf(\"LOG\", \"Super awesome!\")} // onSuccess\n  ).go()\n```\n\n* Example only with on Failed actions:\n\n```kotlin\nKillerTask(\n    { // main task\n        Log.wtf(\"LOG\", \"KillerTask is awesome\")\n        \"super\" // implicit return\n    },\n    {}, // onSuccess is empty\n    { e: Exception? -> Log.wtf(\"LOG\", e.toString()) } // onFailed\n  ).go()\n```\n\n### Example of an app using KillerTask\n\n[kotlillon](https://github.com/inaka/kotlillon) Compilation of simple Kotlin examples, all together in one Android app.\n\n## Support\n\nFor questions or general comments regarding the use of this library, please use our public [hipchat room](http://inaka.net/hipchat).\n\nIf you find any bugs or have a problem while using this library, please [open an issue](https://github.com/inaka/KillerTask/issues/new) (or send a pull request with your solution).\n\nYou can check all of our open-source projects at [inaka.github.io](http://inaka.github.io/).\n\n\n\n","author":"Fernando Ramirez","date":"2016-01-25","type":"article","categories":["Kotlin","Android"],"features":["highlightjs"],"description":"","filename":"","lang":"EN","enclosure":null},{"title":"Using Kotlin For Tests in Android","url":"https://medium.com/@sergii/using-kotlin-for-tests-in-android-6d4a0c818776#.vx2bsqrbm","body":"\n### Using Kotlin For Tests in Android\n\nMany developers are quite optimistic about Kotlin future for Android. It [sounds so sweet](https://medium.com/@sergii/say-hello-to-kotlin-78d8afff14a#.423ivzn8q): less verbose, more type-safety, zero-overhead null-safety, Java interop. But not everyone is ready to take a risk and start writing production code using new programming language. Indeed, it could be not mature enough and will add dependencies which increase method count of APK for more than 6.5K. But what if we’ll use Kotlin only for tests?\n\n#### Project setup\n\nSo we can setup Kotlin plugin and related libraries to be only in [_testCompile_ ](https://docs.gradle.org/current/userguide/artifact_dependencies_tutorial.html)dependencies scope. Here is what we should set in build.gradle:\n\n```groovy\ndependencies {\n    compile fileTree(dir: 'libs', include: ['*.jar'])\n    compile 'com.android.support:appcompat-v7:23.2.0'\n\n    testCompile 'junit:junit:4.12'\n    testCompile \"org.jetbrains.kotlin:kotlin-stdlib:$kotlin_ver\"\n    testCompile \"org.jetbrains.kotlin:kotlin-test-junit:$kotlin_ver\"\n}\n```\n\nAnother improtant detail in build.gradle is setting proper source sets to make Kotlin tests folders visible to compiler and IDE. Also we should make sure that Kotlin won’t be used in the production code:\n\n```groovy\nandroid {\n    //...\n    sourceSets {\n        test.java.srcDirs += 'src/test/kotlin'\n    }\n}\n\nafterEvaluate {\n    android.sourceSets.all { sourceSet ->\n        if (!sourceSet.name.startsWith(\"test\"))\n        {\n            sourceSet.kotlin.setSrcDirs([])\n        }\n    }\n}\n```\n\n#### Example\n\nLet’s create a tiny Android app which will convert temperature from Celsius to Kelvin and Fahrenheit. Here I create ThermoConverter.java utility class which is quite easy to make unittestable.\n\nThen we can add simple unit tests for the same functionality in _java_ and _kotlin_ source folders written in Java and Kotlin respectively. Android Studio will mark both _test/java_ and _test/kotlin_ folders with the proper color to indicate them as test packages.\n\nKotlin example unit test code could be as simple as the follows — it will be enough for our demo purposes.\n\n```kotlin\nclass ThermoConverterTestKotlin {\n    private val ALLOWED_DELTA = 0.01f\n\n    @Test\n    fun thermoTest() {\n        val celsiusVal = 232.778f\n        val thermoModel = ThermoConverter.getTemperature(celsiusVal)\n        assertEquals(celsiusVal, thermoModel.celsius, ALLOWED_DELTA)\n        assertEquals(451f, thermoModel.fahrenheit, ALLOWED_DELTA)\n    }\n}\n```\n\nAnd here is the overall project structure:\n\n![](https://d262ilb51hltx0.cloudfront.net/max/800/1*shTe7vHBNQJLQOk1WBzZaQ.png)\n\nWhat do we have now? With testCompile dependencies scope we’ve defined that dependencies won’t be included to the main APK file but will be used only for compilation tests sources. We are adding Kotlin source set to the default one used by java code so we can use the same package structure and can have the same package visibility.\n\nHere is how tests result looks in Android Studio for both Java and Kotlin tests executed together:\n\n![](https://d262ilb51hltx0.cloudfront.net/max/800/1*P2ygs6-7S2Wwg33HZVZrFg.png)\n\nYou can note that on this screenshot the execution time of tests with the same logic in Java and Kotlin is different —the second one seems to be slower. I did several experiments and it seems that this slowdown happens only at the first time JVM loads required by Kotlin dependencies, so it won’t bring any significant performance lag at least for the small amount of code.\n\n#### Conclusion\n\nNow you know the one more way how to try Kotlin in your Android project without production dependencies overhead and with lower maintenance risks. You can find full project example on [GitHub](https://github.com/sergiiz/KotlinTestDemo).\n\nThanks to [Antonio Gutierrez](https://medium.com/u/ba532f5866b4) for the original idea about possible Kotlin use-case for testing.\n\n_Update._ Gradle configuration improved to make sure that Kotlin won’t be used in the production code. Thanks to [Dale King](https://medium.com/u/7997a2275b27).\n\n","author":"Sergii Zhuk","date":"2016-03-16","type":"article","categories":["Android","Kotlin"],"features":["highlightjs"],"description":"","filename":"","lang":"EN","enclosure":null},{"title":"Kotlin NoSQL for MongoDB in Action","url":"https://www.youtube.com/watch?v=80xgl3KThvM","body":"\n\n<iframe width=\"960\" height=\"480\" src=\"https://www.youtube.com/embed/80xgl3KThvM\" frameborder=\"0\" allowfullscreen></iframe>\n\n","author":"Andrey Cheptsov","date":"2015-10-22","type":"video","categories":["Kotlin","SQL"],"features":["highlightjs"],"description":"","filename":"","lang":"EN","enclosure":null},{"title":"Kotlin Native 0.2 Release","url":"https://github.com/JetBrains/kotlin-native/releases/tag/v0.2.0","body":"\nI would like to announce release of Kotlin/Native v0.2, with the following changes:\n\n* Added support for coroutines\n* Fixed most stdlib incompatibilities\n* Improved memory management performance\n* Cross-module inline function support\n* Unicode support independent from installed system locales\n* Interoperability improvements\n  * file-based filtering in definition file\n  * stateless lambdas could be used as C callbacks\n  * any Unicode string could be passed to C function\n* Very basic debugging support\n* Improve compilation and linking performance\n\nOne could download binaries from\n* http://download.jetbrains.com/kotlin/native/kotlin-native-linux-0.2.tar.gz\n* http://download.jetbrains.com/kotlin/native/kotlin-native-macos-0.2.tar.gz\nfor Linux and Mac hosts respectively.\nPlease report issues using https://youtrack.jetbrains.com/issues/KT (subsystem Native).\n","author":"Nikolay Igotti","date":"2017-05-11","type":"article","categories":["Kotlin","Kotlin Native"],"features":["highlightjs"],"description":"","filename":"","lang":"EN","enclosure":null},{"title":"Kotlin’s killer features","url":"https://blog.codecentric.de/en/2016/04/kotlins-killer-features/","body":"\nSUMMARY: Kotlin is a new JVM language fully interoperable with Java bytecode. It is clearly inspired by Scala, but has a different design philosophy, a much gentler learning curve and some really helpful features like null-safe types.\n\n## The Importance of TIOBE\n\nHow much value should one place in the TIOBE index? What is it really worth? Let me answer that question after I have checked the rating of my favourite programming language.\n\nHere’s something that must irk all hard-core Scala afficionados: although it has been around for over twelve years and boasts some superior features, it hasn’t made much of a dent in Java’s dominance. In fact it takes a modest 30th place, well behind the Latin that is Fortran and (you may shudder) COBOL. Don’t get me wrong: I like Scala. It deserves much more adoption than it gets at present, so why doesn’t it? My suspicion is that its supposed benefits are not compelling enough to entice people to climb its steep learning curve. Functional programming is hard and not a likely selling point for the average programmer\n\n[![Screen Shot 2016-04-04 at 06.53.46](https://blog.codecentric.de/files/2016/04/Screen-Shot-2016-04-04-at-06.53.46.png)](https://blog.codecentric.de/files/2016/04/Screen-Shot-2016-04-04-at-06.53.46.png)\n\nAlthough this post is about [Kotlin](http://kotlinlang.org/), I feel I have to mention [Scala](http://www.scala-lang.org/), because it nevertheless has been an inspiration for the designers at Jetbrains. They have taken the good parts, left out/re-thought some of the hard stuff and added some new features. “If you are happy with Scala, you most likely do not need Kotlin”, [they even admit,](https://kotlinlang.org/docs/reference/comparison-to-scala.html) but I actually disagree. I like Scala, but after trying out Kotlin for no more than ten hours I can confidently say I like Kotlin better. Admittedly it says more about me as a programmer than about the languages per se, so I invite you to make up your own mind. Maybe it’s the fact that the official Kotlin documentation is only 144 pages. It would take some really fine print to cover all about Scala in the same number of pages.\n\n## Do we need a new language anyway?\n\nNot really. All modern languages are Turing complete. It’s just that I like to code and some languages give me far greater pleasure than others.\n\nBut now that you mention it, there _is_ actually a lot about Java that will continue to annoy us for many years to come, or at least for as long as old source code — written in the days before we all had mobile phones, for heaven’s sake — must keep running on every new JVM generation. If the historical development of Java is of a dirt track road evolved into a motorway, it’s a motorway that allows horse-drawn carriages simply because some teams didn’t get round to retiring their old horses.\n\n[![Twenty years of sources, one JVM?](https://blog.codecentric.de/files/2016/04/carriage.jpg)](https://blog.codecentric.de/files/2016/04/carriage.jpg)\n\nTwenty years of sources, one JVM?\n\nBackward compatibility means we can’t rethink bad ideas or implement new stuff truly elegantly. It has given us gems like:\n\n* raw types and type erasure\n* Checked exceptions. No language has implemented it ever since, it must be a bad idea.\n* Covariant arrays: I give you a bag of apples, you treat it as a bag of fruit, replace an apple with a pear and hand it back to me: runtime mayhem. Mutable collections should be invariant.\n* Object wrappers for primitives, because that’s the only way collection types can contain them. And we all know autoboxing is the source of some of the worst NullPointers.\n* And since the compiler likes you to spell things out rather than infer them, Java source remains more verbose than needed. It’s mitigated somewhat by the autocompletion prowess of modern IDEs, but only somewhat.\n\nThere are clear merits to backward compatibility, but they’re getting less pressing now that the IT world is (rightly) leaving behind the days of monolithic development. One virtual machine shouldn’t have to compile and run the fruits of ten years worth of coding. If we want to make bigger strides in language development we should look beyond Java the language. JVM languages like Scala and Kotlin throw out the bathwater of raw types and let us keep the baby.\n\n## Life saving versus labour saving features\n\nMany features that are commonly touted to win people over to Scala — or to Kotlin in due course —  are what I would term ‘labour saving’. Obvious examples are the code that can be inferred by the compiler and is therefore redundant and best left out. Type inference in variable declarations as well as compiler-generated getters/setters/equals/hashCode (the data qualifier on a class declaration) all save wear on your keyboard.\n\n```kotlin\ndata class Greeter(val name: String) {\n    fun greet() {\n        println(\"Hello, $name\")\n    }\n}\n```\n\nJava is extremely conservative with such compiler inference. A more sophisticated device is operator overloading, i.e. using arithmetic operators for method calls on your own classes, defined like this:\n\n```kotlin\nclass Dollar(val cents: Int) {\n    operator fun plus(cts: Int): Dollar = Dollar(cents + cts)\n    operator fun plus(money: Dollar): Dollar = Dollar(cents + money.cents)\n    override fun toString() = \"$\" + (cents.toFloat() / 100.0)\n}\n```\n\nWe can now use the plus operator (and minus, unary, etc.) to add either integers or other Dollar objects and receive a new Dollar object back.\n\n```kotlin\nval oneDollarTwenty = Dollar(100) + Dollar(20)\nval alsoOneDollarTwenty = Dollar(100) + 20\n```\n\nExtension methods are another great feature. Similar to Scala’s implicit methods, they let you add methods on a per-use basis to classes otherwise closed to extension, typically numeric types or other primitives (like Scala, there are no real primitives; everything is an object).\n\n```kotlin\noperator fun Int.plus(money: Dollar): Dollar = money.plus(this)\n```\n\nAll three combined they let you do things like this:\n\n```kotlin\nval p1 = Dollar(1200)\nval p2 = Dollar(800)\nprintln(p1 + p2 + 3)// invokes p1.plus(p2).plus(3)\nprintln(3 + p1 + p2)// invokes 3.plus(p1).plus(p2)\n```\n\nThe combination of type inference, operator overloading and extension methods can be very neat and very confusing at the same time:\n\n```kotlin\nval totalPrice = 3 + currentPrice() * orderTotal()\n```\n\nI can’t blame you for thinking that totalPrice must be a numeric value, but there’s no way to be sure. The _only_ way to use these features wisely is if you also take even better care than normal in naming or add a type declaration where it isn’t strictly required. Cutting out redundancy is great, but it means the code that’s left should be perfectly self-documenting. It’s your sacred duty as a clean coder. Promise?\n\n## What’s a real killer feature anyway?\n\nI suppose the greatest language features let you do things you couldn’t do before. Those are very few. Failing that, making a programmer’s life happier comes a very good second. Saving keystrokes is one thing, but I believe true killer features are the ones that:\n\n* Help you prevent mistakes due to your own sloppiness.\n* Implement fundamental concepts intuitively.\n\n## The Billion dollar mistake made right\n\nThe true killer feature for me is Kotlin’s null-safe types. It’s the best solution to tackle null references, a.k.a [the Billion dollar mistake](https://en.wikipedia.org/wiki/Null_pointer) and the hated NullPointerException. The NPE is so pernicious that its abreviation doesn’t even need explaining in commit logs. And it’s all due to our own sloppiness! We know how to avoid it, following [Postel’s law](https://en.wikipedia.org/wiki/Robustness_principle): don’t return null references and always check your arguments for nullity, especially when invoked from the outside world. Yeah right.\n\nKotlin takes the only sensible route: the type system simply refuses to compile code that tries to assign or return null:\n\n```kotlin\nval name: String = null // tries to assign null, won't compile\nfun getName() : String = null // tries to return null, won't compile\n```\n\nIf you need nullability you have to ask Kotlin nicely. Every Foo class has a corresponding Foo? type to be used for null references.\n\n```kotlin\nfun getName() : String? = null\nval name: String? = getName()\n```\n\nNullable types require special care. You can’t treat them the same way as non-nullable types, and that’s a very good thing. Since every method call on a nullable type could cause an NPE, the compiler forces you to use the so-called Elvis operator when the result of the call is assigned to a non-null type:\n\n```kotlin\nval nameOrBruce: String = getName() ?: \"Bruce\"\nval nameOrNull: String? = getName()\n```\n\nThe first variable is non-null, therefore we must provide an alternative in case getName() returns null. That’s not needed for the second assignment, since nameOrNull is of a nullable type. The Elvis operator prevents NPEs also in chained calls (from the offical docs):\n\n```kotlin\nval name: String? = bob?.department?.head?.name\n```\n\nIf any of these calls returns null, the rest is skipped. But of course you know better than to write such trainwreck statements (Law of Demeter).\n\nWe’ve had the Optional wrapper pattern in many different flavours as a better way to avoid null references. It’s been in the standard library since Java 8. Kotlin’s types are better by far:\n\n* They’re more conscise: Optional wrappers add verbosity in creating and unwrapping.\n* Optionals don’t offer compile-time safety at all: you can still return and pass null where an Optional is expected and get the same hated NPE.\n* The Optional pattern is just a design pattern. It’s not an integral language feature.\n\nBut my greatest objection to the Optional pattern is that it is so flipping _optional_. Kotlin has made the right decision: only allow null if you explicitly ask for it. This is not a labour saving measure: it actually eliminates the opportunity for errors while forcing you to think more deeply about about design. Do you really need to return null from your method? Isn’t there a better way to signal such special cases? (There is by the way: check out sealed classes, similar to Scala’s case classes).\n\nIt will indeed be a cold day in hell before something like this makes it into the Java language, as long as backward compatibility stays non-negiotionable.\n\n## A bag of apples isn’t always a bag of fruit\n\nJava’s use of wildcards in parameterized types must be one of the least understood and least liked features. It boils down to this: if a juicer _produces_ only apple juice, I may safely call it a fruit juice dispenser (covariance). If the same machine _accepts_ all kinds of fruit, I may safely call it an apple juicer, while you call it a pear juicer (contra-variance).  In code, the dispenser is all about return types (what goes out), while the juicer is about input. In Java, if I want the flexibility to parameterize my juicer with different types of fruit, I have to do this:\n\n```kotlin\npublic interface Juicer {\n    T dispense();\n}\n```\n\nThis lets me make a Juicer<AppleJuice> and a Juice<CarrotJuice>, but it doesn’t let me do this:\n\n```kotlin\nDispenser applejuiceDispenser = new Dispenser();\nDispenser juiceDispenser = applejuiceDispenser;//wont' compile\n```\n\nunless I use the wildcard in the type declaration:\n\n```kotlin\nDispenser< extends Juice> juiceDispenser = applejuiceDispenser;\n```\n\nIn Kotlin parameterized types are also invariant, but you can enhance the type declaration with **in** or **out** to signal contravariance and covariance, respectively. A juicer has fruit coming in and juice coming out. It can be expressed with two interfaces\n\n```kotlin\ninterface Dispense<out T> {\nabstract fun tap(): T\n}\ninterface Squeezer<in T> {\nabstract fun squeeze(fruit: T)\n}\nclass FruitJuicer() : Squeezer, Dispenser {\n [...]\n}\n```\n\nSince the in and out sides of the parameterization are in different interfaces, I can use these more freely and not be constrained by invariance:\n\n```kotlin\nvar appleJuicer : Dispenser = FruitJuicer()\nvar elstarJuicer : Dispenser = FruitJuicer()\nelstarJuicer = appleJuicer; //Won't compile, not covariant\nappleJuicer = elstarJuicer; //OK\n\nvar appleSqueezer : Squeezer = FruitJuicer()\nvar elstarSqueezer: Squeezer = FruitJuicer()\nelstarSqueezer = appleSqueezer; //OK, contravariant\n```\n\nSince the apple squeezer takes all kinds of apples, it’s okay to put only elstars in it. (if you didn’t know an elstar is an apple you should probably look at your eating habits). While this feature does not eliminate runtime goofs to the degree that nullable types do, I think it’s a very elegant solution to a fundamental programming concept that Java didn’t really solve intuitively.\n\n## Summary\n\nI hope to have convinced you that newcomer Kotlin has some really helpful features. Having experienced Scala well beyond the Hello World stage myself, I promise you with confidence that Kotlin is much easier to master. If you’re looking for greater productivity and sheer joy of coding, it’s well worth a try. Last but not least and no surprise, the IDE support in IntelliJ is excellent, coming from Jetbrains.\n\n","author":"Jasper Sprengers","date":"2016-04-04","type":"article","categories":["Kotlin"],"features":["highlightjs"],"description":"","filename":"","lang":"EN","enclosure":null},{"title":"Kotlin 1.1.2 is out","url":"https://blog.jetbrains.com/kotlin/2017/04/kotlin-1-1-2-is-out/","body":"\nWe’re happy to announce the release of Kotlin 1.1.2, the second bugfix and tooling update for Kotlin 1.1. The update brings performance improvements to the compiler and the IntelliJ IDEA plugin, several new features in the tools, and lots of bugfixes in all areas. Kotlin 1.1.2 also brings compatibility with version 2.4.0-alpha of the Android Gradle plugin.\n\nThe complete list of changes in this release can be found in the [changelog](https://github.com/JetBrains/kotlin/blob/1.1.2/ChangeLog.md).\n\nWe’d like to thank our external contributors whose pull requests were included in this release: [Yoshinori Isogai](https://github.com/shiraji) and [Jonathan Leitschuh](https://github.com/JLLeitschuh). Thanks to everyone who tried the EAP builds and sent us feedback, too!\n\n## Migration Notes\n\nThe Kotlin compiler now requires JDK 8 to run. You shouldn’t notice any changes, because most other Java development tools such as Gradle and the Android toolchain also require JDK 8, so you almost certainly already have it installed. For code generated by the compiler, Java 1.6 compatibility is still the default, and we have no plans to drop support for generating Java 1.6 compatible bytecode.\n\nAn object can no longer be declared inside an inner class. Such an object would be able to access the outer class instance, which is conceptually impossible because an object is always a singleton. inner sealed class’es are also prohibited. This is a temporary limitation which will be removed when we add the possibility to declare a subclass of an inner sealed class inside its outer class, and not inside the inner class itself. ([KT-16232](https://youtrack.jetbrains.com/issue/KT-16232), [KT-16233](https://youtrack.jetbrains.com/issue/KT-16233))\n\nUsing a declaration with a name consisting entirely of underscore characters now always requires backticks. ([KT-16264](https://youtrack.jetbrains.com/issue/KT-16264))\n\n## Maven Incremental Compilation\n\nSince Kotlin 1.1.2, incremental compilation which was previously available for IntelliJ IDEA and Gradle builds is now supported for Maven. To enable, set the `kotlin.compiler.incremental` property to true, using either the -D command line argument or the `properties` tag:\n\n```xml\n<properties>\n    <kotlin.compiler.incremental>true</kotlin.compiler.incremental>\n</properties>\n```\n\n## Maven Annotation Processing\n\nKotlin’s annotation processing tool, kapt, can now be invoked from Maven builds. Just add an execution of the `kapt` goal from kotlin-maven-plugin before `compile`:\n\n```xml\n<execution>\n    <id>kapt</id>\n    <goals>\n        <goal>kapt</goal>\n    </goals>\n    <configuration>\n        <sourceDirs>\n            <sourceDir>src/main/kotlin</sourceDir>\n            <sourceDir>src/main/java</sourceDir>\n        </sourceDirs>\n        <annotationProcessorPaths>\n            <!-- Specify your annotation processors here. -->\n            <annotationProcessorPath>\n                <groupId>com.google.dagger</groupId>\n                <artifactId>dagger-compiler</artifactId>\n                <version>2.9</version>\n            </annotationProcessorPath>\n        </annotationProcessorPaths>\n    </configuration>\n</execution>\n```\n\n[Here](https://github.com/JetBrains/kotlin-examples/blob/master/maven/dagger-maven-example/pom.xml) is a complete example of the POM file with Java-Kotlin code support and tests.\n\nPlease note that `kapt` is still not supported for IntelliJ IDEA’s own build system. Launch the build from the “Maven Projects” toolbar whenever you want to re-run the annotation processing.\n\n## Inline Method Refactoring\n\nWe’ve finally implemented the support for Inline Method (Function) in Kotlin code.\n\n## Other IDE Improvements\n\nA large percentage of our efforts in the 1.1.x timeframe is dedicated to improving the performance of the IntelliJ IDEA plugin. We’re releasing several major performance improvements, affecting primarily typing responsiveness, in 1.1.2, and we already have additional major improvements in the pipeline for the 1.1.3 release.\n\nBeyond that, as usual, we’ve implemented a large number of new inspections, quickfixes and small IDE features in this release. Specifically worth mentioning are the support for folding Android String resource references in the editor, as well as new quickfixes for dealing with Android API version issues.\n\n## How to update\n\nTo update the plugin, use Tools | Kotlin | Configure Kotlin Plugin Updates and press the “Check for updates now” button. Also, don’t forget to update the compiler and standard library version in your Maven and Gradle build scripts.\n\nAs usual, if you run into any problems with the new release, you’re welcome to ask for help on the [forums](https://discuss.kotlinlang.org/), on Slack (get an invite [here](http://kotlinslackin.herokuapp.com/)), or to report issues in the [issue tracker](https://youtrack.jetbrains.com/issues/KT).\n\nLet’s Kotlin!\n","author":"Dmitry Jemerov","date":"2017-04-25","type":"article","categories":["Kotlin"],"features":["highlightjs"],"description":"","filename":"","lang":"EN","enclosure":null},{"title":"Ten Kotlin Features To Boost Android Development ","url":"https://www.toptal.com/android/kotlin-boost-android-development","body":"\n## Introduction\n\nA while ago, [Tomasz introduced Kotlin development on Android](https://www.toptal.com/software/kotlin-android-language). To remind you: Kotlin is a new programming language developed by [Jetbrains](https://www.jetbrains.com/), the company behind one of the most popular Java IDEs, [IntelliJ IDEA](https://www.jetbrains.com/idea/). Like Java, Kotlin is a general-purpose language. Since it complies to the Java Virtual Machine (JVM) bytecode, it can be used side-by-side with Java, and it doesn’t come with a performance overhead.\n\nIn this article, I will cover the top ten useful features to boost your Android development.\n\n_Note_: at the time of writing this article, actual versions were Android Studio 2.1.1. and Kotlin 1.0.2.\n\n![Kotlin](https://assets.toptal.io/uploads/blog/image/121111/toptal-blog-image-1472553848441-616cb981fb163d64c2d9d18a7e109d73.jpg)\n\n_Tired of never ending Java code? Try Kotlin, and save your time and sanity._\n\n## Kotlin Setup\n\nSince Kotlin is developed by JetBrains, it is well-supported in both Android Studio and IntelliJ.\n\nThe first step is to [install Kotlin plugin](https://plugins.jetbrains.com/plugin/6954?pr=androidstudio). After successfully doing so, new actions will be available for converting your Java to Kotlin. Two new options are:\n\n1. Create a new Android project and setup Kotlin in the project.\n2. Add Kotlin support to an existing Android project.\n\nTo learn how to create a new Android project, check the [official step by step guide](https://kotlinlang.org/docs/tutorials/kotlin-android.html). To add Kotlin support to a newly created or an existing project, open the [_find action dialog_](https://www.jetbrains.com/help/idea/2016.1/navigating-to-action.html?origin=old_help) using `Command + Shift + A` on Mac or `Ctrl + Shift + A` on Windows/Linux, and invoke the `Configure Kotlin in Project` action.\n\nTo create a new Kotlin class, select:\n\n* `File` > `New` > `Kotlin file/class`, or\n* `File` > `New` > `Kotlin activity`\n\nAlternatively, you can create a Java class and convert it to Kotlin using the action mentioned above. Remember, you can use it to convert any class, interface, enum or annotation, and this can be used to compare Java easily to Kotlin code.\n\nAnother useful element that saves a lot of typing are Kotlin extensions. To use them you have to apply another plugin in your module `build.gradle` file:\n\n```gradle\napply plugin: 'kotlin-android-extensions'\n```\n\n**Caveat**: if you are using the Kotlin plugin action to set up your project, it will put the following code in your top level `build.gradle` file:\n\n```gradle\nbuildscript {\n   ext.kotlin_version = '1.0.2'\n   repositories {\n       jcenter()\n   }\n   dependencies {\n       classpath \"org.jetbrains.kotlin:kotlin-gradle-plugin:$kotlin_version\"\n\n       // NOTE: Do not place your application dependencies here; they belong\n       // in the individual module build.gradle files\n   }\n}\n```\n\nThis will cause the extension not to work. To fix that, simply copy that code to each of the project modules in which you wish to use Kotlin.\n\nIf you setup everything correctly, you should be able to run and test your application the same way you would in a standard Android project, but now using Kotlin.\n\n## Saving Time with Kotlin\n\nSo, let’s start with describing some key aspects of Kotlin language and by providing tips on how you can save time by using it instead of Java.\n\n## Feature #1: Static Layout Import\n\nOne of the most common boilerplate codes in Android is using the `findViewById()` function to obtain references to your views in Activities or Fragments.\n\nThere are solutions, such as the [Butterknife](http://jakewharton.github.io/butterknife/) library, that save some typing, but Kotlin takes this another step by allowing you to import all references to views from the layout with one import.\n\nFor example, consider the following activity XML layout:\n\n```xml\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<RelativeLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    xmlns:tools=\"http://schemas.android.com/tools\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\"\n    android:paddingBottom=\"@dimen/activity_vertical_margin\"\n    android:paddingLeft=\"@dimen/activity_horizontal_margin\"\n    android:paddingRight=\"@dimen/activity_horizontal_margin\"\n    android:paddingTop=\"@dimen/activity_vertical_margin\"\n    tools:context=\"co.ikust.kotlintest.MainActivity\">\n\n    <TextView\n        android:id=\"@+id/helloWorldTextView\"\n        android:layout_width=\"wrap_content\"\n        android:layout_height=\"wrap_content\"/>\n</RelativeLayout>\n```\n\nAnd the accompanying activity code:\n\n```kotlin\npackage co.ikust.kotlintest\n\nimport android.support.v7.app.AppCompatActivity\nimport android.os.Bundle\n\nimport kotlinx.android.synthetic.main.activity_main.*\n\nclass MainActivity : AppCompatActivity() {\n\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        setContentView(R.layout.activity_main)\n\n        helloWorldTextView.text = \"Hello World!\"\n    }\n}\n```\n\nTo get the references for all the views in the layout with a defined ID, use the Android Kotlin extension [Anko](https://github.com/Kotlin/anko). Remember to type in this import statement:\n\n```kotlin\nimport kotlinx.android.synthetic.main.activity_main.*\n```\n\nNote you don’t need to write semicolons at the end of the lines in Kotlin because they are optional.\n\nThe `TextView` from layout is imported as a `TextView` instance with the name equal to the ID of the view. Don’t be confused by the syntax, which is used to set the label:\n\n```kotlin\nhelloWorldTextView.text = \"Hello World!\"\n```\n\nWe will cover that shortly.\n\n**Caveats**:\n\n* Make sure you import the correct layout, otherwise imported View references will have a `null` value.\n* When using fragments, make sure imported View references are used **after** the `onCreateView()` function call. Import the layout in `onCreateView()` function and use the View references to setup the UI in `onViewCreated()`. The references won’t be assigned before the `onCreateView()` method has finished.\n\n## Feature #2: Writing POJO Classes with Kotlin\n\nSomething that will save the most time with Kotlin is writing the POJO (Plain Old Java Object) classes used to hold data. For example, in the request and response body of a RESTful API. In applications that rely on RESTful API, there will be many classes like that.\n\nIn Kotlin, much is done for you, and the syntax is concise. For example, consider the following class in Java:\n\n```java\npublic class User {\n   private String firstName;\n\n   private String lastName;\n\n   public String getFirstName() {\n       return firstName;\n   }\n\n   public void setFirstName(String firstName) {\n       this.firstName = firstName;\n   }\n\n   public String getLastName() {\n       return lastName;\n   }\n\n   public void setLastName(String lastName) {\n       this.lastName = lastName;\n   }\n}\n```\n\nWhen working with Kotlin, you don’t have to write public keyword again. By default, everything is of public scope. For example, if you want to declare a class, you simply write:\n\n```kotlin\nclass MyClass {\n}\n```\n\nThe equivalent of the Java code above in Kotlin:\n\n```kotlin\nclass User {\n   var firstName: String? = null\n\n   var lastName: String? = null\n}\n```\n\nWell, that saves a lot of typing, doesn’t it? Let’s walk through the Kotlin code.\n\n![Kotlin saves a lot of typing](https://assets.toptal.io/uploads/blog/image/121112/toptal-blog-image-1472553996024-d91273edb8c1031b8747a2810f25dc7c.jpg)\n\nWhen defining variables in Kotlin, there are two options:\n\n* Mutable variables, defined by `var` keyword.\n* Immutable variables, defined by `val` keyword.\n\nThe next thing to note is the syntax differs a bit from Java; first, you declare the variable name and then follow with type. Also, by default, properties are non-null types, meaning that they can’t accept `null` value. To define a variable to accept a `null` value, a question mark must be added after the type. We will talk about this and null-safety in Kotlin later.\n\nAnother important thing to note is that Kotlin doesn’t have the ability to declare fields for the class; only properties can be defined. So, in this case, `firstName` and `lastName` are properties that have been assigned default getter/setter methods. As mentioned, in Kotlin, they are both public by default.\n\nCustom accessors can be written, for example:\n\n```kotlin\nclass User {\n   var firstName: String? = null\n\n   var lastName: String? = null\n\n   val fullName: String?\n        get() firstName + \" \" + lastName\n}\n```\n\nFrom the outside, when it comes to syntax, properties behave like public fields in Java:\n\n```kotlin\nval userName = user.firstName\nuser.firstName = \"John\"\n```\n\nNote that the new property `fullName` is read only (defined by `val` keyword) and has a custom getter; it simply appends first and last name.\n\nAll properties in Kotlin must be assigned when declared or are in a constructor. There are some cases when that isn’t convenient; for example, for properties that will be initialized via dependency injection. In that case, a `lateinit` modifier can be used. Here is an example:\n\n```kotlin\nclass MyClass {\n    lateinit var firstName : String;\n\n    fun inject() {\n        firstName = \"John\";\n    }\n}\n```\n\nMore details about properties can be found in the [official documentation](https://kotlinlang.org/docs/reference/properties.html).\n\n## Feature #3: Class Inheritance and Constructors\n\nKotlin has a more concise syntax when it comes to constructors, as well.\n\n### Constructors\n\nKotlin classes have a primary constructor and one or more secondary constructors. An example of defining a primary constructor:\n\n```kotlin\nclass User constructor(firstName: String, lastName: String) {\n}\n```\n\nThe primary constructor goes after the class name in the class definition. If the primary constructor doesn’t have any annotations or visibility modifiers, the constructor keyword can be omitted:\n\n```kotlin\nclass Person(firstName: String) {\n}\n```\n\nNote that a primary constructor cannot have any code; any initialization must be done in the `init` code block:\n\n```kotlin\nclass Person(firstName: String) {\n    init {\n         //perform primary constructor initialization here\n    }\n}\n```\n\nFurthermore, a primary constructor can be used to define and initialize properties:\n\n```kotlin\nclass User(var firstName: String, var lastName: String) {\n  // ...\n}\n\n```\nJust like regular ones, properties defined from a primary constructor can be immutable (`val`) or mutable (`var`).\n\nClasses may have secondary constructors as well; the syntax for defining one is as follows:\n\n```kotlin\nclass User(var firstName: String, var lastName) {\n    constructor(name: String, parent: Person) : this(name) {\n        parent.children.add(this)\n    }\n}\n```\n\nNote that every secondary constructor must delegate to a primary constructor. This is similar to Java, which uses `this` keyword:\n\n```kotlin\nclass User(val firstName: String, val lastName: String) {\n    constructor(firstName: String) : this(firstName, \"\") {\n       //...\n    }\n}\n```\n\nWhen instantiating classes, note that Kotlin doesn’t have `new` keywords, as does Java. To instantiate the aforementioned `User` class, use:\n\n```kotlin\nval user = User(\"John\", \"Doe)\n```\n\n### Introducing Inheritance\n\nIn Kotlin, all classes extend from `Any`, which is similar to `Object` in Java. By default, classes are closed, like final classes in Java. So, in order to extend a class, it has to be declared as `open` or `abstract`:\n\n```kotlin\nopen class User(val firstName, val lastName)\nclass Administrator(val firstName, val lastName) : User(firstName, lastName)\n```\n\nNote that you have to delegate to the default constructor of the extended class, which is similar to calling `super()` method in the constructor of a new class in Java.\n\nFor more details about classes, check [the official documentation](https://kotlinlang.org/docs/reference/classes.html).\n\n## Feature #4: Lambda Expressions\n\nLambda expressions, introduced with Java 8, are one its favorite features. However, things are not so bright on Android, as it still only supports Java 7, and looks like Java 8 won’t be supported anytime soon. So, workarounds, such as [Retrolambda](https://github.com/orfjackal/retrolambda), bring lambda expressions to Android.\n\nWith Kotlin, no additional libraries or workarounds are required.\n\n### Functions in Kotlin\n\nLet’s start by quickly going over the function syntax in Kotlin:\n\n```kotlin\nfun add(x: Int, y: Int) : Int {\n    return x + y\n}\n```\n\nThe return value of the function can be omitted, and in that case, the function will return `Int`. It’s worth repeating that everything in Kotlin is an object, extended from `Any`, and there are no primitive types.\n\nAn argument of the function can have a default value, for example:\n\n```kotlin\nfun add(x: Int, y: Int  = 1) : Int {\n    return x + y;\n}\n```\n\nIn that case, the `add()` function can be invoked by passing only the `x` argument. The equivalent Java code would be:\n\n```java\nint add(int x) {\n   return add(x, 1);\n}\n\nint add(int x, int y) {\n    return x + y;\n}\n```\n\nAnother nice thing when calling a function is that named arguments can be used. For example:\n\n```kotlin\nadd(y = 12, x = 5)\n```\n\nFor more details about functions, check the [official documentation](https://kotlinlang.org/docs/reference/functions.html).\n\n### Using Lambda Expressions in Kotlin\n\nLambda expressions in Kotlin can be viewed as anonymous functions in Java, but with a more concise syntax. As an example, let’s show how to implement click listener in Java and Kotlin.\n\nIn Java:\n\n```java\nview.setOnClickListener(new OnClickListener() {\n    @Override\n    public void onClick(View v) {\n        Toast.makeText(v.getContext(), \"Clicked on view\", Toast.LENGTH_SHORT).show();\n    }\n};\n```\n\nIn Kotlin:\n\n```kotlin\nview.setOnClickListener({ view -> toast(\"Click\") })\n```\n\nWow! Just one line of code! We can see that the lambda expression is surrounded by curly braces. Parameters are declared first, and the body goes after the `->` sign. With click listener, type for the view parameter isn’t specified since it can be inferred. The body is simply a call to `toast()` function for showing toast, which Kotlin provides.\n\nAlso, if parameters aren’t used, we can leave them out:\n\n```kotlin\nview.setOnClickListener({ toast(\"Click\") })\n```\n\nKotlin has optimized Java libraries, and any function that receives an interface with one method for an argument can be called with a function argument (instead of Interface).\n\nFurthermore, if the function is the last parameter, it can be moved out of the parentheses:\n\n```kotlin\nview.setOnClickListener() { toast(\"Click\") }\n```\n\nFinally, if the function has only one parameter that is a function, parentheses can be left out:\n\n```kotlin\n```\n\nFor more information, check [Kotlin for Android developers book](https://leanpub.com/kotlin-for-android-developers) by Antonio Leiva and the [official documentation](https://kotlinlang.org/docs/reference/lambdas.html).\n\n### Extension Functions\n\nKotlin, similar to C#, provides the ability to extend existing classes with new functionality by using extension functions. For example, an extension method that would calculate the MD5 hash of a `String`:\n\n```kotlin\nfun String.md5(): ByteArray {\n    val digester = MessageDigest.getInstance(\"MD5\")\n    digester.update(this.toByteArray(Charset.defaultCharset()))\n    return digester.digest()\n}\n```\n\nNote that the function name is preceded by the name of the extended class (in this case, `String`), and that the instance of the extended class is available via `this` keyword.\n\nExtension functions are the equivalent of Java utility functions. The example function in Java would look like:\n\n```kotlin\npublic static int toNumber(String instance) {\n    return Integer.valueOf(instance);\n}\n```\n\nThe example function must be placed in a Utility class. What that means is that extension functions don’t modify the original extended class, but are a convenient way of writing utility methods.\n\n## Feature #5: Null-Safety\n\nOne of the things you hustle the most in Java is probably `NullPointerException`. Null-safety is a feature that has been integrated into the Kotlin language and is so implicit you usually won’t have to worry about. The [official documentation](https://kotlinlang.org/docs/reference/null-safety.html) states that the only possible causes of `NullPointerExceptions` are:\n\n* An explicit call to throw `NullPointerException`.\n* Using the `!!` operator (which I will explain later).\n* External Java code.\n* If the `lateinit` property is accessed in the constructor before it is initialized, an`UninitializedPropertyAccessException` will be thrown.\n\nBy default, all variables and properties in Kotlin are considered `non-null` (unable to hold a `null` value) if they are not explicitly declared as nullable. As already mentioned, to define a variable to accept a `null` value, a question mark must be added after the type. For example:\n\n```kotlin\nval number: Int? = null\n```\n\nHowever, note that the following code won’t compile:\n\n```kotlin\nval number: Int? = null\nnumber.toString()\n```\n\nThis is because the compiler performs `null` checks. To compile, a `null` check must be added:\n\n```kotlin\nval number: Int? = null\n\nif(number != null) {\n    number.toString();\n}\n```\n\nThis code will compile successfully. What Kotlin does in the background, in this case, is that `number` becomes `nun-null` (`Int` instead of `Int?`) inside the if block.\n\nThe `null` check can be simplified using **safe call operator** (`?.`):\n\n```kotlin\nval number: Int? = null\nnumber?.toString()\n```\n\nThe second line will be executed only if the number is not `null`. You can even use the famous **Elvis operator** (`?:`):\n\n```kotlin\nval number Int? = null\nval stringNumber = number?.toString() ?: \"Number is null\"\n```\n\nIf the expression on the left of `?:` is not `null`, it is evaluated and returned. Otherwise, the result of the expression on the right is returned. Another neat thing is that you can use `throw` or `return` on the right-hand side of the Elvis operator since they are expressions in Kotlin. For example:\n\n```kotlin\nfun sendMailToUser(user: User) {\n    val email = user?.email ?: throw new IllegalArgumentException(\"User email is null\")\n    //...\n}\n```\n\n### The !! Operator\n\nIf you want a `NullPointerException` thrown the same way as in Java, you can do that with the `!!` operator. The following code will throw a `NullPointerException`:\n\n```kotlin\nval number: Int? = null\nnumber!!.toString()\n```\n\n### Casting\n\nCasting in done by using an `as` keyword:\n\n```kotlin\nval x: String = y as String\n```\n\nThis is considered “Unsafe” casting, as it will throw `ClassCastException` if the cast is not possible, as Java does. There is a “Safe” cast operator that returns the `null` value instead of throwing an exception:\n\n```kotlin\nval x: String = y as? String\n```\n\nFor more details on casting, check the [Type Casts and Casts](https://kotlinlang.org/docs/reference/typecasts.html) section of the official documentation, and for more details on `null` safety check the [Null-Safety](https://kotlinlang.org/docs/reference/null-safety.html) section.\n\n### `lateinit` properties\n\nThere is a case in which using `lateinit` properties can cause an exception similar to `NullPointerException`. Consider the following class:\n\n```kotlin\nclass InitTest {\n    lateinit var s: String;\n\n    init {\n        val len = this.s.length\n    }\n\n}\n```\n\nThis code will compile without warning. However, as soon as an instance of `TestClass` is created, an `UninitializedPropertyAccessException` will be thrown because property `s` is accessed before it is initialized.\n\n## Feature #6: Function `with()`\n\nFunction `with()` is useful and comes with the Kotlin standard library. It can be used to save some typing if you need to access many properties of an object. For example:\n\n```kotlin\nwith(helloWorldTextView) {\n    text = \"Hello World!\"\n    visibility = View.VISIBLE\n}\n```\n\nIt receives an object and an extension function as parameters. The code block (in the curly braces) is a lambda expression for the extension function of the object specified as the first parameter.\n\n## Feature #7: Operator Overloading\n\nWith Kotlin, custom implementations can be provided for a predefined set of operators. To implement an operator, a member function or an extension function with the given name must be provided.\n\nFor example, to implement the multiplication operator, a member function or extension function, with the name `times(argument)`, must be provided:\n\n```kotlin\noperator fun String.times(b: Int): String {\n    val buffer = StringBuffer()\n\n    for (i in 1..b) {\n        buffer.append(this)\n    }\n\n    return buffer.toString()\n}\n```\n\nThe example above shows an implementation of binary `*` operator on the `String`. For example, the following expression will assign value “TestTestTestTest” to a `newString` variable:\n\n```kotlin\nval newString = \"Test\" * 4\n```\n\nSince extension functions can be used, it means the default behavior of the operators for all the objects can be changed. This is a double-edged sword and should be used with caution. For a list of function names for all operators that can be overloaded, check the [official documentation](https://kotlinlang.org/docs/reference/operator-overloading.html).\n\nAnother big difference compared to Java are `==` and `!=` operators. Operator `==` translates to:\n\n```kotlin\na?.equals(b) ?: b === null \n```\n\nWhile operator `!=` translates to:\n\n```kotlin\n!(a?.equals(b) ?:\n```\n\nWhat that means, is that using `==` doesn’t make an identity check as in Java (compare if instances of an object are the same), but behaves the same way as `equals()` method along with `null` checks.\n\nTo perform identity check, operators `===` and `!==` must be used in Kotlin.\n\n## Feature #8: Delegated Properties\n\nCertain properties share some common behaviors. For instance:\n\n* Lazy-initialized properties that are initialized upon first access.\n* Properties that implement Observable in Observer pattern.\n* Properties that are stored in a map instead as separate fields.\n\nTo make cases like this easier to implement, Kotlin supports **Delegated Properties**:\n\n```kotlin\nclass SomeClass {\n    var p: String by Delegate()\n}\n```\n\nThis means that getter and setter functions for the property `p` are handled by an instance of another class, `Delegate`.\n\nAn example of a delegate for the `String` property:\n\n```kotlin\nclass Delegate {\n  operator fun getValue(thisRef: Any?, property: KProperty<*>): String {\n    return \"$thisRef, thank you for delegating '${property.name}' to me!\"\n  }\n\n  operator fun setValue(thisRef: Any?, property: KProperty<*>, value: String) {\n    println(\"$value has been assigned to '${property.name} in $thisRef.'\")\n  }\n}\n```\n\nThe example above prints a message when a property is assigned or read.\n\nDelegates can be created for both mutable (`var`) and read-only (`val`) properties.\n\nFor a read-only property, `getValue` method must be implemented. It takes two parameters (taken from the [offical documentation](https://kotlinlang.org/docs/reference/delegated-properties.html)):\n\n* receiver - must be the same or a supertype of the property owner (for extension properties, it is the type being extended).\n* metadata - must be of type `KProperty<*>` or its supertype.\n\nThis function must return the same type as property, or its subtype.\n\nFor a mutable property, a delegate has to provide additionally a function named `setValue` that takes the following parameters:\n\n* receiver - same as for `getValue()`.\n* metadata - same as for `getValue()`.\n* new value - must be of the same type as a property or its supertype.\n\nThere are a few standard delegates that come with Kotlin that cover the most common situations:\n\n* Lazy\n* Observable\n* Vetoable\n\n### Lazy\n\nLazy is a standard delegate that takes a lambda expression as a parameter. The lambda expression passed is executed the first time `getValue()` method is called.\n\nBy default, the evaluation of lazy properties is synchronized. If you are not concerned with multi-threading, you can use `lazy(LazyThreadSafetyMode.NONE) { ... }` to get extra performance.\n\n### Observable\n\nThe `Delegates.observable()` is for properties that should behave as Observables in Observer pattern. It accepts two parameters, the initial value and a function that has three arguments (property, old value, and new value).\n\nThe given lambda expression will be executed every time `setValue()` method is called:\n\n```kotlin\nclass User {\n    var email: String by Delegates.observable(\"\") {\n        prop, old, new ->\n        //handle the change from old to new value\n    }\n}\n```\n\n### Vetoable\n\nThis standard delegate is a special kind of Observable that lets you decide whether a new value assigned to a property will be stored or not. It can be used to check some conditions before assigning a value. As with `Delegates.observable()`, it accepts two parameters: the initial value, and a function.\n\nThe difference is that the function returns a Boolean value. If it returns `true`, the new value assigned to the property will be stored, or otherwise discarded.\n\n```kotlin\nvar positiveNumber = Delegates.vetoable(0) {\n    d, old, new ->\n    new >= 0\n}\n```\n\nThe given example will store only positive numbers that are assigned to the property.\n\nFor more details, check the [official documentation](https://kotlinlang.org/docs/reference/delegated-properties.html).\n\n## Feature #9: Mapping an Object to a Map\n\nA common use case is to store values of the properties inside a map. This often happens in applications that work with RESTful APIs and parses JSON objects. In this case, a map instance can be used as a delegate for a delegated property. An example from the [official documentation](https://kotlinlang.org/docs/reference/delegated-properties.html):\n\n```kotlin\nclass User(val map: Map<String, Any?>) {\n    val name: String by map\n    val age: Int     by map\n}\n```\n\nIn this example, `User` has a primary constructor that takes a map. The two properties will take the values from the map that are mapped under keys that are equal to property names:\n\n```kotlin\nval user = User(mapOf(\n    \"name\" to \"John Doe\",\n    \"age\"  to 25\n))\n```\n\nThe name property of the new user instance will be assigned the value of “John Doe” and age property the value 25.\n\nThis works for var properties in combination with `MutableMap` as well:\n\n```kotlin\nclass MutableUser(val map: MutableMap<String, Any?>) {\n    var name: String by map\n    var age: Int     by map\n}\n```\n\n## Feature #10: Collections and Functional Operations\n\nWith the support for lambdas in Kotlin, collections can be leveraged to a new level.\n\nFirst of all, Kotlin distinguishes between mutable and immutable collections. For example, there are two versions of **Iterable** interface:\n\n* Iterable\n* MutableIterable\n\nThe same goes for **Collection**, **List**, **Set** and **Map** interfaces.\n\nFor example, this `any` operation returns `true` if at least one element matches the given predicate:\n\n```kotlin\nval list = listOf(1, 2, 3, 4, 5, 6)\nassertTrue(list.any { it % 2 == 0 })\n```\n\nFor an extensive list of functional operations that can be done on collections, check this [blog post](http://antonioleiva.com/collection-operations-kotlin/).\n\n## Conclusion\n\nWe have just scratched the surface of what Kotlin offers. For those interested in further reading and learning more, check:\n\n* [Antonio Leiva’s Kotlin blog posts and book](http://antonioleiva.com/kotlin/).\n* [Official documentation](https://kotlinlang.org/docs/reference/) and [tutorials](https://kotlinlang.org/docs/tutorials/) from JetBrains.\n\nTo sum up, Kotlin offers you the ability to save time when writing native [Android](https://www.toptal.com/android) applications by using an intuitive and concise syntax. It is still a young programming language, but in my opinion, it is now stable enough to be used for building production apps.\n\nThe benefits of using Kotlin:\n\n* Support by Android Studio is seamless and excellent.\n* It is easy to convert an existing Java project to Kotlin.\n* Java and Kotlin code may coexist in the same project.\n* There is no speed overhead in the application.\n\nThe downsides:\n\n* Kotlin will add its libraries to the generated `.apk`, so the final `.apk` size will be about 300KB larger.\n* If abused, operator overloading can lead to unreadable code.\n* IDE and Autocomplete behaves a little slower when working with Kotlin than it does with pure Java Android projects.\n* Compilation times can be a bit longer.\n\n","author":"Ivan Kušt","date":"2016-08-30","type":"article","categories":["Kotlin","Android"],"features":["highlightjs"],"description":"","filename":"","lang":"EN","enclosure":null},{"title":"Natural testing with Kotlin","url":"http://vtorosyan.github.io/natural-testing/","body":"\nThere are dozens of programming languages that are used to build a software which runs on JVM. Languages like Groovy, Scala and Clojure are the well known already and now the new cool kid [Kotlin](https://kotlinlang.org/) brings some more disruption into the Java world.\n\nKotlin is a statically typed, open source language from JetBrains. It has been around since 2011, but wasn't heavily used until last years. We have seen constant updates within 1.0.* versions and JetBrains has already announced the new 1.1 (EAP) version which brings more tools, such as type aliases, inline properties and coroutines. \n\nThe great thing about Kotlin is that it is 100% compatible with Java, you can mix Java and Kotlin with no extra effort! \n\nAfter reading [the post](http://tengio.com/blog/more-readable-tests-with-kotlin/) from @tengio I've tried to use Kotlin in writing [tests](https://github.com/vtorosyan/kotlin-spring-data-neo4j/tree/master/src/test/kotlin/com/examples/kotlin) and found it suprisingely effective and natural. \n\nTo illustrate how Kotlin can be used to make testing easy and natural let's write some class which validates given password and write unit tests for it.\n\nThe requirements for the password are rather simple\n* Password should contain only numbers and letters\n* Password should have more than 5 and less than 10 characters\n\n```java\npublic class PasswordValidator {\n\tpublic boolean validate(String password) { /** ... */ }\n}\n```\n\nWe don't need implementation details as we are doing TDD, so everything is ready to write some tests now! \nThere is an unofficial naming convention from [R. Osherove](http://osherove.com/blog/2005/4/3/naming-standards-for-unit-tests.html) for unit tests which I've been using for a lot of years. Basically, the convention says that the name of the method should describe the unit of work, state under which the test is done, and expected behaviour.\n\n```\n[UnitOfWork_StateUnderTest_ExpectedBehavior]\n```\n\nI've seen this convention in many projects and I believe that it is really human-driven, simply makes sense and the best one so far in Java(e.g. compared to standard given-when-then approach). Having that convention, we can have the following test specifications\n\n```java\n@Test\npublic void validate_PasswordWith6CharsContainingNumbersAndDigits_ReturnTrue() {}\n\n@Test\npublic void validate_PasswordWith5CharsContainingNumbersAndDigits_ReturnFalse() {}\n\n@Test\npublic void validate_PasswordWith6CharsContainingBrackets_ReturnFalse() {}\n\n@Test\npublic void validate_PasswordWith5CharsContainingBrackets_ReturnFalse() {}\n\n```\n\n\nNow let's write the same test specifications using Kotlin. In Kotlin, you can use backticks(``) to name your methods or classes as you like. For example if we transform our `PasswordValidator` class from Java to Kotlin, it can look like\n\n```kotlin\nclass `Password Validator`() {\n\tfun `validate given password`() { /** ... */ }\n} \n```\n\nObviously, this is not something convenient and we won't do it, but we'll use it in our test specifications.\n\n\n```kotlin\n@Test\nfun `Validate password and return true when the parameter has 6 chars and contains only numbers and digits`() {}\n\n@Test\nfun `Validate password and return false when the parameter has 5 chars and contains only numbers and digits`() {}\n\n@Test\nfun `Validate password and return false when the parameter has 6 chars and contains brackets`() {}\n\n@Test\nfun `Validate password and return false when the parameter has 5 chars and contains brackets`() {}\n```\n\nAs you can see the test is 100% human readable, even someone who has no idea what test or class is doing can read the method name and understand the purpose. Even more, if you have already somewhere test cases/scenarios written, they can be easily transformed to the unit tests by copy pasting the titles of your test scenarios.\n\nLuckily, it does not end here. We want to have tests as executable, behaviour driven specifications. Having some context about the functionality only in the test method name is not behaviour driven at all. The new [Spek](https://jetbrains.github.io/spek/) framework comes for a help. Here is our tests in Spek\n\n```kotlin\nclass PasswordValidatorTest : Spek({\n    describe(\"A password validator\") {\n        val validator = PasswordValidator()\n\n        it(\"should return true when the parameter has 6 chars and contains only numbers and digits\") {\n            val result = validator.validate(\"qazwsx123\")\n            assertTrue(result)\n        }\n\n        it(\"should return false when the parameter has 5 chars and contains only numbers and digits\") {\n            val result = validator.validate(\"qazw2\")\n            assertFalse(result)\n        }\n\n        it(\"should return false when the parameter has 6 chars and contains brackets\") {\n            val result = validator.validate(\"qazws}\")\n            assertFalse(result)\n        }\n\n        it(\"should return false when the parameter has 5 chars and contains brackets\") {\n            val result = validator.validate(\"qaw2}\")\n            assertFalse(result)\n        }\n    }\n})\n```\n\nAlthough it's not really convenient to put the specification in the initialization block of Spek, but we have purely behaviour driven, human readable and machine executable test. \n\nSpek is the most used framework in Kotlin world now, but not the only one. If you are coming from Scala world you may find interesting the [KotlinTest](https://github.com/kotlintest/kotlintest), which is highly inspired by [ScalaTest](http://www.scalatest.org/).\n\nIf you want to experiment more, check out the list below for some other frameworks/libraries for Kotlin/JVM \n\n* [spek](https://github.com/jetbrains/spek) - A specification framework for JVM.\n* [mockito-kotlin](https://github.com/nhaarman/mockito-kotlin) - A small library that provides helper functions to work with Mockito in Kotlin.\n* [kotlintest](https://github.com/kotlintest/kotlintest) - Flexible and comprehensive testing tool for the Kotlin ecosystem based on and heavily inspired by the superb Scalatest.\n* [hamkrest](https://github.com/npryce/hamkrest) - A reimplementation of Hamcrest to take advantage of Kotlin language features.\n* [expekt](https://github.com/winterbe/expekt) - Expekt is a BDD assertion library for Kotlin, inspired by Chai.js. It works with your favorite test runner such as JUnit and Spek.\n* [Kluent](https://github.com/MarkusAmshove/Kluent) - Kluent is a \"Fluent Assertions\" library written specifically for Kotlin.\n* [kspec](https://github.com/raniejade/kspec) -Specifications for Kotlin.\n* [balin](https://github.com/EPadronU/balin) - Balin is a browser automation library for Kotlin. It's basically a Selenium-WebDriver wrapper library inspired by Geb.\n* [konsent](https://github.com/dmcg/konsent) - An acceptance testing library for Kotlin.\n\n","author":"Vardan Torosyan","date":"2016-08-31","type":"article","categories":["Kotlin","Testing"],"features":["highlightjs"],"description":"","filename":"","lang":"EN","enclosure":null},{"title":"Kotlin XML Binding","url":"http://jonnyzzz.com/blog/2016/01/06/kotlin-xml/","body":"\n\nI like creating DSLs in [Kotlin](https://kotlinlang.org/). It was fun to try creating a DSL for\nXML data binding. Of course there are so many other libraries for JVM that implements it in the other way.\n\nI was looking for a way to use XPath like queries for data binding. I did not want to parse\nqueries from raw strings. The DSL inherited some ideas from XPath queries.\n\nIn Kotlin I used\n[Delegated Properties](https://kotlinlang.org/docs/reference/delegated-properties.html)\nto achieve better readability, avoid explicit type names for serialization/deserialization rules.\n\nLet's consider an example. Say you have an XML:\n```xml\n<project>\n  <settings type=\"q\">\n     <name>Foo</name>\n  </settings>\n  <keys>\n     <key>A</key>\n     <key>B</key>\n     <key>C</key>\n  </keys>\n</project>\n```\n\n\nThanks to the [kotlin.xml.bind](https://github.com/jonnyzzz/kotlin.xml.bind), you may\nparse it with the following DSL in Kotlin:\n\n```kotlin\nclass Project {\n  var type by JXML / XAttribute(\"type\")\n  var name by JXML / \"name\" / XText\n  var keys by JXML / \"keys\" / XElements(\"key\") / XText\n  var any by JXML / \"parameters\" / XAnyElements / XSub(Sub::class.java)\n  var unknownElements by JXML / XUnknown\n}\n```\n\nKotlin compiler infers types for properties, so one should not write types at all.\nIn the example above `type` and `name` properties are `String?`,\n`keys` is `List<String>?`. `XAnyElements` means result will be as collection, `XSub`\nparses sub-elements as `XSub` objects.\n\n[kotlin.xml.bind](https://github.com/jonnyzzz/kotlin.xml.bind) provides serialization and deserialization.\n\nSources / Binaries\n==================\nSources are on GitHub under Apache 2.0 license. Binaries are published to a maven repo.\n\nFor more information, see [kotlin.xml.bind](https://github.com/jonnyzzz/kotlin.xml.bind) project on GitHub.\n\n\nImplementation details\n======================\nI use [JDOM](http://www.jdom.org/) to work with XML. DSL is done in separate module that does not depend on JDOM directly.\n\nYou may find API declarations [here](https://github.com/jonnyzzz/kotlin.xml.bind/blob/master/api/src/main/kotlin/org/jonnyzzz/kotlin/xml/bind/XBind.API.kt).\nFor every DSL [grammar rule](https://en.wikipedia.org/wiki/Terminal_and_nonterminal_symbols) of the DSL I created an interface in Kotlin.\n\nThe main trick is that expressions like `JXML / \"keys\" / XElements(\"key\") / XText` returns an object\nthat implements requirements of\n[Delegated Properties](https://kotlinlang.org/docs/reference/delegated-properties.html)\n.\n\nThe library adds a tiny overhead on every object creation. So now to create an object (e.g. `Project` class above)\nit has to create a number of objects from the DSL that are used behind delegated properties. Reflections\nare still in use to scan available object properties too on serialization/deserialization.\n\nFor tests I created yet another DSL to generate XML easily.\nYou may find more details in [kotlin.xml.dsl](https://github.com/jonnyzzz/kotlin.xml.dsl) on GitHub.\nThis is an example of unit test\n\n```kotlin\n@Test\npublic fun test_read_any_element_does_not_include_parsed() {\n  class Data {\n    var X by JXML / \"x\" / XUnknown\n    var Y by JXML / \"Y\" / XUnknown\n    var Z by JXML / XAnyElements / XUnknown\n  }\n\n  val el = jdom(\"aaa\") {\n    element(\"x\") { text(\"yohoho\")}\n    element(\"Y\") { text(\"123\")}\n    element(\"z\") { text(\"www\")}\n    element(\"p\") { text(\"www\")}\n  }\n\n  val d : Data = JDOM.load(el , Data::class.java)\n\n  Assert.assertEquals(d.Z?.size, 2)\n  Assert.assertEquals(d.Z?.get(0)?.name, \"z\")\n  Assert.assertEquals(d.Z?.get(1)?.name, \"p\")\n}\n```\n\nI use [Gradle](https://gradle.org/) as project model now.\nArtifacts are deployed to [Bintray](https://bintray.com/jonnyzzz/maven)\n\nFuture Work\n===========\nThe ides of the DSL are easily mapped to JSON too. So it's possible to read/write/update JSON files in the same way\nGet rid of reflections and use [Companion Objects](https://kotlinlang.org/docs/reference/object-declarations.html#companion-objects)\nSupport other XML implementations, not only JDOM\nImprove, finalize and document binding DSL\nInvite contributors!\nHave more fun!\n\n\n","author":"Eugene Petrenko","date":"2016-01-06","type":"article","categories":["kotlin","xml","dsl"],"features":["highlightjs"],"description":"","filename":"","lang":"EN","enclosure":null},{"title":"Weekend resources for new Kotlin programmers","url":"http://www.globalnerdy.com/2016/02/20/weekend-resources-for-new-kotlin-programmers/","body":"\n[![jetbrains](http://www.globalnerdy.com/wordpress/wp-content/uploads/2016/02/jetbrains.png)](https://www.jetbrains.com/)Over the years, [JetBrains](https://www.jetbrains.com/) have released a number of nice development tools. Many of you from the .NET world live and die by [ReSharper,](https://www.jetbrains.com/resharper/) the add-on that supercharges Visual Studio and takes a lot of drudgery and donkey-work out of .NET development. If you’re a Java developer tired of the nightmare of self-flagellation that is Eclipse, you probably use [IntelliJ IDEA,](https://www.jetbrains.com/idea/) which is a far nice environment to work in. And if you’re building Android apps, you probably are still giving thanks for [Android Studio,](http://developer.android.com/tools/studio/index.html) which was built on IntelliJ.\n\n[![kotlin](http://www.globalnerdy.com/wordpress/wp-content/uploads/2016/02/kotlin.jpg)](http://kotlinlang.org/)**Six years ago, JetBrains embarked on a project to build a new programming language named [Kotlin](https://kotlinlang.org/)** after an island near St. Petersburg, Russia, where one of their development teams is based. **[On February 15, 2016, JetBrains announced the 1.0 release of Kotlin,](http://blog.jetbrains.com/kotlin/2016/02/kotlin-1-0-released-pragmatic-language-for-jvm-and-android/)** which in their own words, “works everywhere where Java works”:\n\n* IntelliJ IDEA, Android Studio and Eclipse\n* Maven, Gradle and Ant\n* [Spring Boot](https://spring.io/blog/2016/02/15/developing-spring-boot-applications-with-kotlin) (Kotlin support released today!)\n* GitHub, Slack and even Minecraft ![:)](http://i2.wp.com/blog.jetbrains.com/kotlin/wp-includes/images/smilies/simple-smile.png?w=640)\n\nYou can [try out Kotlin online](http://try.kotlinlang.org/) or on your own development environment:\n\n* **IntelliJ IDEA** ([Ultimate or Community](https://www.jetbrains.com/idea/download/)): just create a Kotlin project or a Kotlin file in a Java project\n* **Android Studio**: install the plugin through _Plugin Manager_\n* **Eclipse**: install the plugin through [Marketplace](https://marketplace.eclipse.org/content/kotlin-plugin-eclipse)\n\n...then download [its documentation](https://kotlinlang.org/docs/kotlin-docs.pdf) from the official site, after which you should check out these perfect-for-weekend-enjoyment resources...\n\n### First, a little reading material\n\n![why kotlin is my next programming language](http://www.globalnerdy.com/wordpress/wp-content/uploads/2016/02/why-kotlin-is-my-next-programming-language.jpg)\n\nStart with [Mike Hearn’s](https://medium.com/@octskyward) essay on Medium, _Why Kotlin is my next programming language_. It lays out a pretty complete list of reasons why you’d want to take up development with Kotlin. If you’re convinced by the end of the essay, continue with the videos below...\n\n### The _Fragmented_ podcast on Kotlin\n\n[![fragmented](http://www.globalnerdy.com/wordpress/wp-content/uploads/2016/02/fragmented.png)](http://fragmentedpodcast.com/2015/10/)If you’re going for a walk, run, bike ride, or to the gym, and you’d like to find out more about Kotlin, [check out the October 2015 edition of the Android-centric _Fragmented_ podcast in which hosts Donn Felker and Kaushik Gopal talk about Kotlin with Hadi Hariri, JetBrain’s developer advocacy lead.](http://fragmentedpodcast.com/2015/10/) This one’s pretty in depth and runs 1 hour and 25 minutes.\n\n### Fun with Kotlin\n\n[Eder Bastos,](https://www.linkedin.com/in/ederb) and Android developer at [Raizlabs](http://www.raizlabs.com/), takes under 8 minutes to provide a nice tour of the Kotlin programming language and why you should consider it for your next Android project. This was published January 14, 2016:\n\n<iframe src=\"https://www.youtube.com/embed/ZlQhmkp_jyk?rel=0\" allowfullscreen=\"allowfullscreen\" height=\"540\" frameborder=\"0\" width=\"960\"></iframe>\n\n### Kotlin: New Hope in a Java 6 Wasteland\n\n[Michael Pardo](https://github.com/pardom) gave a Kotlin talk at [Droidcon NYC 2015](http://droidcon.nyc/2015/) on August 27, 2015:\n\n<iframe src=\"https://www.youtube.com/embed/0BiPmgk3nyw?rel=0\" allowfullscreen=\"allowfullscreen\" height=\"540\" frameborder=\"0\" width=\"960\"></iframe>\n\n### Kotlin: The Swift of Android\n\nHere’s [Svetlana Isakova](https://github.com/svtk) of [JetBrains](https://www.jetbrains.com/) (creator of Kotlin, Android Studio, ReSharper and a whole lot of IDEs) at [DroidCon Berlin](http://de.droidcon.com/) on June 4, 2015:\n\n<iframe src=\"https://www.youtube.com/embed/-BvN0X5tqjw?rel=0\" allowfullscreen=\"allowfullscreen\" height=\"540\" frameborder=\"0\" width=\"960\"></iframe>\n\n### Android Development with Kotlin\n\nPresented by [Jake Wharton](http://jakewharton.com/) at the [AndroidKW Meetup](http://www.meetup.com/androidkw/) in Waterloo, Canada, December 3, 2015:\n\n<iframe src=\"https://www.youtube.com/embed/A2LukgT2mKc?rel=0\" allowfullscreen=\"allowfullscreen\" height=\"540\" frameborder=\"0\" width=\"960\"></iframe>\n\nYou may also want to take a look at these other Android/Kotlin presentations by Jake Wharton:\n\n*   [Advancing Android Development with Kotlin](http://jakewharton.com/presentation/2015-11-07-gdg-devfest/) GDG DevFest (Dublin, Ireland, November 7, 2015)\n*   [Advancing Android Development with the Kotlin Language](http://jakewharton.com/presentation/2015-11-06-oredev/) Øredev (Malmö, Sweden, November 6, 2015)\n\n### Functional Programming with Kotlin\n\nHere’s a talk by Mike Hearn (the same Mike Hearn who wrote _Why Kotlin is my next programminglanguage_) where he shows Kotlin in action, with an emphasis on functional programming. This one was posted November 5, 2015, and he’s demonstrating using a pre-1.0-beta version:\n\n<iframe src=\"https://www.youtube.com/embed/AhA-Q7MOre0?rel=0\" allowfullscreen=\"allowfullscreen\" height=\"540\" frameborder=\"0\" width=\"960\"></iframe>\n\n","author":"Joey deVilla","date":"2016-02-20","type":"article","categories":["Kotlin"],"features":["highlightjs"],"description":"","filename":"","lang":"EN","enclosure":null},{"title":"The Kobalt diaries: Parallel builds","url":"http://beust.com/weblog/2016/08/06/the-kobalt-diaries-parallel-builds/","body":"\n![](http://beust.com/pics/parallel-build-result.png)\n\nI’ve always wondered why the traditional build systems we use on the JVM (Maven, Gradle) don’t support parallel builds (edit: this is not quite true, see the comments), so now that I developed my [own build system](http://beust.com/kobalt), I decided to find out if there was any particular difficulty to this problem that I had overlooked. This turned out to be easier than I anticipated and with interesting benefits. Here is a preliminary result of my findings.\n\n## Defining parallel builds\n\nWhile most builds are sequential by nature (task B can’t usually run until task A has completed), projects that contain multiple sub projects can greatly benefit from the performance boost of parallel builds. This speed up will obviously not apply to single projects or subprojects that have direct dependencies on each other (although this is not quite true as we will see below). If you’re curious, the engine that powers Kobalt’s parallel builds is an improved version of TestNG’s own `DynamicGraphExecutor`, which I described in details [in this post](http://beust.com/weblog/2009/11/28/hard-core-multicore-with-testng/).\n\nIn order to measure the efficacy of parallel builds, I needed a more substantial project, so I picked [ktor](https://github.com/Kotlin/ktor), Kotlin’s web framework developed by JetBrains. ktor is interesting because it contains more than twenty sub projects with various dependencies with each other. Here is a dependency graph:\n\n![](http://beust.com/pics/ktor-dependencies.png)\n\nYou can see that `core` is the main project that everybody else depends on. After that, the dependencies open up and we have the potential to build some of these projects in parallel: `locations`, `samples`, etc...\n\nI started by converting the `ktor` build from Maven to Kobalt. Right now, `ktor` is made of about twenty-five `pom.xml` files that add up to a thousand lines of build files. Kobalt’s build file (`Build.kt`) is one file of about two hundred lines, and you can [find it here](https://github.com/cbeust/ktor/blob/kobalt/kobalt/src/Build.kt). The fact that this build file is a pure Kotlin file allows to completely eliminate the redundancies and maximize the reuse of boiler plate code that most sub projects define.\n\nExtracting the dependencies from `Build.kt` is trivial thanks to Kobalt’s convenient syntax to define dependencies:\n\n```kotlin\n$ grep project kobalt/src/Build.kt\nval core = project {\nval features = project(core) {\nval tomcat = project(core, servlet) {\n```\n\nWe see the `core` project at the top of the dependency graph. Then `features` depends on `core`, `tomcat` depends on both `core` and `servlet` and so on...\n\nSo without further ado, let’s launch the build in parallel mode and let’s see what happens:\n\n```\n$ ./kobaltw --parallel assemble\n```\n\nAt the end of a parallel build, Kobalt optionally displays a summary of the way it scheduled the various tasks. Here is what we get after building the project from scratch:\n\n```\n╔══════════════════════════════════════════════════════════════════════════════════════════════════════\n║  Time (sec) ║ Thread 39           ║ Thread 40           ║ Thread 41           ║ Thread 42           ║\n╠══════════════════════════════════════════════════════════════════════════════════════════════════════\n║  0          ║ core                ║                     ║                     ║                     ║\n║  45         ║ core (45)           ║                     ║                     ║                     ║\n║  45         ║                     ║ ktor-locations      ║                     ║                     ║\n║  45         ║                     ║                     ║ ktor-netty          ║                     ║\n║  45         ║                     ║                     ║                     ║ ktor-samples        ║\n║  45         ║ ktor-hosts          ║                     ║                     ║                     ║\n║  45         ║                     ║                     ║                     ║                     ║\n║  45         ║ ktor-hosts (0)      ║                     ║                     ║                     ║\n║  45         ║ ktor-servlet        ║                     ║                     ║                     ║\n║  45         ║                     ║                     ║                     ║                     ║\n║  45         ║                     ║                     ║                     ║                     ║\n║  45         ║                     ║                     ║                     ║ ktor-samples (0)    ║\n║  45         ║                     ║                     ║                     ║ ktor-freemarker     ║\n║  49         ║                     ║                     ║                     ║ ktor-freemarker (3) ║\n...\n╚═════════════════════════════════════════════════════════════════════════════════════════════════════╝\n\nPARALLEL BUILD SUCCESSFUL (68 seconds, sequential build would have taken 97 seconds)\n```\n\nThe “Time” column on the left describes at what time (in seconds) each task was scheduled. Each project appears twice: when they start and when they finish (and when they do, the time they took is appended in parentheses).\n\n## Analyzing the thread scheduling\n\nAs you can see, `core` is scheduled first and since all the other projects depend on it, Kobalt can’t build anything else until that project completes, so the other four threads remain idle during that time. When that build completes forty-five seconds later, Kobalt now determines that quite a few projects are now eligible to build, so they get scheduled on all the idle threads: `ktor-locations`, `ktor-netty`, etc... The first to complete is `ktor-hosts` and Kobalt immediately schedules the next one on that thread.\n\nFinally, Kobalt gives you the complete time of the build and also how long a sequential build would have taken, calculated by simply adding all the individual project times. It’s an approximation (maybe these projects would have been built faster if they weren’t competing with other build threads) but in my experience, it’s very close to what you actually get if you perform the same build sequentially.\n\nObviously, the gain with parallel build is highly dependent on the size of your projects. For example, if project C depends on projects A and B and these two projects are very small, the gain in parallelizing that build will be marginal. However, if A and B are both large projects, you could see your total build time divided by two. Another big factor in the gain you can expect is whether you use an SSD. Since all these parallel builds are generating a lot of files in various directories concurrently, I suspect that a physical hard drive will be much slower than an SSD (I haven’t tested, I only have SSD’s around).\n\n## Taking things further\n\nWhen project B depends on project A, it certainly looks like you can’t start building B until A has completed, right? Actually, that’s not quite true. It’s possible to parallelize (or more accurately, vectorize) such builds too. For example, suppose you launch `./kobaltw test` on these two projects:\n\n```kotlin\n$ ./kobalw test\n----- A:compile\n----- A:assemble\n----- A:test\n----- B:compile\n----- B:assemble\n----- B:test\n```\n\nBut the dependency of B on A is not on the full build: B certainly doesn’t need to wait for A to have run its tests before it can start building. In this case, B is ready to build as soon as A is done assembling (i.e. created A.jar). So here, we could envision having threads scheduled at the task level, and not at the project level. So what we could really do is:\n\n\n```\n╔═════════════════════════════════════════════════════════╗\n║  Time (sec) ║ Thread 39           ║ Thread 40           ║\n╠═════════════════════════════════════════════════════════╣\n║             ║ A:compile           ║                     ║\n║             ║ A:assemble          ║                     ║\n║             ║ A:test              ║ B:compile           ║\n║             ║                     ║ B:assemble          ║\n║             ║                     ║ B:test              ║\n╔═════════════════════════════════════════════════════════╗\n║  Time (sec) ║ Thread 39           ║ Thread 40           ║\n╠═════════════════════════════════════════════════════════╣\n║             ║ A:compile           ║                     ║\n║             ║ A:assemble          ║                     ║\n║             ║ A:test              ║ B:compile           ║\n║             ║                     ║ B:assemble          ║\n║             ║                     ║ B:test              ║\n```\n\nAs you can see above, Kobalt schedules `B:compile` as soon as `A:assemble` has completed while starting `A:test` on a separate thread, resulting in a clear reduction in build time.\n\nThis task-based approach can improve build times significantly since tests (especially functional tests) can take minutes to run.\n\n## Wrapping up\n\nI started implementing parallel builds mostly as a curiosity and with very low expectations but I ended up being very surprised to see how well they work and how they improve my build times, even when just considering project-based concurrency and not task-based concurrency. I’d be curious to hear back from Kobalt users on how well this new feature performs on their own projects.\n\nAnd if you haven’t tried Kobalt yet, it’s extremely easy [to get started](http://beust.com/kobalt).\n\n","author":"Cédric Beust","date":"2016-08-06","type":"article","categories":["Kotlin","Kobalt"],"features":["highlightjs"],"description":"","filename":"","lang":"EN","enclosure":null},{"title":"Calling on EAPers","url":"https://blog.jetbrains.com/kotlin/2016/08/calling-on-eapers/","body":"\nAt JetBrains we’ve always believed in our Early Access Program for our tools, giving developers a chance to use the latest features or fixes as soon as they’re ready. We’ve followed the same philosophy with Kotlin, knowing of course that with a language, some decisions can haunt you for life.\n\nThat is why during the pre-release days of Kotlin, we’d have milestone releases with features and important changes for our early adopters (including ourselves at JetBrains), collect feedback on whether things were working as designed. This release-feedback-adjust cycle has proven invaluable in so many occasions and has definitely helped shape Kotlin 1.0.\n\nBut it’s not over with the release. We’re still continuing to develop Kotlin with new language features and we need your continued support. As you know, we have two ‘branches’ of EAP’s, the 1.0.X ones which are more about bug fixes and tooling, and the 1.1 EAP which is about language changes. And it’s with these EAP’s, the ones with language changes, where we could really use your help. While we don’t recommend you using these 1.1 EAP’s in production code, we definitely do need you to give us feedback. In return, we promise to listen to everything you have to say!\n\n## Using EAP’s\n\nThe easiest way to access EAP’s is via the Tools menu. Open _Tools | Kotlin | Configure Kotlin Plugin Updates_ in the main menu, select Early Access Preview channel 1.0.x or 1.1 and press the _Check for updates now_ button.\n![Screen Shot 2016-08-01 at 17.55.03](https://i0.wp.com/blog.jetbrains.com/kotlin/files/2016/08/Screen-Shot-2016-08-01-at-17.55.03.png?w=640&ssl=1)\nTo use the new builds from Maven or Gradle: add _https://dl.bintray.com/kotlin/kotlin-eap_ or _https://dl.bintray.com/kotlin/kotlin-eap-1.1_ as a repository to your project\n\n_At the moment the first EAP of Kotlin 1.1 is available (with [coroutines](https://youtu.be/4W3ruTWUhpw), type aliases, bound callable reference, local delegated properties, Java 7/8 support and [many more](https://blog.jetbrains.com/kotlin/2016/07/first-glimpse-of-kotlin-1-1-coroutines-type-aliases-and-more/)). Also today we just published first EAP build of Kotlin 1.0.4 with lots of bugs fixes in the compiler and IDE, whole bunch of new intentions, inspections and quickfixes, and it’s now fully compatible with Gradle 2.14.1. For more information check out [the full Kotlin 1.0.4 changelog](https://github.com/JetBrains/kotlin/blob/767329fcab8249214c9c77db8ff1b8c1b3bd44b9/ChangeLog.md)_\n\n## Giving Feedback\n\nMost of the Kotlin team are available on our public ([Slack community](http://kotlinslackin.herokuapp.com)), and specifically on the #eap channel, where we’re very eager to listen to your feedback and help with any questions or issues you may have. Of course, our [issue tracker](http://kotl.in/issue) is always open too\n\nOne of our main goals with Kotlin has always been to make it an industrial language that is pragmatic. And it’s by using Kotlin in many types of applications and scenarios that will help us achieve this goal. For this, we continue to need your help!\n\nThank you and let’s Kotlin!\n\n","author":"Roman Belov","date":"2016-08-04","type":"article","categories":["Kotlin","EAP"],"features":["highlightjs"],"description":"","filename":"","lang":"EN","enclosure":null},{"title":"Getting started with Kotlin and third-party libraries Glide, Dagger 2, Retrofit 2, Realm, MVP and RxJava on Android","url":"http://steelkiwi.com/blog/getting-started-kotlin-libraries-Glide-Dagger/","body":"\nIt’s not a secret to Android developers all around the globe that IT community has been trying to find a distinct replacement of Java. Until 2011 before Kotlin creation was announced the most suitable candidate was Scala. Kotlin source code was published in 2012, and in 2016 the 1.0 version was released.\n\nKotlin was claimed to be a response to massive Java code and Scala low-speed compilation. Today many famous IT companies use Kotlin in their projects. The attention to this language is continuing to grow, as it wins over the developers with its syntax and the fact that Kotlin is supported in IDE by the means of plugin. Even Jake Wharton, recognized Android gospeller, uses Kotlin in the projects of his own thus encouraging Android community to use this language.\n\nLet’s stay abreast of this trend and try Kotlin on practice to see its extensively discussed pros and cons. And also we will learn how to start development of Android applications using Kotlin.\n\n## What does Kotlin hide?\n\nMostly Kotlin is commended for its briefness and code safety and also for compatibility with Java and flexible usage. It’s hard to list all its advantages, so let’s consider the most interesting ones.\n\n### Kotlin’s Strengths:\n\n* It is [fully compatible](https://github.com/steelkiwi/Getting-started-with-Kotlin/blob/master/app/src/main/java/com/ktoi/toi/model/NewsResponse.java#L12) with Java. It can use all available Java frameworks, libraries and also with separate modules in current projects.\n\n* It has [open source code](https://kotlinlang.org/), so it’s easy to track and determine an issue and if you come up with it, you can always submit it to Kotlin developers.\n\n* Kotlins repository consumes less space than Scala, and adding Kotkin to a project is equal to Google library.\n\n* Starting from Java 6, it can use the major part of Java 7 and some portable elements of Java 8. That’s why it is easily available even if you are facing troubles updating to new JVM version.\n\n* There’s immutability by default.\n\n* It has Higher-Order Functions, i.e. the functions that take functions as parameters.\n\n* Null safety. Variables in Kotlin can’t possess the null value by default unless you denote them.\n\nIf the Kotlin advantages are clear, it has disadvantages as well, even though they are not so obvious.\n\n### Weaknesses of Kotlin:\n\n* Kotlin is Java 6 bytecode-oriented and doesn’t use a number of improvements available in Java 8 like invoke-dynamic.\n* There can appear issues with annotation processing.\n* There are no analogues to plugin-macros or compilers which thus limits the usage of convenient Scala macros or plugins like Checker Framework from Java.\n* If you practice joint usage of Java and Kotlin you need to follow certain rules of compatibility.\n* You will have to rewrite some proven to be effective solutions for Android, including the architectural ones as Kotlin enables the usage of alternative approach.\n* The language is pretty young and hasn’t found any specific niche, however, it is suitable not only for Android but also for backend development.\n* The language is pretty green and there are no worked out best practices for solving particular tasks.\n\nLet’s dwell on compatibility and look closely at the example of a simple application development using such popular libraries like:\n\n* [Glide](https://github.com/bumptech/glide)\n* [Dagger 2](https://github.com/google/dagger)\n* [Retrofit 2](https://github.com/square/retrofit)\n* [Realm database](https://realm.io/)\n* [RxJava + RxAndroid](https://github.com/ReactiveX/RxAndroid)\n\nThe app serves as a good instance of libraries data usage and implementation of MVP architecture:\n\n![A good instance of libraries data usage and implementation of MVP architecture](http://steelkiwi.com/media/markdownx/e76ce8ac-7999-473a-9749-1b90edb5ca24.png)\n\n## Let’s proceed to the development:\n\n![](http://steelkiwi.com/media/markdownx/6bc4f839-5ead-4741-bdf3-1939d728b1ed.png)\n\nAfter that configure your project. The easiest way to do this is to press Ctrl+Shift+A and find Configure Kotlin in Project item that will appear in autocomplete:\n\n![](http://steelkiwi.com/media/markdownx/49da4de3-6699-4f1b-89f3-3db63ba53500.png)\n\nTo convert existing Java classes to Kotlin you need to find the command named Convert Java to Kotlin:\n\n![](http://steelkiwi.com/media/markdownx/505130b1-e437-4019-a4de-928b7170b055.png)\n\nNow let's start the integration of the needed libraries A few words before we start. Some libraries like Dagger 2 require Annotation Processing. Java Annotation Processing is not suitable for Kotlin. That’s why it includes its own Annotation Processing Tool for Kotlin (kapt), here is a great opinion on it.\n\nTo activate it you need to add this in the [build.gradle](https://github.com/steelkiwi/Getting-started-with-Kotlin/blob/master/app/build.gradle#L26) file:\n\n    kapt {\n        generateStubs = true\n    }\n    buildscript {\n       ext.supportVersion = '25.0.0'\n       ext.daggerVersion = '2.7'\n       ext.retrofitVersion = '2.1.0'\n       ext.rxVersion = '1.2.1'\n       repositories {\n           mavenCentral()\n           jcenter()\n       }\n       dependencies {\n           classpath \"io.realm:realm-gradle-plugin:2.1.1\"\n       }\n    }\n\n    dependencies {\n       compile fileTree(dir: 'libs', include: ['*.jar'])\n       androidTestCompile('com.android.support.test.espresso:espresso-core:2.2.2', {\n           exclude group: 'com.android.support', module: 'support-annotations'\n       })\n       compile 'com.android.support:appcompat-v7:25.0.0'\n       testCompile 'junit:junit:4.12'\n       compile \"org.jetbrains.kotlin:kotlin-stdlib:$kotlin_version\"\n       compile \"com.android.support:cardview-v7:${supportVersion}\"\n       compile \"com.android.support:design:${supportVersion}\"\n\n       // Dagger 2\n       compile \"com.google.dagger:dagger:${daggerVersion}\"\n       kapt \"com.google.dagger:dagger-compiler:${daggerVersion}\"\n       provided \"org.glassfish:javax.annotation:3.1.1\"\n\n       //Retrofit 2\n       compile \"com.squareup.retrofit2:retrofit:${retrofitVersion}\"\n       compile \"com.squareup.retrofit2:adapter-rxjava:${retrofitVersion}\"\n       compile \"com.squareup.retrofit2:converter-gson:${retrofitVersion}\"\n\n       compile 'com.google.code.gson:gson:2.8.0'\n\n       compile \"io.reactivex:rxjava:${rxVersion}\"\n       compile \"io.reactivex:rxandroid:${rxVersion}\"\n\n       compile 'com.github.bumptech.glide:glide:3.7.0'\n\n     }\n\nThen we create [inheriting class](https://github.com/steelkiwi/Getting-started-with-Kotlin/blob/master/app/src/main/java/com/ktoi/toi/shared/AppDelegate.kt#L10) from Application and configure Realm and dependencies graph for Dagger 2 developed by Google:\n\n    class AppDelegate : Application() {\n\n       var injector: AppInjector? = null\n\n       @Singleton\n       @Component(modules = arrayOf(NewsModule::class))\n       interface AppInjector {\n\n           fun inject(activity: MainActivity)\n\n       }\n\n       override fun onCreate() {\n           super.onCreate()\n           injector = DaggerAppDelegate_AppInjector.builder().build()\n\n           Realm.init(this)\n           val config = RealmConfiguration.Builder().build()\n           Realm.setDefaultConfiguration(config)\n       }\n    }\n\nTo work with HTTP we use Retrofit. We need to create an [interface](https://github.com/steelkiwi/Getting-started-with-Kotlin/blob/master/app/src/main/java/com/ktoi/toi/shared/NewsApiInterface.kt#L8) with one method that will receive news feed:\n\n    interface NewsApiInterface {\n       @GET(\"/feeds/newsdefaultfeeds.cms?feedtype=sjson\")\n       fun getNews(): Observable<NewsResponse>\n    }\n\nWe create [NewsModule class](https://github.com/steelkiwi/Getting-started-with-Kotlin/blob/master/app/src/main/java/com/ktoi/toi/shared/NewsModule.kt#L18) wherein the injected objectives will be created:\n\n    @Module\n    class NewsModule {\n\n       @Provides\n       @Singleton\n       fun provideNewsPresenter(): NewsPresenter {\n           return NewsPresenter()\n       }\n\n       @Provides\n       @Singleton\n       internal fun provideNewApiInterface(): NewsApiInterface {\n           val retrofit = Retrofit.Builder()\n                   .baseUrl(Constants.NEWS_ENDPOINT)\n                   .addConverterFactory(GsonConverterFactory.create())\n                   .addCallAdapterFactory(RxJavaCallAdapterFactory.createWithScheduler(Schedulers.io()))\n                   .build()\n           return retrofit.create(NewsApiInterface::class.java)\n       }\n    }\n\nIn [NewPresenter class](https://github.com/steelkiwi/Getting-started-with-Kotlin/blob/master/app/src/main/java/com/ktoi/toi/presenter/NewsPresenter.kt#L16) we will use RxAndroid and Realm for [news feed processing and caching](https://github.com/steelkiwi/Getting-started-with-Kotlin/blob/master/app/src/main/java/com/ktoi/toi/presenter/NewsPresenter.kt#L32):\n\n    subscription = mNewsApiInterface!!\n           .getNews()\n           .map { it.newsItem }\n           .flatMap({ items ->\n               Realm.getDefaultInstance().executeTransaction({ realm ->\n                   realm.delete(NewsItem::class.java)\n                   realm.insert(items)\n               })\n               Observable.just(items)\n           })\n           .onErrorResumeNext { throwable ->\n               val realm = Realm.getDefaultInstance()\n               val items = realm.where(NewsItem::class.java).findAll()\n               Observable.just(realm.copyFromRealm(items))\n           }\n           .observeOn(AndroidSchedulers.mainThread())\n           .doOnTerminate { mNewsView?.hideLoading() }\n           .subscribe({ mNewsView?.onNewsItemLoaded(it) }, { mNewsView?.onError(it) })\n\nProjects source code is available on [Repository](https://github.com/steelkiwi/Getting-started-with-Kotlin).\n\n### Let’s sum up\n\nAll in all, Kotlin is a modern and secure programming language that simplifies Android apps development. It looks like a distinct alternative to Java as it has good documentation and it is simple enough for understanding. We hope that this article helped you to figure out how to create a project on Kotlin and integrate the needed libraries.\n\n","author":"Yaroslav Polyakov","date":"2016-11-17","type":"article","categories":["Kotlin","Android"],"features":["highlightjs"],"description":"","filename":"","lang":"EN","enclosure":null},{"title":"Kotlin Coding","url":"http://cirorizzo.net/2016/02/03/kotlin-code/","body":"\n###### _Part 2_\n\nAs mentioned in the previous [post](http://www.cirorizzo.net/2016/01/23/kotlin-at-glance/), Kotlin representing a better way to program on the Android platform and the better companion for it is [Android Studio](http://developer.android.com/sdk/index.html).\nIf you're one of the kind still struggling to start to use this Official Android IDE, well this is good chance to give it a try.\n\n#### Setup Android Studio\n\nAndroid Studio comes from [JetBrains](https://www.jetbrains.com/), the same of Kotlin; so no worries about strange configurations or weird plugins: Android Studio has already all what you need to start coding Kotlin.\n\n> The IDE's got another magic feature who convert Java code to Kotlin from Menu **_Code->Convert Java file to Kotlin file_**\n\nAnother cool thing is you can have a project mixing Java and Kotlin at same time across different files (of course you cannot mix Java and Kotlin in the same file/class!).\n\nLet's start having a look what is needed to start or adding some Kotlin classes to an Android Project.\n\nAs mentioned early, you don't need to install anything else to have Kotlin on Android Studio, but you need to specify in the project build tool (Module `build.gradle` file) to include all we need.\n\nAt the beginning of the file, just after the standard Android plugin adding the Kotlin one\n\n```groovy\napply plugin: 'com.android.application'\napply plugin: 'kotlin-android'\n```\n\nFor our purpose one more plugin to use the Kotlin Android Extension (not mandatory)\n\n```groovy\napply plugin: 'kotlin-android-extensions'\n```\n\nAnd in the `buildscript` section of the same file, adding the Kotlin libraries. For the latest version check the [official page](https://kotlinlang.org/docs/reference/using-gradle.html) to have the latest update\n\n```gradle\nbuildscript {\n    repositories {\n        jcenter()\n    }\n    dependencies {\n        classpath \"org.jetbrains.kotlin:kotlin-gradle-plugin:<current version>\"\n    }\n}\n```\n\nIt's my intention to talk on this Kotlin posts series about the basic of the language and how the standard library _Kotlin Android Extension_ (the second library included above) can help and improve exponentially the Kotlin skill programming.\n\n> There's another powerful library called [Anko](https://github.com/Kotlin/anko), a type-safe DSL (...and more) who can help a lot as well, we're going to go deeper later on\n\nAnd one more dependency to include at `dependencies` section\n\n```groovy\ndependencies {\n   compile 'org.jetbrains.kotlin:kotlin-stdlib:<current version>'\n}\n```\n\nIf you're gonna to have your project entirely in Kotlin, your project setup is finished, but if you want to mix Java as well, or basically you want to start adding new Kotlin classes to your existing project is strongly suggested to define two different folders, one for Java and one for Kotlin\n\n```\nproject\n   - src\n      - main (root)\n         - java\n         - kotlin\n```\n\n\nand in that case adding in the `build.gradle` the following snap\n\n```groovy\nsourceSets {\n    main.java.srcDirs += 'src/main/java'\n    main.java.srcDirs += 'src/main/kotlin'\n}\n```\n\nWell done! Now you're ready to start coding...\n\n#### Starting Kotlin Project\n\nStarting a project the first class we're thinking of is an Activity class ;) so let's start from it\n\n> At the moment is not possible starting a Kotlin project by the scratch in Android Studio using wizard template\n\nLet's create an Android project using the template `Empty Activity` and after it we'll have a Java class (...erm, what?)\n\n```java\npublic class MainActivity extends AppCompatActivity {\n   @Override\n   protected void onCreate(Bundle savedInstanceState) {\n      super.onCreate(savedInstanceState);\n      setContentView(R.layout.activity_main);\n   }\n}\n```\n\nwell let's using the JetBrains magic through the auto converter feature selecting the menu `Code->Convert Java file to Kotlin file` and...\n\n```java\nclass MainActivity : AppCompatActivity() {\n   override fun onCreate(savedInstanceState: Bundle?) {\n      super.onCreate(savedInstanceState)\n      setContentView(R.layout.activity_main)\n   }\n}\n```\n\nAs you can notice there are a bunch of smart things like:\n\n* no more semicolon `;` (it's optional, so if you still struggling to get rid of it, Kotlin is tolerant! ;)\n* The _scope_ of the class or method if `public` is omitted (i.e. `class MainActivity`)\n* get rid `extends` keyword for inheritance and just colon `:` instead\n* inherited class used with brackets `()` means to be initialized with the primary constructor (i.e. `AppCompatActivity()`)\n* methods are function and the keyword is just `fun`\n* function returning `void` just not needs any additional keyword\n* the type of a member, param, etc is placed after it and followed by a colon `:`\n* and at last but not least the _Null Safety_ concept; in Kotlin every member, variable comes from a type, is not nullable by default, if you need (permit!) to use a nullable one, has to be declared using a special keyword at the end of the type `?` (i.e. `savedInstanceState: Bundle?`)\n\nSo far easy, isn't it?\nWell, will be even more!\n\n#### Koltin Android Extensions\n\nThe plugin included early at the beginning of Gradle file\n\n```groovy\napply plugin: 'kotlin-android-extensions'\n```\n\n\nis a powerful tool who helps to avoid a lots of boilerplate for binding views in our class and preventing one of the biggest feckless function in Android: `findViewById()`.\n\nStarting have a look to our layout `activity_main.xml`, for sure it'll have the standard `TextView`\n\n```xml\n<TextView\n    android:layout_width=\"wrap_content\"\n    android:layout_height=\"wrap_content\"\n    android:text=\"Hello World!\"\n    android:id=\"@+id/textVw\"/>\n```\n\nwell, usually in Java we need to declare the View\n\n```java\nprivate TextView textVw;\n```\n\n\nand then binding it with instance of the object defined in the layout through this\n\n```java\ntextVw = (TextView) findViewById(R.id.textVw);\n```\n\n\nand starting to use it\n\n```java\ntextVw.setText(\"Hello, How're You?\");\n```\n\nBoring, isn't it?\n\nAll this code in Kotlin is now **useless**, the only thing to do is just starting to use the view\n\n```kotlin\ntextVw.text = \"Hello, How're You?\"\n```\n\nThat's it!\n\nKoltin Android Extensions thinks all the rest...\nYou'll notice about the `import` added by the IDE in the class\n\n```\nimport kotlinx.android.synthetic.main.activity_main.*\n```\n\nThis is used to have the binding with our `TextView`\n\nWhat do you think about? Still skeptical?\nWell, I know you're a developer (_<del>stubborn</del> skeptical people_) ;)\nLet's go further on this thing improving our project step by step later on...\n\nSee you soon on the next post!\n\n","author":"Ciro Rizzo","date":"2016-02-03","type":"article","categories":["Android","Kotlin"],"features":["highlightjs"],"description":"","filename":"","lang":"EN","enclosure":null},{"title":"Exercises in Kotlin: Part 5 - Classes","url":"http://blog.dhananjaynene.com/2016/04/exercises-in-kotlin-part-5-classes/","body":"\nAfter the last post [Exercises in Kotlin: Part 4 - Control flows and return](http://dnblog.ddesk/2016/04/exercises-in-kotlin-part-4-control-flows-and-return/), we shall be exploring classes and objects in the exercises in this post. While retaining many similarities to Java classes, there are actually significant differences in syntax as well and these help classes become a little easier to work with in Kotlin. And save a lot of unnecessary boilerplate code.\n\n## Minimalist Syntax\n\nProbably the minimalistic (and for all practical purposes useless) declaration of a class in Kotlin will be\n\n```kotlin\nclass Foo\n```\n\n## A typical class\n\nThats it. No constructor, no fields, no body. However as is obvious this is not particularly useful. Let us look at a more useful one.\n\n```kotlin\nclass Account (val number: String, var balance: BigDecimal) {\n    fun deposit(amount: BigDecimal) {\n        balance += amount\n    }\n    fun withdraw(amount: BigDecimal) {\n        if (balance < amount) {\n            throw Exception(\"Insufficient funds in the account\")\n        }\n        balance -= amount\n    }\n}\n```\n\nHere `Account` is the class name. It has two properties `number` which is a `String` and `balance` which is a `BigDecimal`. Another aspect is `number` is a read-only property ie. you can't change the value within the body of the class (say in a method) after one is provided at the construction time. As mentioned in an earlier post read-only properties (aka `final` in Java terms) are identified by the keyword `val`, while read-write properties are identified by `var`. Notice the succinct constructor. The properties of the class that are required by the primary constructor are specified immediately after the class name within parenthesis. You can have variables declared in the constructor that are neither `val`s nor `var`s. However they can be used only during construction time and do not become properties of the class (more about that later). Thus unlike Java you don't need to write constructors just in order copy values from the constructor parameter to a member field. Also unlike Java you do not need to write getter/ setter methods in most cases (though you could if you had a specific reason to write custom getter/setters).\n\nClient code for the account class could perhaps use it as follows. Do note that the object is instantiated using the `ClassName(parameter_list)` construct. It is essentially similar to Java except that there is no `new` keyword preceding it.\n\n```kotlin\n// Instantiate object\nval acc1 = Account(\"123\", BigDecimal(\"456.70\"))\n\n// get value of a property and print it\nprintln(acc1.number)\n\n// invoke a method\nacc1.deposit(BigDecimal(\"234.56\"))\n\n// change the value of a property\nacc1.balance = BigDecimal(\"567.89\")\n```\n\n## Member Visibility\n\nNow `balance` needs to be a `var` since it changes. But some might be disappointed at how it can be modified from outside the class. One solution would be to make it a `private var` as follows\n\n```kotlin\nclass Account (val number: String, private var balance: BigDecimal) {\n    fun deposit(amount: BigDecimal) {\n        balance += amount\n    }\n    fun withdraw(amount: BigDecimal) {\n        if (balance < amount) {\n            throw Exception(\"Insufficient funds in the account\")\n        }\n        balance -= amount\n    }\n}\n\nfun somewhereElse() {\n    val acc1 = Account(\"123\", BigDecimal(\"456.70\"))\n\n    // The following wouldn't compile\n    acc1.balance = BigDecimal(\"567.89\")\n\n    // But neither would the following line\n    println(acc1.balance)\n}\n```\n\nWhat if you wanted it to be read-only from outside the class but read-write within the class? You could choose to use the following approach of passing in a parameter to the constructor, using it to declare another property within the body of the class and then declaring that variable to have a private setter. Note that in this case `initBalance` is simply a parameter passed to the constructor (since it is not declared as either a `val` or a `var`), and can be accessed in a read only fashion only during the construction stage. (Thus other methods cannot use this parameter)\n\n```kotlin\nclass Account (val number: String, initBalance: BigDecimal) {\n    var balance = initBalance\n        private set\n\n    fun deposit(amount: BigDecimal) {\n        balance += amount\n    }\n\n    fun withdraw(amount: BigDecimal) {\n        if (balance < amount) {\n            throw Exception(\"Insufficient funds in the account\")\n        }\n        balance -= amount\n    }\n}\n\n```\n\n## Multiple constructors\n\nNow let us assume that we wish to allow the constructor to use a String based value for balance though the balance property on the account should continue to be a BigDecimal. You could modify the class as follows.\n\n```kotlin\nclass Account (val number: String, initBalance: String) {\n    var balance = BigDecimal(initBalance)\n        private set\n\n    fun deposit(amount: BigDecimal) {\n        balance += amount\n    }\n    fun withdraw(amount: BigDecimal) {\n        if (balance < amount) {\n            throw Exception(\"Insufficient funds in the account\")\n        }\n        balance -= amount\n    }\n}\n```\n\nHere `balance` is being initialised by constructing a `BigDecimal` using the `String` value. But we know if the value passed in is not a number, a `NumberFormatException` will be thrown. But we can't see that in the constructor declaration anywhere. Huh?\n\nI won't dwell long on that, but note that Kotlin (unlike Java) does _NOT_ use checked exceptions. Any method could throw any exception at any point in time and it does not have to be documented as a part of the method signature. A fuller discussion of this is beyond the scope of this post, but it should be stated that the conventional wisdom tends towards preferring unchecked exceptions and kotlin supports that style of programming.\n\nNow let us assume we wish to have both types of constructors, one taking the initial balance as a `String` and another as a BigDecimal. Each class can have one primary and zero or more secondary constructors, each one of them eventually calling the primary constructor via the keyword `this`. Note the parameter lists to secondary constructors cannot declare properties using `val` or `var` since these are anyways in turn declared by the primary constructor.\n\n```kotlin\nclass Account (val number: String, initBalance: BigDecimal) {\n    constructor(number: String, initBalance: String) :\n        this(number, BigDecimal(initBalance))\n\n    var balance = initBalance\n        private set\n\n    fun deposit(amount: BigDecimal) {\n        balance += amount\n    }\n    fun withdraw(amount: BigDecimal) {\n        if (balance < amount) {\n            throw Exception(\"Insufficient funds in the account\")\n        }\n        balance -= amount\n    }\n}\n```\n\nSo far our constructors have been only initialising properties. But what if you wanted them to do more. I have shown the way to do so by adding additional `println()` statements during both the primary and secondary construction phases as below.\n\n```kotlin\nclass Account (val number: String, initBalance: BigDecimal) {\n    init {\n        println(\"Into primary constructor\")\n    }\n    constructor(number: String, initBalance: String) :\n        this(number, BigDecimal(initBalance)) {\n        println(\"Into secondary constructor\")\n    }\n\n    var balance = initBalance\n        private set\n\n    fun deposit(amount: BigDecimal) {\n        balance += amount\n    }\n    fun withdraw(amount: BigDecimal) {\n        if (balance < amount) {\n            throw Exception(\"Insufficient funds in the account\")\n        }\n        balance -= amount\n    }\n}\n```\n\nAs can be seen the non property initialisation of primary constructor can be done in the `init{...}` block. Similarly secondary constructors can also include a block at the end which lists out the necessary statements to be performed.\n\n## Data Classes\n\nVery often we need basic classes which are primarily place holders for a collection of different values. Though java does not have an equivalent, in C, you would have called it a `struct` and in scala you would call it a `case class`. In Kotlin we have `data class`. eg.\n\n```kotlin\ndata class Point(val x: Double, val y: Double)\n```\n\nThese classes are tailored for using them as collection of other properties.\n\n*   A data class automatically generates a sensible `equals()/hashcode()` functions for the class based on the properties declared in the primary constructor.\n*   A sensible `toString()` is automatically provided\n*   Another helper method `copy()` to selectively override some property values when creating a copy is also automatically provided.\n*   You can also use a data class similar to a record of values easily since it also generates `component1()`, `component2()`, ... `componentN()` functions which can treat the class as a record of sequence of properties (in the same order as declared in the primary constructor).\n\nLets take a usage at a sample usage of the class above\n\n```kotlin\nval p1 = Point(1.1,2.2)\nprintln(p1)\nprintln(p1.x)\nprintln(p1.component1())\n\nval p2 = p1.copy(x=3.3)\nprintln(p2)\n\nval (x, y) = p1\nprintln(\"\" + x + \":\" + y)\n```\n\nThe output for the above will be as follows\n\n```\nPoint(x=1.1, y=2.2)\n1.1\n1.1\nPoint(x=3.3, y=2.2)\n1.1:2.2\n```\n\nNote, how a second copy (`p2`) was easily created from the first while allowing the ability to override a few values. Also how the `point` object can be destructured into its component values, in this case `val`s `x` and `y`. If the `Point` class had 3 properties, we would have had to provide 3 variables on the left hand side of the assignment operator for it to succeed\n\n## Enum classes\n\nLet us go back to the Account class example. Let us assume we wanted to add an account type member. Account type can either be `Savings` or `Current` (aka Checking). In order to allow the capability we will declare an enum class\n\n```kotlin\nenum class AccountType {\n    Savings, Current\n}\n```\n\nNow we can go ahead and modify the Account class as follows\n\n```kotlin\nclass Account (val number: String, initBalance: BigDecimal, val type: AccountType){ ... }\n\nfun somewhereElse() {\n    val acc1 = Account(\"123\", BigDecimal(\"456.7\"),AccountType.Savings)\n    println(acc1.type)\n}\n```\n\nNow let us take a look at some of the sample usages of the enum class\n\n```kotlin\nfun somewhereElse() {\n    // Iterate through all the enums\n    for( accType in AccountType.values()) {\n        println(accType)\n    }\n\n    // Every enum instance has two properties: name and ordinal\n    println(AccountType.Savings.name)\n    println(AccountType.Current.ordinal)\n\n    // You can recreate an enum instance based on a String\n    println(AccountType.valueOf(\"Savings\"))\n}\n```\n\nThis program will result in the following output\n\n```\nSavings\nCurrent\nSavings\n1\nSavings\n```\n\nThus as you can see, _You could iterate through all the enum types by getting an array of all its possible types using_ Every enum instance has two properties, a `name` which is a string and an `ordinal` which allows the enum values to be used a set of ordered values and allows them to be comparable. The name of course is the name as was provided in the declaration and ordinal is the sequence in the declaration of values. * You can use the string value of the enum to obtain an enum instance using `valueOf()`\n\nFinally you can provide additional properties to each of the enum instances as follows\n\n```kotlin\nenum class Color(r: Int, g: Int, b: Int) {\n    Red(255,0,0),\n    Green(0,255,0),\n    Blue(0,0,255)\n}\n```\n\nWe have looked at the basics of classes in this post. We will look at inheritance next.\n\n","author":"Dhananjay Nene","date":"2016-04-29","type":"article","categories":["Kotlin"],"features":["highlightjs"],"description":"","filename":"","lang":"EN","enclosure":null},{"title":"The Journey of a Spring Boot application from Java 8 to Kotlin: The Application Class","url":"http://engineering.pivotal.io/post/spring-boot-application-with-kotlin/","body":"\nAfter writing a significant amount of Ruby/Rails for many years, lately I have found myself writing a ton of Spring Boot applications. [Spring Boot](http://projects.spring.io/spring-boot/) is a great framework for the JVM that focuses on developer productivity by making \"it easy to create stand-alone, production-grade Spring based Applications that you can 'just run'\". It has a lot of the feel of Rails in the \"convention over configuration\" department but because I end up using Java 8, I have lost some of the \"joy\" that you get when writing in Ruby. Even though Java 8 provides significant improvements over Java 7, I wanted to find out if I could get some more of that joy back by using [Kotlin](https://kotlinlang.org/) to write Spring Boot applications.\n\nKotlin is a new language from the folks at [JetBrains](https://www.jetbrains.com/), creators of IntelliJ and RubyMine, as a replacement for Java in developing their products. Their goal was to create a more concise JVM based language that helps increase developer productivity, avoid some common pitfalls in Java development and be 100% compatible with existing Java programs. It targets Java 6 as the baseline while still adding some great language features so it is quite useful for Android development as well.\n\nThis post, and all that follow, will use an existing Java 8/Spring Boot [application](https://github.com/mikegehard/user-management-evolution-kotlin/tree/running-java) as a starting point for the exploration. This will allow me to see direct comparisons between Java 8 syntax and Kotlin syntax. The journey will allow me to experience first hand what a Spring Boot/Kotlin application might look like as well as learn the language as I go that is a bit more than a \"Hello World\" application.\nIf you want to follow along as I travel, you can check out the evolving source on [GitHub here](https://github.com/mikegehard/user-management-evolution-kotlin).\n\n\nIn addition, these posts are not meant to be a full tutorial on Kotlin and will only cover the language features pertinent to the transformation. If you want a full tutorial, the Kotlin website has a lot of [great information](https://kotlinlang.org/docs/reference/).\n\nFinally, if you have any suggestions for improvements in [the code](https://github.com/mikegehard/user-management-evolution-kotlin), please feel free to submit a GitHub issue or submit a pull request.\n\n## The starting line\n\nThe first thing we need when starting a Spring Boot application is an application class. Here is the [application class](https://github.com/mikegehard/user-management-evolution-kotlin/blob/running-java/applications/billing/src/main/java/com/example/billing/Application.java) that I started with:\n\n```kotlin\npackage com.example.billing;\n\nimport org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\nimport org.springframework.cloud.client.circuitbreaker.EnableCircuitBreaker;\nimport org.springframework.cloud.client.discovery.EnableDiscoveryClient;\n\n@SpringBootApplication\n@EnableDiscoveryClient\n@EnableCircuitBreaker\n\npublic class Application {\n    public static void main(String[] args) {\n        SpringApplication.run(Application.class, args);\n    }\n}\n\n...\n\n```\n\nNo surprises here. We create a static `main()` method on the Application class that Spring Boot detects when you run the executable jar file.\n\nHere is that same application class in Kotlin:\n\n```kotlin\npackage com.example.billing\n\nimport org.springframework.boot.SpringApplication\nimport org.springframework.boot.autoconfigure.SpringBootApplication\nimport org.springframework.cloud.client.circuitbreaker.EnableCircuitBreaker\nimport org.springframework.cloud.client.discovery.EnableDiscoveryClient\n\n@SpringBootApplication\n@EnableDiscoveryClient\n@EnableCircuitBreaker\n\n// This class must not be final or Spring Boot is not happy.\nopen class Application {\n    companion object {\n        @JvmStatic fun main(args: Array<String>) {\n            SpringApplication.run(Application::class.java, *args)\n        }\n    }\n}\n\n```\n\nThe first difference you may notice is the lack of semicolons. Yes ladies and gentlemen, no semicolons in Kotlin. While not a huge deal for some, it was a step in the right direction for me.\n\nThe next difference I noticed is the `open` keyword in front of the class definition. Classes in Kotlin are final by default, as per Item 17 from [Effective Java](http://www.oracle.com/technetwork/java/effectivejava-136174.html): *Design and document for inheritance or else prohibit it*. This is my first experience with friction between Kotlin's \"enforce good practices\" and Spring Boot's conventions. The `@SpringBootApplication` is a convenience annotation that marks the class with the `@Configuration`, `@EnableAutoConfiguration` and `@ComponentScan` annotations. It is the `@Configuration` annotation that forces the use of the `open` keyword. Removing the `open` keyword causes a runtime error when the application boots:\n\n```kotlin\norg.springframework.beans.factory.parsing.BeanDefinitionParsingException: Configuration problem: @Configuration class 'Application' may not be final. Remove the final modifier to continue.\n```\n\nThis is easy enough to fix since this application class doesn't contain any configuration information. Instead of using the `@SpringBootApplication` annotation you can [substitute](https://github.com/mikegehard/user-management-evolution-kotlin/commit/a9045e1968193fc70b4c43a330fde265b3325f7a) the `@EnableAutoConfiguration` and `@ComponentScan` annotations.\n\n```kotlin\npackage com.example.billing\n\nimport org.springframework.boot.SpringApplication\nimport org.springframework.boot.autoconfigure.SpringBootApplication\nimport org.springframework.cloud.client.circuitbreaker.EnableCircuitBreaker\nimport org.springframework.cloud.client.discovery.EnableDiscoveryClient\n\n@EnableAutoConfiguration\n@ComponentScan\n@EnableDiscoveryClient\n@EnableCircuitBreaker\n\nclass Application {\n    companion object {\n        @JvmStatic fun main(args: Array<String>) {\n            SpringApplication.run(Application::class.java, *args)\n        }\n    }\n}\n\n```\n\nThe final differences that I noticed are in the definition of the `main()` method. Kotlin has an idea of [companion objects](https://kotlinlang.org/docs/reference/object-declarations.html#companion-objects). These objects are used in a way similar to static methods in Java but not exactly. That is where the `@JvmStatic` annotation comes in. This annotation tells Kotlin to generate an actual Java static method instead of the \"kinda,sorta\" one that is the default in Kotlin. This annotation is a great example of the investment in JVM compatibility.\n\nThe `main()` method is also missing the `public` modifier. [Methods are public by default](https://kotlinlang.org/docs/reference/visibility-modifiers.html) in Kotlin which reduces a bit of the boilerplate present in Java applications.\n\nFinally, you will notice that arrays in Kotlin are actual parameterized classes instead of the primitive type that they are in Java. Kotlin also puts the type annotation after the variable is defined. We will get into why this is important in future posts.\n\nOne final gotcha with the Kotlin application class is that you have to tell Spring Boot where to find the application class. In Gradle, it is as easy as this:\n\n```kotlin\nspringBoot {\n    mainClass = 'com.example.billing.Application'\n}\n```\n*Update - Feb, 16 2016: You do not need to tell Spring Boot where the application class is any longer. I got this from an early JetBrains blog post.*\n\n# An alternate application class\n\nKotlin also allows functions to be defined outside of classes so we can re-write the application class as:\n\n```kotlin\npackage com.example.billing\n\nimport org.springframework.boot.SpringApplication\nimport org.springframework.boot.autoconfigure.EnableAutoConfiguration\nimport org.springframework.cloud.client.circuitbreaker.EnableCircuitBreaker\nimport org.springframework.cloud.client.discovery.EnableDiscoveryClient\nimport org.springframework.context.annotation.ComponentScan\n\n@EnableAutoConfiguration\n@ComponentScan\n@EnableDiscoveryClient\n@EnableCircuitBreaker\n\nclass Application\n\nfun main(args: Array<String>) {\n    SpringApplication.run(Application::class.java, *args)\n}\n\n```\n\nIf we do this, the `main()` method is defined on a class called `ApplicationKt`, named after the file `Application.kt`, and this slightly changes the `build.gradle` entry:\n\n```kotlin\nspringBoot {\n    mainClass = 'com.example.billing.ApplicationKt'\n}\n```\n*Update - Feb, 16 2016: You do not need to tell Spring Boot where the application class is any longer. I got this from an early JetBrains blog post.*\n\nThis definition simplifies the signature of the `main()` method a bit. Gone are the annotations and the explicit companion object so the code is a little less cluttered.\n\nI'm not sure which one I prefer better. Using the companion object is more explicit about which class contains the `main()` method but the above definition is more succinct. Here we trade less code for an implicit understanding that an ApplicationKt class gets generated by the compiler.\tOver time, I'm thinking the abbreviated application class will grow on me.\n\n# Closing thoughts\nIn my mind, Kotlin is a step in the right direction as a \"better Java\". It seems to me that the language designers did what they could to remain compatible with existing Java programs while not being handcuffed by the legacy of Java. The lack of semi colons may seem trivial but will add up in large codebases and the enforcement of best practices at the language level will also help large codebases.\n\nYes there are some slight gotchas when it comes to smoothly integrating with Spring Boot but those are outweighed by the benefits of the new syntax and language constructs.\n\nIn our next installment, we will take a look at Java Spring Boot configuration classes and compare them to their Kotlin brethren. I'm hoping that we will continue to see gains from Kotlin that will outweigh the friction with Spring Boot.\n\n","author":"Mike Gehard","date":"2016-02-13","type":"article","categories":["Spring Boot","Kotlin"],"features":["highlightjs"],"description":"","filename":"","lang":"EN","enclosure":null},{"title":"Some of my favorite Kotlin features (that we use a lot in Basecamp)","url":"https://m.signalvnoise.com/some-of-my-favorite-kotlin-features-that-we-use-a-lot-in-basecamp-5ac9d6cea95#.q38ew6ikp","body":"\nTeam Android at Basecamp recently passed a fairly big milestone — over 25% of the [Basecamp 3 Android app](https://play.google.com/store/apps/details?id=com.basecamp.bc3) code base now runs on Kotlin! \uD83C\uDF89\n\n![](https://d262ilb51hltx0.cloudfront.net/max/800/1*pF4snICcl63et11YyuM_zw.png)\n_Github statistics for the Basecamp 3 Android app as of 5/27/16._\n\nWe’ve found that Kotlin not only makes our code much better, but massively [increases programmer happiness](https://m.signalvnoise.com/how-i-fell-in-love-with-a-programming-language-8933d5e749ed). All of this ensures we’re making the best app we can for the tens of thousands of Android users we support.\n\nGiven our new experiences with the language, I thought it’d be worth sharing some specifics that make the language so wonderful to work with.\n\nUnlike most articles that introduce you to a language, I’m going to avoid using too much programming lingo. Instead, I’ll try using plain English in the hopes that it’s more accessible to beginners. **\uD83E\uDD17**\n\n**Some notes about the code examples:**\n\n* I am by no stretch an expert in Kotlin. Read, consider, and discuss!\n* They look better on a desktop browser**.** You can get by on the mobile app in landscape mode, but I’d recommend breaking out your laptop to read them.\n* They’re brief and simple on purpose**.** Long-winded examples tend to cause confusion. Take these simple examples and extrapolate them into your own potential uses, and you’ll see a lot more power.\n\nLet’s get started with seven of my current favorites!\n\n#### 1. Replacing simple if/else if/else blocks with when\n\nOne of my absolute favorites.\n\n```java\n// Java  \nif (firstName.equals(\"Dan\")) {  \n    person.setTeam(programmers);  \n} else if (lastName.equals(\"Dihiansan\")) {  \n    person.setTeam(designers);  \n} else {  \n    person.setTeam(others);  \n}\n```\n\n```kotlin\n// Kotlin  \nwhen {  \n    firstName == \"Dan\"       -> person.team = programmers  \n    lastName  == \"Dihiansan\" -> person.team = designers  \n    else                     -> person.team = others  \n}\n```\n\n_when_ blocks are effectively the same as a simple _if_ block, but look how much more readable that is!\n\nThere’s a similar convention when only one argument is being checked. Typically this would be a long, ugly switch/case statement in Java.\n\n```java\n// Java  \nswitch (firstName) {  \n    case \"Dan\": person.setTeam(programmers)  \n        break;  \n    case \"Jay\": person.setTeam(programmers)  \n        break;  \n    case \"Jamie\": person.setTeam(designers)  \n        break;  \n    default:  \n        person.setTeam(others)  \n}\n```\n\n```kotlin\n// Kotlin  \nwhen (firstName) {  \n    \"Dan\", \"Jay\" -> person.team = programmers  \n    \"Jamie\"      -> person.team = designers  \n    else         -> person.team = others  \n}\n```\n\nI swear, this alone is worth writing Kotlin.\n\n#### 2. Beautifying even the ugliest click handlers\n\nUsing [Anko](https://github.com/Kotlin/anko), a library built for Kotlin, click listeners are ridiculously easy.\n\nI hate writing these in Java so much that I could barely bring myself to write an example here. But I soldiered on. \uD83D\uDE2D\n\n```java\n// Java  \nview.setOnClickListener(new View.OnClickListener() {  \n    @Override  \n    public void onClick(View v) {  \n        System.out.println(\"This is horrible\");  \n    }  \n});\n```\n\n```kotlin\n// Kotlin  \nview._onClick_ {  \n    println(\"WAT\")  \n}\n```\n\n#### 3. No more view binding\n\nBy using the [Kotlin Android Extensions](https://kotlinlang.org/docs/tutorials/android-plugin.html), you no longer need to bind views to objects to start working with them. You can access them directly without any binding. Zero. None.\n\n```java\n// Java  \nEditText composer = findViewById(R.id.composer);  \ncomposer.setText(\"Allo!\");\n```\n\n```kotlin\n// Kotlin   \nview.composer.text = \"Allo!\"\n```\n\nThat might not look like a big deal in isolation, but think about how much of your Activity/Controller code is the ceremony of binding a view to an object before you can start to work with that object. Kotlin bypasses all of that.\n\n#### **4. Functions in one line**\n\nOne line functions can technically be written in Java, but you’d be going against generally accepted styles.\n\nKotlin’s inherent brevity makes one-liners (officially called [single-expression functions](https://kotlinlang.org/docs/reference/functions.html#single-expression-functions)) quite common, and they look great. No extra lines and no braces required.\n\n```java\n// Java  \npublic String fullName() {  \n    return getFirstName() + \" \" + getLastName();  \n}\n```\n\n```kotlin\n// Kotlin  \nfun fullName() = \"${firstName} ${lastName}\"\n```\n\n**Bonus**: the return object type is implied, so Kotlin will automatically know the method is returning a String without ever having to write “String” anywhere.\n\nYou may have also noticed in this example 1) [no need for _public_](https://kotlinlang.org/docs/reference/visibility-modifiers.html)and 2) [string interpolation](https://kotlinlang.org/docs/reference/idioms.html#string-interpolation).\n\n#### 5. Convenience methods built on top of familiar objects\n\nKotlin has extended objects you’re familiar with and made them even better and packaged them into the [Kotlin Standard Library](https://kotlinlang.org/api/latest/jvm/stdlib/).\n\nTake String comparisons for example:\n\n```java\n// Java  \nif (name.toLowerCase().contains(firstName.toLowerCase())) {  \n    ...  \n}\n```\n\n```kotlin\n// Kotlin  \nif (name.contains(firstName, true)) { ... }\n```\n\nNot a huge difference, but enough to improve readability in many places. The standard library has tons of these kinds of tweaks. Perfect!\n\n#### 6. Reducing the need for `if (whatever != null)`\n\nNull checking is so painfully common in Java that `if (whatever != null)` is probably in your recurring nightmares.\n\nKotlin has a number of [impressive null safety](https://kotlinlang.org/docs/reference/null-safety.html) features built in, and _let_ is just one of those ways to achieve more readable code.\n\n```java\n// Java  \nif (message != null) {  \n    System.out.println(message)  \n}\n```\n\n```kotlin\n// Kotlin  \nmessage?.let { println(it) }\n```\n\nHere if _message_ is not null, Kotlin will _let_ the block (what’s inside the braces) run. If it’s null, it just skips it.\n\nThere’s one other bit of awesomeness — notice the _println(it)_ statement? The _it_ keyword allows you to reference the object the _let_ began from.\n\n#### 7. The Elvis operator\n\nI mostly love this operator because of its name. It looks like this:\n\n```kotlin\n?: // Turn your head to the left, you may see someone familiar\n```\n\nFun name aside, the real reason this is great is because it handles the common scenario of “if something is null, I want to give it a value, but otherwise just leave it alone”.\n\n```java\n// Java  \nif (people == null) {  \n    people = new ArrayList();  \n}  \nreturn people;\n```\n\n```kotlin\n// Kotlin  \nreturn people ?: emptyArrayList()\n```\n\nHere if _people_ isn’t null, it returns. If it is, it returns whatever is to the right of the Elvis operator.\n\nSo that’s just a brief look at some things that make my life better every day working with Kotlin.\n\nIf you’re interested in getting started with Kotlin, their [documentation](https://kotlinlang.org/docs/reference/) is _very_ good, and you can poke around the interactive [Kotlin Koans](http://try.kotlinlang.org/#/Kotlin%20Koans/Introduction/Hello,%20world!/Task.kt). I tend to struggle with things like koans (feels too much like school work!), so if you’re like me, I’d encourage you to [try building something real](https://kotlinlang.org/docs/tutorials/kotlin-android.html).\n\n_We’re working really hard to make the all-new_ [_Basecamp 3_](https://basecamp.com/?source=svn-5ac9d6cea95) _and its companion_ [_Android app_](https://play.google.com/store/apps/details?id=com.basecamp.bc3) _as great as they can be. Check ’em out!_\n\n_If this was helpful to you, please do hit the heart button below or_ [_let me know on Twitter_](https://twitter.com/dankim) _and we’ll keep adding to this Kotlin series._\n\n","author":"Dan Kim","date":"2016-05-28","type":"article","categories":["Kotlin","Android"],"features":["highlightjs"],"description":"","filename":"","lang":"EN","enclosure":null},{"title":"Building a compiler for your own language: validation","url":"http://tomassetti.me/building-compiler-language-validation/","body":"\n![validation_for_your_own_programming_language](http://i0.wp.com/tomassetti.me/wp-content/uploads/2016/08/validation_for_your_own_programming_language.jpg?resize=730%2C489)\n\nSo you have parsed your code and built a clean AST for it. Now it is time to check if what the user has expressed make sense at all. We should perform validation, identifying semantical errors, to communicate together with lexical and syntactical errors (provided by the parser).\n\n## Series on building your own language\n\nPrevious posts:\n\n1.  _[Building a lexer](http://tomassetti.me/getting-started-with-antlr-building-a-simple-expression-language/)_\n2.  [_Building a parser_](http://tomassetti.me/building-and-testing-a-parser-with-antlr-and-kotlin/)\n3.  [Creating an editor with syntax highlighting](http://tomassetti.me/how-to-create-an-editor-with-syntax-highlighting-dsl/)\n4.  [Build an editor with autocompletion](http://tomassetti.me/autocompletion-editor-antlr/)\n5.  [Mapping the parse tree to the abstract syntax tree](http://tomassetti.me/parse-tree-abstract-syntax-tree/)\n6.  [Model to model transformations](http://tomassetti.me/building-compiler-language-model-model-transformations/)\n\nCode is available [on GitHub](https://github.com/ftomassetti/LangSandbox) under the tag **07_validation**\n\n## Implement semantic checks\n\nIn the previous post we have seen how to implement the function _process_ to execute an action on all the nodes of our AST. A typical case is that we want to execute certain operation only on certain nodes. We want still to use process to navigate the tree. We can do that by creating this function named _specificProcess_.\n\n```kotlin\nfun <T: Node> Node.specificProcess(klass: Class<T>, operation: (T) -> Unit) {\n    process { if (klass.isInstance(it)) { operation(it as T) } }\n}\n```\n\nLet’s see how to use _specificProcess _to:\n\n*   find all the _VariableDeclarations_ and check they are not re-declaring a variable already declared\n*   find all the _VarReferences_ and verify they are not referring to a variable that has been not declared or has been declared after the _VarReference_\n*   perform the same check done on _VarReferences_ also for _Assignments_\n\n```kotlin\ndata class Error(val message: String, val position: Point)\n\nfun SandyFile.validate() : List<Error> {\n    val errors = LinkedList<Error>()\n\n    // check a variable is not duplicated\n    val varsByName = HashMap<String, VarDeclaration>()\n    this.specificProcess(VarDeclaration::class.java) {\n        if (varsByName.containsKey(it.varName)) {\n            errors.add(Error(\"A variable named '${it.varName}' has been already declared at ${varsByName[it.varName]!!.position!!.start}\",\n                    it.position!!.start))\n        } else {\n            varsByName[it.varName] = it\n        }\n    }\n\n    // check a variable is not referred before being declared\n    this.specificProcess(VarReference::class.java) {\n        if (!varsByName.containsKey(it.varName)) {\n            errors.add(Error(\"There is no variable named '${it.varName}'\", it.position!!.start))\n        } else if (it.isBefore(varsByName[it.varName]!!)) {\n            errors.add(Error(\"You cannot refer to variable '${it.varName}' before its declaration\", it.position!!.start))\n        }\n    }\n    this.specificProcess(Assignment::class.java) {\n        if (!varsByName.containsKey(it.varName)) {\n            errors.add(Error(\"There is no variable named '${it.varName}'\", it.position!!.start))\n        } else if (it.isBefore(varsByName[it.varName]!!)) {\n            errors.add(Error(\"You cannot refer to variable '${it.varName}' before its declaration\", it.position!!.start))\n        }\n    }\n\n    return errors\n}\n```\n\nOk, so invoking _validate_ on the root of the AST will return all possible semantic errors.\n\n## Getting all errors: lexical, syntactic, and semantic\n\nWe first need to invoke the ANTLR parser and get:\n\n*   the parse tree\n*   the list of lexical and syntactic error\n\n```kotlin\ndata class AntlrParsingResult(val root : SandyFileContext?, val errors: List<Error>) {\n    fun isCorrect() = errors.isEmpty() && root != null\n}\n\nfun String.toStream(charset: Charset = Charsets.UTF_8) = ByteArrayInputStream(toByteArray(charset))\n\nobject SandyAntlrParserFacade {\n\n    fun parse(code: String) : AntlrParsingResult = parse(code.toStream())\n\n    fun parse(file: File) : AntlrParsingResult = parse(FileInputStream(file))\n\n    fun parse(inputStream: InputStream) : AntlrParsingResult {\n        val lexicalAndSyntaticErrors = LinkedList<Error>()\n        val errorListener = object : ANTLRErrorListener {\n            override fun reportAmbiguity(p0: Parser?, p1: DFA?, p2: Int, p3: Int, p4: Boolean, p5: BitSet?, p6: ATNConfigSet?) {\n                // Ignored for now\n            }\n\n            override fun reportAttemptingFullContext(p0: Parser?, p1: DFA?, p2: Int, p3: Int, p4: BitSet?, p5: ATNConfigSet?) {\n                // Ignored for now\n            }\n\n            override fun syntaxError(recognizer: Recognizer<*, *>?, offendingSymbol: Any?, line: Int, charPositionInline: Int, msg: String, ex: RecognitionException?) {\n                lexicalAndSyntaticErrors.add(Error(msg, Point(line, charPositionInline)))\n            }\n\n            override fun reportContextSensitivity(p0: Parser?, p1: DFA?, p2: Int, p3: Int, p4: Int, p5: ATNConfigSet?) {\n                // Ignored for now\n            }\n        }\n\n        val lexer = SandyLexer(ANTLRInputStream(inputStream))\n        lexer.removeErrorListeners()\n        lexer.addErrorListener(errorListener)\n        val parser = SandyParser(CommonTokenStream(lexer))\n        parser.removeErrorListeners()\n        parser.addErrorListener(errorListener)\n        val antlrRoot = parser.sandyFile()\n        return AntlrParsingResult(antlrRoot, lexicalAndSyntaticErrors)\n    }\n\n}\n```\n\nThen we map the parse tree to the AST and perform the semantic validation. Finally we return the AST and all the errors combined.\n\n```kotlin\ndata class ParsingResult(val root : SandyFile?, val errors: List<Error>) {\n    fun isCorrect() = errors.isEmpty() && root != null\n}\n\nobject SandyParserFacade {\n\n    fun parse(code: String) : ParsingResult = parse(code.toStream())\n\n    fun parse(file: File) : ParsingResult = parse(FileInputStream(file))\n\n    fun parse(inputStream: InputStream) : ParsingResult {\n        val antlrParsingResult = SandyAntlrParserFacade.parse(inputStream)\n        val lexicalAnsSyntaticErrors = antlrParsingResult.errors\n        val antlrRoot = antlrParsingResult.root\n        val astRoot = antlrRoot?.toAst(considerPosition = true)\n        val semanticErrors = astRoot?.validate() ?: emptyList()\n        return ParsingResult(astRoot, lexicalAnsSyntaticErrors + semanticErrors)\n    }\n\n}\n```\n\nIn the rest of the system we will simply call the _SandyParserFacade_ without the need to invoke the ANTLR parser directly.\n\n## Test validation\n\n_Will it fly? _Let’s verify that.\n\n\n```kotlin\nclass ValidationTest {\n\n    @test fun duplicateVar() {\n        val errors = SandyParserFacade.parse(\"\"\"var a = 1\n                                               |var a =2\"\"\".trimMargin(\"|\")).errors\n        assertEquals(listOf(Error(\"A variable named 'a' has been already declared at Line 1, Column 0\", Point(2,0))), errors)\n    }\n\n    @test fun unexistingVarReference() {\n        val errors = SandyParserFacade.parse(\"var a = b + 2\").errors\n        assertEquals(listOf(Error(\"There is no variable named 'b'\", Point(1,8))), errors)\n    }\n\n    @test fun varReferenceBeforeDeclaration() {\n        val errors = SandyParserFacade.parse(\"\"\"var a = b + 2\n                                               |var b = 2\"\"\".trimMargin(\"|\")).errors\n        assertEquals(listOf(Error(\"You cannot refer to variable 'b' before its declaration\", Point(1,8))), errors)\n    }\n\n    @test fun unexistingVarAssignment() {\n        val errors = SandyParserFacade.parse(\"a = 3\").errors\n        assertEquals(listOf(Error(\"There is no variable named 'a'\", Point(1,0))), errors)\n    }\n\n    @test fun varAssignmentBeforeDeclaration() {\n        val errors = SandyParserFacade.parse(\"\"\"a = 1\n                                               |var a =2\"\"\".trimMargin(\"|\")).errors\n        assertEquals(listOf(Error(\"You cannot refer to variable 'a' before its declaration\", Point(1,0))), errors)\n\n}\n```\n\n## Conclusions\n\nThis is all nice and well: with a simple call we can get a list of all errors we have. For each of them we have a description and the position. This is enough for our compiler but we would now need to show these errors in the editor. We will do that in out of the future posts.\n\n","author":"Federico Tomassetti","date":"2016-09-06","type":"article","categories":["Kotlin"],"features":["highlightjs"],"description":"","filename":"","lang":"EN","enclosure":null},{"title":"Things We've Learned During Coolcal Development in Kotlin","url":"https://www.netguru.co/blog/coolcal-development-in-kotlin","body":"\nLearning Kotlin is a pleasant process and only takes a few hours if you’re familiar with the Java programming language :)  The syntax is very intuitive, e.g. a when block is more readable than an if block or switch. At Netguru we had quite an adventure with Kotlin over the last few weeks while creating [the Coolcal app](https://play.google.com/store/apps/details?id=co.netguru.android.coolcal). [Here you can read about how we did it.](https://www.netguru.co/blog/coolcal-android-development-made-easy-and-fun) In this article I want to tell you more about what it’s like to learn Kotlin.\n\n## Our Kotlin Adventure\n\nThe development process is much faster and hassle free with Kotlin. Look at the snippets below.\n\n```kotlin\nwhen (type) {\n            WeatherCodes.CLEAR_SKY_DAY -> descArray[0]\n            WeatherCodes.CLEAR_SKY_NIGHT -> descArray[1]\n            else -> defaultMessage()\n}\n```\n\n**When matches the argument against all branches until some branch condition is satisfied.** It can be an expression or a statement, as the expression value of the satisfied branch becomes the value of the whole expression; the statement values of individual branches are ignored.\n\nDeclaring a singleton object is done by simply adding the object keyword before the name of our object.\n\n```kotlin\nobject InstancesLoader { //Implementaion}\n```\n\nObjects inside a class can be marked with companion object and can be called by using simply the class name as the qualifier.\n\n```kotlin\ncompanion object {\n        val EVENT_DETAILS_BUNDLE = \"event_details_bundle\"\n        }\n//usage\nClassName.EVENT_DETAILS_BUNDLE\n```\n\n**In apps, we frequently need classes just to hold data; a lot of boilerplate code needs to be written.** But in Kotlin, everything is achieved by using data classes. The compiler automatically derives the necessary code.\n\n```kotlin\ndata class Event(val id: Long,\n                 val calendarId: Long,\n                 val begin: Long,\n                 val end: Long,\n                 val isAllDay: Boolean = false,\n                 val title: String? = null,\n                 val displayColor: Int? = null,\n                 val owner: String,\n                 val location: String,\nval description: String): Parcelable { //Parcelable implementation}\n```\n\nThe code above implements members from primary constructor and necessary methods:\n\n* `equals()`/`hashcode()` pair,\n* `toString()`,\n* `copy()`\n\nSmall things like no new keyword also improve the development process.\n\n```kotlin\nvar adapter = EventAdapter(context, null, 0, this)\n```\n\n**The above snippet creates an instance of the EventAdapter class.** These features and many others make Kotlin a really enjoyable language.\n\nCompared to Java, Kotlin is a really modern solution for implementation problems. **Null object handling is a big issue in Java, but Kotlin is a null type safety language** so we don’t have to worry about this, e.g\n\n```kotlin\nsubscription?.unsubscribe()\n```\n\nThe syntax above means that the variable subscription will execute the method unsubscribe if subscription isn’t null. This construction is very helpful and solves null handling problems.\n\nWhat’s more - **when we need to check if a variable is null to operate on it after a null check, we don’t need to cast it to non-null type**; Kotlin supports smart cast operation.\n\n```kotlin\nif (dtStart == null || dtEnd == null) {\n            return \"\"\n        } else {\n            return when (isAllDay) {\n                true -> formatLongDateAllDay(dtStart)\n                false -> formatLongDateNotAllDay(dtStart, dtEnd)\n            }\n}\n```\n\nIn the example above dtStart and dtEnd were automatically cast to proper type.\n\nAccording to [Effective Java](http://www.oracle.com/technetwork/java/effectivejava-136174.html), Item 17 (“Design and document for inheritance or else prohibit it”) **all classes should be final and Kotlin classes correspond to this statement.** This helps developers build a better code base.  \n\n## Awesome libraries to browse\n\nAwesome libraries exist in the Android developer community, and to give up on them would be painful. Fortunately Kotlin is 100% interoperable with Java so it’s possible to use popular Java libraries like Retrofit in Kotlin :)\n\n```kotlin\n@GET(\"forecast\")\n   fun getForecast(@Query(\"lat\") latitude: Double,\n                   @Query(\"lon\") longitude: Double,\n@Query(\"cnt\") count: Long = 0): Observable<ForecastResponse>\n```\n\nIf you are planning to code in Kotlin please take a look at these short tips. **Using higher-order functions in Kotlin creates additional memory allocations and runtime overhead, but we can remedy this problem using an inline modifier.** Remember, though, that inlining is not always possible or wanted - it causes generated code to grow. Listeners and callbacks are awful to write, but they can be clean and more readable thanks to lambda expressions .\n\n```kotlin\neventIconClose.setOnClickListener { activity.finish() }\n```\n\nA nasty thing in Android is the findViewById function, but thanks to [Kotlin Android Extensions](https://kotlinlang.org/docs/tutorials/android-plugin.html) we can obtain the same functionality without this extra, awful code.\n\n```kotlin\ndayOfWeekTextView.text = timeFormatter.formatDayOfWeekShort(todayDt) \n```\n\nDefault values are very helpful - no more method overloading or creating several constructors to cut input parameters.\n\n```kotlin\nfun formatTimeOfDay(dt: Long?, isAllDay: Boolean = false)\n```\n\nWe can use this method with only one parameter like formatTimeOfDay(dt)\n\n**Sometimes a method or constructor has many parameters of the same type, which can be very error prone** - it’s easy to put the wrong value in the wrong place. To help developers beat this problem, language creators added named parameters. It’s worth using :)   \n\n```kotlin\nformatTime(timeMillis = i)\n```\n\nI is value of timeMillis parameter.\n\nDuring the development process, three Netguru Android team members made commits to the code base. As it was an internal project we had very limited resources, commercial projects were always a priority. **This didn’t matter in terms of the quality or continuity of the project, as [our process](https://www.netguru.co/blog/development-process) makes it easier for a team member to join or leave.**\n\nDuring development we found places to make code easier and more readable. We achieved this thanks to powerful language features. **Kotlin extension functions help us make our code easy to understand.** A good example of using this feature is getting a cursor value for a specific column. Writing this in Java for a generic field wouldn’t be as simple as in Kotlin.\n\n```kotlin\ninline fun <T> Cursor.from(columnName: String, getter: Cursor.(Int) -> T): T {\n    val columnIndex = getColumnIndex(columnName)\nreturn getter(columnIndex)\n```\n\nThis method gets a value from cursor for a specific column name; usage of this method is even simpler.\n\n```kotlin\nvar lastForecastSync: Long\n        get() = preferences.getLong(PREF_FORECAST_SYNC, 0)\n        set(value) {\n            into(preferences){\n                putLong(PREF_FORECAST_SYNC, value)\n            }\n        }\ninline fun into(preferences: SharedPreferences,\n                crossinline block: SharedPreferences.Editor.() -> SharedPreferences.Editor) {\n    preferences.edit().block().apply()\n}\n```\n\n```kotlin\nfun Cursor.eventId() = from(_ID) { getLong(it) }\n```\n\n```kotlin\nfun Cursor.eventDescription() = from(DESCRIPTION) { getString(it) }\n```\n\nEverything looks very intuitive and awesome. The next cool thing is using properties for handling shared preferences.\n\nUsing preferences implemented this way is very readable and clean.\n\n<pre>appPreferences.lastForecast = response </pre>\n\nThe above code saves the response into lastForecast.\n\n## Wrapping up\n\nKotlin is one of those languages whose processes are faster and less problematic than those of many other languages. I hope you will find my tips useful and that you will like [our showcase app - Coolcal](https://play.google.com/store/apps/details?id=co.netguru.android.coolcal). Please let me know what you think in the comments below. All feedback will be greatly appreciated.\n\n","author":"Przemek Dąbrowski","date":"2016-07-25","type":"article","categories":["Kotlin"],"features":["highlightjs"],"description":"","filename":"","lang":"EN","enclosure":null},{"title":"DSL builder in Kotlin","url":"https://medium.com/@piotr.slesarew/dsl-builder-in-kotlin-be5816ba3ca7#.xbcofn4hp","body":"\n> Design patterns describe simple and elegant solutions to specific problems in object-oriented software design. (GoF)\n\nWe all use design patterns even if we do not know their names. Builder pattern is one of the most famous and liked patterns for creating objects in an easy and scalable way. Being Java engineer I have had a lot of opportunities to master it. After a few times, I realized there is no fun in writing a builder. Thanks to IntelliJ IDEA we can generate it.\n\n![](https://cdn-images-1.medium.com/max/800/1*Knnn1qwG93dPbf1KEDERtg.png)\n\nThis approach is pretty convenient, as generated code is easy to change and tweak. You can add some checks, validations etc. As always there are some pitfalls. How many times did you have to add some property to your model with existing builder? Imagine that builder was generated and enriched with validation. Is there any fast, codeless way to add the new property to it? The answer is NO. You will have to implement it character by character.\n\nAnother clever way is to achieve this by annotations using Lombok library.\n\n```kotlin\nimport lombok.Builder;\n\n@Builder\nclass Person {\n    private final String name;\n    private final String surname;\n    private final int age;\n}\n```\n\n### Kotlin\n\nAlright, enough of Java world. Let’s talk about Kotlin ❤. When I started my journey with Kotlin I tried to apply my Java experience to every single line of code. The code worked and even looked better than Java, but still I felt there was something wrong with it. Kotlin is a high-level programming language with a lot of robust features. You should know them in order to produce more clear and readable structures.\n\nReferring to builder pattern we can write a really naive Kotlin implementation based on Java experience.\n\n```kotlin\nclass Person(val name: String, val surname: String, val age: Int) {\n    companion object {\n        class Builder {\n            private var name: String = \"\"\n            private var surname: String = \"\"\n            private var age: Int = 0\n\n            fun name(name: String): Builder {\n                this.name = name\n                return this\n            }\n\n            fun surname(surname: String): Builder {\n                this.surname = surname\n                return this\n            }\n\n            fun age(age: Int): Builder {\n                this.age = age\n                return this\n            }\n\n            fun build() = Person(name, surname, age)\n        }\n    }\n}\n\nfun main(args: Array<String>) {\n    Person.Companion\n          .Builder()\n          .name(\"Piotr\")\n          .surname(\"Slesarew\")\n          .age(28)\n          .build()\n}\n```\n\nAt first glance, this looks correctly, but can we do it better? Nowadays object-oriented programming is not enough. Start thinking in functions! Kotlin has the functional paradigm and it is possible to create objects using DSL. A DSL makes the same logic easy to read and write. How is it possible? BAM!\n\n```kotlin\nclass Person private constructor(val name: String, val surname: String, val age: Int) {\n\n    private constructor(builder: Builder) : this(builder.name, builder.surname, builder.age)\n\n    companion object {\n        fun create(init: Builder.() -> Unit) = Builder(init).build()\n    }\n\n    class Builder private constructor() {\n\n        constructor(init: Builder.() -> Unit) : this() {\n            init()\n        }\n\n        lateinit var name: String\n        lateinit var surname: String\n        var age: Int = 0\n\n        fun name(init: Builder.() -> String) = apply { name = init() }\n\n        fun surname(init: Builder.() -> String) = apply { surname = init() }\n\n        fun age(init: Builder.() -> Int) = apply { age = init() }\n\n        fun build() = Person(this)\n    }\n}\n\nfun main(args: Array<String>) {\n    Person.create {\n        name { \"Peter\" }\n        surname { \"Slesarew\" }\n        age { 28 }\n    }\n    \n    // OR\n    \n    Person.create {\n        name = \"Peter\"\n        surname = \"Slesarew\"\n        age = 28\n    }\n}\n```\n\nThis sample shows how amazing Kotlin is and what kind of crazy structures we can create. In addition similar approach was used to build Anko. I am not saying that this is the best solution, but at least it is worth to be aware of.\n\n> Functional programming is like a blessed curse. Purity feels amazing but you feel like you can’t program the “dirty” way anymore. — ([André Staltz](https://twitter.com/andrestaltz/status/696716396626124801))\n\n_If this was interesting to you, please do hit the heart button ❤ or_ [_let me know on Twitter_](https://twitter.com/SliskiCode)_._\n\n","author":"Piotr Ślesarew","date":"2016-10-21","type":"article","categories":["Kotlin"],"features":["highlightjs"],"description":"","filename":"","lang":"EN","enclosure":null},{"title":"Extension functions for more consistent APIs","url":"https://blog.frankel.ch/extension-functions-for-more-consistent-apis/","body":"\nKotlin’s [extension functions](https://kotlinlang.org/docs/reference/extensions.html#extension-functions) are a great way to add behavior to a type sitting outside one’s control - the JDK or a third-party library.\n\nFor example, the JDK’s `String` class offers the `toLowerCase()` and `toUpperCase()` methods but nothing to capitalize the string. In Kotlin, this can be helped by adding the desired behavior to the `String` class through an extension function:\n\n```kotlin\nfun String.capitalize() = when {\n    length < 2 -> toUpperCase()\n    else -> Character.toUpperCase(toCharArray()[0]) + substring(1).toLowerCase()\n}\n\nprintln(\"hello\".capitalize())\n```\n\nExtension functions usage is not limited to external types, though. It can also improve one’s own codebase, to handle null values more elegantly.\n\nThis is a way one would define a class and a function in Kotlin:\n\n```kotlin\nclass Foo {\n    fun foo() = println(\"foo\")\n}\n```\n\nThen, it can be used on respectively non-nullable and nullable types like that:\n\n```kotlin\nval foo1 = Foo()\nval foo2: Foo? = Foo()\nfoo1.foo()\nfoo2?.foo()\n```\n\nNotice the compiler enforces the usage of the null-safe `.?` operator on the nullable type instance to prevent `NullPointerException`.\n\nInstead of defining the `foo()` method directly on the type, let’s define it as an extension function, but with a twist. Let’s make the `.?` operator part of the function definition:\n\n```kotlin\nclass Foo\n\nfun Foo?.safeFoo() = println(\"null-safe foo\")\n```\n\nUsage is now slightly modified:\n\n```kotlin\nval foo1 = Foo()\nval foo2: Foo? = Foo()\nval foo3: Foo? = null\nfoo1.safeFoo()\nfoo2.safeFoo()\nfoo3.safeFoo()\n```\n\nWhether the type is non-nullable or not, the calling syntax is consistent. Interestingly enough, the output is the following:\n\n```\nnull-safe foo\nnull-safe foo\nnull-safe foo\n```\n\nYes, it’s possible to call a method on a [`null` instances](https://kotlinlang.org/docs/reference/extensions.html#nullable-receiver)! Now, let’s update the `Foo` class slightly:\n\n```kotlin\nclass Foo {\n    val foo = 1\n}\n```\n\nWhat if the `foo()` extension function should print the `foo` property instead of a constant string?\n\n```kotlin\nfun Foo?.safeFoo() = println(foo)\n```\n\nThe compiler complains:\n\n```\nOnly safe (?.) or non-null asserted (!!.) calls are allowed on a nullable receiver of type Foo?\n```\n\nThe extension function needs to be modified according to the compiler’s error:\n\n```kotlin\nfun Foo?.safeFoo() = println(this.?foo)\n```\n\nThe output becomes:\n\n```\n1\n1\nnull\n```\n\nExtension functions are a great way to make API more consistent and to handle `null` elegantly instead of dropping the burden on caller code.\n\n","author":"Nicolas Fränkel","date":"2016-10-16","type":"article","categories":["Kotlin"],"features":["highlightjs"],"description":"","filename":"","lang":"EN","enclosure":null},{"title":"Kotlin: The Good, The Bad, and The Ugly","url":"https://medium.com/keepsafe-engineering/kotlin-the-good-the-bad-and-the-ugly-bf5f09b87e6f#.prwij1b6d","body":"\n![](https://d262ilb51hltx0.cloudfront.net/max/2000/1*qPZUptAisHb0s0TSLrBvHA.jpeg)\n*Photo By [Johhy Silvercloud](https://www.flickr.com/photos/johnnysilvercloud/) / [CC-BY-SA](https://creativecommons.org/licenses/by-sa/2.0/)*\n\n### Kotlin: The Good, The Bad, and The Ugly\n\nIn my [last article](https://medium.com/keepsafe-engineering/lessons-from-converting-an-app-to-100-kotlin-68984a05dcb6), I talked about converting Java codebases to Kotlin, and about some of the libraries I like. Here, I’m going to talk about my thoughts on the Kotlin language itself and the way it interacts with Java.\n\n### The Good\n\nThere’s a lot to like about Kotlin. Some of the obvious features like null safety, property access, and unchecked exceptions are covered at length in other [publications](https://blog.jetbrains.com/kotlin/2016/01/kotlin-digest-2015/), so I won’t repeat them here. Instead, here are some of the less commonly discussed features of Kotlin that I really like.\n\n#### Automatic conversion of Java to Kotlin\n\nJetBrains’ Java to Kotlin converter integrated into IntelliJ saves a huge amount of time. It’s far from perfect, but it saves you from having to retype mundane code. Without it, migrating code from Java to Kotlin would take significantly longer.\n\n#### lateinit, Delegates.notNull and lazy\n\nKotlin’s null safety is great, but due to the way the Android Activity lifecycle is designed, you’ll often find that you have to initialize a property in a callback like _onCreate_ instead of your class’s constructor. Let’s say you have a property that you would like to define like:\n\n```kotlin\nval name: String\n```\n\nIf you have to initialize that property in onCreate, it cannot be a _val_: it has to be mutable var. But it still needs to be given a value at initialization time, so the obvious way to define it would be as a nullable property:\n\n```kotlin\nvar name: String? = null\n```\n\nThat works, but then you have to do null checks everywhere you access that property. Even though Kotlin has relatively painless null assertions, you’d rather not have to type _!!_ everywhere if you know that the property isn’t going to be null in practice. Fortunately, Kotlin has better ways: [_lateinit_](https://kotlinlang.org/docs/reference/properties.html#late-initialized-properties) and [_Delegates.notNull_](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.properties/-delegates/not-null.html). With either of those, you can define your property as a non-null type without an initializer:\n\n```kotlin\nlateinit var name: String  \nvar age: Int by Delegates.notNull<String>()\n```\n\nIn either case, if you attempt to access the property before it’s initialized, an exception will be thrown _[1]_. _lateinit_ can’t be used on properties of primitive types, but otherwise the two methods are mostly the same _[2]_.\n\nA third option that can be useful is the _lazy_ delegate. If your property can be initialized with data from only other properties or methods, then this might be a good fit. You can use it like so:\n\n```kotlin\nval imm: InputMethodManager by lazy {   \n    getSystemService(INPUT_METHOD_SERVICE) as InputMethodManager   \n}\n```\n\nThe block passed to _lazy_ isn’t called until the first time the property is read, and the return value of the block is saved for future accesses, so the block will only be called once.\n\n#### Functional collection extensions\n\nKotlin has some great functional [extensions methods on collections and iterables](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/index.html#functions). Functions like [_any_](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/any.html), [_joinToString_](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/join-to-string.html), and [_associate_](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/associate.html) can save you from a lot of hand-coded _for_ loops that are necessary in Java.\n\nThere is also a lazy version of many of the functional collections operations that won’t make a copy of your collection after each operation, but my benchmarks find that the lazy and eager versions of operators have a similar enough performance that it usually won’t matter which one you use _[3]_.\n\n#### Named and default function arguments\n\n[Named parameters](https://kotlinlang.org/docs/reference/functions.html#named-arguments) and [Default parameters](https://kotlinlang.org/docs/reference/functions.html#named-arguments) are pretty basic, but they let you cut down on a lot of boilerplate of defining overloads, and replace one of the main use cases of the Builder pattern.\n\nDepending on your use case, you could potentially even use default arguments for basic dependency injection by making a production dependency the default, and passing a mock during tests.\n\nFor example, if you have a presenter that needs some global state, you could define its constructor like this:\n\n```kotlin\nclass Presenter(  \n        val okhttp: OkHttp = productionOkHttp(),  \n        val picasso: Picasso = productionPicassoInstance()  \n) {...}\n```\n\nThat allows you to create the presenter without arguments from your UI code, while allowing you to pass mock instances of the dependencies during tests. Full DI frameworks are more powerful, but this is a nice example of the usefulness of some simple language constructs.\n\n### The Bad\n\nAlthough Kotlin is great, it’s not perfect. Here are a few aspects of the language that I’m not in love with.\n\n#### No namespaces\n\nKotlin allows you to define functions and properties at the top level of your files. That’s a great feature, but it can cause some confusion when combined with the fact that all top level declarations are referenced unqualified from Kotlin. This can sometimes make it difficult to tell what a function is when reading one of its usages.\n\nFor example, if you define a top level function:\n\n```kotlin\nfun foo() {...}\n```\n\nYou will call that function as foo(). If you have a function with the same name in a different package, it’s not obvious from looking at the call site which function is being called. You can fully qualify the name of the function with the entire name of the package that it’s defined in, but given Java’s convention of very deep package names, that’s not ideal.\n\nOne workaround is to approximate a namespace by using with a singleton object class.\n\n```kotlin\nobject FooActions {  \n    fun foo() {...}  \n}\n```\n\nThat allows you to refer to the function as FooActions.foo() if you’re only calling the functions from Kotlin, but it’s not as pretty if you have Java code that needs to call that function. From Java, you have to refer to the function as FooActions.INSTANCE.foo(), which is certainly not ideal. You can avoid the INSTANCE step by annotating your function with @JvmStatic, which is about the best you can do currently. That’s not a big deal, but it’s some boilerplate that wouldn’t be necessary if Kotlin had namespaces.\n\n#### No static modifier\n\nFollowing on the previous point, Kotlin has unusual handling of static function and property declarations that are called from Java. It’s not bad, but it feels dirtier than necessary. For example, the Android _View_ class defines some static constants like _View.VISIBLE_ and static methods like View.inflate:\n\n```kotlin\npublic class View {  \n    public static final int VISIBLE = 0x00000000;  \n    public static final int INVISIBLE = 0x00000004;  \n    public static View inflate(Context context, int resource) {...}  \n}\n```\n\nThe declaration is simple. In contrast, here’s the equivalent Kotlin:\n\n```kotlin\nclass View {  \n    companion object {  \n        @JvmField   \n        val VISIBLE: Int = 0x00000000  \n        @JvmField   \n        val INVISIBLE: Int = 0x00000004  \n        @JvmStatic  \n        fun inflate(context: Context, resource: Int) {...}  \n    }  \n}\n```\n\nAlthough the Kotlin version isn’t terrible, it’s more verbose than I would normally expect from the language. If you skip the annotations, then Java code will have to use awful syntax to refer to your fields:\n\n```kotlin\n// With annotations:  \nView.VISIBLE;\n```\n\n```kotlin\n//Without annotations:  \nView.Companion.getVISIBLE();\n```\n\nIt feels odd that there are no better ways to create static functions and properties. I know that companion objects are real objects and can do stuff like implement interfaces, but that doesn’t feel like a compelling enough use case to completely replace normal static declarations.\n\n#### Automatic conversion of Kotlin to Java\n\nThis was the first topic in the list of things I like about Kotlin, and it works well. But because it work so well 80% of the time, many of the cases where it fails can be frustrating.\n\nJavadocs are often mangled, especially any paragraphs the wrap lines. Static fields and methods are converted to plain declarations on the companion object, which breaks any Java code that previously called them unless you manually add _@JvmField_ or _@JvmStatic_, respectively.\n\nAll of these problems will certainly get fixed as the Kotlin team has more time to work on the converter, so I’m optimistic in this case.\n\n#### Required property accessor syntax\n\nKotlin has the great syntactic sugar called “property accessor syntax” that allows you to call JavaBeans-style getters and setters as if they were a Kotlin property. So for example, you can call the _Activity.getContext()_ method by writing _activity.context_ instead of writing the whole method name. If you use the actual method call in Kotlin, you will get a lint warning telling you to use the property syntax instead.\n\nThat’s definitely a nice feature, but there are a few cases where method names start with the word “get”, but you don’t want to use the property syntax. One common case is with Java’s atomic classes. If you have a _val i = AtomicInteger()_, you might want to call _i.getAndIncrement()_. But Kotlin wants you to call _i.andIncrement_. That’s clearly not an improvement.\n\nYou can annotate every call site with _@Suppress(“UsePropertyAccessSyntax”)_, but that’s ugly. It would be much better if there was a way to annotate functions you write with a similar annotation that would tell the linter that the function shouldn’t be treated like a property.\n\n#### Method count\n\nWriting code in Kotlin will certainly reduce the number of lines of code in your project. But it will also probably increase the method count of the compiled code, which is of course a drawback if you’re using Android. There are a number of reasons for that, but one of the larger contributors is the way Kotlin implements properties.\n\nUnlike Java, the Kotlin language doesn’t provide any way to define a bare field. All val and var declarations instead create a property. This has the advantage of allowing you to add a get or set definition to a property whenever you want without breaking code that references the property. That’s a great feature that removes the need to write defensive getters and setters in the way that you often do in Java.\n\nThat feature comes at a cost, though. Every public _val_ causes Kotlin to generate both a backing field and a getter function that can be called from Java _[4]_. Every public _var_ will cause both a getter and setter to be generated. Fortunately, private properties with default getters and setters are generated as fields and don’t cause getters or setters to be generated. If you were previously exposing a lot of public fields in Java (which is a common practice for constants), you can end up with a surprising increase in method count.\n\nIf you are close to the method limit in your android app, I recommend using the workaround of applying the _@JvmField_ annotation on public constants for which you don’t expect to need a custom getter for in the future. This will prevent the getters from being generated, and can cut down on your method count.\n\nIt’s not all bad, though. As I discussed in my article on [converting an app to 100% Kotlin](https://medium.com/keepsafe-engineering/lessons-from-converting-an-app-to-100-kotlin-68984a05dcb6), the Kotlin standard library is small and can replace a number of common Java libraries that are much larger once you don’t need them in Java any more. Thanks to the standard library, the method count in that app decreased after converting it to Kotlin. So as long as you avoid the big areas that can increase your method count, you may end up ahead in the end.\n\n### The Ugly\n\nAnd finally, here are two design decisions that the Kotlin team made that I strongly disagree with, and that I don’t expect to change in the future.\n\n#### SAM conversion and Unit returning lambdas\n\nThis one is a really baffling design decision.\n\nOne of the best features of Kotlin is the way it embraces lambda functions. If you have a Java function that takes a SAM interface as a parameter (an interface with a Single Abstract Method):\n\n```kotlin\npublic void registerCallback(View.OnClickListener r)\n```\n\nYou can call it by passing a plain lambda from either Kotlin or Java:\n\n```java\n// Java  \nregisterCallback(() -> { /** do stuff */ })\n```\n\n```kotlin\n//Kotlin  \nregisterCallback { /** do stuff */ }\n```\n\nThis is great. But trying to define a similar method in Kotlin is inexplicably harder. The direct translation is called the same from Java, but requires an explicit type when called from Kotlin:\n\n```kotlin\nfun registerCallback(r: View.OnClickListener)\n```\n\n```kotlin\n// Kotlin. Note that parenthesis are required now._  \nregisterCallback(View.OnClickListener { /** do stuff */ })\n```\n\nThat’s annoying to have to type out, especially if you convert some Java code to Kotlin and find out that it breaks existing Kotlin code.\n\nThe idiomatic way to define that function in Kotlin would be with a function type:\n\n```kotlin\nfun registerCallback(r: () -> Unit)\n```\n\nWhich allows the nice function call syntax in Kotlin, but since all Kotlin functions are required to return a value, this makes calling the function from Java much worse. You have to explicitly return Unit from Java lambdas, so expression lambdas are no longer possible:\n\n```kotlin\nregisterCallback(() -> {\n    /** do stuff */  \n    return Unit.INSTANCE;  \n})\n```\n\nIf you’re writing a library in Kotlin, there isn’t any good way to write a method with a function parameter that is ideal to call from both Java and Kotlin. I try to work around this in my [FlexAdapter](https://github.com/ajalt/flexadapter) library by providing overloads for each method with a function parameter that take either a SAM interface or a Kotlin function type. That lets you have a nice call syntax from both languages, but makes the library API less concise.\n\nHopefully the Kotlin designers change their mind and allow SAM conversions for functions defined in Kotlin in the future, but I’m not optimistic.\n\n### Closed by default\n\nEvery downside to Kotlin I’ve talked about so far are mostly small syntax details that are not quite as clean I’d like, but aren’t a big deal overall. But there’s one design decision that is going to cause a huge amount of pain in the future: All classes and functions in Kotlin are closed by default. It’s a design decision pushed by Effective Java, and it might sound nice in theory, but it’s an obviously bad choice to anyone who’s had to use a buggy or incomplete third-party library.\n\n> _Make all of your leaf classes final. After all, you’re done with the project — certainly no one else could possibly improve on your work by extending your classes. And it might even be a security flaw — after all, isn’t java.lang.String final for just this reason? If other coders in your project complain, tell them about the execution speed improvement you’re getting. — _[_Roedy Green, How to Write Unmaintainable Code_](http://www.mindprod.com/jgloss/unmaindesign.html)\n\nThe Kotlin documentation [actually has a paragraph trying to defend the choice](#), so I’ll address the three reasons they give.\n\n#### “Best practices say that you should not allow these hacks anyway”\n\nThe arguments for closed inheritance are mostly centered around the “Fragile Base Class Problem”, which is the idea that, if you allow someone to subclass your library code, they could change the way it works, potentially causing bugs. While that’s a possibility, there are lots of way to use a library incorrectly that will cause bugs. If you override some functionality in a class, it obviously your responsibility if you break something.\n\nI use the word “obviously”, because overriding functionality is the way to use a library that most explicitly places responsibility on the user. I tutored Computer Science students for years, and while they managed to make nearly every mistake you can imagine, they were never surprised when they broke something by overriding a method. There are much more subtle ways to break a library you use, like passing a value with the correct type but wrong units, or forgetting to call a required method.\n\nI appreciate the approach of writing code that has fewer places that can break, and making classes final might seem to do that. But it’s a certainty that libraries will be incomplete or incorrect, and you will eventually need to use one of those libraries. Modifying the behavior of a closed class is going to require much worse hacks that are more likely to result in bugs than if you could just override one or two of that class’s methods.\n\nBut you don’t even have to take my word for it. Here’s a real world example that might have impacted you personally if you’re an Android dev:\n\nAppCompat 23.2.0 finally saw the addition of [VectorDrawables](https://plus.google.com/+AndroidDevelopers/posts/iTDmFiGrVne) to the support library. This was a very welcome addition that promised to reduce APK size and memory usage. [Except that it caused a huge memory leak in any activities that tried to inflate them](https://code.google.com/p/android/issues/detail?id=205236). The support was [removed a couple weeks later](https://plus.google.com/+AndroidDevelopers/posts/iTDmFiGrVne).\n\nWhere did the memory leaks come from? In order to [implement VectorDrawable inflation](https://medium.com/@chrisbanes/appcompat-v23-2-age-of-the-vectors-91cbafa87c88), the support library authors needed to update the way _Context.getDrawable_ is implemented. But that function is final, so they had to make every View create a new copy of a Resources wrapper that could handle _VectorDrawables_. Besides being a large amount of work, this caused the various wrapped Resources to become out of sync, and to use a large amount of memory due to the duplication. If that function wasn’t final, that mess wouldn’t have happened.\n\n#### “People successfully use other languages (C++, C#) that have similar approach”\n\nPeople also successfully use languages like Python that allow anything at all to be changed at any time. Python has “non-public” methods like __asdict_ that are documented to by implementation details. It also has name mangled functions like ___intern_ that are harder to accidentally call. You can freely monkey-patch or override any of those functions whenever you want, and Python won’t complain.\n\nIn five years of full time Python development, I can’t think of a single time when someone broke my code by overriding a function. I can think of many instances where I’ve altered a non-public function in a safe, correct way in much less time than it would have taken to implement the same functionality if Python prevent me from doing so.\n\nI’m not advocating blindly altering implementation detail of every class you come in contact with, but there’s no reason to make that impossible if it becomes necessary. A common saying in the Python community is that “We’re all consenting adults here.” If you need to make a change to one of my classes, you should be able to.\n\n#### “If people really want to hack, there still are ways: you can always write your hack in Java and call it from Kotlin (see Java Interop), and Aspect frameworks always work for these purposes”\n\nThis is of course a ridiculous argument. You still can’t override closed Kotlin methods in Java without unacceptable use of reflection, so this doesn’t hold any weight.\n\nNot being able to extend from a library means that it becomes very difficult to add features or fix bugs. And in the real world, more libraries than not will need hacking. That’s simply reality, and is never going to change. A library author is never going to be able to predict every possible use case that users will have. Making all of your classes final only prevents users from easily implementing the features you can’t. This was a surprisingly dogmatic choice given how practical the Kotlin designers were in the rest of the language.\n\nIf you write a Kotlin library, please make all of your public functions open. You’ll make life easier on your users in the future.\n\n### Conclusion\n\nKotlin is overall a great language. It is much less verbose than Java, and has an excellent standard library that removes the need to use a lot of the libraries that make Java life bearable. Converting an app from Java to Kotlin is made much easier thanks to automated syntax conversion, and the result is almost always an improvement. If you’re an Android developer, you owe it to yourself to give it a try.\n\nAt [Keepsafe](https://www.getkeepsafe.com/), all new Android development is in Kotlin, and legacy Java code is steadily being converted to Kotlin as we make changes to it.\n\nInterested in working with us? Have a look at our [job openings](https://jobs.lever.co/keepsafe).\n\n**[1]** In the case of a _lateinit_ property, _kotlin.UninitializedPropertyAccessException_ will be thrown, where the _Delegates.notNull_ will throw an _IllegalStateException_.\n\n**[2]** There are some details about _lateinit_ that are worth noting, especially if you plan on accessing a _lateinit_ property from Java code. First is that _lateinit_ cannot be applied to primitive types such as _Int_ or _Double_. The second is that a _lateinit_ property is backed by a field with the same visibility as the property, and this field is visible from Java. Additionally, that backing field can be freely set to null from Java. If any of those are issues for your use case, _Delegates.notNull_ may be a better choice.\n\n**[3]** The lazy _Sequence_ operators can outperform the eager versions by up to 20%, but only once list sizes start growing very large. For lists under a megabyte or so in size, the lazy versions often perform the same or worse than the eager versions.\n\n**[4]** This is a bit of a simplification. Kotlin will only generate a backing field if you don’t define a get function, or if the defined get function doesn’t reference the implicit _field_ identifier.\n\n","author":"AJ Alt","date":"2016-08-20","type":"article","categories":["Kotlin"],"features":["highlightjs"],"description":"","filename":"","lang":"EN","enclosure":null},{"title":"Андрей Бреслав и Дмитрий Жемеров о Kotlin 1.0 на jug.msk.ru","url":"https://habrahabr.ru/post/279667/","body":"\n17 марта 2016 года прошла встреча [jug.msk.ru](http://jug.msk.ru/) с Андреем Бреславом и Дмитрием Жемеровым, посвящённая выпуску версии 1.0 языка программирования Kotlin. Далее рассказывается о прошедшей встрече подробнее.\n\n![КПВД](https://habrastorage.org/files/c29/a51/0ef/c29a510efb444bb4bc8b18f8ad740523.jpg)\n\nО докладчиках\n\nАндрей Бреслав ( [@abreslav](https://habrahabr.ru/users/abreslav/) ) является архитектором языка _Kotlin_, занимаясь его разработкой в компании _JetBrains_ с 2010 года.\n\nНиже приведён список видео докладов Андрея, которые удалось найти:\n\n* «BrainStorm. Автоматизированная оптимизация аппаратно-программных архитектур» (_Computer Science клуб при ПОМИ РАН_, 2011: [видео](https://www.youtube.com/watch?v=wZXEhngRzMA))\n* «Синтаксический анализ для встроенных языков» (_Computer Science клуб при ПОМИ РАН_, 2011: [видео](https://www.youtube.com/watch?v=PARloe1mPkc))\n* «Project Kotlin» (_JUG.ru-2012_: [видео](https://www.youtube.com/watch?v=wjkaPXT_vY4&index=11&list=PLVe-2wcL84b8pj7VOoa-6L9Q0sDjibdoF))\n* «Функции и данные в Kotlin» (_FProg-12 в JetBrains_: [видео](https://www.youtube.com/watch?v=0AzLhiic0fM))\n* «Type-safe Web with Kotlin» (_JPoint 2013_: [видео](https://www.youtube.com/watch?v=6y-4xJWFLl4&index=10&list=PLVe-2wcL84b8pj7VOoa-6L9Q0sDjibdoF))\n* «Компромиссы, или Как проектируются языки программирования» (_Joker 2013_: [видео](https://www.youtube.com/watch?v=CX_K1r0Vklg&index=8&list=PLVe-2wcL84b8pj7VOoa-6L9Q0sDjibdoF))\n* «Компромиссы в разработке языков программирования» (_JPoint 2014_: [видео](https://www.youtube.com/watch?v=HE4yyPpUsy4&index=7&list=PLVe-2wcL84b8pj7VOoa-6L9Q0sDjibdoF))\n* «Kotlin для Android: коротко и ясно» (_Mobius 2014_: [видео](https://www.youtube.com/watch?v=VU_L2_XGQ9s&index=9&list=PLVe-2wcL84b8pj7VOoa-6L9Q0sDjibdoF))\n* «Язык Kotlin для платформы Java» (_JEEConf 2015_: [видео](https://www.youtube.com/watch?v=018n0aXiljc))\n* «Kotlin: Challenges in language design» (_Curry On, Prague 2015_: [видео](https://www.youtube.com/watch?v=zVZFv80l_lQ))\n* «Что делать?» (2015: [видео](https://www.youtube.com/watch?v=P_qrDQMBRzw))\n\nДва доклада я смотрел очно на конференциях, ещё один — в записи. К моему большому удивлению, последний в списке докладов является вовсе не техническим.\n\n\nДмитрий Жемеров ( [@yole](https://habrahabr.ru/users/yole/) ) работает в _JetBrains_ с 2003 года (на некоторое время уходил в _Google_ и вернулся обратно), успев поучаствовать во многих проектах компании, в _IntelliJ IDEA_ в частности. Сейчас Дмитрий руководит командой разработки _Kotlin_ - плагина и пишет книгу [Kotlin in Action](https://www.manning.com/books/kotlin-in-action) (в соавторстве со Светланой Исаковой).\n\nНа [его сайте](http://yole.ru) перечислено ещё несколько персональных проектов (в т.ч. [Syndirella](https://sourceforge.net/projects/syndirella/), про которую [упоминал](https://radio-t.com/p/2016/02/20/podcast-484/) недавно [@bobuk](https://habrahabr.ru/users/bobuk/)).\n\nДоклады Дмитрия, которые удалось найти:\n\n* «Kotlin» (_Riviera DEV 2011_: [видео](https://www.youtube.com/watch?v=P0SisYQrosg))\n* «Kotlin» (_CZJUG-2013_: [видео](https://www.youtube.com/watch?v=acLBPytzpEI))\n* «Static types in JavaScript: what, how and why» (_JSConf EU 2013_: [видео](https://www.youtube.com/watch?v=0r9HPRJUaFo))\n* «Why Python Sucks» (_Europython 2013_: [видео](https://www.youtube.com/watch?v=PlXEsrhF1iE))\n* «SDK, Gradle, AndroidStudio» (_Онлайн школа Android-разработчиков-2015_: [видео](https://www.youtube.com/watch?v=ZyPgFuPwXoQ))\n* «Без слайдов: интервью с Дмитрием Жемеровым из JetBrains» (_Хабрахабр_: [статья с видео](https://habrahabr.ru/company/jugru/blog/263905/))\n* «Опыт использования Kotlin в JetBrains» (Joker 2015: [видео](https://www.youtube.com/watch?v=c1tf_zLGMKM&index=6&list=PLVe-2wcL84b8pj7VOoa-6L9Q0sDjibdoF))\n\nИз перечисленного смотрел только один доклад с конференции в записи и интервью из серии «Без слайдов».\n\nСовсем недавно Андрей и Дмитрий вместе выступали с докладом «Kotlin 1.0» на встрече _JUG.ru_ в Питере — [статья с видео](https://habrahabr.ru/company/jugru/blog/278647/) доклада.\n\n#### О докладе\n\nДо встречи в течение нескольких вечеров почитал [описание языка](https://kotlinlang.org/docs/reference/), посмотрел [примеры](https://github.com/JetBrains/kotlin-examples), попробовал писать код. Есть [поддержка Ant](https://kotlinlang.org/docs/reference/using-ant.html) (уже анахронизм), [Maven](https://kotlinlang.org/docs/reference/using-maven.html) и [Gradle](https://kotlinlang.org/docs/reference/using-gradle.html). Пользоваться языком достаточно приятно. Интеграция с _IntelliJ IDEA_, естественно, есть и весьма хорошая.\n\nУспел послушать три выпуска подкастов, в которых отметились докладчики, представляя версию 1.0 языка _Kotlin_:\n\n* [Разбор полётов, выпуск 102](http://razbor-poletov.com/2016/02/episode-102.html) (Дмитрий Жемеров)\n* [Радио-Т, выпуск 484](https://radio-t.com/p/2016/02/20/podcast-484/) (Дмитрий Жемеров)\n* [SDCast, выпуск 41](https://sdcast.ksdaemon.ru/2016/03/sdcast-41/) (Андрей Бреслав)\n\nВидео питерского выступления на _JUG.ru_ ранее посмотреть тоже успел. В значительной степени содержание совпадало, но были и отличия. Последняя часть (вопросов и ответов), конечно же, полностью отличалась.\n\n![](https://habrastorage.org/files/ebc/899/747/ebc8997475c04c1c82bf59daf46f7d21.jpg)\n\nКак и в Питере, выступление состояло из четырёх частей:\n\n* вводная часть с рассказом о языке (Андрей Бреслав);\n* планы развития после версии 1.0 (Дмитрий Жемеров);\n* вопросы совместимости (Андрей Бреслав);\n* сессия вопросов и ответов.\n\nВ перерыве слушатели могли пообщаться с докладчиками.\n\n![](https://habrastorage.org/files/e0d/ffc/356/e0dffc35632a4c43aade34c9f3efa386.jpg)\n\nПредполагаю, что наиболее интересной частью и для Андрея с Дмитрием была сессия вопросов и ответов. Надеюсь, что для докладчиков тоже был некий элемент неожиданности, т.к. интересные вопросы были. Удивило, что уже есть люди (кроме _JetBrains_), активно использующие язык в промышленной эксплуатации.\n\nОчень хорошо, что задающим вопросы давался микрофон — было слышно, что спрашивают. Записанное видео можно будет комфортно слушать, не напрягаясь при попытке расслышать вопросы.\n\n![](https://habrastorage.org/files/342/253/3f8/3422533f8cc548c8a83e2f03eff97409.jpg)\n\nСпасибо Андрею Бреславу и Дмитрию Жемерову за интересный доклад, Андрею Когуню (_jug.msk.ru_, _КРОК_) и Роману Белову (_JetBrains_) — за организацию мероприятия.\n\nСсылки по теме доклада — языку _Kotlin_:\n\n* [основной сайт](https://kotlinlang.org);\n* [Try Online](http://try.kotlinlang.org);\n* [описание языка](https://kotlinlang.org/docs/reference/);\n* книги [Kotlin in Action](https://www.manning.com/books/kotlin-in-action) и [Kotlin for Android Developers](https://leanpub.com/kotlin-for-android-developers);\n* [Kotlin Koans](https://kotlinlang.org/docs/tutorials/koans.html);\n* [Kotlin Educational Plugin](http://blog.jetbrains.com/kotlin/2016/03/kotlin-educational-plugin/) (выпущен в день встречи, 17 марта).\n\nФото и видео будут доступны [здесь](http://vk.com/jugmsk) и [здесь](https://plus.google.com/communities/115981831554057619568). На рассылку о следующих встречах _jug.msk.ru_ подписаться можно [здесь](http://jug.msk.ru).\n\n","author":"Дмитрий Белобородов","date":"2016-03-22","type":"article","categories":["Kotlin"],"features":["highlightjs"],"description":"","filename":"","lang":"RU","enclosure":null},{"title":"Kotlin & Android: A Brass Tacks Experiment, Part 3.","url":"https://medium.com/@CodingDoug/kotlin-android-a-brass-tacks-experiment-part-3-84e65d567a37#.lgtyczp3h","body":"\n![](https://d262ilb51hltx0.cloudfront.net/max/800/1*UN-S8ELMC2kpHf4tJKfbLQ.png)\n_Disclaimer: I am a Google employee, but the views expressed in this article are not those of my employer._\n\n### Kotlin & Android: A Brass Tacks Experiment, Part 3\n\nThis is post 3 in a series about my experiment using Kotlin in a uniquely Android way. If you haven’t read [part 1 (setup)](https://medium.com/p/kotlin-android-a-brass-tacks-experiment-part-1-3e5028491bcc) and [part 2](https://medium.com/p/kotlin-android-a-brass-tacks-experiment-part-2-c67661cfdf5f) yet, read up to catch up!\n\nWe left things last time with a fairly useful function called “v” using the type-safe builder pattern in Kotlin®. It can be used to build instances of arbitrary types of Android views.\n\n```kotlin\nimport android.content.Context\nimport java.lang.reflect.Constructor\n\ninline fun <reified TV : View>\n        v(context: Context, init: TV.() -> Unit) : TV {\n    val constr = TV::class.java.getConstructor(Context::class.java)\n    val view = constr.newInstance(context)\n    view.init()\n    return view\n}\n```\n\nWe can import this definition into some Kotlin code and call it to create and initialize a new view of any type:\n\n```kotlin\nimport android.view.ViewGroup.LayoutParams\nimport android.view.ViewGroup.LayoutParams.WRAP_CONTENT\nimport android.widget.TextView\n\nval view = v<TextView>(context) {\n    layoutParams = LayoutParams(WRAP_CONTENT, WRAP_CONTENT)\n    text = \"Hello\"\n}\n```\n\n#### But is this practical?\n\nWhat if we want to create a simple layout with two TextViews stacked on top of each other? Here’s a simple view hierarchy expressed in XML:\n\n```xml\n<LinearLayout\n    android:layout_width=\"wrap_content\"\n    android:layout_height=\"wrap_content\"\n    android:orientation=\"vertical\" >\n    <TextView\n        android:layout_width=\"wrap_content\"\n        android:layout_height=\"wrap_content\"\n        android:text=\"Hello\" />\n    <TextView\n        android:layout_width=\"wrap_content\"\n        android:layout_height=\"wrap_content\"\n        android:text=\"World\" />\n</LinearLayout>\n\n```\n\nOur poor v function can’t build all that at once. But it could with some help! We just need an additional function that has smarts for creating views that get added to a parent ViewGroup (such as LinearLayout here, or RelativeLayout). So let’s make a new v function overload to buddy up with our existing v function:\n\n```kotlin\ninline fun <reified TV : View> v(parent: ViewGroup, init: TV.() -> Unit) : TV {\n    val constr = TV::class.java.getConstructor(Context::class.java)\n    val view = constr.newInstance(parent.context)\n    parent.addView(view)\n    view.init()\n    return view\n}\n```\n\nThis function is _almost exactly_ like the original v except for one thing. Its first parameter is of type ViewGroup instead of Context. This new v function needs to know about a _parent_ ViewGroup is so it can add its own newly created view to that parent before initializing and returning it. That’s the first argument to this function. It will then get a hold of the Context needed to initialize the view from the parent argument instead of being passed the Context directly.\n\nLet’s see how this new v function can work together with our old v to build the same view hierarchy as the above XML:\n\n```kotlin\nimport android.content.Context\nimport android.widget.LinearLayout\nimport android.widget.LinearLayout.VERTICAL\nimport android.widget.LinearLayout.LayoutParams\nimport android.widget.LinearLayout.LayoutParams.WRAP_CONTENT\nimport android.widget.TextView\n\nval view = v<LinearLayout>(context) {\n    layoutParams = LayoutParams(WRAP_CONTENT, WRAP_CONTENT)\n    orientation = VERTICAL\n\n    // adds a new TextView as the first child to the LinearLayout (\"this\")\n    v<TextView>(this) {\n        layoutParams = LayoutParams(WRAP_CONTENT, WRAP_CONTENT)\n        text = \"Hello\"\n    }\n\n    // adds a another new TextView to the LinearLayout\n    v<TextView>(this) {\n        layoutParams = LayoutParams(WRAP_CONTENT, WRAP_CONTENT)\n        text = \"World\"\n    }\n}\n```\n\nI love the way these functions nest naturally just like the XML!\n\nIf you recall from [part 2](https://medium.com/p/kotlin-android-a-brass-tacks-experiment-part-2-c67661cfdf5f) of this series, a Kotlin _lambda with receiver_ makes the receiver object available as “this” in the lambda body. In the specific case above, the LinearLayout typed receiver in the _outer_ v lambda (made available via the “this” keyword) is passed as the first parameter of both calls to the new _inner_ v function. Because LinearLayout is a type of ViewGroup, Kotlin knows that we intend to use our new v function overload instead of our original v that takes a Context.\n\nWith these two buddy v functions we can now _programmatically_ and _succinctly_ create nested views as deeply as we want with any type of ViewGroup parent and View child. We’re starting to get a sort uniquely expressive language (some might say “[domain specific language](https://en.wikipedia.org/wiki/Domain-specific_language)”) for creating Android views that’s close to the usual XML representation. It turns out that this is also faster than inflating XML, as we’ll discover in a future post in this series.\n\n#### Room for Improvement\n\nThere’s still some awkwardness with this scheme when you want to specify a dimension of some view in density independent pixels. For example, in XML, you might simply say “48dp” as a value to describe width or height, but to say this programmatically in Kotlin using the API provided by Android, you’d have to write something gnarly like this:\n\n```kotlin\nTypedValue.applyDimension(\n    TypedValue.COMPLEX_UNIT_DIP,\n    48,\n    context.resources.displayMetrics)\n```\n\nSuper yuck! Stay tuned for [next week’s post](https://medium.com/@CodingDoug/kotlin-android-a-brass-tacks-experiment-part-4-4b7b501fa457) where we’ll make use of another Kotlin language feature to address this problem and further tighten up expressions for view creation using our dynamic duo of v functions. Be sure to follow me here on Medium as [@CodingDoug](https://medium.com/@CodingDoug) or on [Twitter as the same](https://twitter.com/CodingDoug) to stay on top of this series!\n\n","author":"Doug Stevenson","date":"2016-02-16","type":"article","categories":["Kotlin","Android"],"features":["highlightjs"],"description":"","filename":"","lang":"EN","enclosure":null},{"title":"Developing a Geospatial Webservice with Kotlin and Spring Boot","url":"https://www.youtube.com/watch?v=tTTEiQj4BHA","body":"\nSpring I/O 2016 - 19 -20 May Barcelona\n\nAs described in this announcement I made on [Spring blog](https://spring.io/blog/2016/02/15/developing-spring-boot-applications-with-kotlin), it is now easy to create a Spring Boot application using Kotlin.\n\nThanks to a sample Geospatial chat application, I will show how Spring Boot and Kotlin share the same pragmatic, innovative and optionated mindset to allow you to build simple but powerful projects.\n\nThat talk will also provide an opportunity to show how to use a relational database with Spring Data but without JPA in order to use advanced PostgreSQL functionalities (like its powerful spatial database extender PostGIS or the native JSON support) while keeping a lightweight stack.\n\n<iframe width=\"960\" height=\"480\" src=\"https://www.youtube.com/embed/tTTEiQj4BHA\" frameborder=\"0\" allowfullscreen></iframe>\n\n\n\nUpdate Nov 25 2016: Also see new version of this talk at Spring One Platform\n\n[Developing a Geospatial Webservice with Kotlin and Spring Boot](https://www.infoq.com/presentations/geospatial-kotlin-boot)\n\n","author":"Sébastien Deleuze","date":"2016-11-25","type":"video","categories":["Kotlin","Spring"],"features":["highlightjs"],"description":"","filename":"","lang":"EN","enclosure":null},{"title":"Gradle Meets Kotlin","url":"http://blog.jetbrains.com/kotlin/2016/05/gradle-meets-kotlin/","body":"\nBack at **JavaOne 2015**, during a lunch break we started chatting with **Hans Dockter, CEO of Gradle**. A couple of days after the conference, a few of us were at the Gradle offices talking about what would be the beginning of the collaboration between JetBrains and Gradle; to bring first-class tooling and support for a static language to Gradle.\n\nToday, at the [Kotlin Night in San Francisco](http://info.jetbrains.com/Kotlin-Night-2016.html), Hans Dockter demoed the first milestone of writing a Gradle build script using Kotlin.\n\n<iframe src=\"https://www.youtube.com/embed/4gmanjWNZ8E\" allowfullscreen=\"\" frameborder=\"0\" height=\"480\" width=\"960\"></iframe>\n\n```kotlin\nimport org.gradle.api.plugins.*\nimport org.gradle.api.tasks.wrapper.*\nimport org.gradle.script.lang.kotlin.*\n\napply<ApplicationPlugin>()\n\nconfigure<ApplicationPluginConvention> {\n    mainClassName = \"samples.HelloWorld\"\n}\n\nrepositories {\n    jcenter()\n}\n\ndependencies {\n    \"testCompile\"(\"junit:junit:4.12\")\n}\n```\n\nGradle allows developers and build engineers to deal with complex build automation scripts. As complexity grows, having a language that is statically-typed can help detect potential misconfigurations at compile time, contributing in reducing runtime issues. Static typing also opens up the door to more sophisticated tooling. All this, combined with key characteristics of Kotlin that enable easy creation of DSL’s, can provide Gradle users benefits while maintaining the level of fluency they are accustomed to.\n\nFor the past 6 months, we’ve been working closely with the Gradle team, in particular with Chris Beams and Rodrigo de Oliveira in bringing Kotlin to Gradle. It has been a tremendously rewarding experience because it has also helped us see use-case scenarios for making scripting in Kotlin a first-class citizen.\n\nWe are very excited for what Gradle has in store and are happy to continue collaborating with them closely in bringing a great experience to Gradle users.\n\nFor more information and how to get the bits to start playing with this, make sure you read the [blog post by the Gradle team](http://gradle.org/blog/kotlin-meets-gradle) for more details. In addition, if you are on the public [**Kotlin Slack**](https://kotlinlang.slack.com), there’s a newly created **#gradle** channel for discussions.\n\n","author":"Hadi Hariri","date":"2016-05-18","type":"article","categories":["Kotlin","Gradle"],"features":["highlightjs"],"description":"","filename":"","lang":"EN","enclosure":null},{"title":"Implementing Android App Shortcuts","url":"https://medium.com/@andreworobator/implementing-android-app-shortcuts-74feb524959b#.vrst29h9p","body":"","author":"Andrew Orobator","date":"2016-12-19","type":"article","categories":["Kotlin","Android"],"features":["highlightjs"],"description":"","filename":"","lang":"EN","enclosure":null}]
